amanhimself.dev
Aman Mittal
I'm Aman Mittal (@amanhimself). Software Developer and Tech Writer. Welcome to my blog!

Generated on 2025-12-10T07:19:31.667Z
Contains the markdown content of each blog post.

---

## 21 Useful Open Source Packages for React Native
Slug: 21-useful-open-source-packages-for-react-native

![cover_image](https://i.imgur.com/nbq2XcZ.png)

We live in the world of a variety, yet mobile devices are dominated by two major platforms, iOS and Android. It is a two-horse race, but that doesnâ€™t make mobile app development _easy_. For iOS you write code using Objective-C or Swift. For Android, you use Java. In addition to different programming languages, the tool chains are entirely different too for both of these mobile platforms.

To create app that work across devices, many modern day developers build Hybrid apps using HTML, CSS and JavaScriptâ€Šâ€”â€Šas you would a web pageâ€” wrapped in native container. This way, you use (almost) one set of source code for developing applications for both iOS and AndroidÂ .

In recent years, hybrid frameworks have evolved from web view to use native APIs. This cross-platform approach of developing a mobile application comes with its own pros and cons. Pros such as being less-time consuming and cost-effective, and cons include performance issues.

One of the great options that fall under the umbrella of cross-platform development is React Native. React Native was developed by Facebook and used by others such as [Tesla Motors](https://medium.com/u/24413768aadb), [Walmart Labs](https://medium.com/u/c884135151a4), [Uber](https://medium.com/u/b97b1b381b5a), [Instagram Engineering](https://medium.com/u/a4c6efa67fe0), [Discord](https://medium.com/u/fddf6af2df19), [Wix](https://medium.com/u/2741d9d88322) and so on.

In a nutshell, React Native allows you to build mobile applications that look, feel and perform much more like native applications. The good thing for developers is that they can use almost the same concepts that are being used for building web applications.

The list below contains an overview of the top open source libraries that you can use in your React Native application.

> [**Also, try out the Crowdbotics application builder to instantly scaffold and deploy a React Native app.**](https://app.crowdbotics.com/dashboard/?utm_campaign=cb-medium&utm_source=blog-post&utm_medium=Medium&utm_content=react-native)

### USEFUL OPEN SOURCE REACT NATIVEÂ PACKAGES

### lottie-react-native

Lottie is a mobile library for Android and iOS that parses Adobe After Effects animations exported as JSON with `bodymovin` and renders them natively on mobile. With over 10k+ stars, this npm module helps you use community/custom build animations in your React Native application.

[**react-native-community/lottie-react-native**](https://github.com/react-native-community/lottie-react-native)

### react-native-vector-icons

`react-native-vector-icons` is the go to library if you are considering to use customizable icons with support for NavBar/TabBar, image source and full styling. This npm module bundles famous icon libraries like:

- FontAwesome
- IonIcons
- EvilIcons
- AntDesign
- MaterialIcons
- Octicons

and many more. It is like have best of all the libraries in one place, and you do not have to go through the process of hooking up multiple libraries and then linking them with the React Native app. It also supports animation with React Nativeâ€™s animation library, `Animated`.

[**oblador/react-native-vector-icons**](https://github.com/oblador/react-native-vector-icons)

### react-native-gifted-chat

Chat applications are a huge part of mobile app development. There are scenarios in which either you build complete chat applications or add it as a feature to your existing app. In both cases, this module is out there to help you get started with the UI. This npm module comes with fully customizable components, dates, multiple TextInput options, Redux support and so on.

[**FaridSafi/react-native-gifted-chat**](https://github.com/FaridSafi/react-native-gifted-chat)

### react-native-image-picker

An essential library for any app with Image upload or Image processing. It supports features like selecting from the gallery, and taking a photo from the camera. Another useful feature in this library that I like is the option to select the quality of an image you want to choose. This feature solves memory issues due to high-resolution images.

[\*_react-native-community/react-native-image-picker_](https://github.com/react-native-community/react-native-image-picker)

### react-native-progress

Showing progress of loading or any other action is important in an app. This library makes it easy to show progress by supporting 5 different components like Linear progress bar, circular, pie and so on using ReactART.

```js

import * as Progress from 'react-native-progress';

<Progress.Bar progress={0.3} width={200} />
<Progress.Pie progress={0.4} size={50} />
<Progress.Circle size={30} indeterminate={true} />
<Progress.CircleSnail color={['red', 'green', 'blue']} />
```

[**oblador/react-native-progress**](https://github.com/oblador/react-native-progress)

### Nativebase

NativeBase is a sleek, ingenious, and dynamic front-end framework to build cross-platform Android and iOS mobile apps using ready-to-use generic components of React Native. What is really great about NativeBase is that you can use shared UI cross-platform components, which will drastically increase your productivity.

Its documentation provides an in-depth specification on each components and customize them. You need a component library like Nativebase while working solo, or quickly prototyping an MVP or if you want to focus on the functionality of your application.

[**GeekyAnts/NativeBase**](https://github.com/GeekyAnts/NativeBase)

### react-navigation

Navigation has been a controversial topic in React Naive community, until `react-navigation` package has started to mature. With version `3` recently launched, this npm module is right now a complete solution provider for managing screens in a React Native application. It offers

- stack navigation
- tab navigation
- drawer navigation
- custom navigation support
- Redux support for complex applications

If you want to try it out, here is cool [example app](https://expo.io/@react-navigation/NavigationPlayground) built using it.

[**react-navigation/react-navigation**](https://github.com/react-navigation/react-navigation)

### react-native-navigation

React Native Navigation provides 100% native platform navigation on both iOS and Android for React Native apps. Developed and maintained by the team at Wix, is the second most commonly used package to support navigation of screens in a React Native app after `react-navigation`.

The reason this package is often a second preference in the community is because of its set up process. You will have to manually hook this library with iOS build and Android `gradle` every time you want to use it by following a number of steps.

### react-native-languages

A community package, react-native-languages is a library that helps you integrate the i18n-js library in a React Native application to internationalize and localize the application. With that, it has many utility functions that you can leverage.

For example, to get the current deviceâ€™s language, you would write the following code.

```js
import RNLanguages from 'react-native-languages';

// Get Current device language
console.log('language', RNLanguages.language);
```

[**react-native-community/react-native-languages**](https://github.com/react-native-community/react-native-languages)

### react-native-billing

This library is exclusively to be used with React Native and Android. Use this library when you need to add in-app billing to your app for Android devices. The tool has a simple interface and works as a bridge by wrapping anjlabâ€™s `InApp Billing` library. This library is up to date and supports ES6 features like `async/await`.

```js
import InAppBilling from "react-native-billing";

async purchase() {
  try {
    await InAppBilling.open();
    const details = await InAppBilling.purchase("android.test.purchased");
    console.log("You purchased: ", details);
  } catch (err) {
    console.log(err);
  } finally {
    await InAppBilling.close();
  }
}
```

[**idehub/react-native-billing**](https://github.com/idehub/react-native-billing)

### react-native-iap

This is a react-native link library project for in-app purchase for both Android and iOS platforms. The goal of this project is to have similar experience between the two platforms for in-app-purchase. It has a vast variety of helper functions that you can use. Android as a platform has more functions for in-app-purchase.

[**dooboolab/react-native-iap**](https://github.com/dooboolab/react-native-iap)

### tcomb-form-native

Forms can be a lot more complicated than icons or components as they have a lot of different parts and thereâ€™s logic involved when it comes to field validation and form submission. With this library, you simplify form processing immenselyÂ .

It has a variety of configuration that is platform specific. Using this library you will be writing a lot less code, get usability and accessibility, and no need to update forms when the domain model changes.

[**gcanti/tcomb-form-native**](https://github.com/gcanti/tcomb-form-native)

### Formik

Handling forms is one of the most important aspect of being a good web developer. Same applies if you are using React Native for developing a mobile application. It is a small library that helps you to create forms in React and facilitates form building. It allows you to get values in and out of a form state, validate and get error messages, and effectively submit forms.

[**jaredpalmer/formik**](https://github.com/jaredpalmer/formik)

### Redux

Redux plays a huge part in React and React Nativeâ€™s ecosystem when it comes to manage state in an application. Redux helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test.

Using Redux, you can query, select, insert, and update a record in the database. Redux also has a really useful feature to edit live code. Redux works with any UI layer, and has a large ecosystem of add ons to fit your needs.

[**reduxjs/redux**](https://github.com/reduxjs/redux)

### redux-form

Another well maintained library for building forms in a React Native application. Along with managing state with Redux, this library allows you to track common form states as focused field, fields in the form, fields that the user has interacted with, field values, and many others.

[**erikras/redux-form**](https://github.com/erikras/redux-form)

### redux-persist

Redux Persist takes your Redux state object and saves it to persisted storage. Then on app launch it retrieves this persisted state and saves it back to redux. Managing user data when locally storing in a mobile device can be hard when data sets become complex. Using React Native API `AsyncStorage` natively can be difficult for large applications.

[**rt2zz/redux-persist**](https://github.com/rt2zz/redux-persist)

### React NativeÂ Debugger

React Native Debugger is standalone application that can be installed on your local machine for debugging a React Native application. As a developer, having a quality debugging environment can lead to be more productive, while helping you track down bugs and creating new features.

Another advantage of using this standalone application, is that it already includes Redux DevTools by default. So if your application is depending on Redux state management library, with minimum configuration, you can hook up your React Native app.

[**jhen0409/react-native-debugger**](https://github.com/jhen0409/react-native-debugger)

### React NativeÂ Firebase

React Native Firebase is lightweight JavaScript library that helps you connect your React Native app to the native Firebase SDK for both iOS and Android platform. This process aims to mirror the official Firebase SDK as closely as possible.

Even though the official SDK works with React Native, this package allows you to consume device SDKs which donâ€™t exist on the Firebase JS SDK. To consume the official SDK in React Native, you will to opt for the web one. Things like AdMob, Analytics, Cloud Messaging (FCM), Remote Config, Performance Monitoring, Dynamic Links are not available in the official Firebase SDK.

[**invertase/react-native-firebase**](https://github.com/invertase/react-native-firebase)

### Jest

Jest is a unit testing framework created by Facebook and released on GitHub. It tests JavaScript code. Jest is a versatile testing tool with the ability to adapt to any JavaScript library or framework. Its advantages include snapshot testing support.

[**Jest Â· _ðŸƒ Delightful JavaScript Testing_**](https://jestjs.io/)

### Enzyme

Enzyme is a testing tool from [AirbnbEng](https://medium.com/u/ebe93072cafd). It supports shallow, full DOM, and static rendering. Enzyme also offers developers API wrappers that are supposed to make asserting, manipulating, and traversing the React DOM easier. Another great benefit of the tool is that it is compatible with other testing libraries and frameworks including Jest and Mocha.

[**airbnb/enzyme**](https://github.com/airbnb/enzyme)

### Detox

The most difficult part of automated testing on mobile is the tip of the testing pyramid is E2E.Detox is End to End (_E2E_) testing library for applications written in React Native. It means testing application like a real user, but automatically with code. You will write code and this testing library provides tools to _click through_ the application like a real human user.

For example, a test for a login screen in Detox as it runs on a device/simulator like an actual user looks like below:

```js
describe('Login flow', () => {
  it('should login successfully', async () => {
    await device.reloadReactNative();
    await expect(element(by.id('email'))).toBeVisible();

    await element(by.id('email')).typeText('john@example.com');
    await element(by.id('password')).typeText('123456');
    await element(by.text('Login')).tap();

    await expect(element(by.text('Welcome'))).toBeVisible();
    await expect(element(by.id('email'))).toNotExist();
  });
});
```

[**wix/Detox**](https://github.com/wix/Detox)

### react-native-mock

This third-party solution is relatively new. React-native-mock helps developers work with the latest versions of React Native. The library was specifically designed to facilitate testing of React Native apps.

[**RealOrangeOne/react-native-mock**](https://github.com/RealOrangeOne/react-native-mock)

### ESLint

Lastly, I leave you with the go to linting library used by almost every JavaScript developer. It is called ESLint. It is a pluggable linting utility for JavaScript and to let programmers discover issues with their JavaScript code before executing it. One great benefit of ESLint is that it gives developers the opportunity to create their own linting rules. I personally prefer to use rules provided by the team at AirBnb with some tweaks of my own.

[**ESLint&mdash;Pluggable JavaScript linter**](https://eslint.org/)

### Conclusion

There are other libraries that modules available for React Native for different purposes. Expect more in future since mobile development is hard when it comes to accessing to different APIs. Libraries such as _axios_ for network calls and _Apollo Client_ to query [GraphQL APIs](https://medium.com/crowdbotics/creating-a-graphql-server-with-nodejs-ef9814a7e0e6) can also be used with React Native, as they are used with React JS. I didnâ€™t think that they are worth mentioning here in detail. I hope the above list provides you ready made solutions to help you build better React Native applications.

[Originally published at Crowdbotics](https://medium.com/crowdbotics/21-useful-open-source-packages-for-react-native-807f65a818a1)

---

## Top open source libraries for Node.js
Slug: 29-useful-open-source-libraries-for-nodejs

![cover_image](https://i.imgur.com/Yv3yfrm.png)

> [Originally published at Crowdbotics](https://medium.com/crowdbotics/29-useful-open-source-libraries-for-nodejs-4cefe08f7205)

[**Node.js**](https://nodejs.org) has become more and more popular as a framework because provides quick and efficient solutions for back-end development and integrates well with front-end platforms.

Created by Ryan Dahl in 2009, Node.js is actively maintained by a large community as an open source project. It enables software and app developers to build fast and scalable web applications using just a few lines of code. [Node.js Foundation](https://medium.com/u/96cd9a1fb56)

The world of custom software development constantly evolves with new trends, techniques, and languages. But, with Node.js, app development is significantly simplified.

In this article, I collated a list of the useful open source libraries that you can use in your upcoming Node.js project.

> [**Also, try out the Crowdbotics App Builder to instantly scaffold and deploy a NodeJS app.**](https://app.crowdbotics.com/create/?utm_campaign=cb-medium&utm_content=node-js)

### ExpressJS

Express.js is a go-to, minimalist framework for Node.js web applications. In recent years, it has been a go to framework to write server side code for the applications that want to use and leverage Node.js.

It is actively maintained by a great community, now supports almost all ES6 features and is used by both big companies and startups. There is no shortage of web frameworks when it comes to Nodejs and Express has survived the popularity phase so far.

[**expressjs**](https://github.com/expressjs)

### AdonisJS

It is a complete MVC Nodejs framework (_other than Sails_) that runs on all major operating systems without a problem.Â . It offers a stable ecosystem to write server-side web applications so you can focus on business needs over finalizing which package to choose or not.

It differs from other Nodejs web frameworks such as Express and Koa in manner that those frameworks are mostly routing libraries with thin layer of middleware on top

AdonisJS is combination of multiple packages that work together gracefully integrate with the application. For example, it provides a built-in ORM that is works well with SQL databases such as Postgres and MySQL. It helps to create efficient SQL- queries and is based on active record idea. Its query builder is easy to learn and allows us to build simple queries quickly.

[**adonisjs/adonis-framework**](https://github.com/adonisjs/adonis-framework)

### MomentJS

The standard JavaScript API already comes with the Date object for working with dates and times. However, this object is not very user-friendly when it comes to printing and formatting dates.

In recent years, MomentJS has become a go to module to use with NodeJS applications to parse, validate, manipulate and format date when building APIs and storing them as data in a preferred database. It is lightweight library and now supports ECMAScript 6.

[**moment/moment**](https://github.com/moment/moment)

### gm

GraphicsMagick and ImageMagick are two popular tools for creating, editing, composing and converting images. With module `gm` you can use both tools directly from within your JavaScript code in a NodeJS application. The module supports all the typical required to operate on an image:

- resizing
- clipping
- encoding

```js
var fs = require('fs'),
  gm = require('gm').subClass({ imageMagick: true });

// resize and remove EXIF profile data
gm('/path/to/my/img.jpg').resize(240, 240);
```

[**aheckmann/gm**](https://github.com/aheckmann/gm)

### sharp

With over 11k+ stars on its Github repository, `sharp` is a high performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP and TIFF images.

The typical use case for this high speed Node.js module is to convert large images in common formats to smaller, web-friendly images with different dimensions. Resizing an image is typically 4x-5x faster than using the quickest ImageMagick and GraphicsMagick settings.

```js
sharp('input.jpg')
  .rotate()
  .resize(200)
  .toBuffer()
  .then( data => ... )
  .catch( err => ... );
```

[**lovell/sharp**](https://github.com/lovell/sharp)

### node-csv

The CSV (comma-separated values) format is often used when interchanging table-based data. For example, Microsoft Excel allows you to export or import your data in that format. `node-csv` simplifies the process of working with CSV data in a server side application.

node-sv provides functionalities for generating, parsing, transforming and stringifying CSV and uses streams API for that. It also comes with a callback API, a stream API and a synchronous API to fulfil your needs.

[**adaltas/node-csv**](https://github.com/adaltas/node-csv)

### Passport

Passport is an ExpressJS compatible authentication middleware for Node.js. Its sole purpose is to authenticate requests which is done through an extensible set of plugins known as strategies. Passport does not mount routes or assume any particular database schema, which maximizes flexibility and allows application-level decisions to be made by the developer.

The API is simple and requires you to provide a request to authenticate, and Passport provides hooks for controlling what occurs when authentication succeeds or fails.

```js
passport.serializeUser(function (user, done) {
  done(null, user.id);
});

passport.deserializeUser(function (id, done) {
  User.findById(id, function (err, user) {
    done(err, user);
  });
});
```

[**jaredhanson/passport**](https://github.com/jaredhanson/passport)

### Nodemailer

An open source package, nodemailer lets you send emails just by using it inside a NodeJS app. It is a single module with zero dependencies so you can use it freely without worrying much about sensitive data leaking.

It also secures email delivery using TLS/STARTTLS and you can attach deliverables with your message. The standard Node.js API does not offer such a feature, but fortunately the module Nodemailer fills this gap.

[**nodemailer/nodemailer**](https://github.com/nodemailer/nodemailer)

### ndb

`ndb` is an improved debugging experience for Node.js, developed and enabled by the team behind Google's Chrome web browser. Currently, it is recommended to use Node `v10.x.x` but if you are considering using this package to debug your Node apps, you are required a minimum version of `8.x.x`. ndb has some powerful features exclusively for Node.js:

- Child processes are detected and attached
- You can place breakpoints before the modules are required
- You can edit your files within the UI
- By default, `ndb` blackboxes all scripts outside current working directory to improve focus. This includes node internal libraries (like `_stream_wrap.js`, `async_hooks.js`, `fs.js`)
- supports memory profiler, JS sampling profiler, breakpoint debugging, async stacks and so on

[**GoogleChromeLabs/ndb**](https://github.com/GoogleChromeLabs/ndb)

### lodash

This is a utility library that provides extra functionalities such as iteration, manipulation of values, testing values, and creating composite functions that work with arrays, objects, numbers, strings and so on. It is one of the most popular open source library in Nodejs ecosystem.

```js
// Load the full build.
const _ = require('lodash');

// Load the core build.
const _ = require('lodash/core');

// Load the FP build for immutable auto-curried iteratee-first data-last methods.
const fp = require('lodash/fp');
```

[**lodash/lodash**](https://github.com/lodash/lodash)

### axios

A promise based HTTP client that provide extra features over `fetch` from native JavaScript API, axios is a popular utility tool among both front-end JavaScript developers and NodeJS. It has following features:

- Make XMLHttpRequests from the browser
- Make http requests from node.js
- Supports the Promise API
- Intercept request and response
- Transform request and response data
- Cancel requests
- Automatic transforms for JSON data
- Client side support for protecting against XSRF

Most of the above enlisted features have ae absent from native `fetch` JavaScript API and adds to the advantage of using `axios`. Check out the example below in which `axios` is being used with `async/await` syntax.

```js
async function getUser() {
  try {
    const response = await axios.get('/user?ID=54321');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
```

### Socket.io

This is a library that enables bi-directional communication in real time by using WebSockets. It provides reliability for handling proxies and load balancers, personal firewalls and antivirus software, and supports binary streaming.

Other features include auto-connection support where unless instructed otherwise a disconnected client will try to reconnect forever until the server is available again. Used by organizations such as Microsoft, Zendesk, and Trello it also includes real-time analytics with counters, logs and charts and has a variety of use cases in IoT.

```js
io.on('connection', socket => {
  socket.emit('request' /* â€¦ */); // emit an event to the socket
  io.emit('broadcast' /* â€¦ */); // emit an event to all connected sockets
  socket.on('reply', () => {
    /* â€¦ */
  }); // listen to the event
});
```

[**socketio/socket.io**](https://github.com/socketio/socket.io)

### PM2

It is a Production Runtime and Process Manager for Node.js applications with a built-in Load Balancer. It allows you to keep applications alive forever, to reload them without downtime and facilitate common devops tasks. Starting an application is easy as well as managing one too.

PM2 has container support as well with the drop-in replacement command for node, called pm2-runtime, run your Node.js application in a hardened production environment. It supports all major Node.js frameworks such as Express, Sails, Hapi and so on.

[**Unitech/pm2**](https://github.com/Unitech/pm2)

### Joi

Introduced with HapiJS, Joi has become a popular library to validate incoming data requests. If you have ever used an ORM when building your Node application such as Sequelize or Mongoose, you know that it is possible to set validation constraints for your model schemas.

This makes it very easy to handle and validate data at the application level before persisting it to the database. When building APIs, the data usually come from HTTP requests to certain endpoints, and the need may soon arise to be able to validate data at the request level.

Joi is used to validate schema objects with additional rules provided by its own API. Moreover, it works with any Nodejs framework rather than just HapiJS.

```js
const Joi = require('joi');

const schema = Joi.object()
  .keys({
    username: Joi.string().alphanum().min(3).max(30).required(),
    password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
    access_token: [Joi.string(), Joi.number()],
    birthyear: Joi.number().integer().min(1900).max(2013),
    email: Joi.string().email({ minDomainAtoms: 2 })
  })
  .with('username', 'birthyear')
  .without('password', 'access_token');
```

[**hapijs/joi**](https://github.com/hapijs/joi)

### TypeORM

Whether you want to work with TypeScript enabled Nodejs server or make use of latest ES6, ES7 JavaScript features to create an API for your application, TypeORM is a popular library that work with multiple databases. It supports both Active Record and Data Mapper patterns, unlike all other JavaScript ORMs currently in existence, which means you can write high quality, loosely coupled, scalable, maintainable applications the most productive way.

For example, a typical connection to a database using TypeORM looks like:

```js
import 'reflect-metadata';
import { createConnection } from 'typeorm';
import { Photo } from './entity/Photo';

createConnection({
  type: 'mysql',
  host: 'localhost',
  port: 3306,
  username: 'root',
  password: 'admin',
  database: 'test',
  entities: [Photo],
  synchronize: true,
  logging: false
})
  .then(connection => {
    // here you can start to work with your entities
  })
  .catch(error => console.log(error));
```

It also supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, WebSQL databases.

[**typeorm/typeorm**](https://github.com/typeorm/typeorm)

### Sequelize

It is a promise based Nodejs ORM that supports multiple SQL based databases such as Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. It features solid transaction support, relations, read replication and more. It comes with its own CLI tool that enables data migrations and model/schema creation easy. It has a simple installation process, all you have to do is install `sequelize` in your Nodejs application along with the driver of that database you are using.

```shell
$ npm install --save sequelize

# And one of the following:
$ npm install --save pg pg-hstore
$ npm install --save mysql2
$ npm install --save mariadb
$ npm install --save sqlite3
$ npm install --save tedious # MSSQL
```

[**sequelize/sequelize**](https://github.com/sequelize/sequelize)

### Mongoose

MongoDB is a commonly used NoSQL database in Nodejs applications. It stores the data in JSON documents and the structure of these documents can vary as it is not enforced like SQL databases.

Mongoose is an Object Data Modelling (ODM) library for MongoDB and Node.js. It manages relationships between data, provides schema validation, and is used to translate between objects in code and the representation of those objects in MongoDB.

```js
const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true });

const Cat = mongoose.model('Cat', { name: String });

const kitty = new Cat({ name: 'Zildjian' });
kitty.save().then(() => console.log('meow'));
```

[**Automattic/mongoose**](https://github.com/Automattic/mongoose)

### MochaJS

Mocha.js is a JavaScript test framework based on Node.js. It enables you to test both in console and in the browser. You can use this really fast testing suite to do the unit and integration testing plus it works with testing patterns such as TDD (_Test-Driven Development_) and BDD (_Behavior Driven Development_). Mocha works well with other assertion libraries such as Chai, Sinon, Should.js. This is an advantage and the reason for its popularity.

```js
const assert = require('assert');

describe('Array', function () {
  describe('#indexOf()', function () {
    it('should return -1 when the value is not present', function () {
      assert.equal([1, 2, 3].indexOf(4), -1);
    });
  });
});
```

[**mochajs/mocha**](https://github.com/mochajs/mocha)

### Chai

Chai is a TDD and BDD assertion framework for Node.js which can be paired with any test runner framework. As an assertion tool, you can use Chai with its rich plugin system such as `chai-as-promised`, `chai-events`, `chai-spies-next`. It gives me much simpler and more readable tests than using my own assertion helpers or other less popular libraries.

[**chaijs/chai**](https://github.com/chaijs/chai)

### SinonJS

This is a standalone testing framework for Node.js. The advantage it possess is that it works with any testing framework. You will find many examples of it being used with Mocha and Chai. It requires minimal integration and supports stubs, spies and mocks. It also supports most browsers (cross-browser support) and runs on the server using Node.js.

[**sinonjs/sinon**](https://github.com/sinonjs/sinon)

### AVA

This is a minimal testing framework to test Node.js applications. It utilizes the async I/O nature of Node and runs concurrent tests, hence, it vastly decreases test suite times. Some of its highlights are:

- Magic assertion in which it adds code excerpts and clean diffs for actual and expected values. If values in the assertion are objects or arrays, only a diff is displayed, to remove the noise and focus on the problem.
- Clean stack traces by automatically removing unrelated lines in stack traces, allowing you to find the source of an error much faster, as seen above.
- supports latest JavaScript features using [**Babel 7**](https://babeljs.io/).

[**avajs/ava**](https://github.com/avajs/ava)

### Jest

Jest is an open source framework that built for writing and running tests in JavaScript. It is open source, created and maintained by the Facebook. It is built with multiple layers on top of jasmine (_another test running framework_) by keeping some of good parts from jasmine. Its strengths are:

- is fast
- it can perform snapshot testing
- is opinionated, and provides everything out of the box without requiring you to make choices

The advantage it has over other NodeJS testing frameworks such as Mocha that it uses its own assertion API whereas using Mocha you have to install another third party module in order to create and run tests. Jest is human friendly framework. It has gained its attraction by its well supported and very fast testing behavior.

[**facebook/jest**](https://github.com/facebook/jest)

### CloudRail

Using CloudRail, you can easily integrate external APIs into your application. CloudRail provides abstracted interfaces that take several services and then exposes a developer-friendly API that uses common functions between all providers.

This means that, for example, upload() works in exactly the same way for Dropbox as it does for Google Drive, OneDrive, and other Cloud Storage Services, and getEmail() works similarly the same way across all social networks.

[**CloudRail/cloudrail-si-node-sdk**](https://github.com/CloudRail/cloudrail-si-node-sdk)

### agenda

Job scheduling is a big part of any server side framework. Luckily, Nodejs has one awesome framework to schedule jobs to run at a particular time and run on a particular day. `agenda` is a light-weight job scheduling library for Node.js. It uses promised based API and has Mongo backed persistence layer.

[**agenda/agenda**](https://github.com/agenda/agenda)

### Nodemon

It is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected. It does not require any additional changes to your code or method of development.

`nodemon` is a replacement wrapper for node, to use `nodemon` replace the word `node` on the command line when executing your script. It was originally written to restart hanging processes such as web servers, but now supports apps that cleanly exit.

[**remy/nodemon**](https://github.com/remy/nodemon)

### Keystone CMS

It is a content management system and web application framework built on Express framework and uses Mongoose as the ODM. It makes it easy to create sophisticated web sites and apps, and comes with a beautiful auto-generated Admin UI. Currently, the Admin UI is a single page application written using React, Redux and Elemental UI. You can use your own Express instance and integrate Keystone as a library.

[**keystonejs/keystone**](https://github.com/keystonejs/keystone)

### Strapi

Another open source Content Management System for Nodejs application, Strapi has its own advantages. One of them is it being headless and supporting multiple databases such as MySQL, Postgres and MongoDB. It has many features such as:

- Modern Admin Panel: Elegant, entirely customizable and fully extensible admin panel
- Secure by default: Reusable policies, CSRF, CORS, P3P, Xframe, XSS
- Plugins Oriented: Install auth system, content management, custom plugins, and more, in seconds
- Powerful CLI: Scaffold projects and APIs on the fly
- Front-end Agnostic: Use any front-end frameworks (React, Vue, Angular, and more.), mobile apps or even IoT
- Blazing Fast: Built on top of Node.js, Strapi delivers amazing performances.

[**strapi/strapi**](https://github.com/strapi/strapi)

### FakerJS

When we start to build an application, we generally do not want to worry much about data. To create a database and fill it with sample data seems much of a hassle to me personally.

```js
var faker = require('faker');

var randomName = faker.name.findName(); // Rowan Nikolaus
var randomEmail = faker.internet.email(); // Kassandra.Haley@erich.biz
var randomCard = faker.helpers.createCard(); // random contact card containing many properties
```

FakerJS a wonderful node module to create fake/mock data when you are starting to build a prototype or an application. It has its own API that has a variety of generators to construct mock data as per your needs.

[**Marak/faker.js**](https://github.com/marak/Faker.js/)

### Dotenv

Saving sensitive data in the form of environmental variables is one good practice to be followed when working with Nodejs web frameworks. Environmental variables are local variables that are made available to an application. Creating these variables is made easy with a tool like `dotenv`.

This module loads environment variables from aÂ `.env` file that you create and adds them to the `process.env` object that is made available to the application. This module allows you to create secret keys that your application needs to function and keep them from going public.

[**motdotla/dotenv**](https://github.com/motdotla/dotenv)

### Conclusion

Nodejs is a mature platform. Working with third party libraries is a huge part of the JavaScript ecosystem and you cannot run from it. Apart from your personal opinion, if you do not appreciate working with different third party libraries then you should definitely think about the tech stack you are working with.

_I hope this list gets you started to with most commonly used open source packages that are used in_ [**_Node.js_**](https://nodejs.org) _community._

---

## 3 Steps to learn React Native in 2019
Slug: 3-steps-to-learn-react-native-in-2019

![cover_image](https://i.imgur.com/LUgTT2v.jpg)

If you are interested in writing code for mobile applications using JavaScript, you are reading the right post. React Native, developed and maintained by Facebook, is an open-source framework to develop cross-platform mobile applications, using the programming language JavaScript.

Currently, in its **0.57 version,** React Native is based on Facebookâ€™s front-end library called ReactJS and shares many concepts. If you are familiar with React, kudos to you! You have crossed the first hurdle. Coming from a frontend development background, React uses a virtual DOM which acts as a shadow to the real DOM available. When an element changes, that change is reflected on the real DOM by Virtual DOM using a node that corresponds to each element.

However, in React Native, there is no DOM other than Native Components which are provided by platforms such as iOS and Android. There are no web views here. React Native has an instance of [**JavaScriptCore**](https://facebook.github.io/react-native/docs/javascript-environment.html) to execute JS code when an application starts. React Native uses RCTBridgeModule to make a connection between native code and JavaScript code. It is currently being used by Facebook, Instagram, Uber, Wix, Tesla and many more.

Here is what I think you can do to advance with React Native development.

## Start with basics

This article briefly provides you with an overview of what is inside the React Native app development process and how things work behind the scenes, briefly. I often come across (especially through [_#100DaysOfCode_](https://x.com/_100DaysOfCOde) campaign) developers who struggle to learn a new framework with little to no background in specific the programming language. My advice, is before you leap to make gigantic projects, start with the basics. Learn the concepts as each specific component to the curve, make sure to apply them as much as you can and build small things.

For example, learn how to use `FlatList` component. Try creating a list with your own dataset or find a mock/fake data set on the internet and try to build a small app out of it. Always remember the feeling you got from creating your first _Hello World_ program. Do you remember that sense of accomplishment?

Take small steps, and build small things at first before dipping your toes deep in the complexity of state management libraries such as Redux and Mobx, or persisting data, using third-party APIs, using TypeScript or Flow, and so on.

These are just tools, you do not need to know them on day one (_but I am not saying you have to never learn about them. The keyword here is that they are TOOLS_). If you are new to JavaScript, make sure you are clear with the basic ES6 features such as classes, arrow functions, and so on. Then, you must go through the basic ReactJS concepts such as props, state, and stateless components in general.

In summary, start by familiarizing yourself with:

- ES6 Features
- ReactJS Components API and LifeCycle methods
- Setting up a development environment for React Native
- Flexbox

## Advance yourÂ way

Once you have basic concepts clear in your mind and have played around a bit to get some amount of hands-on experience, it is time to advance further. Start building bigger apps that work or behave like real applications and interact with real-time data. Here is a list of things you can learn to advance in your journey.

- Offline data storage with `AsyncStorage`
- Working with third-party APIs
- Maps
- Splash Screens
- Navigation
- Redux (for state management)
- Redux Saga and Persist
- Tests and TDD
- Push notifications
- UI Animations
- Build and publish your app
- Continuous Delivery or CI

Note that these are just broad topics to get you started. There are many other things you will learn along the way. Donâ€™t get overwhelmed by that.

## Personal Challenges: What do you want out ofÂ it?

Maybe you to become professional a React Native developer and work in an organization that uses this tech framework or maybe you want to build apps for your clients/customers. Setting your challenges in the way is a great way to accomplish things and learn.

Commit yourself and work on it. Find apps on your phone or in stores that you want to clone or add an extra feature as a functionality, or learn about the user interface.

Do not get overwhelmed by the number of mistakes you make or the errors you get. Getting frustrated and ranting/complaining about it over the internet all day is easy but understand this is that, it will not solve your problems or make you a better developer. All of this is a part of your journey. Keep reminding yourself of that.

## Conclusion

In simple words, React Native brings React to mobile app development. Its goal isnâ€™t to write the code once and run it on any platform. The main goal here is to learn once and write anywhere. An important distinction to make.

[Originally published at The Startup](https://medium.com/swlh/3-steps-to-learn-react-native-in-2019-5cdb3d1e1c84)

---

## Accessing Geo-location and App Permissions in React Native and Expo
Slug: accessing-geo-location-and-app-permissions-in-react-native-and-expo

> [Originally published at React Native Training](https://medium.com/react-native-training/accessing-geo-location-and-app-permissions-in-react-native-and-expo-e7a1bd4714a2)

![cover_image](https://i.imgur.com/jEjHKCI.jpg)

In web, Geolocation is provided as an API that has different methods to use in a web application. Similarly, React Native takes advantage of this API and is available as polyfills. Geolocation is a must have feature to implement in a mobile app. Few of the famous mobile apps that use it for more than 90% in terms of usage are Uber, Google Maps, and more. In this article, I will show how to integrate the Geolocation API in a React Native app in two ways. Using Expo and using `react-native-cli`. Along with that, I am going to implement a real time feature that is commonly used with these types of applications. Asking **user permissions**. Permissions in `react-native-cli` can be a bit tricky but after reading this article, it won't be tricky to you as much.

## Getting Started WithÂ Expo

For this purpose, I am using `expo-cli`. Follow the below commands to set up an Expo project and get started.

```shell

npm install -g expo-cli

expo-cli init find-me

# select blank template & traverse into a newly created directory

npm run ios

# for Window users, run

npm run android
```

You will be welcomed with a default screen. We will start here. First, edit the `App.js`.

![ss](https://i.imgur.com/kWvPIWF.png)

Create a new file for the `FindMe` component at `src -> screens -> FindMe -> index.js`. Inside this file, we will just display a text.

![ss](https://i.imgur.com/rRRzQVb.png)

Here is how our app looks so far.

![ss](https://i.imgur.com/9oCTyax.png)

## Accessing Geolocation API

The Geolocation API exists as a global object called `navigator` object in React Native, just like the web. It is accessible via `navigator.geolocation` in our source code and there is no need to import it.

For our demonstration purposes, we will be using `getCurrentPosition` method from the geolocation API. This method allows a mobile app to request a user's location and accepts three parameters: success callback, error callback and a configuration object in the last.

![ss](https://i.imgur.com/oeYTXrk.png)

The first callback has a `position` argument that is an object with the following properties.

```shell
{
  "timestamp": 1533729980953.91
  "coords": {
    "accuracy": 5,
    "altitude": 0,
    "altitudeAccuracy": -1,
    "heading": -1,
    "latitude": 37.785834,
    "longitude": -122.406417,
    "speed": -1
  }
}
```

Now, implement this in our `FindMe` component.

![ss](https://i.imgur.com/totMaU5.png)

We start be importing `TouchableOpcaity`. It is a wrapper that responds accurately to user touches. In a mobile app, you will be making use of them. Think of it as a button in a web application. This newly imported wrapper accepts an `onPress` prop that is going to trigger the function defined as in the value, in our case `findCurrentLocation`.

`findCurrentLocation` holds the logic of fetching a user's location. We are also using the local state to display coordinates from the data provided to us by `position` object. The text `Where Am I` now becomes clickable.

![ss](https://i.imgur.com/Wj58GJo.png)

Thatâ€™s it for the app part. Now let us see how to add permissions to the same application.

## Using Expo Permissions

Requesting to access a userâ€™s information whether it is location or any other sensitive information on the device, it is your job as the developer to ask for the permissions first. It is one time process, both when developing the application and when the user is using the application. Most permissions are asked when the user installs the application run it for the first time.

For us, Expo has integrated all the permission API we need for this demo app or any other app you are building using Expo. This API has different methods for device types of permissions to grant for. Such as location, camera, audio recording, contacts, camera roll, calendar, reminders (for ios only) and notifications. We are going to use `Location`.

![ss](https://i.imgur.com/e4InNct.png)

We change our state a bit. It will not store the whole geolocation object and `errorMessage` in case of an error. Our `findCurrentLocation` remains the same. In fact, we are not using it. Expo has a method for us that does the same. It is called `getCurrentPositionAsync`. It will only fetch the user's location and other properties made available by `getCurrentPosition` method from Geolocation API and if the permission is granted. In the render method, `onPress` prop is now calling a different method `findCurrentLocationAsync` that holds the logic for asking permission and fetches the location data after the user has granted permission to our app to access it. If not, the error message is set otherwise the location in the state is updated.

The last step is for android users. Open `app.json` and permissions.

![ss](https://i.imgur.com/NvFVYyw.png)
![ss](https://i.imgur.com/gov0n1z.png)

If you press allow, you will see the following result.

![ss](https://i.imgur.com/hEh9YBC.png)

Note that in even in development mode and running the app in a simulator, the permissions are only asked once. To perform this again, you will have to delete the app from your simulator and re-run the command to start the expo app.

## Using react-native-cli

Using `react-native-cli` means you will have to set permissions on your own, however, the logic of getting a user's location is going to be the same.

There are no templates in `react-native-cli` so once the directory is generated, traverse into it and run `npm start` to see if everything is installed correctly. The first thing you will notice when you open this project in an IDE or a code editor is that there is a vast amount of change in the structure of files and folders. Expo had a sort of minimal project structure as compared to this one. There are separate build folders such as `/android` and `/ios` for each platform. You can also use flow (which is similar to TypeScript, open sourced by Facebook).

![ss](https://i.imgur.com/MOyLOFw.png)

We will only modify `App.js` file with the following code.

![ss](https://i.imgur.com/CPryJLE.png)

Observe that `findCoordinates` works the same way as in Expo application and also the code in `render()` function is exactly same. Our next step is to set permissions.

In ios, geolocation is enabled by default when a project is created using `react-native-cli`. To use it, we just need to include a key in `info.plist` which is inside the `ios/findCoordsApp` directory.

![ss](https://i.imgur.com/Iqc2Y2c.png)

For android, we need to add the following line in `android/app/src/AndroidManifest.xml` file.

```xml
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
```

![ss](https://i.imgur.com/eqkj6TT.png)

Now if you run your application you will see the following screen.

![ss](https://i.imgur.com/528AV75.png)

Click on the text and you will be prompted to ask whether to allow the application to request for userâ€™s location or not. For the demonstration purpose, I am using an android Emulator since we have already seen how it works on ios Simulator in the Expo section.

![ss](https://i.imgur.com/RVPukGJ.png)

If you press allow, you will see the following result.

![ss](https://i.imgur.com/z7MQSko.png)

_You can find the complete code in this Github repository._ ðŸ‘‡

[**amandeepmittal/findCoordsApp**](https://github.com/amandeepmittal/findCoordsApp)

If you want to learn more about working with Geolocation API in a React Native application, please go through the [**official documentation**](https://facebook.github.io/react-native/docs/geolocation)**.**

[**Expoâ€™s Documentation**](https://docs.expo.io/versions/latest/sdk/permissions#__next) has a lot more on **Permissions** too.

---

## Adding Bluesky icon to my Astro blog
Slug: add-bluesky-icon-to-astropaper

I use [AstroPaper](https://github.com/satnaing/astro-paper) as the default theme for my blog. It is a minimal, responsive and SEO-friendly Astro blog theme. Astro is a modern static site builder that allows you to build faster websites with less client-side JavaScript. This theme is minimal and customization-friendly.

With [Bluesky growing rapidly, adding over one million users daily](https://www.cnet.com/tech/bluesky-explained-why-this-social-media-network-is-now-growing-by-1-million-users-daily-luke-skywalker/), is built using Expo (where I currently work), and attracting the "tech Twitter" community (yes, Twitter, not X), it reminds me of Twitter's early days.

I decided to look into [AstroPaper's GitHub repository](https://github.com/satnaing/astro-paper) to see if there are any new updates for adding this new icon. The instructions in this post are from [this closed PR](https://github.com/satnaing/astro-paper/pull/209).

---

Lucky for us, all the significant social icons are defined and stored in one file called `src/assets/socialIcons.ts`:

```ts
const socialIcons = {
  // All social SVG icons...
};
```

Let's update the `socialIcons` object by adding a new SVG icon called `Bluesky`, with the following code:

```ts
const socialIcons = {
  // Other social svgs...
  Bluesky: `<svg class="icon-tabler" viewBox="0 0 55 55" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
<path fill="currentColor" d="M27.5,25.73c-1.6-3.1-5.94-8.89-9.98-11.74c-3.87-2.73-5.35-2.26-6.31-1.82c-1.12,0.51-1.32,2.23-1.32,3.24
c0,1.01,0.55,8.3,0.92,9.51c1.2,4.02,5.45,5.38,9.37,4.94c0.2-0.03,0.4-0.06,0.61-0.08c-0.2,0.03-0.41,0.06-0.61,0.08
c-5.74,0.85-10.85,2.94-4.15,10.39c7.36,7.62,10.09-1.63,11.49-6.33c1.4,4.69,3.01,13.61,11.35,6.33c6.27-6.33,1.72-9.54-4.02-10.39
c-0.2-0.02-0.41-0.05-0.61-0.08c0.21,0.03,0.41,0.05,0.61,0.08c3.92,0.44,8.18-0.92,9.37-4.94c0.36-1.22,0.92-8.5,0.92-9.51
c0-1.01-0.2-2.73-1.32-3.24c-0.97-0.44-2.44-0.91-6.31,1.82C33.44,16.85,29.1,22.63,27.5,25.73z" />
</svg>`
};
```

In the AstroPaper theme, the `SOCIALS` array inside the `stc/config.ts` controls the active social profiles displayed on the blog. Let's add the `Bluesky` social link to this array so that the link will appear on its own.

```ts
export const SOCIALS: SocialObjects = [
  // Other social links...
  {
    name: 'Bluesky',
    href: 'https://bsky.app/profile/aman.bsky.social',
    linkTitle: `${SITE.title} on Bluesky`,
    active: true
  }
];
```

Here's what's happening in the snippet above:

- **`name`**: The name of the social media platform.
- **`href`**: Your Bluesky profile URL.
- **`linkTitle`**: Tooltip text shown on hover.
- **`active`**: Displays the icon when set to `true`.

After making this change, the icon will appear (depending on how you customized the AstroPaper theme for your blog) in the hero section and the footer:

![Bluesky icon in hero section](/images/bluesky-icon/ss2.png)

![Bluesky icon in footer](/images/bluesky-icon/ss1.png)

This is great, and you are done! However, I wouldn't say I liked how the icon is filled with the current color. To match it with the rest of the icons and make it appear outline, set the value of `fill` to `none` and add the `stroke-width` to `4` inside the `src/assets/socailIcons.ts` file:

```ts
const socialIcons = {
  // Other social svgs...
  Bluesky: `<svg class="icon-tabler" viewBox="0 0 55 55" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
<path fill="none" stroke-width="4" d="M27.5,25.73c-1.6-3.1-5.94-8.89-9.98-11.74c-3.87-2.73-5.35-2.26-6.31-1.82c-1.12,0.51-1.32,2.23-1.32,3.24
c0,1.01,0.55,8.3,0.92,9.51c1.2,4.02,5.45,5.38,9.37,4.94c0.2-0.03,0.4-0.06,0.61-0.08c-0.2,0.03-0.41,0.06-0.61,0.08
c-5.74,0.85-10.85,2.94-4.15,10.39c7.36,7.62,10.09-1.63,11.49-6.33c1.4,4.69,3.01,13.61,11.35,6.33c6.27-6.33,1.72-9.54-4.02-10.39
c-0.2-0.02-0.41-0.05-0.61-0.08c0.21,0.03,0.41,0.05,0.61,0.08c3.92,0.44,8.18-0.92,9.37-4.94c0.36-1.22,0.92-8.5,0.92-9.51
c0-1.01-0.2-2.73-1.32-3.24c-0.97-0.44-2.44-0.91-6.31,1.82C33.44,16.85,29.1,22.63,27.5,25.73z" />
</svg>`
};
```

You can always change the stroke width (`stroke-width`) as you like. Now, the updated icon will match the other social icons:

![Updated Bluesky icon in hero section](/images/bluesky-icon/ss3.png)

Following the instructions above, you can add whichever icon you'd like. I personally find AstroPaper's customization options to keep my blog up to date with minimal effort. What customizations have you tried? Let me know on [Bluesky](https://bsky.app/profile/aman.bsky.social)!

---

## Add Environment Variables in a Netlify Deployment
Slug: add-environment-variables-in-netlify-deployment

![cover_image](https://i.imgur.com/SX2uERE.png)

Recently I migrated my blog (the one you reading right now) from [Gatsby](https://www.gatsbyjs.com/) to [Next.js](https://nextjs.org/) for some specific reasons. The first reason, me being curious about how Next.js works and how is the developer experience. The second one, I want to have minimal effort and spend less time in managing a blog's UI and spend more time on writing posts. Lately, the vice versa has been the reality.

To not write every CSS element from scratch for responsive design, I am using [Chakra UI](https://blog.logrocket.com/how-to-create-forms-with-chakra-ui-in-react-apps/) for this blog which is a UI component library for React apps. It serves the purpose.

## The idea for the post

The idea of the post came from a problem of my own. Since I am a fan of minimal effort, this blog has been running from a [GitHub repository](https://github.com/amandeepmittal/amanhimself.dev) deployed with [Netlify](https://www.netlify.com/).

There are many advantages to this bare infrastructure such as free HTTPS certificate, using a custom domain, and so on. This way, Netlify manages continuous deployment runs the build command from a Gatsby or a Next.js rendered site. It also triggers a deployment whenever there is a new commit pushed in the GitHub repository.

## The problem that leads me to use an environment variable

That said, let's get back to the main topic. After deploying the blog with 90+ posts, I ran into an issue that is known as "Allocation failed &mdash; JavaScript heap out of memory" in Node.js world.

The issue occurs when the deployment build runs out of memory. Node.js does not handle this by rolling back and moves forward with the build which eventually concludes in the build to fail.

Regardless of what stack or framework you use to deploy your site, if the deployment instance is using a node server, one day you might run into an issue as shown below.

![ss1](https://i.imgur.com/heymZ2D.png)

## The good "Old space" problem in V8

Diving further I got to learn a new thing even though I've been using Node.js since the starting of my own developer career. This issue occurs when the memory consumption of garbage collection in V8 reaches its max limit. If the limit is exceeded, V8 kills the process.

> More information on this issue can be found on [Stackoverflow here](https://stackoverflow.com/questions/48387040/nodejs-recommended-max-old-space-size/48392705). It also explains, when to increase the memory and when to avoid.

## Increasing the memory limit with Environment Variable

According to Chris McCraw's answer [here](https://community.netlify.com/t/fatal-error-call-and-retry-last-allocation-failed-javascript-heap-out-of-memory/1840/4), a Netlify build (if not using an Enterprise plan) should not exceed the limit of 3GB for reliability. In the same thread, there is a proper solution and that leads to the use of environment variables.

If you face this problem using the same approach with Netlify as I did, or for some other reason you want to use environment variables, here is how to get started. Step one is to go to your deployment on Netlify and click the option **Deploy Settings**.

![ss2](https://i.imgur.com/qjEP2pR.png)

This is where all the deployment-related settings are stored. On the next screen, observe a sidebar and under the tab **Build & deploy** there is a sub-tab called **Environment**. Click on that and then click on the button **Edit variables**. Now, you can add the key and value for each environment variable as shown below.

![ss3](https://i.imgur.com/5NKWri1.png)

## Further reading

Here is a list of all the links I came across when resolving this issue:

- [The JavaScript heap out of memory thread](https://community.netlify.com/t/fatal-error-call-and-retry-last-allocation-failed-javascript-heap-out-of-memory/1840/4)
- [The Stackoverflow thread that explains shortcomings of V8 in managing memory](https://stackoverflow.com/questions/48387040/nodejs-recommended-max-old-space-size/48392705)
- [Features of Netlify + GitHub app](https://github.com/apps/netlify)

---

## How to add opacity to a Pressable component in React Native
Slug: add-opacity-to-pressable-component-react-native

`Pressable` component was introduced in React Native in 2020 as a core component wrapper. It can be used instead of existing touchable components including `TouchableOpacity`, `TouchableHighlight`, and `TouchableWithoutFeedback`. These components include styles and effects that sometimes do not meet the desired outcome on individual platforms (Android and iOS).

The way I see using the `Pressable` component is that it can be customized in terms of style, appearance, and extended functionality by creating a custom wrapper/component around it. It also offers a lot of props such as `onPressIn`, `onPressLong`, `hitSlop`, `delayLongPress` and so on, that can be used to implement these extended functionalities.

At times, one thing I like to do is to add opacity feedback when the touch is active. It doesn't provide in the form of a prop directly. Something similar to what [activeOpacity](https://reactnative.dev/docs/touchableopacity#activeopacity) prop on TouchableOpacity does.

In this post, let's build a wrapper component that uses `Pressable` to add opacity feedback to the component.

## Creating a wrapper component

Start by creating a custom `Pressable` component with no styles of its own so it can be a reusable component.

```tsx
// Pressable.tsx
import { useCallback } from 'react';
import {
  Pressable as RNPressable,
  PressableProps,
  PressableStateCallbackType
} from 'react-native';

type CustomPressableProps = PressableProps & {};

export default function Pressable({
  children,
  style,
  ...props
}: CustomPressableProps) {
  const customStyle = useCallback(
    (state: PressableStateCallbackType) => {
      if (typeof style === 'function') {
        return style(state);
      }
      return style;
    },
    [style]
  );

  return (
    <RNPressable style={customStyle} {...props}>
      {children}
    </RNPressable>
  );
}
```

So far, it accepts only three props:

- `children` that is used to add a label on the button (using like a `Text` component from React Native)
- `style` that is used to add styles to the button
- `...props` is used to pass down all the props to the underlying `Pressable` component.

The `useCallback` hook is used to memoize the `customStyle` function. This is to ensure that the `customStyle` function is not recreated on every render. Since React Native's `Pressable` component accepts style as either an object or a function, you need to pass the pressed state in case it is a function. Otherwise, it will throw a TypeScript error. If the `style` is an object, it can be returned as is.

In the above code, since the wrapper component you are creating will only be responsible for handling opacity, other important props like `onPress` are left to be handled where this wrapper component will be used.

## Using the wrapper component

To use the wrapper component in its current state, import it:

```tsx
// app/(tabs)/index.tsx
import { View, Text } from 'react-native';

import CustomPressable from '@/components/Pressable';

export default function Home() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <CustomPressable
        style={{ borderRadius: 4, backgroundColor: '#FF0063', padding: 8 }}
      >
        <Text style={{ color: 'white' }}>Press Me</Text>
      </CustomPressable>
    </View>
  );
}
```

Make sure to add some styles to the `Text` and the `Pressable` components.

## Running the example

Here is the output I get by running the code above. Notice that there is no visual feedback when I press the component on the app screen.

![ss1](https://i.imgur.com/XcLXQbn.gif)

I used the [Touch indicator on an iOS simulator](https://amanhimself.dev/blog/show-touch-indicator-on-ios-simulator/) to show that the button is pressed.

## Adding opacity prop to the wrapper component

In some scenarios, you may want to add and use opacity as the feedback. For example, decrease the opacity to `0.5` when the button is being pressed.

You can extend the `styles` to accept a `pressed` state. It is a boolean that tells whether the component is currently pressed or not. Using it, you can alter the value of the opacity property in styles.

In the wrapper component, add a new prop called `activeOpacity`. This prop accepts a number between `0` and `0.99`. It is used conditionally on the `opacity` property and will only be true when the component is pressed.

When the component is not in a pressed state, the opacity value is `1`.

```tsx
// Pressable.tsx
import { useCallback } from 'react';
import {
  Pressable as RNPressable,
  PressableProps,
  PressableStateCallbackType
} from 'react-native';

type CustomPressableProps = PressableProps & {
  activeOpacity?: number;
};

export default function Pressable({
  children,
  style,
  activeOpacity,
  ...props
}: CustomPressableProps) {
  const customStyle = useCallback(
    (state: PressableStateCallbackType) => {
      const { pressed } = state;
      const baseStyle = { opacity: pressed ? activeOpacity : 1 };

      if (typeof style === 'function') {
        const derivedStyle = style(state);
        return [baseStyle, derivedStyle];
      }
      return [baseStyle, style];
    },
    [activeOpacity, style]
  );

  return (
    <RNPressable style={customStyle} {...props}>
      {children}
    </RNPressable>
  );
}
```

## Running the example with activeOpacity value

The below code snippet modifies the previous example to add an activeOpacity value of `0.5`:

```tsx
export default function Home() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <CustomPressable
        style={{ borderRadius: 4, backgroundColor: '#FF0063', padding: 8 }}
        activeOpacity={0.5}
      >
        <Text style={{ color: 'white' }}>Press Me</Text>
      </CustomPressable>
    </View>
  );
}
```

The output after this step confirms that the opacity is changing as expected.

![ss2](https://i.imgur.com/LDyiXIu.gif)

## Conclusion

The [`Pressable` component](https://reactnative.dev/docs/pressable) has many props that can be used to write an extensive and customized wrapper that fulfills your app's requirements. It is preferred in the official React Native documentation and provides a future-proof way of handling touch-based events.

---

## How to add a recent posts section to your Astro blog
Slug: add-recents-posts-astro-section

Recent posts are a light-weight way to keep readers engaged through your blog's content. Recently, I decided to add this section at the end of each post without using any external service like an analytics service.

Instead, I decided to use tags, which are already present in each blog post's frontmatter and use them to show the most recent posts. I've used tags since the beginning of my blog and I've also written a [post about how I manage tags without getting overwhelmed](/blog/tag-gardening/) by their amount.

Let's dive into the implementation.

## Establish the criteria for recent posts

The beauty of Astro as a template engine is that you can create a reusable component that can be used in multiple pages. Astro components are defined using `.astro` files and work in a similar way to React, Vue, and more modern JavaScript frameworks.

Drop a component file where you keep your Astro components. In my blog's case, I keep them in `src/components/` directory. This component will be used to calculate recent posts based on the following factors:

- Filters out any draft posts. Posts with `draft: true` in the frontmatter
- Filters out current post. The post that the reader is currently viewing
- Filters out any post that is older than 12 months. You can skip it but I want to avoid showing outdated posts
- Each recent post must match at least one shared tag (case-insensitive)
- Show up to three most recent posts

## Start implementing the reusable component

Let's start by creating a component file called `RecentPosts.astro`. This component requires three props:

- `currentSlug`: The slug of the current post
- `currentTags`: The tags listed in the frontmatter of the current post
- `posts`: An array of all blog posts from the content collection

These props can be extracted from `Astro.props` object:

```js
---
import type { CollectionEntry } from 'astro:content';
import { LOCALE } from '@config';

export interface Props {
  currentSlug: string;
  currentTags: string[];
  posts: CollectionEntry<'blog'>[];
}

const { currentSlug, currentTags = [], posts = [] } = Astro.props;
```

Now, you need to set a variable that holds the value of the cutoff date to one year ago. It creates a new Date object for the current date and then subtracts one year from it. This will help you filter out any posts that are older than one year.

```js
const cutoff = new Date();
cutoff.setFullYear(cutoff.getFullYear() - 1);
```

Next, create a normalized set of tags which are lowercased and whitespace-trimmed for consistent matching. For example, "react native" matches "react-native".

```js
const tagSet = new Set(
  currentTags.map(tag => String(tag).toLowerCase().trim()).filter(Boolean)
);
```

Then, create a locale-aware date frontmatter so you can show the date of each post listed in the recent posts section:

```js
const formatter = new Intl.DateTimeFormat(LOCALE.langTag, {
  year: 'numeric',
  month: 'short',
  day: 'numeric'
});
```

## Create a function to filter eligible posts

You need to now create a function that satisfies the criteria defined in the previous section. This function will be used to filter out any posts that do not meet the criteria.

Add a `recentPool` function that excludes posts with missing data, current post, drafts, excludes posts with invalid dates, excludes posts older than the cutoff date, normalizes the post's tags, and include only posts that share at least one tag with the current post:

```js
const recentPool = posts.filter(({ slug, data }) => {
  if (!data || slug === currentSlug) return false;
  if (data.draft) return false;

  const published = new Date(data.pubDatetime);
  if (Number.isNaN(published.getTime())) return false;
  if (published < cutoff) return false;

  const postTags = (data.tags ?? [])
    .map(tag => String(tag).toLowerCase().trim())
    .filter(Boolean);

  return postTags.some(tag => tagSet.has(tag));
});
```

Sort the filtered list by publish date (newest first) and keep the first three results:

```js
const recentPosts = recentPool
  .sort(
    (a, b) =>
      new Date(b.data.pubDatetime).getTime() -
      new Date(a.data.pubDatetime).getTime()
  )
  .slice(0, 3);
```

## Render the recent posts section

Now, you can define the `recentPosts` component to display the recent posts:

```js
{recentPosts.length > 0 && (
  <section class="recent-posts" aria-labelledby="recent-posts-title">
    <h2 id="recent-posts-title" class="recent-title" data-no-anchor="true">
      Recent posts
    </h2>
    <ul>
      {recentPosts.map(({ slug, data }) => {
        const published = new Date(data.pubDatetime);
        return (
          <li>
            <a href={`/blog/${slug}/`}>{data.title}</a>
            <span class="recent-date">{formatter.format(published)}</span>
          </li>
        );
      })}
    </ul>
  </section>
)}

<style>
  .recent-posts {
    @apply mt-10 border-t border-skin-line pt-6;
  }

  .recent-title {
    @apply mb-4 text-xl font-semibold italic text-skin-base;
  }

  .recent-posts ul {
    @apply flex flex-col gap-3;
  }

  .recent-posts li {
    @apply flex items-baseline justify-between gap-3;
  }

  .recent-posts a {
    @apply font-medium text-skin-accent hover:underline;
  }

  .recent-date {
    @apply whitespace-nowrap text-xs text-skin-base/70;
  }
</style>
```

Include the `RecentPosts` component in the current post's layout file. For example, I define a blog post layout file called `src/layouts/PostDetails.astro`:

```js
---
import RecentPosts from '@components/RecentPosts.astro';
// other imports
const { post, posts } = Astro.props;
const { tags } = post.data;
---

<article>
  <Content />
</article>

<RecentPosts currentSlug={post.slug} currentTags={tags} posts={posts} />
```

## Wrap up

That's it! You now have a tag-based recent posts section that works entirely at build-timeâ€”no external services, no client-side JavaScript, and no analytics required. Just by leveraging Astro's content collections and the tags you're already using in your blog.

---

## How to add a Search bar in a FlatList in React Native apps
Slug: add-search-bar-to-a-flatlist-in-react-native

![cover_image](https://i.imgur.com/zeVnUHd.png)

> Originally published at [Crowdbotics.com](https://blog.crowdbotics.com/add-search-bar-flatlist-react-native-apps)

There are few ways to create scrollable lists in React Native. Two of the common ways available in React Native core are `ScrollView` and `FlatList` components. Each has its strength and in this tutorial, let us dive deep to create a search bar with `FlatList` component.

The final result you are going to achieve at the end of this tutorial is shown below.

![ss8](https://i.imgur.com/a5FpiUm.gif)

## Table of contents

- Getting started
- What is FlatList?
- Basic usage of a FlatList component
- Fetching data from Remote API in a FlatList
- Adding a custom Separator to FlatList component
- Adding a Search bar
- Run the app
- Add clear button to input text field
- Conclusion

## Getting started

For the demo we are going to create in this tutorial, I am going to use [Expo](https://expo.io/). You are free to choose and use anything between an Expo CLI or a `react-native-cli`.

To start, let us generate a React Native app using Expo CLI and then install the required dependency to have a charming UI for the app. Open up a terminal window and run the following commands in the order they are mentioned.

```shell
expo init searchbarFlatList

cd searchbarFlatList

yarn install @ui-kitten/components @eva-design/eva lodash.filter

expo install react-native-svg
```

_Note_: The dependency `react-native-svg` is required as a peer dependency for the UI kitten library.

UI Kitten is ready to use now. To check, everything has installed correctly, let us modify `App.js` file as the following snippet:

```js
import React from 'react';
import { ApplicationProvider, Layout, Text } from '@ui-kitten/components';
import { mapping, light as lightTheme } from '@eva-design/eva';

const HomeScreen = () => (
  <Layout style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
    <Text category="h1">HOME</Text>
  </Layout>
);

const App = () => (
  <ApplicationProvider mapping={mapping} theme={lightTheme}>
    <HomeScreen />
  </ApplicationProvider>
);

export default App;
```

The `ApplicationProvider` accepts two props, `mapping` and `theme`.

To run this demo, open up the terminal window and execute the following command.

```shell
expo start
```

I am using an iOS simulator for the demo. Here is the output of the above code snippet.

![ss1](https://i.imgur.com/TZ173Uv.png)

## What is FlatList?

The component `FlatList` is an efficient way to create scrolling data lists in a React Native app. It has a simple API to work with and is more efficient and preferment with a large amount of information to display in comparison to its alternate.

By default, you can just pass in an array of data and this component will do its work. You do not have to take care of formatting the data too often.

## Basic usage of a FlatList component

There are three primary props that a FlatList component requires to display a list of data:

- `data`: an array of data that is used to create a list. Generally, this array is built of multiple objects.
- `renderItem`: is a function that takes an individual element from the `data` array and renders it on the UI.
- `keyExtractor`: it tells the list of data to use the unique identifiers or `id` for an individual element.

To get understand this pragmatically, let us build a mock an array of data and using `FlatList`, let us display it on our demo app. To start, import the following statements in `App.js` file.

```js
import React from 'react';
import { FlatList, View, Text } from 'react-native';
```

Then, create an array of mock data.

```js
const mockData = [
  { id: '1', text: 'Expo ðŸ’™' },
  { id: '2', text: 'is' },
  { id: '3', text: 'Awesome!' }
];
```

Now, modify the `HomeScreen` component with the following snippet:

```js
const HomeScreen = () => (
  <View
    style={{
      flex: 1,
      paddingHorizontal: 20,
      paddingVertical: 20,
      marginTop: 40
    }}
  >
    <FlatList
      data={mockData}
      keyExtractor={item => item.id}
      renderItem={({ item }) => (
        <Text style={{ fontSize: 22 }}>
          {item.id} - {item.text}
        </Text>
      )}
    />
  </View>
);
```

If the Expo cli command to run the development server is still running, you are going to get the following result.

![ss2](https://i.imgur.com/penUpT7.png)

## Fetching data from Remote API in a FlatList

You can even play around with it. Try to fetch data from a real-time remote API and display them in the list instead of mock data. For a start, you can use a public API URL such as [Randomuser.me API](https://randomuser.me/api/). The result to obtain at the end of this section is displayed below.

![ss3](https://i.imgur.com/cAwKEaD.png)

Open, `App.js` file and a state object with some properties to keep track of data from the Random User API. Also, do not forget to modify the import statements.

```js
// modify the import statements as below
import React from 'react';
import {
  FlatList,
  View,
  ActivityIndicator,
  TouchableOpacity
} from 'react-native';
import { ApplicationProvider, Text, Avatar } from '@ui-kitten/components';
import { mapping, light as lightTheme } from '@eva-design/eva';

// add a state object to the HomeScreen component
class HomeScreen extends React.Component {
  state = {
    loading: false,
    data: [],
    page: 1,
    seed: 1,
    error: null
  };

  // ... rest of the code
}
```

With the HTTP request to the API URL, let us fetch the first 20 results for now. Create a handler method called `makeRemoteRequest` that uses JavaScript's `fetch(url)` where `url` is the API request. It will fetch the results in JSON format. In case of a successful response from the API, the loading indicator (_which is going to add later_) will be false.

Also, using the lifecycle method `componentDidMount`, you can render the list of random users at the initial render of the `HomeScreen` component.

```js
 componentDidMount() {
 this.makeRemoteRequest()
 }

 makeRemoteRequest = () => {
 const { page, seed } = this.state
 const url = `https://randomuser.me/api/?seed=${seed}&page=${page}&results=20`
 this.setState({ loading: true })

 fetch(url)
 .then(res => res.json())
 .then(res => {
 this.setState({
 data: page === 1 ? res.results : [...this.state.data, ...res.results],
 error: res.error || null,
 loading: false
 })
 })
 .catch(error => {
 this.setState({ error, loading: false })
 })
 }
```

Next, add a `renderFooter` handler method that is going to display a loading indicator based on the value from the state object. This indicator is shown when the list of data in still being fetched. When the value of `this.state.loading` is true, using the `ActivityIndicator` from react-native components, a loading indicator on the UI screen is shown.

```js
renderFooter = () => {
  if (!this.state.loading) return null;

  return (
    <View
      style={{
        paddingVertical: 20,
        borderTopWidth: 1,
        borderColor: '#CED0CE'
      }}
    >
      <ActivityIndicator animating size="large" />
    </View>
  );
};
```

Here is the output you are going to get when the loading indicator is shown.

![ss5](https://i.imgur.com/FYDMKsp.png)

## Adding a custom Separator to FlatList component

Previously, you learned about the three most important props in the FlatList component. It is so flexible that it comes with extra props to render different components to make UI as pleasing to the user. One such prop is called `ItemSeparatorComponent`. You can add your own styling with custom JSX.

To do so, add another handler method called `renderSeparator`. It consists of rendering a `View` with some styling.

```js
renderSeparator = () => {
  return (
    <View
      style={{
        height: 1,
        width: '86%',
        backgroundColor: '#CED0CE',
        marginLeft: '5%'
      }}
    />
  );
};
```

This completes all of the handler method currently required. Now, let us replace the previous `FlatList` component in `App.js` file with the following snippet.

A list of user names is going to be rendered with an individual item as the user. When pressed it shows an alert message for now but in real-time app, it will go on to display the complete user profile or user's contact.

The individual items in the list are going to be separated by the `renderSeparator` method as well as each item is going to display a user image which is composed of `Avatar` component from `react-native-ui-kitten`. The data is coming from the state object.

```js
<FlatList
  data={this.state.data}
  renderItem={({ item }) => (
    <TouchableOpacity onPress={() => alert('Item pressed!')}>
      <View
        style={{
          flexDirection: 'row',
          padding: 16,
          alignItems: 'center'
        }}
      >
        <Avatar
          source={{ uri: item.picture.thumbnail }}
          size="giant"
          style={{ marginRight: 16 }}
        />
        <Text
          category="s1"
          style={{
            color: '#000'
          }}
        >{`${item.name.first} ${item.name.last}`}</Text>
      </View>
    </TouchableOpacity>
  )}
  keyExtractor={item => item.email}
  ItemSeparatorComponent={this.renderSeparator}
  ListFooterComponent={this.renderFooter}
/>
```

From the above snippet, you can also notice that the loading indicator handler method `renderFooter()` is also used as the value of a prop called `ListFooterComponent`.

You can also use this prop to render other information at the bottom of all the items in the list. One example is to fetch more items in the list and show the loading indicator when the request is made.

Here is the output so far.

![ss4](https://i.imgur.com/eszTsxG.gif)

## Adding a Search bar

To create a search bar on top of the FlatList, you need a component that scrolls away when the list is scrolled. One possible solution is to create a custom Search bar component and render it as the value of `ListHeaderComponent` prop in a FlatList.

Open `App.js` file and add the following prop to the list.

```js
<FlatList
  // rest of the props remain same
  ListHeaderComponent={this.renderHeader}
/>
```

The search bar component is going to be an input field that can take the user's name from the end-user. To build one, let us start by modifying the import statements as below.

```js
import filter from 'lodash.filter';
import {
  ApplicationProvider,
  Text,
  Avatar,
  Input
} from '@ui-kitten/components';
```

Next, modify the `state` object and the following variables to it. The `query` is going to hold the search term when the input is provided. The `fullData` is a temporary array that a handler method is going to filter the user's name on the basis of a query.

```js
state = {
  // add the following
  query: '',
  fullData: []
};
```

Since you are already storing the `results` fetched from the remote API, state variable `data`, let us do the same for `fullData` as well. Add the following inside the handler method `makeRemoteRequest()`.

```js
makeRemoteRequest = () => {
  const { page, seed } = this.state;
  const url = `https://randomuser.me/api/?seed=${seed}&page=${page}&results=20`;
  this.setState({ loading: true });

  fetch(url)
    .then(res => res.json())
    .then(res => {
      this.setState({
        data: page === 1 ? res.results : [...this.state.data, ...res.results],
        error: res.error || null,
        loading: false,

        // ---- ADD THIS ----
        fullData: res.results
      });
    })
    .catch(error => {
      this.setState({ error, loading: false });
    });
};
```

Next, add the handler method that is going to handle the search bar. By default, it is going to format the search term provided as a query to lowercase. The user's name is filtered from the state variable `fullData` while the state variable `data` stores the final results after the search to render the correct user.

```js
handleSearch = text => {
  const formattedQuery = text.toLowerCase();
  const data = filter(this.state.fullData, user => {
    return this.contains(user, formattedQuery);
  });
  this.setState({ data, query: text });
};
```

The `contains` handler method is going to look for the query. It accepts two parameters, the first and last name of the user and the formatted query to lowercase from `handleSearch()`.

```js
contains = ({ name, email }, query) => {
  const { first, last } = name;
  if (first.includes(query) || last.includes(query) || email.includes(query)) {
    return true;
  }
  return false;
};
```

Lastly, add `renderHeader` to render the search bar on the UI.

```js
renderHeader = () => (
  <View
    style={{
      backgroundColor: '#fff',
      padding: 10,
      alignItems: 'center',
      justifyContent: 'center'
    }}
  >
    <Input
      autoCapitalize="none"
      autoCorrect={false}
      onChangeText={this.handleSearch}
      status="info"
      placeholder="Search"
      style={{
        borderRadius: 25,
        borderColor: '#333',
        backgroundColor: '#fff'
      }}
      textStyle={{ color: '#000' }}
    />
  </View>
);
```

That's it to add a search bar to the FlatList component.

## Run the app

To run the app, make sure the `expo start` command is running. Next, go to Expo client and you are going to be prompted by the following screen:

![ss6](https://i.imgur.com/nUcoa0G.png)

Next, try to add a user name from the list being rendered.

![ss7](https://i.imgur.com/KCL5zYz.gif)

## Add clear button to input text field

The last thing I want to emphasize is that using a custom UI component from a UI library such as UI Kitten, you can use general `TextInputProps` from React Native core as well. A few examples are props such as `autoCapitalize`, and `autoCorrect`.

Let us add another prop called `clearButtonMode` that allows the input field to have a clear button appear on the right side. Add the prop to the `Input` inside `renderHeader()`.

```js
<Input
  // rest of the props remain same
  clearButtonMode="always"
/>
```

Now go back to the Expo client and see it in action

![ss8](https://i.imgur.com/fQvxr4j.gif)

## Conclusion

This brings an end to this current tutorial. The screen implemented in this demo is from one of the templates from **Crowdbotics' react-native collection**.

We use UI Kitten for our latest template libraries. Find more about how to create custom screens like this from our open source project [here](https://github.com/crowdbotics/blueprint-react-native-contacts-screen).

You can also find the source code from this tutorial at this [Github repo](https://github.com/amandeepmittal/searchableFlatListDemo).

---

## Advanced code blocks with language labels and copy buttons in Astro
Slug: advanced-code-blocks-with-shiki-and-astro

Code blocks are the backbone of any technical blog. While basic syntax highlighting serves its purpose, readers expect more polished experiences. These experiences can be provided with small enhancements.

Recently, I started enhancing code blocks on my Astro blog to include language labels with a clean header bar on top of each code block. Before this change, this is how a code block would render on my blog:

<img src="/images/astro-blog/blog-1.png" width="640" />

## Current state of a code block

My blog uses Astro as its blog engine, which uses Shiki for syntax highlighting with [dual theme support](/blog/dual-shiki-themes-with-astro/). The foundational configuration is provided by theÂ astro.config.tsÂ file, which Iâ€™ll be going to use.

Shiki automatically addsÂ a data-languageÂ attribute to a code block. This is the key to extracting language information for the header labels. Letâ€™s take the following code block as an example.

<img src="/images/astro-blog/blog-2.png" width="640" />

The above code block is rendered and has a `ts` language set in its markdown source file. Inspecting developer tools in a browser, the same `ts` language is passed down as a value to the `data-language` attribute.

<img src="/images/astro-blog/blog-3.png" width="820" />

Since Shiki does this heavy lifting, all that is needed is to render this information in a blog post without affecting the business logic behind it.

## Initial JavaScript implementation

Using client-side JavaScript, you can easily detect code blocks and programmatically add headers. I have a layout file called `PostDetails. Astro`, which already had a copy button functionality, so it took a lot less guesswork as to where the rendering of a code block's language should go.

```js
function attachCopyButtons() {
  let copyButtonLabel = 'Copy';
  let codeBlocks = Array.from(document.querySelectorAll('pre'));

  for (let codeBlock of codeBlocks) {
    let wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    // ... rest of the function
  }
}
attachCopyButtons();
```

This function creates a wrapper element for each code block. It begins by defining the button label text and querying for all `<pre>` elements, which Shiki uses to wrap code blocks. It then converts a list of notes into an array with `Array.from()` to provide access to array manipulation. For each code block, a div is created with appropriate CSS classes.

## Language formatting

Letâ€™s add the code for extracting and formatting language information:

```js
let language = codeBlock.getAttribute('data-language') || 'text';

const formatLanguage = lang => {
  const languageMap = {
    ts: 'TypeScript',
    js: 'JavaScript',
    tsx: 'TSX',
    jsx: 'JSX',
    md: 'Markdown',
    mdx: 'MDX'
  };

  return (
    languageMap[lang.toLowerCase()] ||
    lang.charAt(0).toUpperCase() + lang.slice(1)
  );
};
const displayLanguage = formatLanguage(language);
```

You can also add more languages to the `languageMap` object or keep it small as per your needs. This mapping covers popular programming languages and provides a fallback that capitalizes the first letter. Hereâ€™s the complete code for what I am using on this blog:

```js
const languageMap = {
  ts: 'TypeScript',
  js: 'JavaScript',
  tsx: 'TSX',
  jsx: 'JSX',
  md: 'Markdown',
  mdx: 'MDX',
  sh: 'Shell',
  bash: 'Bash',
  json: 'JSON',
  yaml: 'YAML',
  yml: 'YAML',
  toml: 'TOML',
  css: 'CSS',
  html: 'HTML',
  xml: 'XML',
  py: 'Python',
  rb: 'Ruby',
  cpp: 'C++',
  swift: 'Swift',
  kotlin: 'Kotlin'
};
```

## Create a header bar structure

The header bar is a visual container for both the language label and the existing copy button. Create a flexbox container to position the language label on the left appropriately and the copy button on the right. The code block below also uses the CSS classes integrated with my blog's theme system.

```js
let headerBar = document.createElement('div');
headerBar.className =
  'code-header flex items-center justify-between bg-skin-card border-b border-skin-border px-4 py-2 rounded-t-md';
```

## Build a language label

To provide clear identification of the code block's programming language, you need to create a language label provider:

```js
let languageLabel = document.createElement('span');
languageLabel.className = 'language-label text-sm text-skin-base font-medium';
languageLabel.innerHTML = displayLanguage;
languageLabel.setAttribute('aria-label', `Code language: ${displayLanguage}`);
languageLabel.setAttribute('role', 'note');
```

In the above code block, the accessibility attributes provide context for screen readers, with the `aria-label` explaining the purpose and the role attribute marking it as informational content.

## Create a copy button

The copy button is used to provide an interactive functionality for copying code to the clipboard. It utilizes a button element that incorporates hover effects and color transitions to leverage the existing theme system. Letâ€™s also create a function to handle the actual copy functionality:

```js
let copyButton = document.createElement('button');
copyButton.className =
  'copy-code text-sm text-skin-base hover:text-skin-accent transition-colors font-medium';
copyButton.innerHTML = copyButtonLabel;
copyButton.setAttribute(
  'aria-label',
  `Copy ${displayLanguage} code to clipboard`
);
copyButton.setAttribute('title', 'Copy code to clipboard');

async function copyCode(block, button) {
  let code = block.querySelector('code');
  let text = code?.innerText;

  await navigator.clipboard.writeText(text ?? '');
  button.innerText = 'Copied';

  setTimeout(() => {
    button.innerText = copyButtonLabel;
  }, 700);
}
```

In the `copyCode` function, the Clipboard API writes the text to the user's clipboard asynchronously. Visual feedback changes the button text to "Copied" temporarily before reverting after 700 milliseconds, providing clear confirmation that the action was successful.

Hereâ€™s how the label and hover effect works on the label:

<img src="/images/astro-blog/blog-4.gif" width="320" />

## Add the language label and copy button to the header

Next, add the language button and copy button to the header bar with the appropriate styling:

```js
headerBar.appendChild(languageLabel);
headerBar.appendChild(copyButton);
codeBlock.setAttribute('tabindex', '0');

codeBlock.className =
  (codeBlock.className || '') + ' rounded-t-none rounded-b-md';

codeBlock?.parentNode?.insertBefore(wrapper, codeBlock);
wrapper.appendChild(headerBar);
wrapper.appendChild(codeBlock);

copyButton.addEventListener('click', async () => {
  await copyCode(codeBlock, copyButton);
});
```

## CSS styles to render header bar and code block

In code block styles, ensure that the header bar and the actual code block appear as one unit when rendered on a blog page:

```css
@layer components {
  .code-header {
    @apply select-none;
    margin-bottom: 0 !important;
  }

  .language-label {
    @apply select-none pointer-events-none;
  }

  .copy-code {
    @apply cursor-pointer select-none;
  }

  .copy-code:hover {
    @apply transform scale-105;
  }

  pre {
    @apply mt-0 mb-4;
    position: relative;
    margin-top: 0 !important;
  }

  pre > code {
    @apply pt-0;
  }

  .code-header + pre {
    margin-top: 0 !important;
    border-top: none;
  }
}
```

## Wrap up

The improved code block now contains the language labels to provide immediate context about what kind of code a reader is looking at:

<img src="/images/astro-blog/blog-5.png" width="640" />

<img src="/images/astro-blog/blog-6.png" width="640" />

When switching to the dark theme, the header bar renders correctly:

<img src="/images/astro-blog/blog-7.png" width="640" />

---

## How to Animate a Header View on Scroll With React Native Animated
Slug: animate-header-view-on-scroll-with-react-native-animated-api

![cover_image](https://i.imgur.com/qDKlX8L.jpg)

The [Animated](https://reactnative.dev/docs/animated.html) library from React Native provides a great way to add animations and give app users a smooth and friendlier experience.

In this tutorial, let's explore a way to create a header view component that animates on the scroll position of the `ScrollView` component from React Native. We will go through the basics of creating a new Animated value as well as explaining the significance of functions and properties like `interpolation`, `extrapolate`, `contentOffset`, and so on.

[The source code is available at GitHub](https://github.com/amandeepmittal/react-native-examples/tree/master/animate-header-on-scroll).

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements on your local dev environment.

- [Node.js](https://nodejs.org/) version >= 12.x.x installed
- Have access to one package manager such as npm or yarn
- [expo-cli](https://github.com/expo/expo-cli) version installed or use npx

The example in the following tutorial is based on Expo SDK 38.

## Installing dependencies

Start by creating a new React Native app generated with `expo-cli`. Do note that all the code mentioned in this tutorial works with plain React Native apps as well. Open up a terminal window and execute the following command:

```shell
npx expo-cli init animate-header-example

# after the project is created, navigate into the directory
cd animate-header-example
```

To handle devices with notch both on iOS and Android operating systems, let's install some libraries first. These libraries are going to add automatic padding on notch devices such that the main view of the app does not intersect with a safe area on notch-enabled devices. Run:

```shell
expo install react-native-safe-area-view react-native-safe-area-context
```

To use safe area views, wrap the root of the React Native app with `SafeAreaProvider` from the [react-native-safe-area-context](https://github.com/th3rdwave/react-native-safe-area-context) library. Open `App.js` and modify the it as shown below:

```js
import React from 'react';
import { Text, View } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';

export default function App() {
  return (
    <SafeAreaProvider>
      <View style={{ flex: 1, alignItems: 'center' }}>
        <Text>Open up App.js to start working on your app!</Text>
      </View>
    </SafeAreaProvider>
  );
}
```

Next, wrap the contents of the `App` component with `SafeAreaView` from the [react-native-safe-area-view](https://github.com/react-navigation/react-native-safe-area-view) library. It is going to have a `style` prop with a `flex` of value `1` and another prop called `forceInset`. Itâ€™s important we add this, especially for some Android devices which might not behave as expected. This prop is going to force the application to add an inset padding on the content view. Setting the value of `top: always` will always imply that padding is forced at the top of the view.

```js
// ... other import statements
import SafeAreaView from 'react-native-safe-area-view';

export default function App() {
  return (
    <SafeAreaProvider>
      <SafeAreaView style={{ flex: 1 }} forceInset={{ top: 'always' }}>
        <View style={{ flex: 1, alignItems: 'center' }}>
          <Text>Open up App.js to start working on your app!</Text>
        </View>
      </SafeAreaView>
    </SafeAreaProvider>
  );
}
```

Here is what happens on an Android device when `forceInset` is not used on `SafeAreaView`:

![ss1](https://i.imgur.com/uBdAKZ4.jpg)

And with the `forceInset` prop applied:

![ss2](https://i.imgur.com/xNZx2rq.jpg)

On iOS, the behavior is as expected:

![ss3](https://i.imgur.com/HXHJRv9.png)

The last step in this section is to create a new component file called `AnimatedHeader.js` inside the `components/` directory. For now, it is going to return nothing.

```js
import React from 'react';
import { Animated, View } from 'react-native';

const AnimatedHeader = () => {
  return null;
};

export default AnimatedHeader;
```

Make sure to import it in the `App.js` file:

```js
// ... after other import statements
import AnimatedHeader from './components/AnimatedHeader';
```

## Creating an animated header component

The animation on the position of the scroll on a `ScrollView` component is going to have an `Animated.Value` of `0`. To create an animation, `Animated.Value` is required. In the `App.js` file, import `useRef` from the React library. Then, define a variable called `offset` with a new `Animated.Value`. To use the Animated library from React Native, import it as well.

```js
import React, { useRef } from 'react';
import { Text, View, Animated } from 'react-native';
// ...other import statements

export default function App() {
  const offset = useRef(new Animated.Value(0)).current;

  // ...
}
```

For this example, it is not required to use the `useRef` hook; however, if you are looking forward to modifying the animated value, it is recommended to use `useRef`. It provides a `current` property that is persisted throughout a component's lifecycle.

The value of the `offset` can now be passed as a prop to the `AnimatedHeader` component.

```js
export default function App() {
  const offset = useRef(new Animated.Value(0)).current;

  return (
    <SafeAreaProvider>
      <SafeAreaView style={{ flex: 1 }} forceInset={{ top: 'always' }}>
        {/* Add the following AnimatedHeader */}
        <AnimatedHeader animatedValue={offset} />
        <View style={{ flex: 1, alignItems: 'center' }}>
          <Text>Open up App.js to start working on your app!</Text>
        </View>
      </SafeAreaView>
    </SafeAreaProvider>
  );
}
```

To access the safe area inset value inside the `AnimatedHeader` component, the library `react-native-safe-area-context` provides a hook called `useSafeAreaInsets()`. This hook returns a safe area insets object with the following values:

```js
{
  top: number,
  right: number,
  bottom: number,
  left: number
}
```

The inset value of `top` is going to be manipulated when defining the animated header.

First, let's import this hook in the `AnimatedHeader.js` file and then define a fixed `HEADER_HEIGHT` constant that is going to be the initial height of the `Animated.View`.

```js
// ... other import statements
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const HEADER_HEIGHT = 200;

const AnimatedHeader = ({ animatedValue }) => {
  const insets = useSafeAreaInsets();

  return null;
};
```

To animate the height of the header view on the scroll, we are going to use interpolation. The `interpolate()` function on `Animated.Value` allows an input range to map to a different output range.

In the current scenario, when the user scrolls, the interpolation on `Animated.Value` is going to change the scale of the header to slide to the top on scroll along the y-axis. This effect is going to minimize the initial value of the height of `Animated.View`.

The interpolation must specify an `extrapolate` value. This determines the scaling of the headerâ€™s height to be visible at the last value in `outputRange`. There are three different values for `extrapolate` available, but we are going to use `clamp`.

Begin by declaring a variable called `headerHeight` that is going to have the value of interpolation. The `Animated.Value` is the prop `animatedValue` coming from the parent component.

The `inputRange` is going to be `0` to the `HEADER_HEIGHT` plus the top inset. The `outputRange` is to be the `HEADER_HEIGHT` plus the top inset to the top inset plus `44`.

```js
const AnimatedHeader = ({ animatedValue }) => {
  const insets = useSafeAreaInsets();

  const headerHeight = animValue.interpolate({
    inputRange: [0, HEADER_HEIGHT + insets.top],
    outputRange: [HEADER_HEIGHT + insets.top, insets.top + 44],
    extrapolate: 'clamp'
  });

  // ...
};
```

Now, let's add an `Animated.View` to render from this component. It is going to use `position: absolute` to help cover the background behind the status bar as well as the same color as the whole header.

```js
const AnimatedHeader = ({ animatedValue }) => {
  // ...
  return (
    <Animated.View
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        zIndex: 10,
        height: headerHeight,
        backgroundColor: 'lightblue'
      }}
    />
  );
};
```

This section ends with the following output:

![ss4](https://i.imgur.com/kOdpwwL.png)

## Manipulating the ScrollView

In the `App.js` file, a `ScrollView` component is going to be displayed beneath the header component and, in return, it is going to display a list of mocked data.

For this example, I've prepared a bare minimum list of book titles in a separate file called `data.js`.

```js
const DATA = [
  {
    id: 1,
    title: 'The Hunger Games'
  },
  {
    id: 2,
    title: 'Harry Potter and the Order of the Phoenix'
  },
  {
    id: 3,
    title: 'To Kill a Mockingbird'
  },
  {
    id: 4,
    title: 'Pride and Prejudice'
  },
  {
    id: 5,
    title: 'Twilight'
  },
  {
    id: 6,
    title: 'The Book Thief'
  },
  {
    id: 7,
    title: 'The Chronicles of Narnia'
  },
  {
    id: 8,
    title: 'Animal Farm'
  },
  {
    id: 9,
    title: 'Gone with the Wind'
  },
  {
    id: 10,
    title: 'The Shadow of the Wind'
  },
  {
    id: 11,
    title: 'The Fault in Our Stars'
  },
  {
    id: 12,
    title: "The Hitchhiker's Guide to the Galaxy"
  },
  {
    id: 13,
    title: 'The Giving Tree'
  },
  {
    id: 14,
    title: 'Wuthering Heights'
  },
  {
    id: 15,
    title: 'The Da Vinci Code'
  }
];

export default DATA;
```

The next step is to import this file in `App.js`. Also, import the `ScrollView` component from React Native.

```js
//...
import { ScrollView, Text, View, Animated } from 'react-native';

import DATA from './data';
```

Next, modify the contents of the `App` component. The important prop to note below in the `ScrollView` component is the `onScroll` prop. Mapping gestures like scrolling directly to an animated value can be done by using `Animated.Event`. This type of event function is passed as the value to the `onScroll` prop.

`Animated.Event` accepts an array of objects as the first argument which is going to be the `contentOffset`, which tells the current position of the scrolling view. It changes every time the user scrolls up or down. The value of `contentOffset` along the y-axis is going to be the same `Animated.Value` that is used to interpolate the height of the `AnimatedHeader` component.

It is recommended that you pass the second argument of `useNativeDriver` in `Animated.Event` .

```js
export default function App() {
  const offset = useRef(new Animated.Value(0)).current;

  return (
    <SafeAreaProvider>
      <SafeAreaView style={{ flex: 1 }} forceInset={{ top: 'always' }}>
        <AnimatedHeader animatedValue={offset} />
        <ScrollView
          style={{ flex: 1, backgroundColor: 'white' }}
          contentContainerStyle={{
            alignItems: 'center',
            paddingTop: 220,
            paddingHorizontal: 20
          }}
          showsVerticalScrollIndicator={false}
          scrollEventThrottle={16}
          onScroll={Animated.event(
            [{ nativeEvent: { contentOffset: { y: offset } } }],
            { useNativeDriver: false }
          )}
        >
          {DATA.map(item => (
            <View
              key={item.id}
              style={{
                marginBottom: 20
              }}
            >
              <Text style={{ color: '#101010', fontSize: 32 }}>
                {item.title}
              </Text>
            </View>
          ))}
        </ScrollView>
      </SafeAreaView>
    </SafeAreaProvider>
  );
}
```

Here is the output after this step on an iOS device:

![ss5](https://i.imgur.com/QFWrJCN.gif)

On Android:

![ss6](https://i.imgur.com/4HlPFNQ.gif)

## Conclusion

I hope you had fun reading this tutorial. If you are trying the Animated library from React Native for the first time, wrapping your head around it might take a bit of time and that's the part of the process.

Some of the important topics covered in this post are listed as links for further reading below:

- [The onScroll prop](https://reactnative.dev/docs/scrollview#onscroll)
- [Interpolation](https://reactnative.dev/docs/animations#interpolation)
- [Tracking gestures with Animated.Event](https://reactnative.dev/docs/animations#tracking-gestures)

Originally published at [Jscrambler](https://jscrambler.com/blog/how-to-animate-a-header-view-on-scroll-with-react-native-animated).

---

## How to add an app icon in a React Native Android app
Slug: app-icon-react-native-android

![cover_image](https://i.imgur.com/tZtGF2K.png)

In this post, let's generate an app icon and learn how to add it to an Android app build with React Native.

## Generating an app icon

### Quickly build an app icon

To create an app icon we are going to make use of a free tool called [Expo Icon Builder](https://buildicon.netlify.app/). Thanks to [Evan Bacon](https://x.com/baconbrix?lang=en) for making it free and available for us to use. You are free to use any other design tool of your own choice such as Figma.

This tool allows building an app icon quickly using an Emoji icon with a customized background color scheme. For example, in the below image you will find that we have selected the coffee icon emoji since it is going to represent the main app. The Emoji icon is selected from the right-hand panel. The selected item is shown on the left-hand side. You can also add a customized background color.

![04-1](https://i.imgur.com/ulbO2nm.png)

After selecting the icon you have to download it by clicking the download button at the top left corner.

![04-2](https://i.imgur.com/dnvBU00.png)

### Generate different assets for Android

Android requires five separate sizes for different screen pixel densities. Icons for lower resolution are created automatically from the baseline (_mdpi_). Refer to the table below for more information on pixel densities:

|   Resolution    | Density | Pixel units |
| :-------------: | :-----: | :---------: |
| mdpi (Baseline) | 160 dpi |     1Ã—      |
|      hdpi       | 240 dpi |    1.5Ã—     |
|      xhdpi      | 320 dpi |     2Ã—      |
|     xxhdpi      | 480 dpi |     3Ã—      |
|     xxxhdpi     | 640 dpi |     4Ã—      |

Another free service I like to use to generate different assets for the app icon is called [makeappicon.com](https://makeappicon.com/). This service generate different assets for various pixel densities based on the above table.

All you have to do is upload the app icon we created in the previous step and provide an email where the icons will be available to download.

![04-3](https://i.imgur.com/JHjruoR.png)

It creates icons for both platforms iOS and Android. For this demo app, we are only interested in the `android/` directory it generates. A different set of directories are created that are prefixed with `mipmap` and suffixed with different sizes like `hdpi` and `mdpi`.

![04-4](https://i.imgur.com/lKLlS1a.png)

## Where to place the icon?

Within an Android app, the icons live at the following path: `android/app/src/main/res`. Now copy the contents of the `android/` directory generated in the previous step and paste them to that location. Note that there going to be the same directory names. You will have to replace those old directories with the new ones to be pasted.

![04-5](https://i.imgur.com/myCrBZc.png)

## Should the icons be rounded or squared?

Depending on the Android device the system will decide whether to use a square icon or a rounded icon. You may need both types of the icon. For this demo app, we are going to use the icon we generated and exclude the rounded icon from the configuration of the Android app.

To not use the rounded icon, open `android/app/src/main/AndroidManifest.xml` file and remove the modify following line:

```xml
android:roundIcon="@mipmap/ic_launcher_round"
```

To the same icon generated in the previous step:

```xml
android:roundIcon="@mipmap/ic_launcher"
```

In the same file, you will find the code snippet: `android:icon="@mipmap/ic_launcher"` points towards the original icon filename.

You will have to run the build command `npx react-native run-android` to apply these changes to show the app icon.

![04-6](https://i.imgur.com/KYxddTW.jpg)

## Resources

That's it to generate and a new icon for your Android app. Please find the [link here](https://developer.android.com/google-play/resources/icon-design-specifications) to learn more about Google Play's icon design specifications.

---

## Atom: An Editor of 21st Century
Slug: atom-an-editor-of-21st-century

The [Atom](http://atom.io/) I am talking about is not a small particle in the world of developers. Built and maintained by Github and the community, it is more than just an editor.

In our world, in the world of developers, an editor plays an amount of significant role when it comes to writing code. They might seem just a tool, as a matter of fact, they are, but for someone who takes pleasure in writing code, it is an essential piece in their setup.

Using an editor is really a matter of choice, your comfort zone but the game of plugins have a big role to play. As yourself, I have tried my hands on different editors & IDEs and for now I have decide to settle with Atom for its enormous amount of plugins available. Another reason for me is that itâ€™s written in JavaScript (exactly CoffeeScript & since I am a JS enthusiast) and is completely free to use because of its open source normality.

It is inspiring to open-source community as well. Few months back, Facebook released there version called Nuclide which focus more on mobile development. Then there is Electron for building cross-platform desktop application. Both are based on Atom Shell.

Atom is mature in terms of plugins when comes to keeping the pace with newer technologies. When I started out with Node.js, I tried to stick with Webstorm IDE but soon Atom lured me for its support of frameworks like Ionic (a plugin called Ionic-Preview and I am still exploring) thanks to the community plugins and the other matter of fact that itâ€™s open source.

![1](https://i.imgur.com/a5Ziwot.jpg)

## Packages

There are more than 4.5k +packages published already. To view, Open the Settings view by clicking Packages > Settings View > Open in the menu bar or by using the (cmd + ,) keyboard shortcut.

Atom Packages are categorized further into:

- Community packages: Packages written by people outside of GitHubâ€™s Atom team.
- Core packages: These are developed by the Atom team and come bundled with Atom but you can disable them if they are no use to you.
- Development packages: Packages which you have on your machine and use in Atom from that local source.

Core Packages do provide support for most favorable programming/scripting languages but if you are using something out of the box then you must check the Community packages. Chances of finding the one are in your favour there.

If you are still unable to find what you are looking, you should try developing a package for yourself and then if you like share it with the community.

## TIP- Decreasing Startup Time

There may come a period of time when your Atom might behave sluggishly. What will you do?

- Youâ€™ll remove all the packages (a.k.a plugins) you donâ€™t use but for some reason you had them installed,
- or there isnâ€™t much use of that particular package and you can do without it,
- or it was there just for fun. But before removing the packages, one must know which package is consuming how much startup time. You might want some of those unnecessary packages to stay with you if you know they are not the real culprits who are slowing down your development environment.

![2](https://i.imgur.com/HEqlVPv.png)

I have seen (mostly on online forums) some developers groan about this kind of sluggishness but I havenâ€™t met it yet.

**Recommended Packages**

Most of these packages are helpful in my daily JavaScript coding environment. I think they will be helpful to you too.

- open-recent (to continue where you left)
- sync-settings (do you work more than one machine? This for you)
- Ionic-Preview (for people who are working Ionic Framework)
- terminal-plus (terminal inside atom)
- atom-jade (there is support for ejs, handlebars, mustache too)
- jade (if you are into jade, this is a snippets package)
- js-hyperclick (as your project goes bigger, you will get addicted to it)
- atom-lupa (nice one if your daily musings includes React)
- autocomplete-modules (Node.js devs: autocompletes require statements)
- atom-pair (developed by the folks at Pusher, a must if you do pair coding)
- javascript-snippets (JavaScript and Node.js snippets)
- atom-nodejs-snippets (this is another Nodejs & JavaScript snippet package, made by me. Supports ES6 syntax)
- linter + linter-jshint
- atom-ternjs (JavaScript code intelligence for Atom)
- encourage (a nice one to have, if you are having a dark day, fun)

The main advantage of an editor like Atom is that you can highly customize it. You can hack it, make your own packages, or use the one that are already there in the community and bend them as per your needs.

## Lastly

![3](https://i.imgur.com/HIgoDE2.jpg)

_Note: At the time of writing this post, Webstorm IDE did not have support for frameworks like Ionic and the latest Atom Version is 1.8.0._

---

## How Authentication Flow works in React Native apps using React Navigation 4.x
Slug: authentication-navigation-flow-in-react-native-apps

![cover_image](https://i.imgur.com/0xwhr2a.png)

Mobile apps are made of screens that in number can vary depending on the app you are developing. Handling user navigation can be tricky to learn and do in mobile apps, but with dedicated open-source libraries like [`react-navigation`](https://reactnavigation.org) do make the process a lot easier.

React Navigation library is common among React Native developers. It is built with JavaScript, and you can create React components and apply any navigation pattern. On the device, it will give the natural look and feel.

It is up to the developer now, on how to make the best use of navigation between different screens in a React Native app. There are more than one navigation patterns available. If you are starting in the React Native ecosystem, this post will guide you through to use different the patterns of navigation such as Stack and Switch navigation using `react-navigation` library's latest `4.x.x` version.

## Table of Contents

- Requirements
- Installing navigation library
- Create app screens
- Setup navigation
- Navigating between two screens
- Managing authentication flow
- Conclusion

## Requirements

If you are going to code along, make sure you have already installed the following:

- [Nodejs](https://nodejs.org) (>=`10.x.x`) with npm/yarn installed.
- [expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli/) (>= `3.x.x`), previously known as `create-react-native-app`.
- Mac users must be running an iOS simulator.
- Windows/Linux users must be running an Android emulator.

To know more about how to setup and run the simulator or the emulator on your local development environment visit React Nativeâ€™s [official documentation here](https://facebook.github.io/react-native/docs/getting-started).

## Installing navigation library

To get started, create a new Expo app using `expo-cli` with the following command from a terminal window. When asked, choose the `blank` template.

```shell
expo init expo-example

# navigate inside the project directory
cd expo-example
```

Once inside the project directory, install the following dependencies.

```shell
yarn add react-navigation react-navigation-stack

expo install react-native-gesture-handler
react-native-screens
```

As compared to previous versions of `react-navigation`, all three navigation patterns have been modularised in their own dependencies. If you are using:

- stack navigation, then install `react-navigation-stack`
- for tabs install `react-navigation-tabs`
- for drawer install `react-navigation-drawer`
- switch navigation pattern is still under `react-navigation` and is only used for specific use cases such as authentication flow

More appropriate information about each dependency related to its own navigation pattern can be found in the [official docs here](https://reactnavigation.org/docs/en/stack-navigator.html).

After installing these dependencies, you can verify that they have been installed by opening the `package.json` file.

```json
"dependencies": {
    "expo": "^34.0.1",
    "react": "16.8.3",
    "react-dom": "^16.8.6",
    "react-native": "https://github.com/expo/react-native/archive/sdk-34.0.0.tar.gz",
    "react-native-gesture-handler": "~1.3.0",
    "react-native-reanimated": "~1.1.0",
    "react-native-screens": "1.0.0-alpha.22",
    "react-native-web": "^0.11.4",
    "react-navigation": "4.0.0",
    "react-navigation-stack": "1.5.1"
  },
```

## Create App Screens

I like to arrange different setups and related files under the folder structure. Here is how it is going to look like at the end of this tutorial. It is also a good practice to organize or give structure to your project.

![1](https://i.imgur.com/lkVcW5L.png)

The three files inside the `screens` folder are going to be functional components for now, with some dummy text to display. Create these files with the following code snippets.

For `Home.js`:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function Home() {
  return (
    <View style={styles.container}>
      <Text>Home</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

For `Login.js`:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function Login() {
  return (
    <View style={styles.container}>
      <Text>Login</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

For `Signup.js`:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function Signup() {
  return (
    <View style={styles.container}>
      <Text>Signup</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

The idea here is to create a foundation of three different screens and mock a login/signup and main (_in the current case, the home screen_) screen navigation pattern. This is a common pattern in most mobile apps where the user has to either signup or login before accessing the rest of the application.

## Setup Navigation

After creating these three screens, create a new directory called `navigation`. Inside this, create three new files:

- `index.js`
- `AppNavigation.js`
- `AuthNavigation.js`

Let us setup the `AppNavigation` first since it will contain only one screen. Open up the file and add the following code.

```js
//AppNavigation.js
import { createStackNavigator } from 'react-navigation-stack';
import Home from '../screens/Home';

const AppNavigation = createStackNavigator(
  {
    Home: { screen: Home }
  },
  {
    initialRouteName: 'Home'
  }
);

export default AppNavigation;
```

Stack Navigation provides your app to navigate between screens, where each new screen is placed on the top of the previous one. It is literally like a stack and hence the name. This is done by `createStackNavigator` function. A route configuration object is passed to this function. The `Home` route corresponds to the `Home.js` component.

On an iOS device, a new screen slides from the right, and on Android, it fades from the bottom.

Next, edit `AuthNavigation.js` file.

```js
//AuthNavigation.js
import { createStackNavigator } from 'react-navigation-stack';
import Login from '../screens/Login';
import Signup from '../screens/Signup';

const AuthNavigation = createStackNavigator(
  {
    Login: { screen: Login },
    Signup: { screen: Signup }
  },
  {
    initialRouteName: 'Login'
  }
);

export default AuthNavigation;
```

Similarly, in `AuthNavigation` two screens, login and signup are passed. In the second object that is passed to `createStackNavigator` function, the `initialRouteName` indicates that when this navigation file runs, the first screen that will be shown is going to be `Login`. In other words, it is used to set a default screen to whatever the value `initialRouteName` is set to.

In `AppNavigation` since there is only one screen, so it will always show `Home` screen whether to pass the `initialRouteName` in that file or not. Next, open `index.js` file in the same directory and add the following code.

```js
//index.js
import { createAppContainer } from 'react-navigation';
import AuthNavigation from './AuthNavigation';

const AppContainer = createAppContainer(AuthNavigation);

export default AppContainer;
```

The `createAppContainer` function is responsible for managing the navigation state of the app and links the app to the top-level navigator. The navigation state comes in handy when you are passing data between two screens.

Lastly, open the `App.js` file and use `AppContainer` to be the top-level component.

```js
//App.js
import React from 'react';
import AppContainer from './navigation';

export default function App() {
  return <AppContainer />;
}
```

Now open your app in a simulator device by executing the command `expo start` from a terminal window. You will see that it shows only the `Login` screen.

<img src='https://cdn-images-1.medium.com/max/800/1*AjWvmQ72BYHLrqCtmBsbiw.png' />

_Notice the empty space at the top of the screen?_ That is the header section. When using Stack Navigation pattern, each screen is assigned a header automatically. If you do not require to use it, you can set the `headerMode` property to the value of `none` to `createStackNavigator` function. Open `AuthNavigation.js` to edit.

```js
// AuthNavigation.js
const AuthNavigation = createStackNavigator(
  {
    Login: { screen: Login },
    Signup: { screen: Signup }
  },
  {
    initialRouteName: 'Login',
    headerMode: 'none'
  }
);
```

You can read more about app containers [here](https://reactnavigation.org/docs/en/app-containers.html#props-of-createappcontainer-on-react-native).

## Navigating between two screens

Right now, there is no way you can navigate from the `Login` to the `Signup` screen. To do so, let us use `this.props.navigation`. Each screen component in the app using `react-navigation` library is automatically provided with the `navigation` prop. It further has [different reference values](https://reactnavigation.org/docs/en/navigation-prop.html) to navigate between different screens directly from a screen.

To transit between login to signup, create a button like below and pass an `onPress` prop to it in `Login.js` file. The value of this prop is going to hold the `navigation` prop reference.

```js
//Login.js

//import Button
import { StyleSheet, Text, View, Button } from 'react-native';

export default class Login extends React.Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>Login</Text>
        <Button
          title="Go to Signup"
          onPress={() => this.props.navigation.navigate('Signup')}
        />
      </View>
    );
  }
}
```

Passing the name of the route as the first parameter to `navigation.navigate()` is necessary. Now go back to the simulator, and you will find a new button. Press the button, and it will take you to the `Signup` screen component.

<img src='https://cdn-images-1.medium.com/max/800/1*1SAUNjPgkuXtC-QU8tioSg.gif' />

Similarly, you can add a way to navigate back to the login screen component from the signup.

```js
//Signup.js

export default class Signup extends React.Component {
  goToLogin = () => this.props.navigation.navigate('Login');
  render() {
    return (
      <View style={styles.container}>
        <Text>Signup</Text>
        <Button title="Go to Login" onPress={this.goToLogin} />
      </View>
    );
  }
}
```

Here is the output.

<img src='https://cdn-images-1.medium.com/max/800/1*dO_4EKaKWrv8HlNo3WPPJA.gif' />

## Managing Authentication Flow

In React Navigation, to manage authentication flow, Switch Navigator is used. This navigation pattern only loads one screen at a time, and there is no back functionality by default. It resets the initial route when switching between the screens. To get started open `index.js` file, import `createSwitchNavigator` from `react-navigation` and add the following code.

```js
//index.js
import { createSwitchNavigator, createAppContainer } from 'react-navigation';
import AuthNavigation from './AuthNavigation';
import AppNavigation from './AppNavigation';

const SwitchNavigator = createSwitchNavigator(
  {
    Auth: AuthNavigation,
    App: AppNavigation
  },
  {
    initialRouteName: 'Auth'
  }
);

const AppContainer = createAppContainer(SwitchNavigator);

export default AppContainer;
```

Note that, the `AppContainer` is still being exported from the file, but it now accepts `SwitchNavigator` as the parameter. Like the `createStackNavigator`, `createSwitchNavigator` also accepts route config as the first parameter and the configuration values as the second. The route config is going to be done between the authentication navigation screens and the other screens related to the app.

Import both `AuthNavigation` and `AppNavigation` and set the `Auth` as the initial route. This means that the login screen is going to be shown for the when apps load for the first time.

Let us mock the behavior of logging into the app and see what happens when the user successfully logs in. Open `Login.js` file, define an initial state with two properties: `email` and `password`.

```js
//Login.js
import React from 'react';
import { StyleSheet, View, Button, TextInput } from 'react-native';

export default class Login extends React.Component {
  state = {
    email: '',
    password: ''
  };

  handleEmailChange = email => {
    this.setState({ email });
  };

  handlePasswordChange = password => {
    this.setState({ password });
  };

  onLogin = async () => {
    const { email, password } = this.state;
    try {
      if (email.length > 0 && password.length > 0) {
        this.props.navigation.navigate('App');
      }
    } catch (error) {
      alert(error);
    }
  };

  goToSignup = () => this.props.navigation.navigate('Signup');
  render() {
    const { email, password } = this.state;

    return (
      <View style={styles.container}>
        <View style={{ margin: 10 }}>
          <TextInput
            name="email"
            value={email}
            placeholder="Enter email"
            autoCapitalize="none"
            onChangeText={this.handleEmailChange}
          />
        </View>
        <View style={{ margin: 10 }}>
          <TextInput
            name="password"
            value={password}
            placeholder="Enter password"
            secureTextEntry
            onChangeText={this.handlePasswordChange}
          />
        </View>
        <Button title="Login" onPress={this.onLogin} />
        <Button title="Go to Signup" onPress={this.goToSignup} />
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

The `onLogin` handler function allows the user to navigate to the `Home` screen only if the email and the password fields are not empty. It is used on the `onPress` prop for the following button.

```js
<Button title="Login" onPress={this.onLogin} />
```

Look at the complete demo below.

<img src='https://cdn-images-1.medium.com/max/800/1*mPCEThKI-qoYL6y1TgWzHw.gif' />

## Conclusion

_The authentication flow works!_ By following this tutorial, you have learned how to use the latest `react-navigation` library to manage and mimic an authentication flow in a React Native app. Using the current knowledge, in the next post, you are going to build some actual forms in React Native apps with proper styling and validation using awesome libraries like Formik and Yup. I hope this post works as fundamental for the next one.

_You can find the complete code used in this tutorial at the Github repo [here](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.1.0)._

**Important resources from this post:**

- [`react-navigation`](https://reactnavigation.org) library docs
- [Stack Navigator](https://reactnavigation.org/docs/en/stack-navigator.html)
- [Switch Navigator](https://reactnavigation.org/docs/en/switch-navigator.html)
- [`navigation` props](https://reactnavigation.org/docs/en/navigation-prop.html)

[Originally published at Heartbeat](https://heartbeat.fritz.ai/how-authentication-flow-works-in-react-native-apps-using-react-navigation-4-x-a30bb4d9e5d6)

---

## Automate installing apps and utilities with Homebrew bundle
Slug: automation-with-homebrew-bundle

If you periodically set up your Macbook from scratch like I do, you're probably frustrated by the manual setup process.

Homebrew to the rescue. It's a macOS package manager that I've used since I started using macOS. It allows creating a "bundle" file that can automate the process of installing many command-line utilities, applications, and apps from the App Store.

## Create a bundle file

In my dotfiles repository, I've created a `brewfile.sh`, which contains the following list:

```shell
# Specify directory to install
cask_args appdir: "/Applications"

# Install packages
tap 'homebrew/bundle'
brew 'mas'
brew 'direnv'
brew 'git'
brew 'git-crypt'
brew 'git-lfs'
brew 'readline'
brew 'scrcpy'
brew 'yarn'
brew 'watchman'
brew 'vale'
brew 'cocoapods'
brew 'typos-cli'

# Images, Video
brew 'ffmpeg'

# Fonts
cask 'font-jetbrains-mono'
cask 'font-hack-nerd-font'

# Other apps
cask 'insomnia'
cask 'visual-studio-code'
cask 'google-chrome'
cask 'google-chrome@canary'
cask 'brave-browser'
cask 'arc'
cask 'imageoptim'
cask 'expo-orbit'

## App Store apps
mas "1Password 7", id: 1333542190
mas "Slack", id: 803453959
mas 'Bandwidth+', id: 490461369
```

When I am setting up my Macbook, I [download this file](https://github.com/amandeepmittal/dotfiles) and run the following command to install everything from this file:

```shell
brew bundle --file=brewfile.sh
```

## Dissection of the bundle file

The important piece from the above configuration is to define a path for the applications to install inside the `Applications` directory. Otherwise, macOS might recognize an app or warn you to manually move it inside that directory. The `cask_args` allows passing the directory path.

```shell
cask_args appdir: "/Applications"
```

Then, adding third-party repos from Homebrew allows installing packages from external sources.

```shell
tap 'homebrew/bundle'
tap "homebrew/core"
```

The next step is to install packages and other applications that I'd be installing manually otherwise.

Also, I discovered that [`mas`](https://github.com/mas-cli/mas) is a command line interface for macOS App Store and allows an app from the store with its product identifier and can be used with brew. For example:

```shell
mas 'Bandwidth+', id: 490461369
```

Searching an app's product identifier is easy and requires searching the app using `mas search app-name`. For example:

```shell
mas search 1Password
  1333542190  1Password 7 - Password Manager                  (7.9.11)
```

I like this way of installing necessary stuff when I set it up from scratch.

---

## Basic Navigation in Ionic Applications
Slug: basic-navigation-in-ionic-applications

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/https-medium-com-amanhimself-basic-navigation-in-ionic-applications-ecb199cdf15b)

Navigation in Ionic does not work using normal routing like you might have done in some of the client side web frameworks, especially when compared to browser based navigation. It uses the terminology of `pages` which I find is more generalised and correctly named as compared Ionic version 1's `states`. This approach is quite similar to navigation in a native mobile application.

Pages are _pushed_ and _popped_ from the navigation controller a class defined whose subclass available in Ionic is `ion-nav`. The logic here is equivalent to that of a stack. The purpose of `ion-nav` is to work with the navigation stack.

To define a nav bar in an ionic app:

```html
<!--Home.html-->
<ion-navbar>
  <ion-title> Ionic App </ion-title>
</ion-navbar>
```

Inside the typescript file associated to above HTML code, we will have access to Navigation Controller.

```ts
// home.ts
import { Component } from '@angular/core';
import { NavController } from 'ionic-angular';

@Component({
  selector: 'page-home',
  templateUrl: 'home.html'
})
export class HomePage {
  constructor(public navCtrl: NavController) {}
}
```

Thus, we can access `NavController` and it's properties such as `push` and `pop` to navigate to a different page or back to the previous page.

Note: _Deeplinking is available in Ionic with URLs but that is altogether a different topic._

---

## Block unwanted external links using Google Search Console's Disavow
Slug: block-unwanted-external-links-using-google-search-console-disavow

When managing a docs site SEO, you might encounter situations when external websites link to incorrect or non-existent pages from your site. These unwanted backlinks can impact your site's search performance and create unnecessary 5xx errors.

Solution is to use Google Search Console's [disavow links tool](https://support.google.com/webmasters/answer/2648487?hl=en) to create a list of unwanted backlinks.

## Detecting incorrect external links

Recently, I encountered an interesting case where a (spammy looking) website linked to Expo documentation with a typo in the URL. Google Search Console reported this as a 5xx Page not indexed.

![ss1](/images/disavow-1.png)

Now, even though the page exists, requesting a re-index validation in Google Search Console wouldn't solve this problem (I tried this and that's how I stumbled upon the solution).

This is a common issue many website owners face, external sites linking to incorrect URLs that you don't have direct control over.

## Understanding the impact

Incorrect external links can cause multiple issues such as: 404 error reports and 5xx Page not indexed.

## Using Google's Disavow links tool

Google Search Console provides adding disavow links tool, which tells Google to ignore specific backlinks when assessing your site during the next crawl.

To use it, you can :

1. Gather a list of all the external links that are broken
2. Create a text (`.txt`) file containing these URLs you want Google to ignore

```txt
# Pages to disavow
https://example.com/incorrect-page
https://another-site.com/wrong-link
```

If required, you can also also disavow the complete domain by adding it to the text file:

```txt
# Sites to disavow
domain:example.com
```

3. Open Google Search Console's [disavow links tool page](https://search.google.com/search-console/disavow-links) and select your domain property under **Select property**
4. Upload your disavow file and confirm the submission

![ss2](/images/disavow-2.png)

## Summary

The Google Search Console disavow links tool is a valuable resource for managing unwanted or incorrect external links. While it shouldn't be your first solution as per [Google's documentation](https://support.google.com/webmasters/answer/2648487?hl=en), it's an effective way to handle situations where you can't get incorrect links modified at their source.

---

## Blogging tips after 3 years and a 100+ posts
Slug: blogging-tips-after-3-years

![cover_image](https://i.imgur.com/XHghbGg.jpg)

> Your time is limited... &mdash; Steve Jobs

A blog can be a useful piece for many reasons not only to you but to many others. Such it has been in my journey. Not only I have been able to generate leads (being a contract developer, it helps), it has been one of the most important things I have done in my career of being a dev. Sometimes, I do go back and read my blog posts when seeking information for a specific topic.

I've been [blogging](https://amanhimself.dev) in tech and writing tutorials using various JavaScript frameworks (Node.js, Reactjs, React Native, Gatsby) for three years now. One of the biggest advantages through blogging I have found lies in the previous sentence. I have the freedom to try and play around with many different stacks and frameworks. This helps me understand about the betterment of their use case.

The motivation behind this article is to share my thoughts on blogging since I have been asked too many times to provide some insight from my journey and why I think blogging can help you achieve your goals at a faster rate if you are willing to dip your toes. Or let us just say you want to share what you know and you find blogging as the medium to do so.

## Its about consistency

One of the major lessons I have learned from blogging is that to build an audience or if you are trying to scratch that itch of sharing what you know, you have to be consistent. That said, it doesn't matter how many blog posts you write and publish in a week or a month, achieving the deadlines you set for yourself, you need to be diligent.

When I started blogging on [Medium](https://medium.com/@amanhimself) I wasn't much consistent for the first year. But I was putting content out in form shorter posts or long length tutorials once in a while.

After a while, it made me realize how far I have come and how can I improve managing my time if I want to continue to publish more content. It helps me to create a schedule in my daily routine and dedicate several hours in a week either researching or building app demos and writing tutorials around them.

## Topic consistency is a thing too

Apart from managing one's time and schedule, you have to be focused as to what your blog is going to be about. For example, when I started blogging, for a long time, I was writing posts on Node.js and backend. With time, my focus of work shifted towards front-end development and more precisely, towards the React Native ecosystem.

In recent times, my focus on writing tutorials on what I do and know shifted with that. You have to keep the content you are sharing in some sense, professional for the audience to read. You cannot assume the type of reader you are going to have.

## Draft your posts in advance

Plan ahead. This is the best suggestion I can give it to you if you are interested in pursuing blogging in tech for a longer period of time.

Draft your posts in advance and make sure that it helps you stick to your publishing schedule even when you are taking vacations or having a week off.

I usually write almost all of my blog posts in Markdown format and store each draft on my laptop, inside a directory of [my blog site](https://amanhimself.dev). This way, it saves me time when I publish them since I use Gatsby and Markdown format for each blog post.

When I publish on sites like [Medium](https://medium.com/@amanhimself) that do not support Markdown format completely, I use a tool called [Markdown to Medium](https://markdowntomedium.com/) which allows you to publish markdown formatted posts on Medium with correct syntax highlighting **( this is important if your post contain code snippets)** using editable GitHub gists. It is fast and it works like a charm. (_Shoutout to [Jake Bennett](https://x.com/jacobbennett) for creating it and making it free to use_). However, at the same time, publishing on sites like [Dev.to](https://dev.to/amanhimself), Markdown can be your friend.

## List your ideas

Having a list of ideas is beneficial. Not every day you are going to feel like brainstorming about new topics or micro-managing a bigger topic in its subparts.

This helps you follow the previous step too, and help you plan with a clearer vision of what you might be writing or publishing in upcoming weeks or months.

Use tools that are favorable to you to manage a list of ideas. I use Notion to track each blog post. From the idea to the date, it gets published.

You can decide on what topics you want to write about. Not everything has to be too technical or walk through about building "X" with a specific framework or a stack or have to belong. It can be something work-related you are passionate about, something that you might find super simple (like writing Redux sagas) but it helps someone less experienced or who are just starting in their career.

## Publish on your platform

This is a lesson I have learned late and in a hard way. Even though I have been professionally blogging for about two years now, I only did create and hosted my blog in the middle of last year.

I don't want you to make this mistake. Since day one, make sure you have a blog hosted on under your domain and it is linked with your portfolio website. It doesn't have to be pretty. Even though you are writing on other platforms or for publications, make sure to ask about their policy of re-publishing the post on your platform. Most publications do allow and generally have time span after which you can publish it under your domain provided the post links back to the original link/website.

Having one's platform with blog posts (regardless of their number) is much better than having no personal blogging platform at all. It is the core. When someone comes knocking on your down for a role or an offer, at first, they are going to see your website/platform and rather than publication.

## Study not other bloggers but content creators too

One advantage we have these days is there is no shortage of the amount of content and platforms that you can host. To keep up to date with topics you want to write about, surely, at a certain point in time, you can never know everything about it.

Apart from other blogs I regularly follow, I exhaustively use Twitter, Medium, Dev.to, tech podcasts, official documentation and sometimes books to keep myself up to date and research whats going on. I can never be an expert on everything but I do love to share my perspective and I believe everyone has a unique perspective. Also researching and learning go hand-in-hand. I learn new things every day and at a faster rate when I share them.

## You learn how to take criticism

Blogging taught me how to separate constructive criticism (which I consider actual feedback) from the criticism we find every day on the internet and that doesn't help anyone.

Some places on the internet exist where people are too harsh in their opinions but that's a good thing. You get a sense of feeling whom to hear and whom to shut out completely. In other words, you grow.

## Share everything, everywhere

If you are writing on your blog but not sharing on every available platform that costs nothing, you are not helping much. Your blog post tends to help someone you might even don't know them.

It helps to drive the community forward and help someone when they are actually seeking useful information to their problem that you have already faced or shared.

Platforms I regularly share my content on:

- Medium
- Dev.to
- Twitter
- Reddit
- Hacker News
- LinkedIn
- Instagram
- Major publications like [freeCodeCamp](https://www.freecodecamp.org/news/)

Getting on the first page of the search engine is amazing but that doesn't happen in every scenario or overnight. Use these platforms. Cross-post and use canonical URLs and get on the wagon.

## Summary

I hope this post serves its purpose and I urge you to go ahead and write your blog post if you haven't started already. There is no worst-case scenario here. Have a starting point, and stick to it. Also, I do consider writing is a skill in life worth learning and practicing, and blogging helps me do that.

Happy Writing!

---

## Exploring React Native: Header blur effect in Expo Router
Slug: blur-effect-in-header-with-expo-router

Modern mobile app interfaces go beyond opaque header bars. On iOS, a frosted-glass like blur effect when scrolling a screen which contains the header is quite easy with Expo Router and React Navigation.

In this article, let's explore how to implement this effect in a React Native app using Expo Router. For demonstration, the following will be the final result:

<img src="/images/react-native/manga-list-03.gif" width="480" />

## Using Stack.Screen options

Since Expo Router wraps the React Navigation library, you can use `Stack.Screen` options to achieve the blur effect. On iOS, this requires adding two props: `headerBlurEffect` and `headerTransparent`.

In `app/_layout.tsx`, a `Stack` component is used to define the layout of the app. The `Stack.Screen` component is used to define the screen's layout and options. Currently, there's only one screen in the app, so it's the root screen (`app/index.tsx`). Update the `Stack.Screen` component with the `headerBlurEffect` and `headerTransparent` props:

```tsx
// app/_layout.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';

const queryClient = new QueryClient();

export default function RootLayout() {
  return (
    <QueryClientProvider client={queryClient}>
      <Stack>
        <Stack.Screen
          name="index"
          options={{
            headerTitle: 'Manga',
            headerBlurEffect: 'regular',
            headerTransparent: true
          }}
        />
      </Stack>
      <StatusBar style="auto" />
    </QueryClientProvider>
  );
}
```

It's important to note that adding `headerBlurEffect` alone will have no effect on the look and feel of the app. You have to set the header to transparent for the blur effect prop to work.

<img src="/images/react-native/manga-list-04.png" width="260" />

The header is now appears blurred. Though, as an app user, I haven't scrolled the screen yet, the content of the screen is already behind the header.

There's another problem with this approach. On Android, this effect does not work and results in a bad experience:

<img src="/images/react-native/manga-list-05.png" width="480" />

## Using header height hook to add a safe area

To fix the issue from the previous section, you can use the [`useHeaderHeight` hook](https://reactnavigation.org/docs/use-header-height). This hook returns the height of the header, which you can use to offset the content in `app/index.tsx`.

```tsx
// app/index.tsx
import { useHeaderHeight } from '@react-navigation/elements';
import { FlatList, Pressable, StyleSheet, Text, View } from 'react-native';

import Indicator from '@/components/Indicator';
import { useTrendingManga } from '@/hooks';
import Ionicons from '@expo/vector-icons/Ionicons';
import { Link } from 'expo-router';

export default function HomeScreen() {
  const { data, isLoading, isError } = useTrendingManga();
  const headerHeight = useHeaderHeight();

  if (isLoading) {
    return <Indicator isLoading={isLoading} />;
  }

  if (isError) {
    return <Indicator isError={isError} />;
  }

  return (
    <View style={[styles.container]}>
      <FlatList
        data={data}
        renderItem={({ item }) => (
          <Link href={`/${item.id}`} asChild>
            <Pressable style={styles.mangaItem}>
              <Text style={styles.mangaTitle}>{item.title.romaji}</Text>
              <Ionicons name="chevron-forward" size={16} color="#ccc" />
            </Pressable>
          </Link>
        )}
        contentContainerStyle={{ paddingTop: headerHeight }}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  errorText: {
    color: 'red',
    fontSize: 16
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    paddingHorizontal: 12
  },
  mangaItem: {
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  mangaTitle: {
    fontSize: 16,
    color: 'red'
  }
});
```

Result of the above code is:

<img src="/images/react-native/manga-list-06.png" width="260" />

Importing `useHeaderHeight` from React Navigation gets called to get the exacct header height (which can vary by the device's screen size). Then, the value of the height is applied as `paddingTop` to the `FlatList` component's `contentContainerStyle` to correctly offset the content and prevent it from appearing behind the transparent header.

A key insight here is that the `contentContainerStyle` with `paddingTop: headerHeight` makes sure that the content starts after the header. The value of `paddingTop` is only applied to the scrollable content.

## Applying blur effect only on iOS

In the first section, you learned that the blur effect does not work on Android.

<img src="/images/react-native/manga-list-07.png" width="540" />

To make sure the blur effect is applied only on iOS, you can use the `Platform` module from React Native. In `app\_layout.tsx`, import `Platform` from `react-native` and conditionally check if the platform is iOS to apply `headerBlurEffect` and `headerTransparent`:

```tsx
// app/_layout.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Stack } from 'expo-router';
import { Platform } from 'react-native';

const queryClient = new QueryClient();

export default function RootLayout() {
  return (
    <QueryClientProvider client={queryClient}>
      <Stack>
        <Stack.Screen
          name="index"
          options={{
            headerTitle: 'Manga',
            headerBlurEffect: Platform.OS === 'ios' ? 'regular' : undefined,
            headerTransparent: Platform.OS === 'ios'
          }}
        />
        <Stack.Screen
          name="[id]"
          options={{
            headerTitle: 'Manga Details'
          }}
        />
      </Stack>
    </QueryClientProvider>
  );
}
```

Then, in `app/index.tsx`, for `headerHeight` let's do the similar platform check:

```tsx
// app/index.tsx
<FlatList
  data={data}
  renderItem={({ item }) => (
    <Link href={`/${item.id}`} asChild>
      <Pressable style={styles.mangaItem}>
        <Text style={styles.mangaTitle}>{item.title.romaji}</Text>
        <Ionicons name="chevron-forward" size={16} color="#ccc" />
      </Pressable>
    </Link>
  )}
  contentContainerStyle={{
    paddingTop: Platform.OS === 'ios' ? headerHeight : 0
  }}
/>
```

Using ternary operator on `contentContainerStyle` ensures that padding is added only on iOS. On Android, it has a regular opaque header that doesn't need this adjustment.

<img src="/images/react-native/manga-list-08.png" width="540" />

### Other types of blur properties

Since Expo Router wraps React Navigation library underneath, all supported values documented in [React Navigation documentation](https://reactnavigation.org/docs/native-stack-navigator/#headerblureffect) are available.

For example, if you use `systemThinMaterialDark`, it will be applied to the iOS app, giving a different blur aesthetic that might better match a dark-themed application:

```tsx
// app/_layout.tsx
<Stack.Screen
  name="index"
  options={{
    headerTitle: 'Manga',
    headerBlurEffect:
      Platform.OS === 'ios' ? 'systemThinMaterialDark' : undefined,
    headerTransparent: Platform.OS === 'ios'
  }}
/>
```

<img src="/images/react-native/manga-list-09.png" width="260" />

## Wrapping up

By combining `Stack.Screen` options with platform-specific code to gracefully add a fall back for Android, you can create an iOS-style blur effect for the header of your React Native app. This approach provides a native experience that users expect from modern mobile applications, with minimal code complexity and excellent cross-platform compatibility.

---

## Build a Chatbot with Dialogflow and React Native
Slug: build-a-chatbot-with-dialogflow-and-react-native

![cover_image](https://i.imgur.com/SUVqOZ5.jpg)

Chatbots are a powerful way to provide conversational experiences for any software product. Each conversational experience depends on the implementation of the chatbot to either be a good or poor experience for the end user. The modern day world is living in the technology wave of Artificial Intelligence and bots are a huge part of it.

In this tutorial, we are going to build a chatbot application from scratch using [Dialogflow](https://dialogflow.com/) and React Native. The main reason to use Google's Dialogflow for this tutorial is that you do not have to go through a hefty signup process by providing your card details, unlike other bot frameworks or similar service providers.

_What are we going to build?_ Let us build a chatbot that returns the current date when asked in different ways.

The complete code for this tutorial can be found inside this [Github repository](https://github.com/amandeepmittal/RNDialogflowChatbot).

## Requirements

In order to follow this tutorial, you will need:

- `react-native-cli` version `2.0.1` or above available via `npm`
- Knowledge of React, React Native and JavaScript
- A Google account
- `react-native-gifted-chat`, which provides a customizable and complete chat UI interface
- `react-native-dialogflow`, which will help us bridge our app with Google Dialogflowâ€™s SDK

## Getting Started

In order to get started, the first requirement to use `react-native-cli` and create a new project directory. Run the following command from your terminal.

```shell
react-native init RNDiagflowChatbot

# traverse inside the directory
cd RNDiagflowChatbot
```

Also, make sure that you are now inside the project directory in your terminal window. This step is required since we are going to add two npm packages that are going to help us build our Chatbot app.

```shell
npm install --save react-native-gifted-chat react-native-dialogflow react-native-voice
```

Note that we are not going to use `react-native-voice` directly but you are required to install and link to the React Native project. The reason is `react-native-dialogflow` requires `react-native-voice` as a peer dependency. The next step is to link the Dialogflow SDK library to the React Native project.

```shell
react-native link react-native-dialogflow
react-native link react-native voice
```

You will get a success message when the linking process is complete. Also, to prevent the application from crashing later when we are running it, you have to add some permissions for iOS inside the file `iOS/RNDiagflowChatbot/Info.plist`, inside the root `<dict>` tag.

```xml
// Info.plist

  <key>NSSpeechRecognitionUsageDescription</key>
  <string>Your usage description here</string>
  <key>NSMicrophoneUsageDescription</key>
  <string>Your usage description here</string>
  <key>UIRequiredDeviceCapabilities</key>
```

Now, let us move on to create the first chat component. We will be using the `App` component inside the `App.js` file but you are most welcome to refactor your code later.

```js
// App.js
import React, { Component } from 'react';
import { StyleSheet, Text, View, Image } from 'react-native';
import { GiftedChat } from 'react-native-gifted-chat';

class App extends Component {
  state = {
    messages: [
      {
        _id: 1,
        text: `Hi! I am the FAQ bot ðŸ¤– from Jscrambler.\n\nHow may I help you with today?`,
        createdAt: new Date(),
        user: {
          _id: 2,
          name: 'FAQ Bot',
          avatar: 'https://i.imgur.com/7k12EPD.png'
        }
      }
    ]
  };

  onSend(messages = []) {
    this.setState(previousState => ({
      messages: GiftedChat.append(previousState.messages, messages)
    }));
  }

  render() {
    return (
      <View style={{ flex: 1, backgroundColor: '#fff' }}>
        <GiftedChat
          messages={this.state.messages}
          onSend={messages => this.onSend(messages)}
          user={{
            _id: 1
          }}
        />
      </View>
    );
  }
}

export default App;
```

We start by requiring necessary components, including `GiftedChat` from the `react-native-gifted-chat` package. In the component's state, you will find one static or welcome message whenever the component gets rendered initially.

The `createdAt` time will display the current time and date in the chat UI. The `user` object is the user sending messages â€” in our case, the bot. It is defined with properties like username, its unique ID, and an avatar. The `react-native-gifted-chat` automatically adds a circle avatar in the UI.

The line `<View style={{ flex: 1, backgroundColor: '#fff' }}>` in the render function shows that you can add your own custom styling along using Gifted Chat's components. The `GiftedChat` component can take props like `messages` from our component's initial state, an `onSend` prop that is a callback function used when sending the message, and the user ID of the message.

This is how easy to implement a chat interface in a React Native app. To run your app in an iOS simulator, run the command `react-native run-ios`. For Android users, run the command `react-native run-android` and do make sure you have the Android emulator (or commonly known as Android Virtual Device) running the background.

See the current state of our application in action below.

![](https://i.imgur.com/tBiBSef.png)

## Google's Dialogflow Setup

Dialogflow is an NLP service from Google. It has many integrations, SDKs for many languages and prebuilt agents. It works very straightforward with Google Assistant. Visit [the Dialogflow website](https://dialogflow.com/) and create a new account or log-in with your existing Google ID. Once you are logged in, you will be welcomed by a screen that consists of different **Agents**.

![](https://i.imgur.com/50uiOOR.png)

Click on the `Create Agent` button to make one. We are going to name our agent: **faq-bot**. Fill in the details like below.

![](https://i.imgur.com/HDhFKLS.png)

After filling out the details, click on the button `Create`.

Generally, for small applications you will have one agent. In Dialogflow, the basic flow of conversation involves these steps:

- The user giving input
- Your Dialogflow agent parsing that input
- Your agent returning a response to the user

These _agents_ can understand the vast and varied nuances of human language and translate that to standard and structured meaning that your apps and services can understand. Each agent contains different **intents**.

An intent is the action or the response sent back to the user in the chatbot application. An intent can contain different types of responses or actions. The next step in the process is to create your first intent.

![](https://i.imgur.com/8xUJ1vt.png)

An intent can be a simple text response that is displayed back to the user or trained phrases to match a specific intent. There are also actions and parameters that extract parameters or information from user queries. Examples of this kind of information include dates, times, names, places, and more.

Right now, we do not have any intent created of our own. Let us create one in the next section.

## First Dialogflow Intent

Let us add our first intent which we are going to call `date.current`. The purpose of this intent is to return the current date back to the user when asked. We can add pre-defined common training phrases to identify what the user is asking to our bot. Take a look below at the following training phrases.

![](https://i.imgur.com/xf0iubV.png)

Since â€œdateâ€ as a keyword is available in Dialogflow's API, it is automatically considered to be a parameter to take action on.

![](https://i.imgur.com/oViXxwC.png)

The Last step in this process is to add a text response for the user to receive.

![](https://i.imgur.com/CO4Suon.png)

Do not forget to click the `Save` button at the top.

## Connecting Dialogflow with React Native

We need a few keys to use Dialogflow's npm package with our app. Right now, from the console window, go to Settings (it is an icon next to the agent's name).

![](https://i.imgur.com/Gkm6tVn.png)

Then click on the value next to `Service Account`.

![](https://i.imgur.com/L8vIgwg.png)

Once in the service account, find the account that named `Dialogflow Integrations`, and scroll to the right until you see the three dots. Click on this menu, and click `Create Key`.

![](https://i.imgur.com/pf9AQaP.png

Download it as JSON file, and open that file in an editor. You will find the following content in this file.

```json
{
  "type": "service_account",
  "project_id": "faq-bot-XXXX",
  "private_key_id": "XXXX",
  "private_key": "-----BEGIN PRIVATE KEY-----XXXX\n-----END PRIVATE KEY-----\n",
  "client_email": "XXXX",
  "client_id": "XXXX",
  "auth_uri": "XXXX",
  "token_uri": "XXXX",
  "auth_provider_x509_cert_url": "XXXX",
  "client_x509_cert_url": "XXXX"
}
```

Every key in the JSON file will have its value (in place of `XXXX`) some of them are sensitive.

## Building the Chatbot

Now, create a new file called `env.js` and inside place the same values as above.

```js
// env.js

export const dialogflowConfig = {
  type: 'service_account',
  project_id: 'faq-bot-XXXX',
  private_key_id: 'XXXX',
  private_key: '-----BEGIN PRIVATE KEY-----XXXX\n-----END PRIVATE KEY-----\n',
  client_email: 'XXXX',
  client_id: 'XXXX',
  auth_uri: 'XXXX',
  token_uri: 'XXXX',
  auth_provider_x509_cert_url: 'XXXX',
  client_x509_cert_url: 'XXXX'
};
```

Next, export the configuration object. You will be requiring it among other things in the `App.js` file.

```js
import { Dialogflow_V2 } from 'react-native-dialogflow';

import { dialogflowConfig } from './env';
```

Also, we are refactoring the user object by separating it from the state like below.

```js
const BOT_USER = {
  _id: 2,
  name: 'FAQ Bot',
  avatar: 'https://i.imgur.com/7k12EPD.png'
};
```

The state now looks like below.

```js
state = {
  messages: [
    {
      _id: 1,
      text: `Hi! I am the FAQ bot ðŸ¤– from Jscrambler.\n\nHow may I help you with today?`,
      createdAt: new Date(),
      user: BOT_USER // <= note this
    }
  ]
};
```

Let us now use a lifecycle method `componendDidMount` to apply Dialogflow's configuration.

```js
componentDidMount() {
    Dialogflow_V2.setConfiguration(
      dialogflowConfig.client_email,
      dialogflowConfig.private_key,
      Dialogflow_V2.LANG_ENGLISH_US,
      dialogflowConfig.project_id
    );
  }
```

All the values inside `Dialogflow_V2.setConfiguration()` are coming from the `env.js` file. In the `onSend` function, you have to make sure that it sends the text of the message to the Dialogflow agent. Refactor it like below.

```js
onSend(messages = []) {
    this.setState(previousState => ({
      messages: GiftedChat.append(previousState.messages, messages)
    }));

    let message = messages[0].text;
    Dialogflow_V2.requestQuery(
      message,
      result => this.handleGoogleResponse(result),
      error => console.log(error)
    );
  }
```

The method `Dialogflow_V2.requestQuery` is used to send a text request to the agent. It contains three parameters:

- the text itself as the first parameter; in our case `message`
- the `result` and `error` callback functions

The function `handleGoogleResponse(result)` handles the response coming back and further calls the `sendBotResponse()` function.

```js
handleGoogleResponse(result) {
    let text = result.queryResult.fulfillmentMessages[0].text.text[0];
    this.sendBotResponse(text);
}

sendBotResponse(text) {
    let msg = {
      _id: this.state.messages.length + 1,
      text,
      createdAt: new Date(),
      user: BOT_USER
    };

    this.setState(previousState => ({
      messages: GiftedChat.append(previousState.messages, [msg])
    }));
  }
```

The `sendBotResponse` function then updates the state of the `App` component and display whatever response back to the user in the chat interface. See the application in action below.

![](https://i.imgur.com/jeaZoRY.gif

You can find the complete code for `App.js` below.

```js
// App.js

import React, { Component } from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { GiftedChat } from 'react-native-gifted-chat';
import { Dialogflow_V2 } from 'react-native-dialogflow';

import { dialogflowConfig } from './env';

const BOT_USER = {
  _id: 2,
  name: 'FAQ Bot',
  avatar: 'https://i.imgur.com/7k12EPD.png'
};

class App extends Component {
  state = {
    messages: [
      {
        _id: 1,
        text: `Hi! I am the FAQ bot ðŸ¤– from Jscrambler.\n\nHow may I help you with today?`,
        createdAt: new Date(),
        user: BOT_USER
      }
    ]
  };

  componentDidMount() {
    Dialogflow_V2.setConfiguration(
      dialogflowConfig.client_email,
      dialogflowConfig.private_key,
      Dialogflow_V2.LANG_ENGLISH_US,
      dialogflowConfig.project_id
    );
  }

  handleGoogleResponse(result) {
    let text = result.queryResult.fulfillmentMessages[0].text.text[0];
    this.sendBotResponse(text);
  }

  onSend(messages = []) {
    this.setState(previousState => ({
      messages: GiftedChat.append(previousState.messages, messages)
    }));

    let message = messages[0].text;
    Dialogflow_V2.requestQuery(
      message,
      result => this.handleGoogleResponse(result),
      error => console.log(error)
    );
  }

  sendBotResponse(text) {
    let msg = {
      _id: this.state.messages.length + 1,
      text,
      createdAt: new Date(),
      user: BOT_USER
    };

    this.setState(previousState => ({
      messages: GiftedChat.append(previousState.messages, [msg])
    }));
  }

  render() {
    return (
      <View style={{ flex: 1, backgroundColor: '#fff' }}>
        <GiftedChat
          messages={this.state.messages}
          onSend={messages => this.onSend(messages)}
          user={{
            _id: 1
          }}
        />
      </View>
    );
  }
}

export default App;
```

## Conclusion

The possibilities of using a powerful API such as Dialogflow are endless. In no time, you can build up your own chatbot interface inside a React Native application as a valuable support or marketing tool.

[Originally published at Jscrambler](https://jscrambler.com/blog/build-a-chatbot-with-dialogflow-and-react-native)

---

## Build a Custom Modal with the Animated API in React Native
Slug: build-a-custom-modal-with-the-animated-api-in-react-native

![cover_image](https://i.imgur.com/0bXMoSY.png)

> [Originally published at Heartbeat](https://heartbeat.fritz.ai/build-a-custom-modal-with-the-animated-api-in-react-native-abf4b650622)

Creating a better user experience is one of the most important aspects of any application. This is where animations in mobile applications come into play. Animations are an important part of your mobile application.

Fortunately, for React Native developers, there is recommended a way to create desirable user experiences. It can be achieved through [Animated API](https://facebook.github.io/react-native/docs/animated.html). For most use cases Animated API provides the best use case to design and create fluid animations.

In this tutorial, you are going to take dive deep in creating a custom modal and animated it on a button click. This is the final result we looking to achieve in a React Native application.

<img src='https://miro.medium.com/max/367/1*F9LUoINWB7uRjTYX5FCDdg.gif' />

### Table of Contents

- Prerequisites
- Setup up Screens
- Setting up Redux
- Creating an animated Custom Modal
- Integrating Custom Modal to HomeScreen
- Animating HomeScreen
- Conclusion

## Prerequisites

Here is a complete list of plugins, packages, and tools that youâ€™re going to need in order to follow along.

- Nodejs >= `v8.x.x` installed along with npm/yarn.
- `watchman`, the file change watcher for React Native projects.
- [Expo CLI](https://docs.expo.io/versions/latest/workflow/expo-cli/) >= `v2.19.4`.

To get started create a new project using `expo-cli` toolchain with the following set of commands. The first command will create a new project directory. Make sure you are inside the project when running the application in a simulator environment or a real device.

```shell
# create a new bare project
expo-cli init rn-animations

# navigate inside the directory
cd rn-animations

# to start the project
yarn start
```

We are using `yarn` to kickstart the app but you are most welcome to use npm or npm scrips or use Expo CLI tool command: `expo start`. This way you can verify that the project has been created successfully.

Next step is to install different dependencies or libraries that our little demo project is going to depend. Run the below command from a terminal window.

```shell
yarn add redux react-redux styled-components @expo/vector-icons
```

After installing these dependencies, this is how `package.json` file looks like.

```json
{
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "eject": "expo eject"
  },
  "dependencies": {
    "@expo/vector-icons": "^10.0.2",
    "expo": "^33.0.0",
    "react": "16.8.3",
    "react-dom": "^16.8.6",
    "react-native": "https://github.com/expo/react-native/archive/sdk-33.0.0.tar.gz",
    "react-native-web": "^0.11.4",
    "react-redux": "^7.0.3",
    "redux": "^4.0.1",
    "styled-components": "^4.3.1"
  },
  "devDependencies": {
    "babel-preset-expo": "^5.1.1"
  },
  "private": true
}
```

## Setup up Screens

Create two screens inside a new directory called `screens/`. One is going to be the home screen for the app and the main UI point. The second screen is going to be a normal screen but will behave like a custom modal in terms of UI behavior. You can name them whatever you like but make sure to remember those names.

Here is the initial snippet of `screens/HomeScreen.js`.

```js
import React from 'react';
import styled from 'styled-components';

class HomeScreen extends React.Component {
  render() {
    return (
      <Container>
        <ButtonText>Open Modal</ButtonText>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
`;

const ButtonText = styled.Text`
  font-size: 20px;
  font-weight: 600;
`;

export default HomeScreen;
```

The above snippet is using `styled-components` to define new UI elements using React Native API. For more information on to read on how to integrate `styled-components` and its advantage in a React Native app, please go through this [link](https://medium.com/swlh/using-styled-components-with-react-native-de645fcf4787).

For `CustomModal.js`:

```js
import React from 'react';
import styled from 'styled-components';

class CustomModal extends React.Component {
  render() {
    return (
      <Container>
        <Text>CustomModal</Text>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
`;

const Text = styled.Text`
  font-size: 20px;
  font-weight: 600;
`;

export default CustomModal;
```

Now, let us import the `HomeScreen` component inside `App.js`. This component is going to be the entry point of our app.

```js
import React from 'react';

import HomeScreen from './screens/HomeScreen';

export default function App() {
  return <HomeScreen />;
}
```

On running the application using `yarn start` you will get the following result. The header has a breakthrough line indicates that the stack navigator has been integrated into our app.

<img src='https://cdn-images-1.medium.com/max/800/1*VRSKOFVSI-C0KEaTlyW_Pw.png' />

## Setting up Redux

In this section, let us create a simple reducer for Redux state management library. It might be that redux as a library is overkill for the purpose of this tutorial, so if you don't want to use it, please find a way that works for you. Also, I am not going to get into details of how you should manage reducers and actions right now. That said, first create a reducer inside a new file called `reducers/index.js` with an initial state.

```js
const initialState = {
  action: ''
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'OPEN_MODAL':
      return { ...state, action: 'openModal' };
    case 'CLOSE_MODAL':
      return { ...state, action: 'closeModal' };
    default:
      return state;
  }
};

export default reducer;
```

Since the `redux` and `react-redux` dependencies are already installed, open `App.js` file and inside write the code to hook a store provider for redux to manage global state in the app.

```js
import React from 'react';
import { createStore } from 'redux';
import { Provider } from 'react-redux';
import HomeScreen from './screens/HomeScreen';
import reducer from './reducers';

const store = createStore(reducer);

const App = () => (
  <Provider store={store}>
    <HomeScreen />
  </Provider>
);

export default App;
```

The redux setup is complete. Let us move on to the next section where the real thing starts.

## Creating an animated Custom Modal

Even though we are creating this custom modal as a screen, you can always use this as a re-usable component. Open `CustomModel.js` file and add the following snippet of code.

```js
import React from 'react';
import styled from 'styled-components';

class CustomModal extends React.Component {
  render() {
    return (
      <Container>
        <Header />
        <Body />
      </Container>
    );
  }
}

const Container = styled.View`
  position: absolute;
  background: white;
  width: 100%;
  height: 100%;
  z-index: 100;
`;

const Header = styled.View`
  background: #333;
  height: 150px;
`;

const Body = styled.View`
  background: #eaeaea;
  height: 900px;
`;

export default CustomModal;
```

The above component is simple. It contains three react native views. On the `Container` we are using the CSS property `position: absolute`. The `z-index` will allow the modal to appear on the top of the `HomeScreen` component. The `Header` and the `Body` are subviews with fixed `height`.

In order to see this in action, open `HomeScreen.js` and import it.

```js
// ...
import CustomModal from './CustomModal';

class HomeScreen extends React.Component {
  render() {
    return (
      <Container>
        <CustomModal />
        <ButtonText>Open Modal</ButtonText>
      </Container>
    );
  }
}

// ...
```

You will get the following result in your simulator.

<img src='https://cdn-images-1.medium.com/max/800/1*rIrz_kLxluX_9Pll7tj-Vg.png' />

Great! Now that we can see the Custom Model on the screen, let us start applying some animations. To apply animations in this demo application, we will be using `Animated` API from React Native. You do not have to install anything rather than import the API from React Native core. Open `CustomModel.js` and modify it. In the below snippet, also define an initial state.

This initial state value defines an Animated `top` value to push model up and down.

```js
import React from 'react';
import styled from 'styled-components';
import { Animated } from 'react-native';

class CustomModal extends React.Component {
  state = {
    top: new Animated.Value(900)
  };
  render() {
    return (
      <AnimatedContainer style={{ top: this.state.top }}>
        <Header />
        <Body />
      </AnimatedContainer>
    );
  }
}

const Container = styled.View`
  position: absolute;
  background: white;
  width: 100%;
  height: 100%;
  z-index: 100;
`;

const AnimatedContainer = Animated.createAnimatedComponent(Container);

const Header = styled.View`
  background: #333;
  height: 150px;
`;

const Body = styled.View`
  background: #eaeaea;
  height: 900px;
`;

export default CustomModal;
```

Right now, the initial top value is receiving an Animated value of `900`. The syntax `Animated.Value()` is used to bind style properties such as we are using with `AnimatedContainer`. In order to perform animations, the component or the `View` has to be Animated, thus, you can `Animated.createAnimatedComponent()` to transform a basic `View` an Animated one.

Next, define a custom method called `toggleModal` before the render function. This function will handle the animations to open and close the modal. So far, it is:

```js
componentDidMount() {
        this.toggleModal()
    }

toggleModal = () => {
    Animated.spring(this.state.top, {
        toValue: 174
    }).start()
}
```

In the above snippet, we are using spring animations using `Animated.spring()` method. This is used to configure animations based on the analytical values to create a simple spring model based on physics. To read more about this method, take a look at this [link](https://facebook.github.io/react-native/docs/animated#spring) in official React Native documentation. The `toValue` is passed as the second parameter. Lastly, to start an animation, you need to call the method `.start()`.

To trigger this animation on the first render of the component `CustomModal`, we are using React's lifecycle method `componentDidMount()`.

You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*Nl3yw5Rgy4Wo3NnBGpvSbg.gif' />

We need to add a button to close the modal. Let us add the styles and view for the close button on the modal. Create a `CloseView` component with `styled-components` library inside a `TouchableOpacity` button. Also, for the close icon, we are going to use `@expo/vector-icons` library.

```js
import React from 'react';
import styled from 'styled-components';
import { Animated, TouchableOpacity, Dimensions } from 'react-native';
import * as Icon from '@expo/vector-icons';

const screenHeight = Dimensions.get('window').height;

class CustomModal extends React.Component {
  state = {
    top: new Animated.Value(screenHeight)
  };

  componentDidMount() {
    this.toggleModal();
  }

  toggleModal = () => {
    Animated.spring(this.state.top, {
      toValue: 174
    }).start();
  };

  closeModal = () => {
    Animated.spring(this.state.top, {
      toValue: screenHeight
    }).start();
  };

  render() {
    return (
      <AnimatedContainer style={{ top: this.state.top }}>
        <Header />
        <TouchableOpacity
          onPress={this.closeModal}
          style={{
            position: 'absolute',
            top: 120,
            left: '50%',
            marginLeft: -22,
            zIndex: 1
          }}
        >
          <CloseView style={{ elevation: 10 }}>
            <Icon.Ionicons name="ios-close" size={44} color="blue" />
          </CloseView>
        </TouchableOpacity>
        <Body />
      </AnimatedContainer>
    );
  }
}

const Container = styled.View`
  position: absolute;
  background: white;
  width: 100%;
  height: 100%;
  z-index: 100;
`;

const AnimatedContainer = Animated.createAnimatedComponent(Container);

const Header = styled.View`
  background: #333;
  height: 150px;
`;

const Body = styled.View`
  background: #eaeaea;
  height: ${screenHeight};
`;

const CloseView = styled.View`
  width: 44px;
  height: 44px;
  border-radius: 22px;
  background: white;
  justify-content: center;
  align-items: center;
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
`;

export default CustomModal;
```

To calculate the height of a screen's device, in the above snippet, start by importing `Dimensions` API. React Native uses Dots Per Inch (DPI) to measure the size (_width and height_) of a device's screen. `Dimensions.get("window").height` allows to gather the screen height. We then use this `screenHeight` variable in three places. First, the initial state which was before had a static value of `900` is now able to adapt for different devices.

Second, to close the modal or inside `closeModal()` method. In the `toggleModal` function we are setting a custom to value of `174` which leaves a partial view of the `HomeScreen` in the background. If you set this value to `0`, the custom modal will cover the whole screen. To close the modal is setting this value to default screen's height. The `TouchableOpacity` that wraps the close button invokes the method `closeModal`.

The third place where the variable `screenHeight` are the styles of the view container: `Body`. Please note that box-shadow will not work on Android devices. If you still want to give the close button a shadow, use `elevation` property as inline styles to `CloseView`.

You will get the following result in your simulator device.

<img src='https://cdn-images-1.medium.com/max/800/1*ZCOwR-WWqOjoE1gkuKkArQ.gif' />

## Integrating Redux to Modal

In this section, you are going to use Redux to manage the state of opening and closing the modal. We have already defined the reducers and actions to serve this purpose. Open `CustomModal.js` and import the `connect` High Order Function `react-redux` library. After that, create two new functions that are somewhat boilerplate code when using a redux in any React or React Native application. These functions are called: `mapStateToProps()` and `mapDispatchToProps()`.

```js
// ...
import { connect } from 'react-redux';

function mapStateToProps(state) {
  return { action: state.action };
}

function mapDispatchToProps(dispatch) {
  return {
    closeModal: () =>
      dispatch({
        type: 'CLOSE_MODAL'
      })
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(CustomModal);
```

Next, let us merge the business logic to trigger animations for opening and closing the modal inside the same `toggleModal` function. The below snippet uses `if` statements to track the right action coming from the global state.

```js
toggleModal = () => {
  if (this.props.action === 'openModal') {
    Animated.spring(this.state.top, {
      toValue: 174
    }).start();
  }
  if (this.props.action === 'closeModal') {
    Animated.spring(this.state.top, {
      toValue: screenHeight
    }).start();
  }
};
```

Also, change the value for `onPress` attribute at the `TouchableOpacity` to `onPress={this.props.closeMenu}`. Lastly, `componentDidMount()` method is going to call `toggleModal()` only on the initial render which means it is going to be called only once. To resolve this, let us use `componentDidUpdate()`. This lifecycle method triggers every time there is a new state or change in props.

```js
componentDidUpdate() {
        this.toggleModal()
    }
```

## Integrating Custom Modal to HomeScreen

Since the initial state at the application level right now is empty, you are not going to see the modal trigger, by itself, when you refresh the Expo app. This serves the purpose of keeping the default behavior of the modal to be closed. But top open this custom modal, we are going to add a button on the `HomeScreen` to activate it.

Open `HomeScreen.js` and connect it to the redux state like below.

```js
import React from 'react';
import { TouchableOpacity } from 'react-native';
import styled from 'styled-components';
import { connect } from 'react-redux';
import CustomModal from './CustomModal';

class HomeScreen extends React.Component {
  render() {
    return (
      <Container>
        <CustomModal />
        <TouchableOpacity onPress={this.props.openModal}>
          <ButtonText>Open Modal</ButtonText>
        </TouchableOpacity>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
`;

const ButtonText = styled.Text`
  font-size: 20px;
  font-weight: 600;
`;

function mapStateToProps(state) {
  return { action: state.action };
}

function mapDispatchToProps(dispatch) {
  return {
    openModal: () =>
      dispatch({
        type: 'OPEN_MODAL'
      })
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(HomeScreen);
```

Click the button `Open Modal` on the UI screen and you will get similar results as follows.

<img src='https://cdn-images-1.medium.com/max/800/1*4RgkT_Rmn2gqO-6Q99wXHA.gif' />

_Congratulations! You have just created a custom model that is animated and integrated it from another screen_. You can end this tutorial right here if it serves the purpose or the as the title suggests. Though, if you want to continue, let us add some animations to the HomeScreen to create a pleasing UI in the next section.

## Animating HomeScreen

In the `HomeScreen` component we are going to import quite a few APIs from React Native. The result we are trying to achieve is as follows. It will be easier for you to view what we want to happen to understand the code in this section.

<img src='https://cdn-images-1.medium.com/max/800/1*F9LUoINWB7uRjTYX5FCDdg.gif' />

Now that you have seen that let us first go through what are we going to import from `react-native`.

```js
// ...
import {
  TouchableOpacity,
  StatusBar,
  Animated,
  Easing,
  Platform
} from 'react-native';
```

In the above demo, we are switching between status bar's color from dark to light when the modal opens, we are going to use `StatusBar` inside `componentDidMount()`.

```js
    componentDidMount() {
        StatusBar.setBarStyle("dark-content", true)

        if (Platform.OS == "android") {
            StatusBar.setBarStyle("light-content", true)
        }
    }
```

Next, we define an initial state to manage Animations with two properties, `scale` and `opacity`.

```js
state = {
  scale: new Animated.Value(1),
  opacity: new Animated.Value(1)
};
```

The create a `toggleModal` method where most of the things are happening. It gets triggered by `componentDidUpdate()` lifecycle method just like in the `CustomModal` component.

```js
componentDidUpdate() {
        this.toggleModal()
    }

    toggleModal = () => {
        if (this.props.action === "openModal") {
            Animated.timing(this.state.scale, {
                toValue: 0.9,
                duration: 300,
                easing: Easing.in()
            }).start()
            Animated.spring(this.state.opacity, {
                toValue: 0.5
            }).start()

            StatusBar.setBarStyle("light-content", true)
        }

        if (this.props.action === "closeModal") {
            Animated.timing(this.state.scale, {
                toValue: 1,
                duration: 300,
                easing: Easing.in()
            }).start()
            Animated.spring(this.state.opacity, {
                toValue: 1
            }).start()

            StatusBar.setBarStyle("dark-content", true)
        }
    }
```

To trigger the effect `HomeScreen` shrinking in the background when the modal opens, is achieved by using `Animated.timing()`. This method maps time range to an `easing` value. This `easing` value triggers the `Easing` module from react native core. This module implements common visualization motions such as bounce, elastic, in (_which we are using_) and out, cubic, sin, back, ease, linear, quad, inout and many more. To get complete information about Easing, please refer to the docs [here](https://facebook.github.io/react-native/docs/easing).

The `Animated.timing()` has a default value of `500` milliseconds. We are changing it to `300`.

To create partial opacity when the home screen shrinks in the background, we are again using spring animations. Depending on whether the modal is being opened or closed, the style of the `StatusBar` is being changed by calling the `StatusBar.setBarStyle()` method.

Here is the complete code for `HomeScreen.js` file.

```js
import React from 'react';
import {
  TouchableOpacity,
  StatusBar,
  Animated,
  Easing,
  Platform
} from 'react-native';
import styled from 'styled-components';
import { connect } from 'react-redux';
import CustomModal from './CustomModal';

class HomeScreen extends React.Component {
  state = {
    scale: new Animated.Value(1),
    opacity: new Animated.Value(1)
  };

  componentDidMount() {
    StatusBar.setBarStyle('dark-content', true);

    if (Platform.OS == 'android') {
      StatusBar.setBarStyle('light-content', true);
    }
  }

  componentDidUpdate() {
    this.toggleModal();
  }

  toggleModal = () => {
    if (this.props.action === 'openModal') {
      Animated.timing(this.state.scale, {
        toValue: 0.9,
        duration: 300,
        easing: Easing.in()
      }).start();
      Animated.spring(this.state.opacity, {
        toValue: 0.5
      }).start();

      StatusBar.setBarStyle('light-content', true);
    }

    if (this.props.action === 'closeModal') {
      Animated.timing(this.state.scale, {
        toValue: 1,
        duration: 300,
        easing: Easing.in()
      }).start();
      Animated.spring(this.state.opacity, {
        toValue: 1
      }).start();
      StatusBar.setBarStyle('dark-content', true);
    }
  };

  render() {
    return (
      <RootView>
        <CustomModal />
        <AnimatedContainer
          style={{
            transform: [{ scale: this.state.scale }],
            opacity: this.state.opacity
          }}
        >
          <TouchableOpacity onPress={this.props.openModal}>
            <ButtonText>Open Modal</ButtonText>
          </TouchableOpacity>
        </AnimatedContainer>
      </RootView>
    );
  }
}

const RootView = styled.View`
  flex: 1;
  background: black;
`;

const Container = styled.View`
  flex: 1;
  background: white;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  justify-content: center;
  align-items: center;
`;

const AnimatedContainer = Animated.createAnimatedComponent(Container);

const ButtonText = styled.Text`
  font-size: 20px;
  font-weight: 600;
`;

function mapStateToProps(state) {
  return { action: state.action };
}

function mapDispatchToProps(dispatch) {
  return {
    openModal: () =>
      dispatch({
        type: 'OPEN_MODAL'
      })
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(HomeScreen);
```

In the above snippet, do take note of `RootView`. We are also converting the good old `Container` into an Animated view.

## Conclusion

This completes this tutorial about creating animated custom modal to provide a pleasant user experience in your react native application. You learned how to use the animated library and some of its methods such as `spring`, `timing` along with `Easing` module. With the help of redux to manage state, you created a custom modal UI.

---

## Build a Progressive Web App using React
Slug: build-a-progressive-web-app-using-react

> [Originally this article was published on Zeolearn.com](https://www.zeolearn.com/magazine/an-introduction-to-progressive-web-apps-pwa)

![cover_image](https://i.imgur.com/qQAmt3M.jpg)

**Progressive Web App with React!** When I read this I thought, why not build one ourselves. If you are familiar with React and a bit about its ecosystem such as Create-React-App utility, this guide is for you.

If you spend at least third quarter of your day on internet then you have seen or read about progressive web apps here and there. _No?_ PWA are performance focused web applications that are especially streamlined for a mobile device. They can be saved over a deviceâ€™s home screen and tend to consist a native app feel and look. The first PWA app I used on my mobile device is the Lite Twitter one which got released a few months back. Here is the link if you want to try: [https://lite.twitter.com/](https://lite.twitter.com/). They even support push notifications and offline support these days.

### Getting Started

Let us create a basic React app using _Create-React-App_ generator, the official scaffolding tool to generate _Reactjs_ _App_ released and maintained by _Facebook_. To install it, we will use our command line tool:

```shell
npm install --global create-react-app
```

Once the installation process is complete, go to your desired directory and create an empty project. Run this from your command-line interface:

```shell
create-react-app react-pwa-example

# and cd in that directory
cd react-pwa-example
```

Go ahead and take a look at the directory structure and **package.json** file. See what dependencies come with this scaffolding tool.

CRA or Create React App is one of the best with minimum hassle tool that I am currently using to build apps and prototypes with React. It is running all that Babel, Webpack stuff behind the scenes. If you want more information or want to customize the process, read [here](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#npm-run-eject).

I hope, regardless of the timeline, your package.json file looks like this:

```json
{
  "name": "react-pwa-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^16.2.0",
    "react-dom": "^16.2.0",
    "react-scripts": "1.0.17"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  }
}
```

We need to one more dependency and that is React-Router: Go Back to your terminal:

```shell
npm install --save react-router-dom@4.2.2
```

You can now try running the application from terminal and see if everything is working:

```shell
npm run start
```

The boilerplate code will and look like this:

![](https://i.imgur.com/3vGXI94.png)

### Building the PWAÂ App

Since the sole purpose of this guide is to make you familiar with the build process, I am not going to work out a complex application. For sake of simplicity and your precious time, we will build a simple app. Go to `src/App.js` file and make amendments exactly like below:

```js
import React, { Component } from 'react';
import { BrowserRouter, Route, Link } from 'react-router-dom';
import logo from './logo.svg';
import './App.css';
import Home from './components/Home';
import About from './components/About';

class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>React App</h2>
        </div>
        <BrowserRouter>
          <div>
            <Route path="/" exact component={Home} />
            <Route path="/about" exact component={About} />
          </div>
        </BrowserRouter>
      </div>
    );
  }
}
export default App;
```

In above we are including two pages using `react-router-dom.`Further we define **Home** and **About** Components in `src/components/` directory. It is always a best practice to use this approach and make sure that react components are short and readable.

For `Home.js`:

```js
import React from 'react';
import { Link } from 'react-router-dom';

const home = () => {
  return (
    <div title="Home">
      <h1>Home Page</h1>
      <p>
        <Link to="/about">About</Link>
      </p>
    </div>
  );
};

export default home;
```

And for `About.js`:

```js
import React from 'react';
import { Link } from 'react-router-dom';

const about = () => {
  return (
    <div title="About">
      <h1>About Page</h1>
      <p>
        <Link to="/">Home</Link>
      </p>
    </div>
  );
};

export default about;
```

Now to see if everything working, run `npm start` from your terminal window, and you will get a similar result:

![](https://i.imgur.com/qdqY2YP.png)

If you click on the **About** button/hyperlink, the `react-router-dom` will render the **about** page without changing the common Header part that is defined in `App.js`. This is a bare minimum single page application.

Our main job is still yet to be done. Letâ€™s convert this bare minimum React application to a PWA.

### Installing Lighthouse

Lighthouse is a free tool from Google that evaluates your app based on their PWA checklist. Add it to your Chrome browser from [here](https://developers.google.com/web/tools/lighthouse/). Once installed as an extension we can start the auditiing process by clicking on the Lighthouse at top right corner where other extension might exist in your browser. Click on the icon and then make sure you are on right tab by checking the URL shown in the lighthouse popup. Also, make sure that development server of Create-react-app from terminal is running. Otherwise Lighthouse wonâ€™t be able to generate report. The report that is generated by the Lighthouse is based on a checklist that available to view [here](https://developers.google.com/web/progressive-web-apps/checklist).

![](https://i.imgur.com/c3oDUYx.png)

Click on the Generate Report button. After the process is completed, a new window will open where Lighthouse has generated a report. By the looks of it, it does not look pleasing to the Lighthouse and as a Progressive Web App.

![](https://i.imgur.com/khE0Q5o.png)
![](https://i.imgur.com/8OjdMK4.png)

We will be solving these issues one by one.

### Setting up a ServiceÂ Worker

Letâ€™s setup a service worker first. That is the first thing Lighthouse audited. What is a service worker, you ask? Well, it is a proxy server that sit between web applications, browsers and the network. We can use it to make React Apps work offline (remember the earlier point we discussed. Progressive Web Apps are focused on performance). You can definitey read details about it on [Googleâ€™s Web Fundamental Docs](https://developers.google.com/web/fundamentals/primers/service-workers/?hl=en).

It is a two step process. First we will create a`service-worker.js` file (service worker, after all is JavaScript code) and then register that worker in our `index.html`.

In the `public` directory of our app structure, create a file `service-worker.js`. I am going to use Addy Osmani's service worker configuration and I will recommend you to do so, at least for this one. You can find the complete thing in much detail [here](https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-3-offline-support-and-network-resilience-c84db889162c). To continue, make sure you add the following code in `service-worker.js` file:

```js
var doCache = false;

var CACHE_NAME = 'my-pwa-cache-v1';

self.addEventListener('activate', event => {
  const cacheWhitelist = [CACHE_NAME];
  event.waitUntil(
    caches.keys().then(keyList =>
      Promise.all(
        keyList.map(key => {
          if (!cacheWhitelist.includes(key)) {
            console.log('Deleting cache: ' + key);
            return caches.delete(key);
          }
        })
      )
    )
  );
});

self.addEventListener('install', function (event) {
  if (doCache) {
    event.waitUntil(
      caches.open(CACHE_NAME).then(function (cache) {
        fetch('manifest.json')
          .then(response => {
            response.json();
          })
          .then(assets => {
            const urlsToCache = ['/', assets['main.js']];
            cache.addAll(urlsToCache);
            console.log('cached');
          });
      })
    );
  }
});

self.addEventListener('fetch', function (event) {
  if (doCache) {
    event.respondWith(
      caches.match(event.request).then(function (response) {
        return response || fetch(event.request);
      })
    );
  }
});
```

Our next step is to register the our service worker by loading the one we just wrote in `service-worker.js`. Add this before the closing `</body>` tag in `index.html`.

```html
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function () {
      navigator.serviceWorker
        .register('service-worker.js')
        .then(
          function (registration) {
            console.log(
              'ServiceWorker registration successful with scope: ',
              registration.scope
            );
          },
          function (err) {
            console.log('ServiceWorker registration failed: ', err);
          }
        )
        .catch(function (err) {
          console.log(err);
        });
    });
  } else {
    console.log('service worker is not supported');
  }
</script>
```

Make sure you restart the dev server by running `npm run start` from the terminal. You must see this line if you open Chrome's DevTools > Console:

![](https://i.imgur.com/HRVYgGB.png)

If we run the Lighthouse audit process again, I hope we will get a better result.

![](https://i.imgur.com/xaTMUez.png)

Yes, you can clearly compare the above with our previous audit. It has improved, and our previous first issue is now coming under Passed Audits. Now letâ€™s move and add some enhancement.

### Adding Progressive Enhancement

Progressive Enhancement is a way to improve the app/site since it will work without any JavaScript loading. Now, we want to display a loading message and some CSS or none (your choice) before the React app initializes the DOM. Letâ€™s add the required CSS and a loading message to our `index.html`. To increase performance, I am also adding all our CSS (that is CSS contained inside `App.css` and `index.css`) in our `index.html` file.

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#000000">
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
  <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
  <title>React App</title>
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    .App {
      text-align: center;
    }
    .App-logo {
      height: 80px;
    }
    .App-header {
      background-color: #222;
      height: 150px;
      padding: 20px;
      color: white;
    }
    .App-title {
      font-size: 1.5em;
    }
    .App-intro {
      font-size: large;
    }
    @keyframes App-logo-spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div id="root">
    <div class="App">
      <p>
        Loading...
      </p>
    </div>

    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function () {
          navigator.serviceWorker.register('service-worker.js').then(function (registration) {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          }, function (err) {
            console.log('ServiceWorker registration failed: ', err);
          }).catch(function (err) {
            console.log(err)
          });
        });
      } else {
        console.log('service worker is not supported');
      }
    </script>

</body>

</html>
```

We can now delete `App.css` and `index.css` file from out project directory and also remove their import references from `App.js` and `index.js`.

The above process improves the performance of our app by 10 points. The overall PWA score is same though:

![](https://i.imgur.com/lHn2hZG.png)

### Adding it to Deviceâ€™s HomeÂ Screen

The creators of create-react-app is so good to us that they have already included a `manifest.json` file in `public` directory with some basic configuration. This feature that we are currently adding allows a user to save our PWA site page on their device's home screen. In future, if the user wish to open the app, they can do that just by using PWA as a normal application and it will open in their phone's default browser.

For this purpose, we are going to edit `public/manifest.json`:

```json
{
  "short_name": "PWA React App",
  "name": "Progressive React App Example",
  "icons": [
    {
      "src": "logo.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "logo-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#000",
  "background_color": "#000"
}
```

Letâ€™s talk about this file a bit. The `short_name` is the name of app that will appear on Home Screen of device. `name` will appear on the splash screen. `icons` is important and is the main icon of our app and will appear along the `short_name` on home screen, just like a native mobile application. The size of the icon must be `192x192`. I haven't played around with other image formats but you can. [Here](https://i.imgur.com/RaN7Qey.png) is the link to a dummy logo for this walkthrough we are working on. Add it to the `public` directory. The 512 setting is for splash screen and is a requirement in auditing process. So here is the [link](https://i.imgur.com/TmblrhM.png) to download that.

Next is `start_url` that notifies that the app was started from Home Screen. Below it there are three more properties. `display` is for the appearance of the app, and I am making `theme_color` and `background_color` to be same since I want the application to match header background.

We will now solve one of our issue in the previous audit. We are left with only some of them to resolve.

![](https://i.imgur.com/zyot782.png)

### Deployment

First, let us turn the caching on. In `service-worker.js` edit the first line and change the existing boolean value to `true`.

```js
var doCache = true;
```

I will be using [Firebase](https://firebase.google.com/) here for deployment since it is easy to connect it with a web/mobile application for prototyping IMO. First, in Firebase console, create a new project `pwa-example-1`. Now, install the firebase-tool we need to deploy our PWA app. We will be installing this dependency as a global module.

Now the CLI tool will prompt for some questions. I am adding a series of images for clarity, make sure you choose the same answers when prompted.

```shell
npm install -g firebase-tools

# then run the following commands
firebase login
firebase init
```

![](https://i.imgur.com/0cg1Dtt.png)
![](https://i.imgur.com/7pg1Di0.png)
![](https://i.imgur.com/7pg1Di0.png)

Press the Enter key for final time and you will get a success message and two firebase config files generated in your project directory:Â `.firebaserec` and `firebase.json`.

Now, it is time to deploy our app. From terminal run:

```shell
npm run build && firebase deploy
```

The above command tells create-react-app to build our project into the build/ folder, which Firebase CLI tool then deploys. Firebase CLI tool will give you back a URL, save it and open it in Chrome, and then run our Lighthouse audit for the last time. The hosting url will be similar to below:

```shell
Hosting URL: https://pwa-example-1.firebaseapp.com
```

This solves our main issue from starting regarding using HTTTPS over HTTP. With that, all of our issues our solved and our PWA app gets 100/100 score.

![](https://i.imgur.com/VSEWUqI.png)
![](https://i.imgur.com/2GJL7m5.png)

The score looks good to me for our first application. The performance bar above of our application can be improved and there are few ways to that. I will not get into that since the scope of this application is for learning purpose.

You can find the complete code at [this Github repository](https://github.com/amandeepmittal/react-pwa-app). Go ahead to clone the repo, donâ€™t forget to `npm install` once inside the project directory and then head start by trying out aforementioned PWA tips and techniques.

---

## React Hooks Basicsâ€Šâ€”â€ŠBuilding a React Native App with React Hooks
Slug: build-a-react-native-app-with-react-hooks

![cover_image](https://i.imgur.com/5QMLIPd.png)

> [Originally published at Crowdbotics](https://medium.com/crowdbotics/build-a-react-native-app-with-react-hooks-5498e1d5fdf6)

React `16.8` welcomed the dawn of Hooks. This new addition is both a new concept and pragmatic approach that helps you use state and lifecycle methods behavior in functional React components, that is, without writing a class. The intention to implement this new feature in React ecosystem is to benefit all the community.

Whether you are a developer with a front-end role or write mobile apps using React Native, chances are that you are going to come across Hooks often enough in your working environment. Of course, you do not have to use them. You can still write class components, they are not going anywhere yet. However, I personally like to think it is an important part of being a developer and using something like React in our work/day-job/side-hustle projects by keeping up to date with these new features.

Following the footsteps of ReactJS, React Native community recently announced that they will be adding support for hooks shortly in the upcoming version `0.59`. I have been waiting for them to officially make this announcement before I publish this tutorial, only to spike up your interest in Hooks.

In this tutorial, I will walk you through the steps on using Hooks in a React Native application by building a small demo app and understand the most common Hooks in detail before that. Moreover, I am going to briefly introduce you to the concept of `flexbox` and how is it significantly different in React Native than the web.

#### Tldr;

- Requirements
- Setting up Crowdbotics Project
- Setup a React Native app
- What are Hooks?
- Implementing Hooks in react native
- Building a Todo List App
- What is `flexbox`?
- Adding Hooks to the Todo List App
- Rendering the list
- Completing and Deleting an Item
- Conclusion

### Requirements

In order to follow this tutorial, you are required to have the following installed on your dev machine:

- NodeJS above `8.x.x` installed on your local machine
- Know, how to run simple npm commands
- JavaScript/ES6 basics
- `watchman` the file watcher installed
- `react-native-cli` installed through npm

For a complete walkthrough on how you can set up a development environment for React Native, you can go through [official documentation here](https://facebook.github.io/react-native/docs/getting-started).

### Setting up a Crowdbotics Project

In this section, you will be setting up a Crowdbotics project that has React Native pre-defined template with stable and latest dependencies for you to leverage. However, at the time of writing this tutorial, the template does not use React Native version `0.59`. So instead of going into too much hassle about upgrading this React Native app, I will be walking you through creating a new React Native project in the next section.

To follow along, setting up a new project using Crowdbotics app builder service is easy. Visit [app.crowdbotics.com](http://app.crowdbotics.com) dashboard. Once you are logged in, choose `Create a new application`.

<img src='https://cdn-images-1.medium.com/max/800/1*9gollubzgEx8AyxPs_TjFw.png' />

On `Create an Application page`, choose `React Native` template under Mobile App. Lastly, choose the name of your template at the bottom of this page and then click the button `Create by app!` After a few moments, your Crowdbotics project will be created. Upon creation, it will redirect you to the app dashboard, where you can see a link to GitHub, Heroku, and Slack. Once your project is created, you will get an invitation from Crowdbotics to download your project or clone the repository from Github either on them email you logged in or as a notification if you chose Github authentication.

### Setup a React Native App

Once you installed \`react-native-cli\` you can begin by generating a React Native project. Run the below command to initialize a new React Native project. Also, note that you can name your React Native app anything.

`react-native init RNHooksTODOAPP`

Using this command, a new project folder will be generated, traverse inside it and you will be welcome by a slightly different file system (a new file that you might not have seen before is `metro.config.js`, which you can ignore it for now).

<img src='https://cdn-images-1.medium.com/max/800/1*vk2tjcthKq5R5CI4CoSYhg.png' />

Also, note that `RNHooksTODOAPP` is the project and directory name, so in its place, you can enter anything. For more information on the current release candidate of React Native, you can visit their Github project.

[facebook/react-native
\_A framework for building native apps with React. Contribute to facebook/react-native development by creating an accountâ€¦\_github.com](https://github.com/facebook/react-native/releases 'https://github.com/facebook/react-native/releases')[](https://github.com/facebook/react-native/releases)

To run the mobile application in an iOS/Android simulator you can run the same old CLI commands like `react-native run-ios` or `run-android`.

### What areÂ Hooks?

Hooks in React have been available since the version `16.7.0-alpha`. They are functions that allow you to use React state and a component's lifecycle methods in a functional component. Hooks do not work with classes. If you are familiar with React, you know that the functional component has been called as a functional stateless component. Not any more.

Since previously, only a class component allowed you to have a local state. Using Hooks, you do not have to refactor a class component when using React or React Native into a functional component only because you want to introduce local state or lifecycle methods in that component. In other words, Hooks allow us to write apps in React with function components.

React provides a few built-in Hooks like `useState` and `useEffect`. You can also create your own Hooks to re-use the stateful behavior between different components.

### Implementing Hooks in ReactÂ Native

In the example below, let us take a look at how you will manage the local state of a component by using Hooks. Open up `App.js` file and paste this code.

```js
import React, { useState } from 'react';
import { StyleSheet, Text, View, Button } from 'react-native';

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <View style={styles.container}>
      <Text>You clicked {count} times.</Text>
      <Button
        onPress={() => setCount(count + 1)}
        title="Click me"
        color="red"
        accessibilityLabel="Click this button to increase count"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF'
  },
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10
  },
  instructions: {
    textAlign: 'center',
    color: '#333333',
    marginBottom: 5
  }
});
```

We will start by writing a basic old-fashioned counter example to understand the concept of using Hooks. In the above code snippet, you are starting by importing the usual along with `useState` from `react` library. This built-in hook allows you to add a local state to functional components. Notice that we are writing a functional component: `export default function App()`, instead of traditionally writing a class component we are defining a normal function.

This `App` function has state in the form of `const [count, setCount] = useState(0)`. React preserves this state between all the re-rendering happening. `useState` here returns a pair of values. The first one being the `count` which is the current value and the second one is a function that lets you update the _current_ value. You can call `setCount` function from an event handler or from somewhere else. It is similar to `this.setState` in a class component. In above, we are using the function inside the button component: `setCount(count + 1)`

`useState(0)` hook also takes a single argument that represents the initial state. We are defining the initial state as `0`. This is the value from which our counter will start.

To see this in action, open two terminal windows after traversing inside the project directory.

```shell
# first terminal window, run
npm start

# second window, run
react-native run-ios
```

Once the build files are created, the simulator will show you a similar result like below.

<img src='https://cdn-images-1.medium.com/max/800/1*_Ecf_sv3Sx1UyzlYHFHIbw.png' />

If you play around a bit and hit the button `Click me`, you will see the counter's value is increased.

<img src='https://cdn-images-1.medium.com/max/800/1*GKTkcgsmsqdrIMoNWKAyhg.gif' />

As you know by now, that the `App` component is nothing but a function that has state. You can even refactor it like below by introducing another function to handle `Button` click event and it will still work.

```js
export default function App() {
  const [count, setCount] = useState(0);

  function buttonClickHandler() {
    setCount(count + 1);
  }

  return (
    <View style={styles.container}>
      <Text>You clicked {count} times.</Text>
      <Button
        onPress={buttonClickHandler}
        title="Click me"
        color="red"
        accessibilityLabel="Click this button to increase count"
      />
    </View>
  );
}
```

### Building a Todo List app withÂ Hooks

In this section, you are going to build a Todo List application using React Native framework and Hooks. I personally love building Todo list applications when getting hands-on experience over a new programming concept or approach.

We have already created a new project in the last section when we learned about Hooks. Let us continue from there. Open up `App.js` and modify it with the following code.

```js
import React from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  TextInput
} from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.header}>Todo List</Text>
      <View style={styles.textInputContainer}>
        <TextInput
          style={styles.textInput}
          multiline={true}
          placeholder="What do you want to do today?"
          placeholderTextColor="#abbabb"
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    backgroundColor: '#F5FCFF'
  },
  header: {
    marginTop: '15%',
    fontSize: 20,
    color: 'red',
    paddingBottom: 10
  },
  textInputContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    borderColor: 'black',
    borderBottomWidth: 1,
    paddingRight: 10,
    paddingBottom: 10
  },
  textInput: {
    flex: 1,
    height: 20,
    fontSize: 18,
    fontWeight: 'bold',
    color: 'black',
    paddingLeft: 10,
    minHeight: '3%'
  }
});
```

We need a text input field to add items to our list. For that, `TextInput` is imported from `react-native`. For demonstration purposes, I am keeping styles simple, especially the background color. If you want to make the UI look good, go ahead. In the above code, there is a header called `Todo List` which has corresponding `header` styles defined using `StyleSheet.create` object. Also, take notice of the `View` which uses `justifyContent` with a value of `flex-start`.

### What isÂ flexbox?

Creating a UI in a React Native app heavily depends on styling with `flexbox`. Even if you decide to use a third party library kit such as `nativebase` or `react-native-elements`, their styling is based on `flexbox` too.

The `flexbox` layout starts by creating a flex container with an element of `display:flex`. If you are using `flexbox` for the web you will have to define this `display` property. In react native, it is automatically defined for you. The flex container can have its own children across two axes. The main axis and cross axis. They both are perpendicular to each other.

These axes can be changed as a result of property `flexDirection`. In the web, by default, it is a row. In React Native, by default, it is a column.

<img src='https://cdn-images-1.medium.com/max/800/1*t9nPsrpaOMDMv-FIPzdc3g.png' />

To align an element along the horizontal axis or the cross axis in React Native you have to specify in the `StyleSheet` object with the property of `flexDirection: 'row'`. We have done the same in the above code for the `View` that contains `TextInput` field.

Flexbox is an algorithm that is designed to provide a consistent layout on different screen sizes. You will normally use a combination of `flexDirection`, `alignItems`, and `justifyContent` to achieve the right layout. Adding `justifyContent` to a component's style determines the distribution of children elements along the main axis. `alignItems` determine the distribution of children elements along the cross axis.

Back to our app. Right now, if you run it in a simulator, it will look like below.

<img src='https://cdn-images-1.medium.com/max/800/1*yq7SnNuaSIdCyn7FehC6xg.png' />

Let us add an icon to represent a button to add items to the todo list. Go to the terminal window right now and install `react-native-vector-icons`.

```shell
npm install -S react-native-vector-icons

# Also link it
react-native link react-native-vector-icons
```

Now go back to `App.js` file. We have already imported `TouchableOpacity` from `react-native` core. Now let us import `Icon` from `react-native-vector-icons`.

```js
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  TextInput
} from 'react-native';

import Icon from 'react-native-vector-icons/Feather';
```

Next step is to add the `Icon` element inside `TouchableOpacity` next to the `TextInput`. This means the _plus_ to add an item to the list must be on the same line or axis as the text input field. `TouchableOpacity` makes the icon clickable and can have an event listener function (_which we will add later_) to run the business logic for adding an item to the list.

```js
<View style={styles.textInputContainer}>
  <TextInput
    style={styles.textInput}
    multiline={true}
    placeholder="What do you want to do today?"
    placeholderTextColor="#abbabb"
  />
  <TouchableOpacity>
    <Icon name="plus" size={30} color="blue" style={{ marginLeft: 15 }} />
  </TouchableOpacity>
</View>
```

Now if you go back to the simulator you will have the following screen.

<img src='https://cdn-images-1.medium.com/max/800/1*Tt5Dqz4LZvxdFu8D5rd3wA.png' />

### Adding Hooks to theÂ App

In this section, you are going to add a local state to the component using Hooks. We will start by initializing the local state for the App component with the new hooks syntax. For that, you have to require `useState` from `react` core. Also, note that the initial state passed below is passed as an argument to the `useState()` function.

```js
import React, { useState } from 'react';

// ...
export default function App() {
  const [value, setValue] = useState('');
  const [todos, setTodos] = useState([]);

  addTodo = () => {
    if (value.length > 0) {
      setTodos([...todos, { text: value, key: Date.now(), checked: false }]);
      setValue('');
    }
  };

  // ...
}
```

The first `value` is the value of `TextInput` and it is initially passed as an empty string. In the next line, `todos` are declared as an empty array that will later contain multiple values. The `setValue` is responsible for changing the value of `value` on `TextInput` and then initializing the empty value when the `value` from the state is assigned as an item to `todos` array. `setTodos` is responsible for updating the state.

The `addTodo` function we define is a handler function that will check if the `TextInput` field is not empty and the user clicks the plus icon, it will add the `value` from state to the `todos` and generate a unique key at the same time to retrieve each todo item record from `todos` array to display as a list. The initial value for `checked` is false since no todo item can be marked as completed by default, that is when adding it to the list.

Here is the complete code for `App.js` after adding state through Hooks.

```js
import React, { useState } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  TextInput
} from 'react-native';

import Icon from 'react-native-vector-icons/Feather';

export default function App() {
  const [value, setValue] = useState('');
  const [todos, setTodos] = useState([]);

  addTodo = () => {
    if (value.length > 0) {
      setTodos([...todos, { text: value, key: Date.now(), checked: false }]);
      setValue('');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.header}>Todo List</Text>
      <View style={styles.textInputContainer}>
        <TextInput
          style={styles.textInput}
          multiline={true}
          placeholder="What do you want to do today?"
          placeholderTextColor="#abbabb"
          value={value}
          onChangeText={value => setValue(value)}
        />
        <TouchableOpacity onPress={() => handleAddTodo()}>
          >
          <Icon name="plus" size={30} color="blue" style={{ marginLeft: 15 }} />
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'flex-start',
    alignItems: 'center',
    backgroundColor: '#F5FCFF'
  },
  header: {
    marginTop: '15%',
    fontSize: 20,
    color: 'red',
    paddingBottom: 10
  },
  textInputContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    borderColor: 'black',
    borderBottomWidth: 1,
    paddingRight: 10,
    paddingBottom: 10
  },
  textInput: {
    flex: 1,
    height: 20,
    fontSize: 18,
    fontWeight: 'bold',
    color: 'black',
    paddingLeft: 10,
    minHeight: '3%'
  }
});
```

### Rendering theÂ List

You are going to create a new component that will be responsible for displaying each task that a user adds. Create a new file called `TodoList.js` and add the following code to the file.

```js
import React from 'react';
import { StyleSheet, TouchableOpacity, View, Text } from 'react-native';
import Icon from 'react-native-vector-icons/Feather';

export default function TodoList(props) {
  return (
    <View style={styles.listContainer}>
      <Icon name="square" size={30} color="black" style={{ marginLeft: 15 }} />
      <Text style={styles.listItem}>{props.text}</Text>
      <Icon
        name="trash-2"
        size={30}
        color="red"
        style={{ marginLeft: 'auto' }}
        onPress={props.deleteTodo}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  listContainer: {
    marginTop: '5%',
    flexDirection: 'row',
    borderColor: '#aaaaaa',
    borderBottomWidth: 1.5,
    width: '100%',
    alignItems: 'stretch',
    minHeight: 40
  },
  listItem: {
    paddingBottom: 20,
    paddingLeft: 10,
    marginTop: 6,
    borderColor: 'green',
    borderBottomWidth: 1,
    fontSize: 17,
    fontWeight: 'bold',
    color: 'white'
  }
});
```

Now let us import this component in `App.js` to render todo items when we add them by clicking the plus sign button. Also, you are now required to import `ScrollView` in App component from react native core.

```js
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  TextInput,
  ScrollView
} from 'react-native';

// ...

import TodoList from './TodoList';

// ...
return (
  <View style={styles.container}>
    {/* ... */}
    <ScrollView style={{ width: '100%' }}>
      {todos.map(item => (
        <TodoList text={item.text} key={item.key} />
      ))}
    </ScrollView>
  </View>
);
```

The `ScrollView` is a component that renders all its child at once. A good case to use when you are not rendering a large amount of data or data coming from a third party API. Now, enter a new task (_like below_) and try adding it to the todo list.

<img src='https://cdn-images-1.medium.com/max/800/1*yQ1-JAtWzgF8paZLnBbxxg.gif' />

### Completing and Deleting anÂ Item

This is the last section to complete our application. We need two handler functions to implement functionalities of checking a todo list item mark and deleting a todo list item.

Define two functions like below after `addTodo`.

```js
checkTodo = id => {
  setTodos(
    todos.map(todo => {
      if (todo.key === id) todo.checked = !todo.checked;
      return todo;
    })
  );
};

deleteTodo = id => {
  setTodos(
    todos.filter(todo => {
      if (todo.key !== id) return true;
    })
  );
};
```

The first function `checkTodo` uses `map` function to traverse the complete todos array, and then check only that item that has been toggled by the user using its icon on the mobile app by matching its `key` (look at the `addTodo` function, we defined a key when adding an item to the todo list). The `deleteTodo` function uses `filter` to remove an item from the list.

To make it work, we need to pass both of these functions to `TodoList` component.

```js
// App.js
<ScrollView style={{ width: '100%' }}>
  {todos.map(item => (
    <TodoList
      text={item.text}
      key={item.key}
      checked={item.checked}
      setChecked={() => checkTodo(item.key)}
      deleteTodo={() => deleteTodo(item.key)}
    />
  ))}
</ScrollView>
```

Now open, `TodoList.js` and these new props.

```js
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';
import Icon from 'react-native-vector-icons/Feather';

export default function TodoList(props) {
  return (
    <View style={styles.listContainer}>
      <Icon
        name={props.checked ? 'check' : 'square'}
        size={30}
        color="black"
        style={{ marginLeft: 15 }}
        onPress={props.setChecked}
      />
      <View>
        {props.checked && <View style={styles.verticalLine} />}
        <Text style={styles.listItem}>{props.text}</Text>
      </View>
      <Icon
        name="trash-2"
        size={30}
        color="red"
        style={{ marginLeft: 'auto' }}
        onPress={props.deleteTodo}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  listContainer: {
    marginTop: '5%',
    flexDirection: 'row',
    borderColor: '#aaaaaa',
    borderBottomWidth: 1.5,
    width: '100%',
    alignItems: 'stretch',
    minHeight: 40
  },
  listItem: {
    paddingBottom: 20,
    paddingLeft: 10,
    marginTop: 6,
    borderColor: 'green',
    borderBottomWidth: 1,
    fontSize: 17,
    fontWeight: 'bold',
    color: 'black'
  },
  verticalLine: {
    borderBottomColor: 'green',
    borderBottomWidth: 4,
    marginLeft: 10,
    width: '100%',
    position: 'absolute',
    marginTop: 15,
    fontWeight: 'bold'
  }
});
```

Now run the app and see it in action.

<img src='https://cdn-images-1.medium.com/max/800/1*wKSEa-PSOHjNXNbMQ-5WvQ.gif' />

### Conclusion

This completes our tutorial. I hope this tutorial helps you understand the basics of React Hooks and then implement them with your favorite mobile app development framework, React Native.

You can extend this demo application by adding `AsyncStorage` or a cloud database provider and making this application real time. Also, do not forget to enhance the UI to your liking.

_To read more about React Hooks check out the_ [_official Overview page here_](https://reactjs.org/docs/hooks-state.html)_._

_The complete code for this tutorial is available in the Github repository below._

[amandeepmittal/RNHooksTODOAPP](https://github.com/amandeepmittal/RNHooksTODOAPP)

---

## How to Build an Audio Player in React Native
Slug: build-an-audio-player-in-react-native

![cover_image](https://i.imgur.com/XFvTGys.jpg)

Learning React Native development revolves around some common interface patterns that you should practice. One common UI built-in mobile application is an audio player.

In this tutorial, you are going to build a functioning interface for an audio player with common functionalities like

- Load the audio file;
- Play/pause the audio file;
- Navigate to next track;
- Navigate to the previous track.

Apart from building the user interface, you are also going to learn a lot about using the `expo-av` module. This module provides an API for any Expo application to consume for media playback. Also, this module contains APIs both for audio and video media, but here we are only going to look at the audio portion.

You will find the complete code for this tutorial at [this GitHub repository](https://github.com/amandeepmittal/music-player-expo).

## What Are We Building?

The end result of this React Native tutorial is to have an audio player that can play tracks from remote audio files. For the demonstration, the app is going to use audio files related to a play written by William Shakespeare from **[Librivox](https://librivox.org/hamlet-by-william-shakespeare/)**. All these audio files are available under the public domain, so you do not have to worry about copyright issues.

![](https://i.imgur.com/euXYG6Z.png)

## Requirements

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- [Nodejs](https://nodejs.org) (>=`10.x.x`) with npm/yarn installed.
- [expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli/) (>= `3.x.x`), previously known as `create-react-native-app`.
- Mac users must be running an iOS simulator.
- Windows/Linux users must be running an Android emulator.

To know more about how to setup and run the simulator or the emulator on your local development environment visit React Nativeâ€™s [official documentation here](https://facebook.github.io/react-native/docs/getting-started).

## Getting Started

To start, you first have to initialize a new React Native project using the `expo-cli` tool. The only requirement right now is to have `expo-cli` installed. Then, create a new project directory, navigate to it, and install the required dependency to add the functionality of playing an audio file inside the React Native app.

```shell
expo init music-player-expo

# navigate inside the app folder
cd music-player-expo

# install the following dependency
npm install expo-av
```

The dependency `expo-av` will help you use the Audio API and its promise-based asynchronous methods to play the audio files within the React Native app. The source of these audio files can be local or remote.

Once you have generated the app and installed the dependency, execute the command below to open the boilerplate application that comes with `expo-cli`.

```shell
expo start
```

The following screen will welcome you:

![ss1](https://i.imgur.com/dxJdAeg.png)

Since the app will be consuming a bunch of audio files from a remote resource, it is better if you create an array that will contain details related to each of the audio files and their resource in the form of a URI. Open `App.js` and add the following array before the `App` component.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const audioBookPlaylist = [
  {
    title: 'Hamlet - Act I',
    author: 'William Shakespeare',
    source: 'Librivox',
    uri:
      'https://ia800204.us.archive.org/11/items/
      hamlet_0911_librivox/hamlet_act1_shakespeare.
      mp3',
    imageSource:
      'http://www.archive.org/download/
      LibrivoxCdCoverArt8/hamlet_1104.jpg'
  },
  {
    title: 'Hamlet - Act II',
    author: 'William Shakespeare',
    source: 'Librivox',
    uri:
      'https://ia600204.us.archive.org/11/items/
      hamlet_0911_librivox/hamlet_act2_shakespeare.
      mp3',
    imageSource:
      'http://www.archive.org/download/
      LibrivoxCdCoverArt8/hamlet_1104.jpg'
  },
  {
    title: 'Hamlet - Act III',
    author: 'William Shakespeare',
    source: 'Librivox',
    uri:
      'http://www.archive.org/download/
      hamlet_0911_librivox/hamlet_act3_shakespeare.
      mp3',
    imageSource:
      'http://www.archive.org/download/
      LibrivoxCdCoverArt8/hamlet_1104.jpg'
  },
  {
    title: 'Hamlet - Act IV',
    author: 'William Shakespeare',
    source: 'Librivox',
    uri:
      'https://ia800204.us.archive.org/11/items/hamlet_0911_librivox/hamlet_act4_shakespeare.mp3',
    imageSource:
      'http://www.archive.org/download/LibrivoxCdCoverArt8/hamlet_1104.jpg'
  },
  {
    title: 'Hamlet - Act V',
    author: 'William Shakespeare',
    source: 'Librivox',
    uri:
      'https://ia600204.us.archive.org/11/items/hamlet_0911_librivox/hamlet_act5_shakespeare.mp3',
    imageSource:
      'http://www.archive.org/download/LibrivoxCdCoverArt8/hamlet_1104.jpg'
  }
];

export default function App() {
  return (
    <View style={styles.container}>
      <Text>Open up App.js to start working on your app!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

In the above snippet, `imageSource` is going to provide an album or an audiobook cover.

## Define an initial state in the App Component

In this section, you are going to convert the functional `App` component that comes with the default Expo app into a class component. This conversion will be useful to define an initial state that will hold an object with properties like:

- `isPlaying` to check whether the audio player is playing the audio file or not. This is going to be a boolean value.
- `playbackInstance` to hold the instance of the current track being played.
- `volume` the current volume of the audio for this media.
- `currentIndex` to gather the index of which track is currently being played. This helps in navigating and playing the next and the previous track from the `audioBookPlaylist` array.
- `isBuffering` holds a boolean value to check whether the current media is being buffered.

The initial state of the `App` component is going to look like the below snippet. Open `App.js` to add the state.

```js
export default class App extends React.Component {
  state = {
    isPlaying: false,
    playbackInstance: null,
    currentIndex: 0,
    volume: 1.0,
    isBuffering: false
  };
  render() {
    return (
      <View style={styles.container}>
        <Text>Open up App.js to start working on your app!</Text>
      </View>
    );
  }
}
```

## Building the UI: Audio Player Controls

In this section, let us build the UI components of how the basic audio player is going to look like. To start, please make sure that you are importing React Native elements like `TouchableOpacity` and `Image` from the core. Also, to add icons, let us import `Ionicons` from the library [`@expo/vector-icons`](https://github.com/expo/vector-icons).

This package comes with the Expo app, so you do not have to undergo the process of installing it as a separate module. This demo is going to use `Ionicons` from this package but feel free to use [another icon library](https://expo.github.io/vector-icons/).

```js
import { StyleSheet, TouchableOpacity, View, Image } from 'react-native'
import { Ionicons } from '@expo/vector-ico
```

The next step is to modify the render function inside `App.js`. Inside the container view, you are going to add an image that will display the cover of the audio book from the resource. Beneath this cover image, there will be three buttons that will let you control the audio files within the app.

```js
<View style={styles.container}>
  <Image
    style={styles.albumCover}
    source={{
      uri: 'http://www.archive.org/download/LibrivoxCdCoverArt8/hamlet_1104.jpg'
    }}
  />
  <View style={styles.controls}>
    <TouchableOpacity style={styles.control} onPress={() => alert('')}>
      <Ionicons name="ios-skip-backward" size={48} color="#444" />
    </TouchableOpacity>
    <TouchableOpacity style={styles.control} onPress={() => alert('')}>
      {this.state.isPlaying ? (
        <Ionicons name="ios-pause" size={48} color="#444" />
      ) : (
        <Ionicons name="ios-play-circle" size={48} color="#444" />
      )}
    </TouchableOpacity>
    <TouchableOpacity style={styles.control} onPress={() => alert('')}>
      <Ionicons name="ios-skip-forward" size={48} color="#444" />
    </TouchableOpacity>
  </View>
</View>
```

The conditional rendering implied on the second button states that whenever the boolean value of `isPlaying` is changed to true, the UI will display a pause button instead of a play button. Each button is accumulating an icon.

All of these buttons are going to be inside another view with a specific styling. You will notice the same thing in the above snippet. Outside the class component, using a `StyleSheet` object, let us add the styling.

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  },
  albumCover: {
    width: 250,
    height: 250
  },
  controls: {
    flexDirection: 'row'
  },
  control: {
    margin: 20
  }
});
```

To provide styles to your React Native components, there are no classes or IDs in React Native like in web development. To create a new style object, you use the `StyleSheet.create()` method. When creating a new style object every time the component renders, `StyleSheet` creates style objects with IDs that are further used to reference instead of rendering the whole component again and again.

Execute the command `expo start` from a terminal window, if you haven't already, and you will get the following result.

![](https://i.imgur.com/V15bamY.png)

## Exploring the Audio API

To play a sound in an Expo application, youâ€™re required to use and import the API for the Audio class from `expo-av`. So at the top of the `App.js` file and after other imports, you can add the following line.

```js
import { Audio } from 'expo-av';
```

To customize the audio experience inside an iOS or an Android app, Expo provides an asynchronous method called `setAudioModeAsync()`. This method takes an options object as its only parameter. This object contains a list of key-value pairs that are required to enable and use the audio component.

Inside the `App` component, you are going to add a lifecycle method `componentDidMount()`. This method should be defined after the initial state. It will help you configure the `Audio` component from the `expo-av` module.

```js
async componentDidMount() {
    try {
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: false,
        interruptionModeIOS: Audio.INTERRUPTION_MODE_IOS_DO_NOT_MIX,
        playsInSilentModeIOS: true,
        interruptionModeAndroid: Audio.INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,
        shouldDuckAndroid: true,
        staysActiveInBackground: true,
        playThroughEarpieceAndroid: true
      })

      this.loadAudio()
    } catch (e) {
      console.log(e)
    }
  }
```

Let us take all the options that are being passed in the `setAudioModeAsync` method. These options will define how the audio player is going to behave.

The `allowsRecordingIOS` is a boolean which, when enabled, will allow recording in iOS devices. The `playsInSilentModeIOS` indicates whether the audiobook app should play while the device is in silent mode.

The `interruptionModeIOS` & `interruptionModeAndroid` is how the audio of the app will behave with the audio of other apps. For example, what if you receive a call while listening to the audio player? How will the audio from the audiobook app behave? The value of these two options sets that. Currently, the option for the iOS device is set to be interrupted by the audio of other apps, hence `INTERRUPTION_MODE_IOS_DO_NOT_MIX`.

However, in the case of Android, the value `INTERRUPTION_MODE_ANDROID_DUCK_OTHERS` indicates that the volume of the audio from other apps will be lowered while the audiobook app is running. This term, `Duck` is known as lowering the volume. To set this option for Android, you have to set the value of `shouldDuckAndroid` to true.

Lastly, the lifecycle method is going to trigger the `loadAudio` function, which you are going to see in action in the next section.

## Loading the Audio File

After the lifecycle method `componentDidMount()` inside the `App.js` file, you are going to enter another asynchronous function called `loadAudio()`. This function will handle the loading of the audio file for the app's player.

```js
async loadAudio() {
  const {currentIndex, isPlaying, volume} = this.state

  try {
    const playbackInstance = new Audio.Sound()
    const source = {
      uri: audioBookPlaylist[currentIndex].uri
    }

    const status = {
      shouldPlay: isPlaying,
      volume
    }

    playbackInstance.setOnPlaybackStatusUpdate(this.onPlaybackStatusUpdate)
    await playbackInstance.loadAsync(source, status, false)
    this.setState({playbackInstance})
    } catch (e) {
      console.log(e)
    }
}

onPlaybackStatusUpdate = status => {
  this.setState({
    isBuffering: status.isBuffering
  })
}
```

The `new Audio.Sound()` allows you to create an instance that will take the source of the audio file (_which can be either from a local asset file or a remote API URI like in the current scenario_). From the state property `currentIndex` the Audio instance created will find the index value in the array of `audioBookPlaylist` to read the source URI and play the audio file.

On the instance of Audio, a method called `setOnPlaybackStatusUpdate` is used. This method has a handler function being passed, which is known as `onPlaybackStatusUpdate`. This handler function is responsible for updating the UI whether the media is being currently buffered or being played. To track the state of buffering, `isBuffering` is used from the initial state property. Whenever the state of the Audio instance changes, this gets an update.

Lastly, the `loadAsync` function is called on the Audio instance, which takes in three parameters. This first parameter is the source of the audio file. The second parameter indicates the status of the object. This `status` object further uses the properties of `shouldPlay` and `volume`. The value of the property `shouldPlay` is indicated by `isPlaying` from the initial state object. The last boolean value passed in `loadAsync` indicates whether the audio player app should download the audio file before playing. In the current scenario, there is no requirement for that. Thus, it has been set to `false`.

## Control Handlers

After the previous section, let us add three new methods which are going to control the state of the audio instance being played or paused. Also, changing to the next track or the previous track is going to be represented by different handler functions. Further, these handler functions are going to be used on `onPress` props of each button created in the UI section.

```js
handlePlayPause = async () => {
  const { isPlaying, playbackInstance } = this.state;
  isPlaying
    ? await playbackInstance.pauseAsync()
    : await playbackInstance.playAsync();

  this.setState({
    isPlaying: !isPlaying
  });
};

handlePreviousTrack = async () => {
  let { playbackInstance, currentIndex } = this.state;
  if (playbackInstance) {
    await playbackInstance.unloadAsync();
    currentIndex < audioBookPlaylist.length - 1
      ? (currentIndex -= 1)
      : (currentIndex = 0);
    this.setState({
      currentIndex
    });
    this.loadAudio();
  }
};

handleNextTrack = async () => {
  let { playbackInstance, currentIndex } = this.state;
  if (playbackInstance) {
    await playbackInstance.unloadAsync();
    currentIndex < audioBookPlaylist.length - 1
      ? (currentIndex += 1)
      : (currentIndex = 0);
    this.setState({
      currentIndex
    });
    this.loadAudio();
  }
};
```

The `handlePlayPause` checks the value of `isPlaying` to decide whether to play an audio file from the resource it is currently loaded or not. This decision is made using a conditional operator, and then the state is updated accordingly. The `playBackInstance` is holding the same value from the previous section when an audio file is loaded.

The next handler function `handlePreviousTrack` is used to skip back to the previous audio track in the playlist. It first clears the current track being played using `unloadAsync` from the Audio API, using the property value of `currentIndex` from the state. Similarly, the handler function `handleNextTrack` clears the current track and then using the `currentIndex` navigates to the next track.

## Completing the Player UI

The last piece of the puzzle in this audio player app is to display the information of the audio file which is being played. This information is already provided in the mock API array `audioBookPlaylist`. Create a new function called `renderFileInfo` before the `render` function with the following JSX to display. Also, update the `StyleSheet` object.

```js
renderFileInfo() {
    const { playbackInstance, currentIndex } = this.state
    return playbackInstance ? (
      <View style={styles.trackInfo}>
        <Text style={[styles.trackInfoText, styles.largeText]}>
          {audioBookPlaylist[currentIndex].title}
        </Text>
        <Text style={[styles.trackInfoText, styles.smallText]}>
          {audioBookPlaylist[currentIndex].author}
        </Text>
        <Text style={[styles.trackInfoText, styles.smallText]}>
          {audioBookPlaylist[currentIndex].source}
        </Text>
      </View>
    ) : null
  }

// update the Stylesheet object
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  },
  albumCover: {
    width: 250,
    height: 250
  },
  trackInfo: {
    padding: 40,
    backgroundColor: '#fff'
  },
  trackInfoText: {
    textAlign: 'center',
    flexWrap: 'wrap',
    color: '#550088'
  },
  largeText: {
    fontSize: 22
  },
  smallText: {
    fontSize: 16
  },
  control: {
    margin: 20
  },
  controls: {
    flexDirection: 'row'
  }
})

```

Next, use this function inside the `render` method of the `App` component below the view that holds all the control buttons. Also, update the control buttons to use appropriate handler functions from the previous section. Here is the complete code of the `render` function.

```js
render() {
    return (
      <View style={styles.container}>
        <Image
          style={styles.albumCover}
          source={{ uri: 'http://www.archive.org/download/LibrivoxCdCoverArt8/hamlet_1104.jpg' }}
        />
        <View style={styles.controls}>
          <TouchableOpacity style={styles.control} onPress={this.handlePreviousTrack}>
            <Ionicons name='ios-skip-backward' size={48} color='#444' />
          </TouchableOpacity>
          <TouchableOpacity style={styles.control} onPress={this.handlePlayPause}>
            {this.state.isPlaying ? (
              <Ionicons name='ios-pause' size={48} color='#444' />
            ) : (
              <Ionicons name='ios-play-circle' size={48} color='#444' />
            )}
          </TouchableOpacity>
          <TouchableOpacity style={styles.control} onPress={this.handleNextTrack}>
            <Ionicons name='ios-skip-forward' size={48} color='#444' />
          </TouchableOpacity>
        </View>
        {this.renderFileInfo()}
      </View>
    )
  }
```

Now, run the application, and you will get the following result.

![](https://i.imgur.com/sF49I90.gif)

## Conclusion

You have reached the end of this tutorial. We hope you enjoyed it and learned how to integrate the `expo-av` library to use an Audio class to create functionality in your cross-platform applications and build an audio player. An important thing to retain from this demo application is how to use available methods like `loadAsync()`, and `unloadAsync()`.

The resources used in order to create this tutorial can be found below:

- [Expo Audio API](https://docs.expo.io/versions/latest/sdk/audio/) documentation
- [expo-av](https://docs.expo.io/versions/latest/sdk/av/) documentation
- [Librivox audio files in public domain](https://librivox.org/hamlet-by-william-shakespeare/), a big thank you!

[Originally published at Jscrambler](https://jscrambler.com/blog/how-to-build-an-audio-player-in-react-native)

---

## Build a REST API with Node.js and HarperDB
Slug: build-rest-api-with-nodejs-harperdb

![cover_image](https://i.imgur.com/9hGD05n.png)

If you are building an application using Node.js, it can get a little overwhelming since there are a variety of databases to choose from and different ways to build APIs. One way to reduce development time and focus on the problem you are trying to solve is to use Database as a service to store the data. The advantage of this approach is to use a cloud database system without purchasing hardware which can be cost and time effective.

One such database service is [HarperDB Cloud](https://harperdb.io/developers/get-started/?utm_source=amanmittal). To build REST APIs rapidly this service allows us to perform all database operations using a single endpoint. It supports a variety of programming languages such as JavaScript, Java, Python, and so on. Some of the features of HarperDB are the following:

- single endpoint API
- allow JSON, CSVs file insertions
- support SQL queries for full CRUD operations
- Supports Math.js and GeoJSON
- limited database configuration required

In this post, let's build a simple REST API using Node.js and HarperDB Cloud to store some data. We are also going to use [Express](https://expressjs.com/) as the framework to build the Node.js server. It is a minimal and quite unopinionated framework.

## Prerequisites

Before you begin this tutorial, youâ€™re going to need the following:

- [Node.js](https://nodejs.org/) version above `12.x.x` installed on your local machine
- Access to a package manager such as npm or yarn
- Basic JavaScript and ES6 knowledge
- Access to a REST API client such as [Postman](https://www.postman.com/) or [Insomnia](https://insomnia.rest/)
- Access to a [HarperDB Cloud](https://harperdb.io/developers/get-started/?utm_source=amanmittal) instance (_free tier_)

To continue with the rest of the tutorial, please make sure you have an account with HarperDB Cloud and are logged in.

## Getting started

Start by creating the project directory on a local development environment. Give this directory a name and navigate into it. Then, initialize this project to manage npm dependencies by creating a `package.json` file.

```bash
mkdir harperdb-cloud-demo

# navigate inside the project directory
cd harperdb-cloud-demo

# create a package.json file
npm init --yes
```

The `--yes` flag uses the default settings when initializing a `package.json` from npm config you might have set up.

After the initializing step, let us add an express package. From the terminal window, run the command:

```bash
yarn add express@4.17.1 body-parser@1.19.0
```

Next, create a new file called `index.js` at the root of the project with the following code to trigger a minimal server:

```js
const express = require('express');

const app = express();
const PORT = 8000;

app.get('/', (req, res) => res.json('Express Server'));

app.listen(PORT, () => {
  console.log(`âš¡ï¸[server]: Server is running at https://localhost:${PORT}`);
});
```

In the above code snippet, the `app` is an object provided by Express API for the developer to communicate with the application and bootstrap a server.

Go back to the terminal and trigger the common `node index.js` to start the server. This `node` command is the simplest way to trigger a development server when building APIs with Node.js. Now, open up your favorite REST client to test APIs. For the demonstration purpose, I am going to use [Insomnia](https://insomnia.rest/).

You can test API endpoint by invoking a call to `http://localhost:8000` and it is going to return the result as shown below.

![hdb1](https://i.imgur.com/WKqKyDW.png)

## Watching file changes with nodemon

An essential development-related utility library that saves time when working on Node.js projects is [nodemon](https://www.npmjs.com/package/nodemon). It's a tool that helps the development of Node.js based applications by automatically restarting the Node application when file changes in the directory are detected.

To start using it in the current Express server, install it by using `yarn add -D nodemon` where `-D` flag is used to indicate that the dependency to install is a `devDependency`. After installing this dev dependency, open `package.json` file and add a start script as shown below.

```json
"scripts": {
    "start": "nodemon index.js",
},
```

Now, you can use either `npm run start` or `yarn run start` command to trigger the server. That's it to set up a basic Node.js server using the Express framework.

## Setting up an instance of HarperDB Cloud

In the introductory section of this post, you get the idea of what HarperDB Cloud is and features it supports. In this section, let us create the first database instance to store the data for the REST API using this cloud database service.

Assuming by now you have access main dashboard screen as shown below. To create a new instance, click on the plus button.

![hdb2](https://i.imgur.com/2RXthtd.png)

Then select the HarperDB Cloud instance option.

![hdb3](https://i.imgur.com/TouMF9P.png)

Fill in the details regarding the instance. Make sure to create a strong password and give a better username under Instance Credentials (I am keeping them simple for brevity).

![hdb4](https://i.imgur.com/598zmb4.png)

If you are on the free tier, leave everything in the screen below to default selections and click the button `Confirm Instance Details`.

![hdb5](https://i.imgur.com/xqXQNSL.png)

After entering the details, it is going to ask you to re-confirm all the instance details you have entered and if everything is okay, press the button `Add Instance`.

![hdb6](https://i.imgur.com/UvhsKoq.png)

Make sure to remember the username and the password you have entered here. They will be required to authenticate the Node.js server with the HarperDB Client. Once the instance of the cloud database is created, it is going to appear as shown below.

![hdb7](https://i.imgur.com/Yzyj4Ct.png)

You can click on the instance card from the UI and will be welcomed by the first screen to add a schema.

![hdb8](https://i.imgur.com/UCfOUQT.png)

A schema in HarperDB is necessary. It is equivalent to a collection of tables. Without an existing schema, you cannot create a new table and without a table, you cannot add or update data from HarperDB instance. To proceed, the schema and the table has to be created. Let's do it with the UI interface.

On the left-hand side, under the header where it says `schemas`, write in the name of your first schema.

![hdb9](https://i.imgur.com/ANIPBcC.png)

Once a schema is created, the option to add one or more tables appears. Let's create the first table called `books` as shown below. Besides the name of the table, HarperDB also asks to enter or assign the field for a `hash_attribute`. This attribute is equivalent to the unique identifier for each record that exists in the table `books`. Traditionally, most data tables have `id` as the unique identifier so it is passed as the value.

![hdb10](https://i.imgur.com/ohBkB9H.png)

The schema as well as the table are now successfully created.

![hdb11](https://i.imgur.com/5S1al13.png)

Let's save all the credentials required for the Node.js server to connect to the database. Create a `.env` file at the root of the project with for keys as shown below.

```bash
INSTANCE_URL=https://cloud-1-buildapps.harperdbcloud.com
INSTANCE_USERNAME=admin
INSTANCE_PASSWORD=password
INSTANCE_SCHEMA=dev
```

You are going to add your own HarperDB instance values here. Do not use the same values for each key as shown above, since it won't work. This just to demonstrate that these values are not wrapped inside quotes.

## Connecting HarperDB Cloud with a Nodejs server

To connect the HarperDB Cloud instance created in the previous section, let's install a dependency called [Harperive](https://github.com/chandan-24/Harperive#readme) that is going to let us interact with the database by performing CRUD (_Create, Read, Update, Delete_) operations. Go back to the terminal window and run the command:

```bash
yarn add harperive@1.0.1 dotenv@8.2.0
```

Once the dependency is installed, create a new directory called config and inside it, create a new file called `dbconfig.js`.

To connect to the database instance, you require three things:

- Database instance URL
- Database instance username
- Database instance password

At the end of the previous section, all these values are saved inside a `.env` file as environment variables. Using the `dotenv` package, these environment variables are now accessible throughout the Node.js server app. Inside the `dbconfig.js` file, import `dotenv` package as the first line and then import `harperive`. Create a `DB_CONFIG` object that is going to be passed as the argument to `harperive.client`. The `schema` field in the `DB_CONFIG` object is optional. Since this demo app has only one schema, thus, to avoid mentioning the schema field again and again when sending a query to the database, its name can be passed here.

Add the following code snippet to the `dbconfig.js` file.

```js
require('dotenv').config();
const harperive = require('harperive');

const DB_CONFIG = {
  harperHost: process.env.INSTANCE_URL,
  username: process.env.INSTANCE_USERNAME,
  password: process.env.INSTANCE_PASSWORD,
  schema: process.env.INSTANCE_SCHEMA // optional
};

const Client = harperive.Client;
const db = new Client(DB_CONFIG);

module.exports = db;
```

Exporting the `db` instance of the actual HarperDB client is going to allow us to query the database.

## Setting up body-parser

To set up routes or endpoints of the server application, you need to include `body-parser` in the `index.js`.

BodyParser parses incoming HTTP requests as middleware under `req.body` before routes or API have access to them and perform any further actions on them. A very useful and essential step when using forms in a web application.

```js
const express = require('express');
const bodyParser = require('body-parser');

const app = express();
const PORT = 8000;

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

// routes to be defined here

app.listen(PORT, () => {
  console.log(`âš¡ï¸[server]: Server is running at https://localhost:${PORT}`);
});
```

The `urlencoded` method in the above snippet allows the body-parser middleware to extract data from form fields. In the REST client such as Postman or Insomnia, it is possible to send the data as form fields. The `json` method allows the JSON data to be extracted.

## Query to add a new record

Since the database doesn't have any records, let's start by writing the first query to insert new data in the database. Create a new directory called `api/` and inside it create a new file called `index.js`. Open index.js file and import the `db` from `config/dbconfig.js` file.

```js
const db = require('../config/dbconfig');
```

One of the main advantages of HarperDB is in querying the data from a database instance. It allows us to query the data either in the form of SQL queries or NoSQL queries. The advantage here is that the power of complex SQL queries can easily be used here to perform an operation. I am going to define all the queries in NoSQL form, however, do not forget to check official docs for more information on performing SQL queries [here](https://docs.harperdb.io/?version=latest#0b5f3698-60fc-4783-b736-b510d6063996).

The first query is going to be called `addBook`. This query is going to insert the data incoming from an HTTP request.

```js
exports.addBook = (request, response) => {
  db.insert(
    {
      table: 'books',
      records: [
        {
          title: request.body.title,
          author: request.body.author
        }
      ]
    },
    (err, res) => {
      if (err) response.status(500).json(err);

      response.status(res.statusCode).json(res.data);
    }
  );
};
```

Each of the query functions as in the above code snippet is going to have at least two parameters: `request` and `response`.

- `request`: useful when creating or updating a new task and read data from the body (this where BodyParser works like a charm).
- `response`: useful to fulfill that incoming request with a response from the server. Generally, it contains the correct status code of the HTTP status code. This HTTP status code determines whether the incoming request was fulfilled or if there is an error. This the part of the REST paradigm and is considered a best practice.

When inserting data using a NoSQL query, it is mandatory to specify the name of the table in the database. In the current case its `books`. Since you have already specified the Schema when creating a connection using the HarperDB client, there is no need to explicitly define it here. `records` in HarperDB are similar to rows of data with having each field as a column.

You may have noticed in the above query that I am not explicitly adding an `id` attribute to uniquely identify each data record. HarperDB automatically creates a unique `id` for each data record.

The data being inserted here has two fields. The `title` and the `author` for each book. They represent the name of the columns or attributes in each data record. The value of each of these fields is going to be the incoming value from an HTTP request, parsed by the `body-parser` middleware function.

## Running the first query to insert data

To insert the first data record in the database lets create a route. Open `index.js` file in the root directory and import the `api` as `routesController`. A controller is a naming convention in an Express framework app. It is the business logic that binds the endpoints/routes that are going to define below to what action or operation they will perform on an incoming request on that particular route.

```js
// after other import statements
const routesController = require('./api/index');

//after defining middleware functions

app.route('/books').post(routesController.addBook);
```

Go back to the REST client and make sure the Node.js server is running from the terminal window.

Add the endpoint which is `http://localhost:8000/books`, select the type of the request which is `POST`. Select option `Form URL encoded` and the two key-value pairs as shown below:

![hdb12](https://i.imgur.com/BceIJrT.png)

Press the `Send` button it an HTTP request to insert the data to the HarperDB is made. If it's successful, a success message shown below is returned.

![hdb13](https://i.imgur.com/BbTRyru.png)

Go back to the HarperDB studio and you are going to see the same data record being shown.

![hdb14](https://i.imgur.com/Rz6ZRPS.png)

Do notice the two timestamp fields. They are auto inserted by the HarperDB and are auto-maintained.

- `__createdtime__`: to record the timestamp when data is inserted.
- `__updatedtime__`: to record the timestamp when any data field is updated for the last time.

Try to add more values to the database.

## Query to search by value

HarperDB allows to search database records in a table by using a column field name which is also known as an `attribute`. Let's add another query to get a data record when an HTTP request is sent just by searching the name of the author. Open `api/index.js` file and the following:

```js
exports.getByAuthor = (request, response) => {
  db.searchByValue(
    {
      table: 'books',
      searchAttribute: 'author',
      searchValue: request.body.author,
      attributes: ['*']
    },
    (err, res) => {
      if (err) response.status(500).json(err);

      console.log(res);

      response.status(res.statusCode).json(res.data);
    }
  );
};
```

The data returned from the database is going to be in JSON format. Go back to the main `index.js` file and add another route.

```js
app.route('/author').post(routesController.getByAuthor);
```

Open the REST Client and make a request as shown below. The response of this HTTP request is going to be every data record that contains the value of the attribute `author`.

![hdb15](https://i.imgur.com/vd1PtH7.png)

## Query to search by hash

Another important way to search for data in a table is by the unique identifier. HarperDB has a special method to do the same. This method is called `searchByHash` and only allows us to search the database table using the identifier specified as has an attribute. In the `api/index.js` file, add another query called `getById`.

```js
exports.getById = (request, response) => {
  db.searchByHash(
    {
      table: 'books',
      hashValues: [request.body.id],
      attributes: ['title']
    },
    (err, res) => {
      if (err) response.status(500).json(err);

      response.status(res.statusCode).json(res.data);
    }
  );
};
```

When this query successfully runs, the result from the database is only going to show the `title` attribute of the data record. This is done by passing the name of an attribute as the value of the `attributes` property in the above snippet.

Add the endpoint in the main `index.js` file.

```js
app.route('/search').post(routesController.getById);
```

Go to the REST client and run the query.

![hdb16](https://i.imgur.com/jOT7zuw.png)

## Query to delete the data record

To delete a record from the table in HarperDB is simple. All you have to do is pass the `id` or the unique identifier for the record stored in the table. The unique identifier, as you know, is stored as a hash value.

Add the following query to the `api/index.js` file.

```js
exports.deleteBook = (request, response) => {
  db.delete(
    {
      table: 'books',
      hashValues: [request.body.id]
    },
    (err, res) => {
      if (err) response.status(500).json(err);

      response.status(res.statusCode).json(res);
    }
  );
};
```

Next, go to the main `index.js` file and add the endpoint.

```js
app.route('/delete').post(routesController.deleteBook);
```

Lastly, go back to the REST client, pass on the id of the data record to delete. On successful deletion, it gives a response back in the form of a `message` that is directly sent from the HarperDB instance. This is very helpful since this message response can be directly used with any REST client or sent to a frontend framework.

![hdb17](https://i.imgur.com/qYEmPkv.png)

## Conclusion

_Congratulations!_ You have reached the end of the tutorial.

I hope this post does convey you to try the capabilities of HarperDB. I personally like how it support both SQL and NoSQL queries as well as some advanced features like adding timestamps automatically and hashing unique ids in a consistent way across all data tables and schemas.

**Resources & Further Reading:**

- [Are hash attributes case sensitive in HarperDB?](https://harperdbhelp.zendesk.com/hc/en-us/articles/115003081994-Are-Hash-Attributes-Case-Sensitive-)
- [HarperDB SQL Guide](https://harperdbhelp.zendesk.com/hc/en-us/articles/115002146754-HarperDB-SQL-Guide)
- [Harperive](https://github.com/chandan-24/Harperive)
- If you are looking to learn more about creating [REST APIs with Node.js and MySQL, checkout post the here](https://geshan.com.np/blog/2020/11/nodejs-mysql-tutorial/).
- [HarperDB documentation](https://harperdb.io/developers/documentation/overview/?utm_source=amanmittal)
- [HarperDB Developer examples](https://harperdb.io/developers/developer-examples/?utm_source=amanmittal) includes tutorials on React, Websocket, Python, etc.

---

## Build and validate forms in React Native using Formik and Yup
Slug: build-validate-forms-with-react-native-formik-yup

![cover](https://i.imgur.com/JK4oQuJ.png)

> [Originally published at Heartbeat](https://heartbeat.fritz.ai/build-and-validate-forms-in-react-native-using-formik-and-yup-6489e2dff6a2)

Formik and yup are great development tools to build awesome looking UI forms as per your React Native application needs. You will get the full context of this statement by the end of this tutorial when I walk you through in this post, to build two forms for login and signup screens, and showcase how easy it is to validate them using the combination of libraries like Formik and Yup.

> This tutorial is going to use some already setup source code from [**this Github repo release**](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.1.0).

Make sure you download the source code in order to follow this post closely and for a better understanding of libraries like Formik and yup. The source code file you are downloading contains the use of navigation patterns like Stack and Switch to fulfill the requirement of mimicking authentication flow in a React Native app. It also contains minimal code for three screens:

- Login
- Signup
- Home

You are going to continue to build on them. For complete detail on how I set up this authentication flow, please follow the previous post [How Authentication Flow works in React Native apps using React Navigation 4.x](https://heartbeat.fritz.ai/how-authentication-flow-works-in-react-native-apps-using-react-navigation-4-x-a30bb4d9e5d6).

## Table of Contents

- Requirements
- Installing the libraries
- Creating reusable components
- Create a login form
- Add Formik to the login form
- Handle form submission
- Validate form with yup
- Refactor error message
- Disable Button when form is not valid
- Show errors only if touch for specified field
- Show a loading indicator on Login button while submitting
- A challenge for you ðŸ’ª
- Conclusion

## Requirements

If you are going to code along, make sure you have already installed the following:

- Nodejs (>=`10.x.x`) with npm/yarn installed.
- expo-cli (>=`3.x.x`), previously known as create-react-native-app.
- Mac users could use an iOS simulator.
- Windows/Linux users must be running an Android emulator.

To know more about how to setup and run the simulator or the emulator on your local development environment visit React Native's official documentation [here](https://facebook.github.io/react-native/docs/getting-started).

## Installing the libraries

Right now, the `package.json` file from the previous post looks like the following. It contains a basic Expo blank template and dependencies for `react-navigation` library.

```json
"dependencies": {
    "expo": "^34.0.1",
    "react": "16.8.3",
    "react-dom": "^16.8.6",
    "react-native": "https://github.com/expo/react-native/archive/sdk-34.0.0.tar.gz",
    "react-native-gesture-handler": "~1.3.0",
    "react-native-reanimated": "~1.1.0",
    "react-native-screens": "1.0.0-alpha.22",
    "react-native-web": "^0.11.4",
    "react-navigation": "4.0.0",
    "react-navigation-stack": "1.5.1"
  },
```

Install the libraries that are going to be used to create login and signup forms. Open up a terminal window and execute the following command.

```shell
yarn add formik yup react-native-elements
```

The UI library `react-native-elements` is a "Cross-Platform React Native UI Toolkit" that makes easy to build various interface components in React Native apps with additional functionalities. It will speed up the development process for this demo.

## Creating reusable components

Inside `components/` directory create two new files called: `FormButton.js` and `FormInput.js`. Both of these components are going to be presentational and reusable in screen components. Open `FormButton.js` file, import the `Button` component `react-native-elements` library.

It is a touchable element that allows the user to interact with the device's screen and perform the next action. This custom component will receive props for styling and its style. The component library `react-native-elements` has different ways to [style a button](https://react-native-training.github.io/react-native-elements/docs/button.html#buttonstyle).

```js
//FormButton.js
import React from 'react';
import { Button } from 'react-native-elements';

const FormButton = ({ title, buttonType, buttonColor, ...rest }) => (
  <Button
    {...rest}
    type={buttonType}
    title={title}
    buttonStyle={{ borderColor: buttonColor, borderRadius: 20 }}
    titleStyle={{ color: buttonColor }}
  />
);

export default FormButton;
```

Next, open `FormInput.js` file. Again, it is going to be a custom component for a text input field. Import the [`Input`](https://react-native-training.github.io/react-native-elements/docs/input.html#docsNav) element from `react-native-elements`. It allows the user to enter the text in a form UI. It receives props as well and since using Expo, `vector-icons` can be imported without installing a third party dependency manually.

Lastly, notice how the remaining props are passed through an object using rest operator. This is also known as [rest parameter syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters). Make sure the order of the props remains same as below. That is, the `...rest` comes before other props in the `FormInput` component, as it won't be able to override those other properties.

```js
import React from 'react';
import { Input } from 'react-native-elements';
import { StyleSheet, View } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const FormInput = ({
  iconName,
  iconColor,
  returnKeyType,
  keyboardType,
  name,
  placeholder,
  value,
  ...rest
}) => (
  <View style={styles.inputContainer}>
    <Input
      {...rest}
      leftIcon={<Ionicons name={iconName} size={28} color={iconColor} />}
      leftIconContainerStyle={styles.iconStyle}
      placeholderTextColor="grey"
      name={name}
      value={value}
      placeholder={placeholder}
      style={styles.input}
    />
  </View>
);

const styles = StyleSheet.create({
  inputContainer: {
    margin: 15
  },
  iconStyle: {
    marginRight: 10
  }
});

export default FormInput;
```

## Create a login form

Now that the custom components are all set up, let us create a login screen component. Open `screens/Login.js` file and import all required statements. Then, without changing the state or any handler functions from the previous base repo you downloaded and are following for this tutorial, let us straight dive into the render method of the `Login` component.

```js
import React from 'react';
import { StyleSheet, SafeAreaView, View } from 'react-native';
import { Button } from 'react-native-elements';
import FormInput from '../components/FormInput';
import FormButton from '../components/FormButton';

export default class Login extends React.Component {
  state = {
    email: '',
    password: ''
  };

  handleEmailChange = email => {
    this.setState({ email });
  };

  handlePasswordChange = password => {
    this.setState({ password });
  };

  onLogin = async () => {
    const { email, password } = this.state;
    try {
      if (email.length > 0 && password.length > 0) {
        this.props.navigation.navigate('App');
      }
    } catch (error) {
      alert(error);
    }
  };

  goToSignup = () => this.props.navigation.navigate('Signup');
  render() {
    const { email, password } = this.state;

    return (
      <SafeAreaView style={styles.container}>
        <FormInput
          name="email"
          value={email}
          placeholder="Enter email"
          autoCapitalize="none"
          onChangeText={this.handleEmailChange}
          iconName="ios-mail"
          iconColor="#2C384A"
        />
        <FormInput
          name="password"
          value={password}
          placeholder="Enter password"
          secureTextEntry
          onChangeText={this.handlePasswordChange}
          iconName="ios-lock"
          iconColor="#2C384A"
        />
        <View style={styles.buttonContainer}>
          <FormButton
            buttonType="outline"
            onPress={this.handleOnLogin}
            title="LOGIN"
            buttonColor="#039BE5"
          />
        </View>
        <Button
          title="Don't have an account? Sign Up"
          onPress={this.goToSignup}
          titleStyle={{
            color: '#F57C00'
          }}
          type="clear"
        />
      </SafeAreaView>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  },
  buttonContainer: {
    margin: 25
  }
});
```

Notice, inside the `SafeAreaView` there are two `FormInput` fields and two buttons, out of which, one is the custom button previously created. The properties on input fields such as `secureTextEntry` and `autoCapitalize` are unique to each input field. Thus, this where the `rest` parameter syntax comes in handy. Also, notice how the type of both buttons will make a UI difference in the output below.

<img src='https://miro.medium.com/max/300/1*K-r4nW6kke_tsxLgp_BvKA.png' />

## Add Formik to the login form

Formik is a small library that helps forms to be organized in React and React Native with the following things:

- it keeps track of form's state
- handles form submission via reusable methods and handlers (_such as `handleChange`, `handleBlur`, and `handleSubmit`_)
- handles validation and error messages out of the box

At times it becomes hard to manage and fulfill the above points. Using Formik, you can understand what exactly is happening in forms and write fewer lines of code. Created by [Jared Palmer](https://x.com/jaredpalmer) it has a great [API](https://jaredpalmer.com/formik/docs/overview) to refer.

To get started, open `Login.js` file and import the library.

```js
//Login.js

// ... with other import statements
import { Formik } from 'formik';
```

Next, inside the `SafeAreaView` use `Formik` as the wrapper element. It comes with different props to handle forms such as `initialValues` and `onSubmit` handler method. The `initialValues` accepts an object containing form values. In the case of the current form, these values are going to be `email` and `password`. The `onSubmit` method accepts a function that has these `values` as the first argument to handle the form submission.

Lastly, the third method used in Formik is the render method itself. It follows the [Render Prop pattern](https://reactpatterns.com/#render-prop). Take a look at the Login component below.

```js
export default class Login extends React.Component {
  goToSignup = () => this.props.navigation.navigate('Signup');
  render() {
    return (
      <SafeAreaView style={styles.container}>
        <Formik
          initialValues={{ email: '', password: '' }}
          onSubmit={values => {}}
        >
          {formikProps => (
            <Fragment>
              <FormInput
                name="email"
                value={values.email}
                onChangeText={formikProps.handleChange('email')}
                placeholder="Enter email"
                autoCapitalize="none"
                iconName="ios-mail"
                iconColor="#2C384A"
              />
              <FormInput
                name="password"
                value={values.password}
                onChangeText={formikProps.handleChange('password')}
                placeholder="Enter password"
                secureTextEntry
                iconName="ios-lock"
                iconColor="#2C384A"
              />
              <View style={styles.buttonContainer}>
                <FormButton
                  buttonType="outline"
                  onPress={formikProps.handleSubmit}
                  title="LOGIN"
                  buttonColor="#039BE5"
                />
              </View>
            </Fragment>
          )}
        </Formik>
        <Button
          title="Don't have an account? Sign Up"
          onPress={this.goToSignup}
          titleStyle={{
            color: '#F57C00'
          }}
          type="clear"
        />
      </SafeAreaView>
    );
  }
}
```

The `value` prop in each of the above input fields is given the initial value from the `formikProps`. It is passed through each render function that provides access to the state of the form as `initialValues`. You have to define these values just as you would do in the state of a class component. Other than that, it also gives access to handle the change of each input field (when user types in the email or the password) and a method to submit the form: `handleSubmit`.

You can refactor the current component into the following:

```js
{
  ({ handleChange, values, handleSubmit }) => (
    <Fragment>
      <FormInput
        name="email"
        value={values.email}
        onChangeText={handleChange('email')}
        placeholder="Enter email"
        autoCapitalize="none"
        iconName="ios-mail"
        iconColor="#2C384A"
      />
      <FormInput
        name="password"
        value={values.password}
        onChangeText={handleChange('password')}
        placeholder="Enter password"
        secureTextEntry
        iconName="ios-lock"
        iconColor="#2C384A"
      />
      <View style={styles.buttonContainer}>
        <FormButton
          buttonType="outline"
          onPress={handleSubmit}
          title="LOGIN"
          buttonColor="#039BE5"
        />
      </View>
    </Fragment>
  );
}
```

On looking back to the simulator you will notice that Login form looks the same but now on clicking the login button, nothing happens. Let us make it work. The `onSubmit` prop handles the form submission. Right now, to see that the values of both input field are being recorded, let us add an `alert` method.

```js
onSubmit={values => { alert(JSON.stringify(values))}}
```

Go back to the login screen and fill both input fields and click the login button. You will get a dialog box stating the values of both `email` and `password`.

<img src='https://miro.medium.com/max/342/1*u5tfp9wdSzcC1C_yXVOpXA.gif' />

## Handle Form Submission

Now let us add the logic to enter the app whenever the user clicks the login button instead of showing the values they entered in a dialog box. First, add a method on the `onSubmit` prop on `Formik` element.

```js
onSubmit={values => {this.handleSubmit(values)}}
```

Next, define the `handleSubmit` method before the `render` function.

```js
handleSubmit = values => {
  if (values.email.length > 0 && values.password.length > 0) {
    this.props.navigation.navigate('App');
  }
};
```

The logic is still the same as it was when you started building this login form. The user can only log in to the app if the `email` and `password` fields are not empty. The only difference that the values for both fields were derived from the initial state of the component before.

<img src='https://miro.medium.com/max/342/1*V7tcVyD4usE5LHxmBjWYfQ.gif' />

The custom input component does not need the `value` prop to be passed on separately.

```js
//FormInput.js
const FormInput = ({
  iconName,
  iconColor,
  returnKeyType,
  keyboardType,
  name,
  placeholder,
  ...rest
}) => (
  <View style={styles.inputContainer}>
    <Input
      {...rest}
      leftIcon={<Ionicons name={iconName} size={28} color={iconColor} />}
      leftIconContainerStyle={styles.iconStyle}
      placeholderTextColor="grey"
      name={name}
      placeholder={placeholder}
      style={styles.input}
    />
  </View>
);
```

## Validating form with yup

The [`yup`](https://github.com/jquense/yup) library is useful to manage complex validation when using Formik in either React or React Native apps. Formik supports both synchronous and asynchronous form validation. It has support for schema based form level validation from yup.

Import everything from the `yup` library with other import statements.

```js
import * as yup from 'yup';
```

If you are familiar with Nodejs development, you will find `yup` library is quite similar to another validation library called `joi`. Next, let us define a new object before the `Login` class component called `validationSchema`.

Since `initialValues` is an object, you have to specify `yup.object()` and define a `shape` of the object. Note that, inside the `shape` when defining input fields, make sure their name corresponds the same as described in `initialValues`. Next, each field in this object is supported by a chain of validation methods provided by the [yup API](https://github.com/jquense/yup#api). The type of both `email` and `password` is going to be a string since the method `onChangeText` return values as strings.

```js
const validationSchema = Yup.object().shape({
  email: Yup.string()
    .label('Email')
    .email('Enter a valid email')
    .required('Please enter a registered email'),
  password: Yup.string()
    .label('Password')
    .required()
    .min(4, 'Password must have at least 4 characters ')
});
```

Using a library like Yup saves a lot of time, especially when you do not have to define custom validation methods to check for an input field. For example, in the above snippet, using [`.email()`](https://github.com/jquense/yup#stringemailmessage-string--function-schema) automatically matches against a regex instead defining regex to check the validity of an email input field.

Also, for every valid method, you can enter a custom return message that's shown in case of an error. Look at theÂ .required() again at the email in the above code snippet. It's stating that when an email isn't provided, this message passed in quotes will be shown as the error message. Similarly, for password, when the length of the input field is less than four characters, it will display an error message.
The last step to add the validationSchema to work, is to add a prop with the same name in the Formik element.

```js
<Formik
  initialValues={{ email: '', password: '' }}
  onSubmit={values => {
    this.handleSubmit(values)
  }}
  // new line
  validationSchema={validationSchema}>
  {*/ Rest of the code /*}
</Formik>
```

Next, `formikProps` also provide `errors` to access error messages.

```js
// pass errors below
{({ handleChange, values, handleSubmit, errors }) => (
```

After each input field, you will have to add a `Text` element to display the error message. Import it from `react-native` and then after each input field adds the following.

```js
<FormInput
  name='email'
  value={values.email}
  onChangeText={handleChange('email')}
  placeholder='Enter email'
  autoCapitalize='none'
  iconName='ios-mail'
  iconColor='#2C384A'
/>
<Text style={{ color: 'red' }}>{errors.email}</Text>
<FormInput
  name='password'
  value={values.password}
  onChangeText={handleChange('password')}
  placeholder='Enter password'
  secureTextEntry
  iconName='ios-lock'
  iconColor='#2C384A'
  />
<Text style={{ color: 'red' }}>{errors.password}</Text>
```

Try to click the login button without entering details in any input field.

<img src='https://miro.medium.com/max/342/1*expc7TVHGfERe5bAzqRQyg.gif' />

Notice, how both the custom error message for the `email` field and a default message for `password` is displayed. Now, try to enter an invalid string in the email and a password of fewer than four characters and then submit the login button.

<img src='https://miro.medium.com/max/342/1*ZwUTsbRc712QZ5EKAHfJ5A.gif' />

Notice that the error messages change and the correct error message is displayed.

## Refactor error message

In this section, let us create a reusable presentational component to display the error messages. Open `components/ErrorMessage.js` file and add the following.

```js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const ErrorMessage = ({ errorValue }) => (
  <View style={styles.container}>
    <Text style={styles.errorText}>{errorValue}</Text>
  </View>
);

const styles = StyleSheet.create({
  container: {
    marginLeft: 25
  },
  errorText: {
    color: 'red'
  }
});

export default ErrorMessage;
```

Next, go back to the `Login.js` file, import this component. Below each input field where there is a `Text` element, replace it with the newly created custom `ErrorMessage`.

```js
<FormInput
  name='email'
  value={values.email}
  onChangeText={handleChange('email')}
  placeholder='Enter email'
  autoCapitalize='none'
  iconName='ios-mail'
  iconColor='#2C384A'
/>
<ErrorMessage errorValue={errors.email} />
<FormInput
  name='password'
  value={values.password}
  onChangeText={handleChange('password')}
  placeholder='Enter password'
  secureTextEntry
  iconName='ios-lock'
  iconColor='#2C384A'
  />
<ErrorMessage errorValue={errors.password} />
```

The error messages are now properly aligned with the input fields.

<img src='https://miro.medium.com/max/300/1*KwAE5I4ur3B8qaktUhT40Q.png' />

## Disable Button when form is not valid

Formik provides a quicker way to disable the submit button until there is no error shown for any input field. This is done via the prop value of `isValid` which returns `true` when there are no errors. The `disabled` property is added to the `FormButton`, which is where `react-native-elements` shine.

```js
 {({ handleChange, values, handleSubmit, errors, isValid, isSubmitting }) => (
            <Fragment>
              {*/ Res of the code remains same /*}
              <View style={styles.buttonContainer}>
                <FormButton
                  buttonType='outline'
                  onPress={handleSubmit}
                  title='LOGIN'
                  buttonColor='#039BE5'
                  disabled={!isValid}
                />
              </View>
            </Fragment>
          )}
```

Notice that how the colour of the button is changed to grey and it is not clickable at all.

<img src='https://miro.medium.com/max/300/1*Qy20v8rNAxUXAfTiGuEF3Q.png' />

But entering values for input fields it comes back to life.

<img src='https://miro.medium.com/max/300/1*5dqPrzK-Kt1jEIZC1GE_UA.png' />

## Show errors only if touch for specific field

If you have noticed that the current state of the form shows errors for both fields even when the user is entering the first field and hasn't yet seen what is required in the second field.

<img src='https://miro.medium.com/max/342/1*C0h4mvUsoWFROF2g46g27A.gif' />

To fix this, let us use two `touched` and `handleBlur` from `formikProps`.

```js
{({
  handleChange,
  values,
  handleSubmit,
  errors,
  isValid,
  isSubmitting
  touched,
  handleBlur,
}) => ()
```

The`handleBlur` is passed as the value to the `onBlur` prop on the input field. This prop is used to track whether an input field has been touched by the user or not â€” the `touched` tracks what fields have been touched. Using the combination of both, you can get the following behavior.

<img src='https://miro.medium.com/max/342/1*RFD3xPeXNZrcRmBfgYG6bA.gif' />

Here is the code snippet on how to do this. On each input field, add the `onBlur` prop with the corresponding value passed to `handleBlur` method.

```js
// on email
onBlur={handleBlur('email')}

// on password
onBlur={handleBlur('password')}
```

Next, when displaying the error message, modify it is as follows for both fields.

```js
// for email
<ErrorMessage errorValue={touched.email && errors.email} />

// for password
<ErrorMessage errorValue={touched.password && errors.password} />
```

## Show a loading indicator on Login button while submitting

Next, when submitting the login credentials, you do not want the user to press the button twice. `formikProps` has a solution for this too. Using `isSubmitting` you can track that when the form is is in submitting phase. Usually, in real-time application, this submitting phase will depend on the asynchronous network call to the server. On the `disabled` prop, you can use an OR condition to solve this issue.

```js
disabled={!isValid || isSubmitting}
```

To mimic an API call, add a `setTimeout` function to the `handleSubmit` method.

```js
handleSubmit = values => {
  if (values.email.length > 0 && values.password.length > 0) {
    setTimeout(() => {
      this.props.navigation.navigate('App');
    }, 3000);
  }
};
```

Now observe how the button gets disabled when it is touched.

<img src='https://miro.medium.com/max/342/1*kIE7F1iAyhq7UGQGajeDnw.gif' />

You can add a loading indicator to the button, thanks to the prop with the same name available in `react-native-elements`.

```js
loading = { isSubmitting };
```

<img src='https://miro.medium.com/max/342/1*BTJ51fiAMYUwO91C3n3xWQ.gif' />

## A challenge for you ðŸ’ª

Using the knowledge obtained from this tutorial, get it to work and build a signup form that looks like below with for four input fields:

- Name of the user
- Email
- Password
- A confirm password

The challenge here is to make sure both fields: `password` and `confirmPassword` matches and an appropriate error message are shown is they do not match. To find the solution, lookout for the next post, where you will get the answer to this problem as well as some more functionalities such handling error when the input field is not of type string.

Here is a teaser:

<img src='https://miro.medium.com/max/342/1*rzA-V867nUz7llMUWP26Yw.gif' />

## Conclusion

_Congratulations ðŸŽ‰_

You just learned how to create, handle, and validate forms in React Native using Formik and Yup. I hope in your production React Native apps, some little tricks used in this tutorial such as in handling buttons and using loading indicators help. You will find the code for this tutorial along with the completed challenge at the [this Github repo release](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.2.0).

**Important resources used to write this tutorial**:

- [`react-native-elements`](https://react-native-training.github.io/react-native-elements/docs/button)
- [Official Formik docs](https://jaredpalmer.com/formik/docs/guides/react-native)
- [Yup API](https://github.com/jquense/yup#api)
- [Bamlab offers HOC components with `react-native-formik` such that you do not have write everything from scratch](https://github.com/bamlab/react-native-formik)

---

## Building an authenticated MERN Stack App Using Material UI
Slug: building-a-mern-stack-app-with-material-ui

![cover](https://i.imgur.com/YHJ7UNq.png)

> [Originally published at Crowdbotics](https://medium.com/crowdbotics/building-a-mern-stack-app-with-material-ui-33ff8ca4da01)

It can sometime be overwhelming to build a full-stack web application using a stack like MERN.

Setting up the the back end and connecting it with a client-side library like React to fetch and display data is just the beginning. One you have the data user will interact with, you need to focus on developing a functional User Interface (_UI_) for your web application. For some developers, UI can be the tricky part.

[MERN](https://medium.com/crowdbotics/deploy-a-mern-stack-app-on-heroku-b0c255744a70) is full-stack because it consists of MongDB, Express, [React](https://www.crowdbotics.com/build/react) and [Nodejs](https://crowdbotics.com/build/node-js). Each of these technologies can be replaced with something comparable but it is common practice to use them together.

React is the library you will use to build the front-end of the web application. Express is a Nodejs framework that helps you to build a server that communicates to and fro with a NoSQL database like MongoDB.

In this tutorial, I am going to show you how to build a small web application using this technology stack, step-by-step. Along with building a simple web app, you will learn how to use the Material UI library to make the application look good. You can then use what you learn here for to make your own applications look better and be more functional.

### Pre-requisites

Before we get started, install all the tools we are going to need to set up our application.

- Nodejs
- MongoDB
- yarn
- create-react-app

_The last in the above list are installed using npm._

### Set up the MERNÂ App

To get started, you need to follow the steps below by opening your terminal and typing these commands. To keep you from getting lost, I will leave a comment before each command using `#`.

```shell

# create an empty directory and traverse inside it
mkdir mern-material-demo

# initialize it with npm
npm init -y

# install server side dependencies (initially)
yarn add express mongoose cookie-parser express-jwt jsonwebtoken

# use babel for import statements in Node
yarn add -D babel-cli babel-preset-env babel-watch

# create a client using create-react-app from root
create-react-app client
```

After this step, make sure your root project looks like below with some extra files and folders.

<img src='https://cdn-images-1.medium.com/max/800/1*_JHQWIDI9FjHq-pr0k1x1Q.png' />

We are going to bootstrap the server using Babel. To setup and learn what Babel is, please read [here](https://hackernoon.com/how-to-use-import-statements-in-nodejs-94c85e23aeb7).

The next step is to define the configuration you will need to proceed with server creation. Inside `server`, create a new file `config/index.js` and define the following inside it.

```js
const config = {
  port: process.env.PORT || 4000,
  jwtSecret: process.env.JWT_SECRET || 'mkT23j#u!45',
  mongoURI: process.env.MONGODB_URI || 'mongodb://localhost/mern-auth'
};

export default config;
```

For MongoDB, I am going to use a local instance. If you want to use a cloud service (free tier), please [read the steps to set it up and consume in a Node server app here](https://blog.crowdbotics.com/how-to-deploy-a-mern-stack-app-on-heroku/).

Make sure add the `dev` script inside `package.json`.

```json
"scripts": {
	"dev": "babel-watch index.js"
}
```

### Connect Database and theÂ Server

Inside `config` directory, create a new file called `dbConnection.js`. Let us start by defining the MongoDB connection.

```js
import mongoose from 'mongoose';
import config from './index';

const URI = config.mongoURI;
mongoose.connect(URI);

// When successfully connected
mongoose.connection.on('connected', () => {
  console.log('Established Mongoose Default Connection');
});

// When connection throws an error
mongoose.connection.on('error', err => {
  console.log('Mongoose Default Connection Error : ' + err);
});
```

I am going to use [Mongoose](https://mongoosejs.com/) as ODM (_Object Document Mapper_). This helps write queries inside the Node server and create business logic behind it. It also provides a schema-based solution to create data models and define them in our Node app.

Although MongoDB is a schema-less database, Mongoose helps our application understand the data structure and organize it at the same time. The most basic benefit is to make a connection between the Express app when it bootstraps and the MongoDB instance on our local machine.

Letâ€™s create a small server in the `index.js` file of the root of our web app. Here it is in action.

```js
import express from 'express';
import cookieParser from 'cookie-parser';
import config from './server/config';

// DB connection
require('./server/config/dbConnection');

const app = express();

// middleware functions
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

// Error handling middleware
app.use((err, req, res, next) => {
  if (err.name === 'UnauthorizedError') {
    res.status(401).json({ error: err.name + ':' + err.message });
  }
});

app.listen(config.port, () => {
  console.log(`ðŸš€ at port ${config.port}`);
});
```

If you are getting a message like below (_ignore the mongoose warning_), this means our server is up and running and successfully connected to the local instance of the database.

### Building The UserÂ Model

To demonstrate, I am going to create a user data model with properties to save the user data when a new user registers with our application. We are going to save user credentials and validate it using Mongoose in this section. Create a new file inside `server/models/user.js`.

We will start by importing the necessary dependencies at the top of our file and then create a new Mongoose Schema, `userSchema` which is an object with properties. Typically, NoSQL databases are super flexible, in that they allow us to put whatever we want in them without enforcing any specific kind of structure. However, Mongoose adds a layer of structure on top of the typical MongoDB way of doing things. This helps us perform additional validation to ensure that our users are not submitting any random data to our database without us having to write tons of boilerplate code ourselves.

```js
import mongoose from 'mongoose';
import crypto from 'crypto';
const Schema = mongoose.Schema;

const userSchema = new Schema({
  name: {
    type: String,
    trim: true,
    required: 'User Name is required'
  },
  email: {
    type: String,
    trim: true,
    unique: 'Email already exists',
    match: [/.+\@.+\..+/, 'Please fill a valid email address'],
    required: 'Email is required'
  },
  hashedPassword: {
    type: String,
    required: 'Password is required'
  },
  salt: {
    type: String
  }
});

userSchema
  .virtual('password')
  .set(function (password) {
    this._password = password;
    this.salt = this.makeSalt();
    this.hashedPassword = this.encryptedPassword(password);
  })
  .get(function () {
    return this._password;
  });

userSchema.methods = {
  authenticate: function (plainText) {
    return this.encryptedPassword(plainText) === this.hashedPassword;
  },
  encryptedPassword: function (password) {
    if (!password) return '';
    try {
      return crypto
        .createHmac('sha1', this.salt)
        .update(password)
        .digest('hex');
    } catch (err) {
      return '';
    }
  },
  makeSalt: function () {
    return Math.round(new Date().valueOf() * Math.random()) + '';
  }
};

userSchema.path('hashedPassword').validate(function (v) {
  if (this.hashedPassword && this._password.length < 6) {
    this.invalidate('password', 'Password must be at least 6 characters long.');
  }
  if (this.isNew && !this._password) {
    this.invalidate('password', 'Password is required.');
  }
}, null);

export default mongoose.model('User', userSchema);
```

We now use the `userSchema` object to add a virtual`password` field. Note that whatever property is described inside the `userSchema` object is going to be saved in the MongoDB document. We are not saving the password directly. We are creating a virtual field first to generate an encrypted hash of the password and then save it in our database.

A virtual field is a document property that can be used to combine different fields or decompose a single value into multiple values for storage but never gets carried on inside the MongoDB database itself.

Using the Nodejs `crypto` module we are creating a hash that updates the virtual `password`. The â€˜saltâ€™ field is a randomly generated string for each password. This terminology comes from cryptography. We are also putting in the logic of validating the password field and checking whether it is 6 characters long. Lastly, we export the `User` model to be used with routes and controllers logic in our server.

### User Routes

Now, letâ€™s write the business logic behind the routes to create for the React end to interact with the server. Create a new file `server/controllers/user.js` and write the following code. Import the user model first that from the previous section.

```js
import User from '../models/user';
import errorHandler from '../helpers/dbErrorHandler';

export const registerUser = (req, res, next) => {
  const user = new User(req.body);
  user.save((err, result) => {
    if (err) {
      return res.status(400).json({
        error: errorHandler.getErrorMessage(err)
      });
    }
    res.status(200).json({
      message: 'New user registered successfully!'
    });
  });
};

export const findUserById = (req, res, next, id) => {
  User.findById(id).exec((err, user) => {
    if (err || !user) {
      return res.status(400).json({
        error: 'No user found with that credentials!'
      });
    }
    req.profile = user;
    next();
  });
};

export const findUserProfile = (req, res) => {
  // eliminate password related fields before sending the user object
  req.profile.hashedPassword = undefined;
  req.profile.salt = undefined;
  return res.json(req.profile);
};

export const deleteUser = (req, res, next) => {
  let user = req.profile;
  user.remove((err, deletedUser) => {
    if (err) {
      return res.status(400).json({
        error: errorHandler.getErrorMessage(err)
      });
    }
    deletedUser.hashedPassword = undefined;
    user.salt = undefined;
    res.json(user);
  });
};
```

I have also added a helper function inside a separate file at the location `server/helpers/dbErrorHandler.js` to gracefully handle any error that occurs in any of the routes like we are using in above and respond back with a meaningful message. You can download the file from [here](https://gist.github.com/amandeepmittal/56e30487a2782fa7f0209ab0f3cd518a).

In the file above, we are creating three controller functions. The first one, `registerUser`, creates a new user in the database from the JSON object received in a `POST` request from the client. The JSON object is received inside `req.body` that contains the user credentials we need to store in the database. Further, `user.save`, saves the new user in the database. Notice that we are not creating a unique field which is common in this type of scenarios to identify each new user saved in our database. This is because MongoDB database creates an `_id` field each time a new record is saved.

The next function we are exporting is `findUserById`. It queries the database to find the specific details related to the user whose `_id` is provided in parametric route (which I will define shortly). If a matching user is found with that `_id` in the database, then the user object is returned and appended inside the `req.profile`.

`findUserProfile` controller function retrieves the user detail from `req.profile` and removes any sensitive information such as password's hash and salt values before sending this user object to the client. The last function `deleteUser` removes the the user details from the database.

Now let use the controller logic and add it to corresponding routes inside `server/routes/user.js`.

```js
import express from 'express';
import {
  registerUser,
  findUserById,
  findUserProfile,
  deleteUser
} from '../controllers/user';

const router = express.Router();

router.route('/api/users').post(registerUser);

router.route('/api/users/:userId').get(findUserProfile).delete(deleteUser);

router.param('userId', findUserById);

export default router;
```

The controller functions are first imported and then used with their corresponding route.

### Auth Routes

To restrict access to user operationsâ€Šâ€”â€Šsuch as the logged in user can only access their profile and no one elseâ€™sâ€Šâ€”â€Šwe are going to implement a JWT authentication to protect the routes. The two routes required to sign in and sign out the user from our application are going to be inside a separate file `server/routes/auth.js`.

```js
import express from 'express';
import { signin, signout } from '../controllers/auth';

const router = express.Router();

router.route('/auth/signin').post(signin);

router.route('/auth/signout').get(signout);

export default router;
```

The first route uses an HTTP `POST` request to authenticate a user with email and password credentials. The second route is used when the user hits the `signout` button (which we will implement in our front-end). The logic behind how these two routes work has to be defined in another file. Create a new file `server/controllers/auth.js` with the following code.

```js
import User from '../models/user';
import jwt from 'jsonwebtoken';
import expressJwt from 'express-jwt';
import config from '../config';

export const signin = (req, res) => {
  User.findOne({ email: req.body.email }, (err, user) => {
    if (err || !user) {
      return res.status(401).json({
        error: 'User not found'
      });
    }
    if (!user.authenticate(req.body.password)) {
      return res.status(401).json({
        error: 'Wrong Email or Password!'
      });
    }

    const token = jwt.sign(
      {
        _id: user._id
      },
      config.jwtSecret
    );

    res.cookie('t', token, {
      expire: new Date() + 9999
    });

    return res.json({
      token,
      user: { _id: user._id, name: user.name, email: user.email }
    });
  });
};

export const signout = (req, res) => {
  res.clearCookie('t');
  return res.status(200).json({
    message: 'Sign out successful!'
  });
};

export const requireSignin = expressJwt({
  secret: config.jwtSecret,
  userProperty: 'auth'
});

export const hasAuthorization = (req, res) => {
  const authorized = req.profile && req.auth && req.profile._id == req.auth._id;
  if (!authorized) {
    return res.status(403).json({
      error: 'User is not authorized!'
    });
  }
};
```

I am using two JWT related packages from `npm` to enable authentication and protect our routes: `express-jwt` and `jsonwebtoken`. You already installed them when we bootstrapped this project. The first controller function `signin` we are exporting receives user's credentials in `req.body`. Email is used to retrieve the matching user from the database. Remember, we have added a `unique` field when defining the `userSchema`.

```js
// model/user.js
	email: {
		type: String,
		trim: true,
		unique: 'Email already exists',
		match: [/.+\@.+\..+/, 'Please fill a valid email address'],
		required: 'Email is required'
  },
```

Since we are also receiving userâ€™s password, we are going to verify it with the hash and the salt value that we stored in our database. The signed JWT is returned to the client to authenticate the user with their details if successful. We are using browserâ€™s cookies here to store the JWT token. You can use the browserâ€™s local storage for this purpose.

The `signout` function above clears the cookie containing the signed JWT token. The last two functions are important for our application. Both `requireSignin` and `hasAuthorization` are used to protect access to certain routes from an unauthorized user. They check and validate the user on client whether they are authenticated to give access.

`requireSignin` method here verifies a valid JWT in the `Authorization` header of the request. `hasAuthorization` allows a user to operate protected routes by checking that the user who is sending the request is identical to the authenticated user. In our application we are going to use this on one protected route. We are going to delete the user profile and their data from the database in that route.

Now let us use these methods to protect user routes. Open `server/routes/user.js`.

```js
import express from 'express';
import {
  registerUser,
  findUserById,
  findUserProfile,
  deleteUser
} from '../controllers/user';

// import them to protect routes
import { requireSignin, hasAuthorization } from '../controllers/auth';

const router = express.Router();

router.route('/api/users').post(registerUser);

router
  .route('/api/users/:userId')
  .get(requireSignin, findUserProfile)
  .delete(requireSignin, hasAuthorization, deleteUser);

router.param('userId', findUserById);

export default router;
```

### Finishing theÂ back-end

With the routing logic set up, we can now complete the server by adding our routes to `index.js` file.

```js
import express from 'express';
import cookieParser from 'cookie-parser';
import config from './server/config';
// ADD these
import userRoutes from './server/routes/user';
import authRoutes from './server/routes/auth';

// DB connection
require('./server/config/dbConnection');

const app = express();

// middleware functions
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

// ADD routes
app.use('/', userRoutes);
app.use('/', authRoutes);

app.use((err, req, res, next) => {
  if (err.name === 'UnauthorizedError') {
    res.status(401).json({ error: err.name + ':' + err.message });
  }
});

app.listen(config.port, () => {
  console.log(`ðŸš€ at port ${config.port}`);
});
```

To test these routes, open up a [REST](https://medium.com/crowdbotics/building-a-rest-api-with-koajs-417c276929e2) Client like [Postman](https://www.getpostman.com/) or [Insomnia](https://insomnia.rest/) and the URL `http://localhost:4000/api/users` with required fields in order to create a user.

<img src='https://cdn-images-1.medium.com/max/800/1*xPH-zPCYtLcp18FdUP8iHw.png' />

If there are no errors, you are going to receive the message `Successfully signed up!`. This means the user has been added to the database. If you try to make a new user with same credentials, it will throw an error this time.

<img src='https://cdn-images-1.medium.com/max/800/1*X3DWS3U5S-iBlOfYfmZ0cw.png' />

If you use a MongoDB Client to view the records of your local database like [Mongo Compass](https://www.mongodb.com/products/compass) or [Robomongo](https://robomongo.org/), you can easily see newly created userâ€™s details.

<img src='https://cdn-images-1.medium.com/max/800/1*z2Gd9TSd6sDBaIFWGorcTQ.png' />

Using the same user credentials, we will attempt a sign-in. It should give us a JWT back.

<img src='https://cdn-images-1.medium.com/max/800/1*6U2XmG6nC_9W1-JBRG284w.png' />

It works!

Except for the sensitive information that we eliminated from the route, we are receiving back the token and a user object.

Now letâ€™s find the user profile. Hit the URL `http://localhost:4000/api/users/{USER_ID}` where `USER_ID` is the same created by MongoDB database when adding the user record.

<img src='https://cdn-images-1.medium.com/max/800/1*eDWff4NSiZhwDQmvRSJmSQ.png' />

You have to add the `Bearer` before signed JWT returned from the previous request at the Header `Authorization`. This completes our API testing and now we can focus on building the front-end of our application.

### Adding Material UI inÂ React

There are a series of steps to follow to add the Material UI Library to our react app. Traverse in the `client` directory and follow the below steps. We are going to use Material Icons in SVG form, so letâ€™s add that package.

```shell
# Open terminal and install the package
yarn add @material-ui/core @material-ui/icons
```

Material-UI uses `Roboto` font and we have to add it through Google Font CDN to our client side. Open `public/index.html` add the following. Letâ€™s also change the title.

```html
<head>
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Roboto:300,400,500"
  />
  <title>MERN App</title>
</head>
```

To see if everything installed correctly and is working, run the client project using command `yarn start`. This will open the default React app that comes with `create-react-app` at URL `http://localhost:3000`. To see our our assets (such as **Roboto** font) being loaded, go to _Developer Tools_ and open _Network_ tab. Refresh the page to reload the assets and you will notice that the font family is being loaded.

<img src='https://cdn-images-1.medium.com/max/800/1*_7ZRhHMJ3-hgT_FbtqrKpw.png' />

### Defining the HomeÂ Page

Now letâ€™s build the first component of our application. Create a new file inside `src/components/Home.js` and put the following content.

```js
import React, { Component } from 'react';
import { withStyles } from '@material-ui/core/styles';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';
import CardMedia from '@material-ui/core/CardMedia';
import Typography from '@material-ui/core/Typography';
import logo from '../logo.svg';

const styles = theme => ({
  card: {
    maxWidth: 700,
    margin: 'auto',
    marginTop: theme.spacing.unit * 5
  },
  title: {
    padding: `${theme.spacing.unit * 3}px ${theme.spacing.unit * 2.5}px ${
      theme.spacing.unit * 2
    }px`,
    color: theme.palette.text.secondary,
    fontSize: 24
  },
  media: {
    minHeight: 450
  }
});

class Home extends Component {
  render() {
    const { classes } = this.props;
    return (
      <div>
        <Card className={classes.card}>
          <Typography type="headline" component="h2" className={classes.title}>
            Welcome to the MERN APP
          </Typography>
          <CardMedia
            className={classes.media}
            image={logo}
            title="Auth with MERN"
          />
          <CardContent>
            <Typography type="body1" component="p">
              This is a demo application that uses a Node + MongoDB API for user
              authentication. Built With React + Material UI.
            </Typography>
          </CardContent>
        </Card>
      </div>
    );
  }
}

export default withStyles(styles)(Home);
```

The first component we are importing from `@material-ui` in this file is `withStyles`. It allows us to style a component by declaring a `styles` object with access top-level styles such as we are using `theme` with our home component. We will define these top-level `theme` related styles shortly in `App.js`. Next, we are importing `Card, CardContent, CardMedia` to create a card view. `CardMedia` is used to display any media file whereas `CardContent` is used with `Typography` to output text. Typography is used to present hierarchy based styles over text to the content as clearly and efficiently as possible.

Now open up `App.js` and add the following content.

```js
import React, { Component } from 'react';
import MuiThemeProvider from '@material-ui/core/styles/MuiThemeProvider';
import { createMuiTheme } from '@material-ui/core/styles';
import green from '@material-ui/core/colors/green';
import red from '@material-ui/core/colors/red';

import Home from './components/Home';

const theme = createMuiTheme({
  palette: {
    primary: {
      light: '#C8E6C9',
      main: '#4CAF50',
      dark: '#2E7D32',
      contrastText: '#fff'
    },
    secondary: {
      light: '#EF9A9A',
      main: '#F44336',
      dark: '#C62828',
      contrastText: '#000'
    },
    openTitle: green['400'],
    protectTitle: red['400'],
    type: 'dark'
  }
});

class App extends Component {
  render() {
    return (
      <MuiThemeProvider theme={theme}>
        <Home />
      </MuiThemeProvider>
    );
  }
}

export default App;
```

`MuiThemeProvider` and `createMuiTheme` classes are used to create default theme. The theme specifies the color of the components, darkness of the surfaces, level of shadow, appropriate opacity of ink elements, and so on. If you wish to customize the theme, you need to use the `MuiThemeProvider` component in order to inject a theme into your application. To configure a theme of your own, `createMuiTheme` is used. You can also make the theme dark by setting type to `dark` like we have done above. Lastly, `<MuiThemeProvider theme={theme}>` is where the top level styles are being passed to child components, in our case `Home`.

If you render the app by running `yarn start`, you will get the below output.

<img src='https://cdn-images-1.medium.com/max/800/1*ccxb9zV_vqwALeW0ijWLyw.png' />

### Adding ReactÂ Router

We need a way to navigate different routes for the user to sign in and sign out. In this section, we will add `react-router` library to our app for this purpose.

```shell
yarn add react-router react-router-dom
```

`react-router` library is a collection of navigational components. To get started, create a new file inside `src` folder called `Routes.js`.

```js
import React, { Component } from 'react';
import { Route, Switch } from 'react-router-dom';

import Home from './components/Home';

class Routes extends Component {
  render() {
    return (
      <Switch>
        <Route exact path="/" component={Home} />
      </Switch>
    );
  }
}

export default Routes;
```

The `Route` component is the main building block of React Router. Anywhere that you want to only render content based on the locationâ€™s pathname, you should use a `Route` element. `Switch` is used to group different `Route` components. The route for the homepage, our `Home` component does include an `exact` prop. This is used to state that route should only match when the pathname matches the routeâ€™s path exactly. To use the newly created Routes, we have to make some changes to `App.js` to make it work.

```js
import React, { Component } from 'react';
import MuiThemeProvider from '@material-ui/core/styles/MuiThemeProvider';
import { createMuiTheme } from '@material-ui/core/styles';
import green from '@material-ui/core/colors/green';
import red from '@material-ui/core/colors/red';
import { BrowserRouter } from 'react-router-dom';

import Routes from './Routes';

const theme = createMuiTheme({
  palette: {
    primary: {
      light: '#C8E6C9',
      main: '#4CAF50',
      dark: '#2E7D32',
      contrastText: '#fff'
    },
    secondary: {
      light: '#EF9A9A',
      main: '#F44336',
      dark: '#C62828',
      contrastText: '#000'
    },
    openTitle: green['400'],
    protectTitle: red['400'],
    type: 'dark'
  }
});

class App extends Component {
  render() {
    return (
      <BrowserRouter>
        <MuiThemeProvider theme={theme}>
          <Routes />
        </MuiThemeProvider>
      </BrowserRouter>
    );
  }
}

export default App;
```

The `BrowserRouter` defined above is used when you have a server that will handle dynamic requests.

### Connecting Node server andÂ React

I wrote an article for Crowdbotics dealing [how to connect a Node.js server with the React front end **here**](https://blog.crowdbotics.com/how-to-set-up-a-node-backend-with-hapi-js-for-a-react-web-app/)**.** We do not need to review the whole process. Just open your `package.json` and add the following for our app to kickstart.

```json
"proxy": "http://localhost:4000/"
```

Next, I am going to add methods to be used in different components that will handle API calls from our server side code. Create two new files inside `utils` directory: `api-auth.js` and `api-user.js`.

```js
// api-user.js

export const registerUser = user => {
  return fetch('/api/users/', {
    method: 'POST',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(user)
  })
    .then(response => {
      return response.json();
    })
    .catch(err => console.log(err));
};

export const findUserProfile = (params, credentials) => {
  return fetch('/api/users/' + params.userId, {
    method: 'GET',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      Authorization: 'Bearer ' + credentials.t
    }
  })
    .then(response => {
      return response.json();
    })
    .catch(err => console.error(err));
};

export const deleteUser = (params, credentials) => {
  return fetch('/api/users/' + params.userId, {
    method: 'DELETE',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      Authorization: 'Bearer ' + credentials.t
    }
  })
    .then(response => {
      return response.json();
    })
    .catch(err => console.error(err));
};
```

In `api-auth.js`, add the following.

```js
// api-auth.js
export const signin = user => {
  return fetch('/auth/signin/', {
    method: 'POST',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    credentials: 'include',
    body: JSON.stringify(user)
  })
    .then(response => {
      return response.json();
    })
    .catch(err => console.log(err));
};

export const signout = () => {
  return fetch('/auth/signout/', {
    method: 'GET'
  })
    .then(response => {
      return response.json();
    })
    .catch(err => console.log(err));
};
```

The `signin` method takes care of user credentials from the view component (which we will create shortly), then uses `fetch` to make a `POST` call to verify the user credentials with the backend. The `signout` method uses `fetch` to make a GET call to the sign-out API endpoint on the back-end.

### Front-End: Auth Components

Next, we will setup all the necessary components required for authentication.

One by one, I am going to create new files so please follow closely.

Create a new directory inside `components` and call it `auth`. Then, create a new file `auth-helper.js`.

```js
import { signout } from '../../utils/api-auth.js';

const auth = {
  isAuthenticated() {
    if (typeof window == 'undefined') return false;

    if (sessionStorage.getItem('jwt'))
      return JSON.parse(sessionStorage.getItem('jwt'));
    else return false;
  },
  authenticate(jwt, cb) {
    if (typeof window !== 'undefined')
      sessionStorage.setItem('jwt', JSON.stringify(jwt));
    cb();
  },
  signout(cb) {
    if (typeof window !== 'undefined') sessionStorage.removeItem('jwt');
    cb();
    //optional
    signout().then(data => {
      document.cookie = 't=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
    });
  }
};

export default auth;
```

These functions will help us manage the state of authentication in the browser. Using these methods our client side app will be able to check whether the user has logged in or not. To protect the routes, such as a userâ€™s profile, from un-authorized access, we have to define a new component inside `PrivateRoute.js` and make use of the methods above.

```js
import React, { Component } from 'react';
import { Route, Redirect } from 'react-router-dom';
import auth from './auth-helper';

const PrivateRoute = ({ component: Component, ...rest }) => (
  <Route
    {...rest}
    render={props =>
      auth.isAuthenticated() ? (
        <Component {...props} />
      ) : (
        <Redirect
          to={{
            pathname: '/signin',
            state: { from: props.location }
          }}
        />
      )
    }
  />
);

export default PrivateRoute;
```

We are going to use this component as an auth flow in the `Routes.js` we have defined. Components that rendered via this route component will only load when the user is authenticated. Our last component related to user authentication is to be defined inside `Signin.js`.

```js
import React, { Component } from 'react';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';
import CardMedia from '@material-ui/core/CardMedia';
import Button from '@material-ui/core/Button';
import TextField from '@material-ui/core/TextField';
import Typography from '@material-ui/core/Typography';
import Icon from '@material-ui/core/Icon';
import { withStyles } from '@material-ui/core/styles';
import auth from './auth-helper';
import { Redirect } from 'react-router-dom';
import { signin } from '../../utils/api-auth.js';

const styles = theme => ({
  card: {
    maxWidth: 600,
    margin: 'auto',
    textAlign: 'center',
    marginTop: theme.spacing.unit * 5,
    paddingBottom: theme.spacing.unit * 2
  },
  error: {
    verticalAlign: 'middle'
  },
  title: {
    marginTop: theme.spacing.unit * 2,
    color: theme.palette.openTitle
  },
  textField: {
    marginLeft: theme.spacing.unit,
    marginRight: theme.spacing.unit,
    width: 300
  },
  submit: {
    margin: 'auto',
    marginBottom: theme.spacing.unit * 2
  }
});

class Signin extends Component {
  state = {
    email: '',
    password: '',
    error: '',
    redirectToReferrer: false
  };

  clickSubmit = () => {
    const user = {
      email: this.state.email || undefined,
      password: this.state.password || undefined
    };

    signin(user).then(data => {
      if (data.error) {
        this.setState({ error: data.error });
      } else {
        auth.authenticate(data, () => {
          this.setState({ redirectToReferrer: true });
        });
      }
    });
  };

  handleChange = name => event => {
    this.setState({ [name]: event.target.value });
  };

  render() {
    const { classes } = this.props;
    const { from } = this.props.location.state || {
      from: {
        pathname: '/'
      }
    };
    const { redirectToReferrer } = this.state;
    if (redirectToReferrer) {
      return <Redirect to={from} />;
    }

    return (
      <Card className={classes.card}>
        <CardContent>
          <Typography type="headline" component="h2" className={classes.title}>
            Sign In
          </Typography>
          <TextField
            id="email"
            type="email"
            label="Email"
            className={classes.textField}
            value={this.state.email}
            onChange={this.handleChange('email')}
            margin="normal"
          />
          <br />
          <TextField
            id="password"
            type="password"
            label="Password"
            className={classes.textField}
            value={this.state.password}
            onChange={this.handleChange('password')}
            margin="normal"
          />
          <br />{' '}
          {this.state.error && (
            <Typography component="p" color="error">
              <Icon color="error" className={classes.error}>
                error
              </Icon>
              {this.state.error}
            </Typography>
          )}
        </CardContent>
        <CardActions>
          <Button
            color="primary"
            variant="raised"
            onClick={this.clickSubmit}
            className={classes.submit}
          >
            Submit
          </Button>
        </CardActions>
      </Card>
    );
  }
}

export default withStyles(styles)(Signin);
```

This is a form component that contains `email` and `password` field (\_as we defined in state above) for the user to enter to get authenticated. `redirectToReferrer` property in state is what we are using if the user gets verified by the server or not. If the credentials entered by the user are valid, this property will trigger `Redirect` component of `react-router-dom`.

### Front-End: User Components

Similarly to our auth routes, we are going to separate our user components inside `components/user/` folder. First, we need a React component to register a new user. Create a file called `Signup.js`.

```js
import React, { Component } from 'react';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';
import CardActions from '@material-ui/core/CardActions';
import Button from '@material-ui/core/Button';
import TextField from '@material-ui/core/TextField';
import Typography from '@material-ui/core/Typography';
import Icon from '@material-ui/core/Icon';
import { withStyles } from '@material-ui/core/styles';
import DialogTitle from '@material-ui/core/DialogTitle';
import DialogActions from '@material-ui/core/DialogActions';
import DialogContentText from '@material-ui/core/DialogContentText';
import DialogContent from '@material-ui/core/DialogContent';
import Dialog from '@material-ui/core/Dialog';
import { Link } from 'react-router-dom';

import { registerUser } from '../../utils/api-user.js';

const styles = theme => ({
  card: {
    maxWidth: 600,
    margin: 'auto',
    textAlign: 'center',
    marginTop: theme.spacing.unit * 5,
    paddingBottom: theme.spacing.unit * 2
  },
  error: {
    verticalAlign: 'middle'
  },
  title: {
    marginTop: theme.spacing.unit * 2,
    color: theme.palette.openTitle
  },
  textField: {
    marginLeft: theme.spacing.unit,
    marginRight: theme.spacing.unit,
    width: 300
  },
  submit: {
    margin: 'auto',
    marginBottom: theme.spacing.unit * 2
  }
});

class Signup extends Component {
  state = {
    name: '',
    password: '',
    email: '',
    open: false,
    error: ''
  };

  handleChange = name => event => {
    this.setState({ [name]: event.target.value });
  };

  clickSubmit = () => {
    const user = {
      name: this.state.name || undefined,
      email: this.state.email || undefined,
      password: this.state.password || undefined
    };
    registerUser(user).then(data => {
      if (data.error) {
        this.setState({ error: data.error });
      } else {
        this.setState({ error: '', open: true });
      }
    });
  };

  render() {
    const { classes } = this.props;
    return (
      <div>
        <Card className={classes.card}>
          <CardContent>
            <Typography
              type="headline"
              component="h2"
              className={classes.title}
            >
              Sign Up
            </Typography>
            <TextField
              id="name"
              label="Name"
              className={classes.textField}
              value={this.state.name}
              onChange={this.handleChange('name')}
              margin="normal"
            />
            <br />
            <TextField
              id="email"
              type="email"
              label="Email"
              className={classes.textField}
              value={this.state.email}
              onChange={this.handleChange('email')}
              margin="normal"
            />
            <br />
            <TextField
              id="password"
              type="password"
              label="Password"
              className={classes.textField}
              value={this.state.password}
              onChange={this.handleChange('password')}
              margin="normal"
            />
            <br />{' '}
            {this.state.error && (
              <Typography component="p" color="error">
                <Icon color="error" className={classes.error}>
                  error
                </Icon>
                {this.state.error}
              </Typography>
            )}
          </CardContent>
          <CardActions>
            <Button
              color="primary"
              variant="raised"
              onClick={this.clickSubmit}
              className={classes.submit}
            >
              Submit
            </Button>
          </CardActions>
        </Card>
        <Dialog open={this.state.open} disableBackdropClick={true}>
          <DialogTitle>New Account</DialogTitle>
          <DialogContent>
            <DialogContentText>
              New account successfully created.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Link to="/signin">
              <Button color="primary" autoFocus="autoFocus" variant="raised">
                Sign In
              </Button>
            </Link>
          </DialogActions>
        </Dialog>
      </div>
    );
  }
}

export default withStyles(styles)(Signup);
```

We start the component by declaring an empty state that contains various properties such as name, email, password and error. The `open` property is used to capture the state of a `Dialog` box.

In Material UI, a `Dialog` is a type of modal window that appears in front of app content to provide critical information or ask for a decision. The modal in our case will either render an error message or the confirmation message depending on the status returned from the server.

We are also defining two handler functions. `handleChange` changes the new value of every input field entered. `clickSubmit` invokes when a user after entering their credentials, submit the registration form. This function calls `registerUser` from the API to send the data to the backend for further actions.

Create a new file called `Profile.js`.

```js
import React, { Component } from 'react';
import { withStyles } from '@material-ui/core/styles';
import Paper from '@material-ui/core/Paper';
import ListItem from '@material-ui/core/ListItem';
import ListItemAvatar from '@material-ui/core/ListItemAvatar';
import ListItemText from '@material-ui/core/ListItemText';
import ListItemSecondaryAction from '@material-ui/core/ListItemSecondaryAction';
import Avatar from '@material-ui/core/Avatar';
import Typography from '@material-ui/core/Typography';
import Person from '@material-ui/icons/Person';
import Divider from '@material-ui/core/Divider';
import auth from '../auth/auth-helper';
import { findUserProfile } from '../../utils/api-user.js';
import { Redirect, Link } from 'react-router-dom';

import DeleteUser from './DeleteUser';

const styles = theme => ({
  root: theme.mixins.gutters({
    maxWidth: 600,
    margin: 'auto',
    padding: theme.spacing.unit * 3,
    marginTop: theme.spacing.unit * 5
  }),
  title: {
    margin: `${theme.spacing.unit * 3}px 0 ${theme.spacing.unit * 2}px`,
    color: theme.palette.protectedTitle
  }
});

class Profile extends Component {
  constructor({ match }) {
    super();
    this.state = {
      user: '',
      redirectToSignin: false
    };
    this.match = match;
  }
  init = userId => {
    const jwt = auth.isAuthenticated();
    findUserProfile(
      {
        userId: userId
      },
      { t: jwt.token }
    ).then(data => {
      if (data.error) {
        this.setState({ redirectToSignin: true });
      } else {
        this.setState({ user: data });
      }
    });
  };
  componentWillReceiveProps = props => {
    this.init(props.match.params.userId);
  };
  componentDidMount = () => {
    this.init(this.match.params.userId);
  };
  render() {
    const { classes } = this.props;
    const redirectToSignin = this.state.redirectToSignin;
    if (redirectToSignin) {
      return <Redirect to="/signin" />;
    }
    return (
      <Paper className={classes.root} elevation={4}>
        <Typography type="title" className={classes.title}>
          Profile
        </Typography>
        <List dense>
          <ListItem>
            <ListItemAvatar>
              <Avatar>
                <Person />
              </Avatar>
            </ListItemAvatar>
            <ListItemText
              primary={this.state.user.name}
              secondary={this.state.user.email}
            />{' '}
            {auth.isAuthenticated().user &&
              auth.isAuthenticated().user._id == this.state.user._id && (
                <ListItemSecondaryAction>
                  <DeleteUser userId={this.state.user._id} />
                </ListItemSecondaryAction>
              )}
          </ListItem>
          <Divider />
        </List>
      </Paper>
    );
  }
}

export default withStyles(styles)(Profile);
```

This component shows a single user who is authenticated by the back-end of our application. The profile information of each user is stored in the database. This is done by the `init` function we have defined above the render function of our component.

We are using `redirectToSignin` redirect to the user on sign-out. We are also adding a delete profile button as a separate component which has to be defined in a separate file called `DeleteUser.js`.

```js
import React, { Component } from 'react';
import IconButton from '@material-ui/core/IconButton';
import Button from '@material-ui/core//Button';
import DialogTitle from '@material-ui/core/DialogTitle';
import DialogActions from '@material-ui/core/DialogActions';
import DialogContentText from '@material-ui/core/DialogContentText';
import DialogContent from '@material-ui/core/DialogContent';
import Dialog from '@material-ui/core/Dialog';
import Delete from '@material-ui/icons/Delete';
import auth from '../auth/auth-helper';
import { deleteUser } from '../../utils/api-user';
import { Redirect, Link } from 'react-router-dom';

class DeleteUser extends Component {
  state = {
    redirect: false,
    open: false
  };
  clickButton = () => {
    this.setState({ open: true });
  };
  deleteAccount = () => {
    const jwt = auth.isAuthenticated();
    deleteUser(
      {
        userId: this.props.userId
      },
      { t: jwt.token }
    ).then(data => {
      if (data.error) {
        console.log(data.error);
      } else {
        auth.signout(() => console.log('deleted'));
        this.setState({ redirect: true });
      }
    });
  };
  handleRequestClose = () => {
    this.setState({ open: false });
  };
  render() {
    const redirect = this.state.redirect;
    if (redirect) {
      return <Redirect to="/" />;
    }
    return (
      <span>
        <IconButton
          aria-label="Delete"
          onClick={this.clickButton}
          color="secondary"
        >
          <Delete />
        </IconButton>

        <Dialog open={this.state.open} onClose={this.handleRequestClose}>
          <DialogTitle>{'Delete Account'}</DialogTitle>
          <DialogContent>
            <DialogContentText>
              Confirm to delete your account.
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={this.handleRequestClose} color="primary">
              Cancel
            </Button>
            <Button
              onClick={this.deleteAccount}
              color="secondary"
              autoFocus="autoFocus"
            >
              Confirm
            </Button>
          </DialogActions>
        </Dialog>
      </span>
    );
  }
}

export default DeleteUser;
```

This component is used for deleting the user profile that exists in the database. It uses the same `deleteUser` API endpoint we defined in our back-end. `deleteAccount` method is responsible for handling this task.

### Front-End: Completing theÂ Navbar

In this section we are going to complete our client side routes by leveraging a `Navbar` component. Create a new file `component/Navbar.js`.

```js
import React from 'react';
import AppBar from '@material-ui/core/AppBar';
import Toolbar from '@material-ui/core/Toolbar';
import Typography from '@material-ui/core/Typography';
import IconButton from '@material-ui/core/IconButton';
import Home from '@material-ui/icons/Home';
import Button from '@material-ui/core/Button';
import auth from './auth/auth-helper';
import { Link, withRouter } from 'react-router-dom';

const isActive = (history, path) => {
  if (history.location.pathname == path) return { color: '#F44336' };
  else return { color: '#ffffff' };
};
const Menu = withRouter(({ history }) => (
  <AppBar position="static">
    <Toolbar>
      <Typography type="title" color="inherit">
        MERN App
      </Typography>
      <Link to="/">
        <IconButton aria-label="Home" style={isActive(history, '/')}>
          <Home />
        </IconButton>
      </Link>
      {!auth.isAuthenticated() && (
        <span>
          <Link to="/signup">
            <Button style={isActive(history, '/signup')}>Sign up</Button>
          </Link>
          <Link to="/signin">
            <Button style={isActive(history, '/signin')}>Sign In</Button>
          </Link>
        </span>
      )}
      {auth.isAuthenticated() && (
        <span>
          <Link to={'/user/' + auth.isAuthenticated().user._id}>
            <Button
              style={isActive(
                history,
                '/user/' + auth.isAuthenticated().user._id
              )}
            >
              My Profile
            </Button>
          </Link>
          <Button
            color="inherit"
            onClick={() => {
              auth.signout(() => history.push('/'));
            }}
          >
            Sign out
          </Button>
        </span>
      )}
    </Toolbar>
  </AppBar>
));

export default Menu;
```

This `Navbar` component will allow us to access routes as views on the front-end. From `react-router` we are importing a High Order Component called `withRouter` to get access to history object's properties and consume our front-end routes dynamically.

Using `Link` from `react-router` and `auth.isAuthenticated()` from our authentication flow, we are checking for whether the user has access to authenticated routes or not, that is, if they are logged in to our application or not.

`isActive` highlights the view to which the current route is activated by the navigation component.

### Running the Application

The next step is to import this navigation component inside `Routes.js` and define other necessary routes we need in our app. Open `Routes.js` and add the following.

```js
import React, { Component } from 'react';
import { Route, Switch } from 'react-router-dom';
import Navbar from './components/Navbar';

import Home from './components/Home';
import PrivateRoutes from './components/auth/PrivateRoutes';
import Signin from './components/auth/Signin';
import Profile from './components/user/Profile';
import Signup from './components/user/Signup';

class Routes extends Component {
  render() {
    return (
      <div>
        <Navbar />
        <Switch>
          <Route exact path="/" component={Home} />
          <PrivateRoutes path="/user/edit/:userId" />
          <Route path="/user/:userId" component={Profile} />
          <Route path="/signup" component={Signup} />
          <Route path="/signin" component={Signin} />
        </Switch>
      </div>
    );
  }
}

export default Routes;
```

After completing this test, letâ€™s test our application. Make sure you are running the backend server using `nr dev` command in one tab in your terminal. Using another tab or window, traverse to `client` directory and run the command `yarn start`. Once the application starts, you will be welcomed by the Homepage, as below.

<img src='https://cdn-images-1.medium.com/max/800/1*sl6_pEHr8QLBK3hi3V6tTg.png' />

Notice in the navbar above there are three buttons. The home icon is for Home page highlighted `red` in color. If you move on to the sign in page, you will see the sign in button highlighted. We already have one user registered to our application (_when we were building the API_). Please enter the credentials (_email:_ [_jane@doe.com_](mailto:jane@doe.com) and _password: pass1234 or the credentials you entered_) as shown below and submit the form.

<img src='https://cdn-images-1.medium.com/max/800/1*N8oztui9YOVgyHAP1jUW0w.png' />

On submitting the form you will be redirected to the home page as per the component logic. The changes can be noticed at the navigation menu. Instead of sign-up and sign-in, you will see My Profile and Sign Out button. Click My Profile and you can see the current userâ€™s details.

<img src='https://cdn-images-1.medium.com/max/800/1*-xTVUQbUhb6yJnZIIk6eHw.png' />

On clicking the `delete` icon it will delete the user. You can also try signing out of the application by clicking on the sign out button from navigation and then you will be redirected to the home page.

### Conclusion

We have reached the end. Even though this tutorial is lengthy and, a lot is going on, I am sure if you take your time, you will understand the concepts and the logic behind it. It is after all, a full-stack MERN application. It uses JSON Web Tokens as an authentication strategy.

If you want to learn **how to deploy this application, you can continue to read** [**this article**](https://amanhimself.dev/blog/deploy-a-mern-stack-app-on-heroku)**.**

**The complete code for the tutorial at [this Github repository](https://github.com/amandeepmittal/mern-material-demo)**

---

## Building a React Native Mobile App with AWS Amplify and Expo
Slug: building-a-react-native-mobile-app-with-aws-amplify-and-expo

![cover](https://i.imgur.com/G1PqZSM.png)

There is a joke going in dev community about serverless tech stacks using servers?! Some of the trolls even take that this an offensive way. What are they missing out is the advantages Serverless computing has to offer. Advantages like reduced development time and operation costs are some of the factors that could not be overlooked. Spending time and energy writing and wiring your application is worth rather than continuously managing resources and then worry about them at the time of scaling. This might sound too hot to some but serverless is a pragmatic solution in some use cases.

In this tutorial, you will be learning how to integrate a serverless computing service called AWS Amplify in a mobile app using React Native. AWS Amplify has a complete set of toolchain with authentication, a choice between wiring and managing GraphQL or REST API, data storage, push notification and analytics.

### TLDR

- What is AWS Amplify?
- Requirements
- Getting Started
- Configure Amplify User
- Initialize AWS Amplify
- Add a GraphQL API
- Publish API to AWS Cloud
- Integrating Expo app with Amplify SDK
- Adding a Todo Input Field
- Adding a Mutation using Graphql API
- Run Query to fetch data
- Conclusion

## What is AWS Amplify?

Amazon Web Service is a well-known technology that provides cloud services. Since its launch in 2017, Amplify has come a long way in terms of providing a definitive toolchain. The first attraction for me personally is that it is open source. Next, are the CLI plugins and services that you can enable with one click when integrating it in a framework like React Native (_or any other_). Services such as support for GraphQL and REST APIs, basic UI components to get you started, authentication HOCs, storage, hosting and many more are available in its toolchain.

## Requirements

Here is a complete list of plugins, packages, services you are going to need in order to gain something from this tutorial.

- [NodeJS](https://nodejs.org) `v8.x.x` or higher installed along with `npm/yarn`
- [`watchman`](https://facebook.github.io/watchman/docs/install.html) the file change watcher for React Native project
- AWS account
- Amplify CLI plugin
- Expo CLI (\_earlier known as `create-react-native-app`)

_Note_: To use any Amplify service and to follow the rest of this tutorial, you need an AWS account (_which is free_). If you do not have one, please consider signing up for one [here](https://portal.aws.amazon.com/billing/signup?redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation) for the free tier.

## Getting Started

After you have the first three requirements from the previous section let us install the last two. Both of them are command line plugins to scaffold and configure our React Native + AWS Amplify project. Open a terminal window and execute the following command.

```shell
npm install -g @aws-amplify/cli expo-cli
```

Once both of the CLIs are installed, make sure you are on the same version (_at least the major one_) as we are.

```shell
amplify --version
# Output
1.6.6

expo-cli --version
# Output
2.15.4
```

Next, let us create a new React Native project using Expo CLI.

```shell
expo-cli init expo-amplify-demo
```

It will then prompt for a few questions. The first and most important one is choosing a workflow. Choose the default option, that is `blank`. Then it will prompt you to enter the name of your app, you can leave it to default or enter a name. You can use `yarn` to install dependencies by pressing `Y`. After a few moments, a new project directory will appear on the desired location. Traverse inside it before we proceed to the next step.

## Configure Amplify User

Once you are signed-in to AWS console, open up a terminal window and run the following command.

```shell
amplify configure
```

This will open up the AWS console dashboard. Go back to terminal and press enter to continue.

<img src='https://cdn-images-1.medium.com/max/800/1*MdFM6jQ1y-AAONd9OFJ4dA.png' />

Next, are going to be a bunch of questions in order to configure a user account to use Amplify with your React Native application. These questions are as following:

- **Choose a region:** us-east-2
- **Specify the username of the new IAM user:** expo-amplify-demo

On entering the username, press enter and it will open AWS console again in a browser window for you to add a user.

<img src='https://cdn-images-1.medium.com/max/800/1*61bLl2uI4m4r6liLVWUFPQ.png' />

In the above screen, make sure that **Programmatic access** is checked. It allows adding the newly created user to have access to create resources in the form of different APIs and tools by providing you with an access key and secret key. Then click on button **Next: Permissions**.

<img src='https://cdn-images-1.medium.com/max/800/1*25jaknfbqMWRnqiR_EvQ8A.png' />

In the above screen, you will notice that a policy has been selected by default. Let it be. This provides you the full access to AWS services by enabling the aws user (_the current user you are creating_) to be an administrator. Then, click on **Next: Tags**.

<img src='https://cdn-images-1.medium.com/max/800/1*Ust7wTI9lbNMvrXzPnsiHA.png' />

Leave this one blank, and click on **Next: Review**.

<img src='https://cdn-images-1.medium.com/max/800/1*uJEWxsCGDpGOYomhqrlrzw.png' />

Click on **Create user** on the next page and you will be directed to a new page where you will find **Access Key** and **Secret Key**. Do not close this window yet.

<img src='https://cdn-images-1.medium.com/max/800/1*74JJCqo-N-uYRTRC24d-pg.png' />

Go to your terminal window, press the Enter key and it will ask you for the Access Key and the Secret Key. Enter both of them sequentially. Lastly, it will ask you about the profile name. You can enter the project name or user name here. Pressing enter for the last time will create a new AWS user. This section is complete.

## Initialize AWS Amplify

To integrate AWS Amplify with the React Native app run the following command and be ready to answer a few more questions ðŸ˜„. _I know, I know_. But imagine, not having these questions. The amount of setup being performed right now just by answering a few questions and pressing enters' a few times adds a lot of value by saving developer time.

Open a terminal window, and make sure you are inside the React Native/Expo directory.

```shell
amplify init
```

This command will help you setup amplify SDK inside the React Native app. First, a few sets of questions that are prompted can be seen below.

<img src='https://cdn-images-1.medium.com/max/800/1*9azNVPxkeEVPZ_Nsg7YP5w.png' />

Next, you will be prompted with a question on whether to use an AWS profile or not. You have to choose `Yes` and then on to the next question, choose the user name that you created in the previous steps when configuring amplify. If you are setting up for the time, you are probably going to have only one username in the list, unlike below.

<img src='https://cdn-images-1.medium.com/max/800/1*KEorokAmLOGIaeOFfdu2SQ.png' />

After the amplify SDK initialization process is complete, notice there are some new file changes inside the project directory. A new directory `amplify/` and a new file `aws-exports.js`

<img src='https://cdn-images-1.medium.com/max/800/1*LA_uIoKTDhVgT-tqogeOhA.png' />

The `amplify` directory takes care of configuration files that required in order to setup and makes amplify SDK work with the current React Native app. These configuration files are further divided into two parts. One set of files are just for your local machine and another is for aws cloud. Please remember, whenever you make changes related to amplify SDK in your app, they are, by default, modifications made to the local part or development part. When you are done making modifications and are ready to deploy your changes to the cloud, you use special amplify commands such as `push`. After running this `push` command, only the changes are written in aws cloud.

The file `aws-exports.js` contains details related to amplify cloud service and credentials for the SDK to be imported inside the React Native app. You will be using this file later on.

```js
// WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten.

const awsmobile = {
  aws_project_region: 'us-east-2'
};

export default awsmobile;
```

## Add a GraphQL API

The idea of this section is that in your React Native app, you will be having an API that performs CRUD operations. CRUD stands for _Create, Read, Update and Delete_. Amplify toolchain makes this process easier using its own backend and data storing capabilities. Amplify supports HTTP requests to REST and GraphQL endpoints. Using AWS AppSync, you can easily build data-driven applications in real-time with offline capabilities.

To set up an entire API for the app all you have to do is execute the below command.

```shell
amplify add api
```

This CLI execution automatically creates a fully functional GraphQL API including data sources, resolvers with basic schema structure for queries, mutations, and subscriptions, downloads client-side code and configuration files that are required in order to run these operations by sending requests. The above command will prompt you to choose between what type of API you want to write in. Choose **GraphQL**, and enter a **profile API name**.

<img src='https://cdn-images-1.medium.com/max/800/1*0A5e8OUG9xZr7JkOgAG32g.png' />

Next, it will again, give you two options to choose as to how you want to authenticate your AWS AppSync API. In a real-time application, you will have different users accessing the database and making requests to it. For that, you will always go with **Amazon Cognito User Pool**. This is more of a pragmatic approach. That step needs authentication process and we will be covering that in a future post. For the current demo, choose the option **API Key**.

Do note that this option is only for brief prototype sessions or development process. Any AppSync API key expires after seven days lifecycle. For the next question **Do you have an annotated GraphQL schema?** the answer is `N` or no. Amplify comes with pre-defined schemas that can be changed later. Press `Y` for the next question: **Do you want a guided schema creation?**

<img src='https://cdn-images-1.medium.com/max/800/1*szS_04apcvVgkUjeMPLrVg.png' />

Select `single object with fields`. Next, it will ask if you want to edit the GraphQL Schema. Say yes to that for now. This will open up a new file called `schema.graphql` which contains a schema of type `Todo` with a different set of fields. This step does create a new folder inside `amplify/backend/api/` that further contains the metadata information related to GraphQL API.

<img src='https://cdn-images-1.medium.com/max/800/1*3E2yW1nN6T4E_d_c_vU3XA.png' />

Here is the model inside `schema.graphql` file.

```graphql
type Todo @model {
  id: ID!
  name: String!
  description: String
}
```

If you are not familiar to GraphQL models and its types here is brief information about them. A `type` in a GraphQL schema is that piece of data that is stored in the database. Each `type` can have a different set of fields. You can think of a `type` as an object coming from the JavaScript background. For example, in the above schema for `Todo` model is the `type` that has three fields: `id`, `name` and `description`. Also, `@model` is used for storing types in Amazon DynamoDB. This is the database is used by Amazon when storing our app data.

Every `type` in a database generates a unique identity to each piece of information stored to further identify and persist in CRUD operations through HTTP requests. The `id` in this case is generated by Amplify and has a value of a built-in type of `ID` which, in GraphQL terminology, is known as a scalar type. You can read more about the different types identified in a GraphQL schema [here](https://graphql.org/graphql-js/basic-types/).

The exclamation mark `!` signifies that the field is required when storing the data and it must have value. In the above schema, there are two required fields: `id` and `name` for the `Todo` type.

Save this file, go back to the terminal window and press enter. You will be prompted with a success message (_probably, in green_). All the changes you have just made are now saved locally.

## Publish API to AWS Cloud

To publish all the changes you have made (or left it default) in the local environment to AWS Cloud, run the command `amplify push`.

<img src='https://cdn-images-1.medium.com/max/800/1*6gTwOhKVRGSzjZzP48WUTA.png' />

On running the command, as a prompt, you get a table in return with information about resources that you have used and modified or enabled. The name of these resources is described in the Category section. The **Resource name** in the above table is the API name you choose in the previous section. Next column is the type of operation for the API to be sent, that is currently, **Create**. The provider plugin column signifies that these resources are now being published to the cloud. Press `Y` to continue.

Amplify CLI interface will now check for the schema and then compile it for any errors before publishing final changes to the cloud.

<img src='https://cdn-images-1.medium.com/max/800/1*pA5KjvyCwGgTDKeR8W3IyA.png' />

In the next step, it prompts whether you want to generate code for your newly created GraphQL API? Press `Y`. Then choose javascript as the code generation language. If you are using `TypeScript` or `flow`, now is the time to pick one. In the above image, for the last question, press `Y`. This will create a new folder inside the src directory which contains GraphQL schema, query, mutations, subscriptions as JavaScript files. On operating the API, these files can be accessible for different operations later.

Press `Y` to the next question that asks you to update all GraphQL related operations. Also, let maximum statement depth be the default value of `2`. It will take a few moments to update the resources on the aws cloud and will prompt with a success message when done.

<img src='https://cdn-images-1.medium.com/max/800/1*QIYXuBoTZFvbSPiTyDG8tA.png' />

At the end of the success message you will get a GraphQL API endpoint and a GraphQL API Key (_which we learned previously that it expires on the 7th day_). You do not have to save it somewhere on your desktop and panic. This information is added to `aws-exports.js` file automatically for you now.

## Integrating Expo app with Amplify SDK

To make use of amplify SDK in the React Native app, install the following dependencies.

```shell
yarn add aws-amplify aws-amplify-react-native
```

The package `aws-amplify` allows making requests to auth and API services provided AWS. The other package `aws-amplify-react-native` is specific to React Native as a library that contains useful components to be used in a project. You can verify that both of these packages were installed by peeking into `package.json` file > `dependencies`.

```json
"dependencies": {
    "aws-amplify": "^1.1.26",
    "aws-amplify-react-native": "^2.1.10",
    "expo": "^32.0.0",
    "react": "16.5.0",
    "react-native": "https://github.com/expo/react-native/archive/sdk-32.0.0.tar.gz"
  },
```

Open `App.js` and add the configuration keys from `aws-exports-.js` and make amplify SDK aware of them.

```js
// App.js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

// ---------This is the part to add
import Amplify from 'aws-amplify';
import config from './aws-exports';

Amplify.configure(config);

// -----------------------------
```

That's it for the integration part. Now let us write some GraphQL interactions and make sure it works with our React Native app in real-time.

## Adding a Todo Input Field

To capture the user input, we are going to use a component state as follows. Add the below before the render method inside the `App` component.

```js
//App.js
state = {
  name: '',
  todos: []
};
```

In the above state, there is a `name` field of the todo item and an array called `todos` that will be used to fetch all the todo items from the GraphQL API and display on the UI. Note that, there is another field called `description` in the GraphQL schema but since it isn't required, we are not going to use it here.

Next, import `TextInput` and `TouchableOpacity` to create an input field and native button. Here is the complete code for `App.js`.

```js
import React from 'react';
import {
  StyleSheet,
  Text,
  View,
  TextInput,
  TouchableOpacity
} from 'react-native';

import Amplify from 'aws-amplify';
import config from './aws-exports';

Amplify.configure(config);

export default class App extends React.Component {
  state = {
    name: '',
    todos: []
  };

  onChangeText = (key, val) => {
    this.setState({ [key]: val });
  };

  addTodo = () => {};

  render() {
    return (
      <View style={styles.container}>
        <TextInput
          style={styles.input}
          value={this.state.name}
          onChangeText={val => this.onChangeText('name', val)}
          placeholder="Add a Todo"
        />
        <TouchableOpacity onPress={this.addTodo} style={styles.buttonContainer}>
          <Text style={styles.buttonText}>Add +</Text>
        </TouchableOpacity>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingHorizontal: 10,
    paddingTop: 50
  },
  input: {
    height: 50,
    borderBottomWidth: 2,
    borderBottomColor: 'blue',
    marginVertical: 10
  },
  buttonContainer: {
    backgroundColor: '#34495e',
    marginTop: 10,
    marginBottom: 10,
    padding: 10,
    borderRadius: 5,
    alignItems: 'center'
  },
  buttonText: {
    color: '#fff',
    fontSize: 24
  }
});
```

Go to the terminal window and run the command `npm start` to view this either in an iOS simulator or an android emulator. You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*gj26-fBY1i3hRAmTm8Jj8A.png' />

## Adding a Mutation using Graphql API

A _mutation_ in GraphQL is all about handling operations like adding, deleting or modifying data. Currently, the React Native application is basic but it serves the purpose of making you familiar with amplify as a toolchain and its integration with the cross-platform framework. To add a todo item and to retrieve the same you need some business logic to communicate with GraphQL backend. Let us start with a mutation.

In the file `App.js`, import `API` and `graphqlOperation` from `aws-amplify`. Here, `API` is the category for AWS resource and the later is the method to run either a mutation or the query. Inside the `src/graphql/mutation.js` file you will find some mutation functions that we can make use of to create, delete, or update a note in the database. Also import `createTodo` from this file.

```js
//App.js

// ...
import Amplify, { API, graphqlOperation } from 'aws-amplify';
import config from './aws-exports';
import { createTodo } from './src/graphql/mutations';
// ...
```

Add a function `addTodo` before the `render` method which uses `API.graphqlOperation()` the method from amplify SDK. This method will intake the mutation as the first argument and whatever input user enters inside the app UI, as the second argument.

```js
// App.js

addNote = async event => {
  const { name, todos } = this.state;

  event.preventDefault();

  const input = {
    name
  };

  const result = await API.graphql(graphqlOperation(createTodo, { input }));

  const newTodo = result.data.createTodo;
  const updatedTodo = [newTodo, ...todos];
  this.setState({ todos: updatedTodo, name: '' });
};
```

The above function takes `name` as the input where `name` is the text of a todo item. Also, notice the use of `async/await`. This helps to fetch the result from the mutation and update the `todos` array in the state with the latest todo item and previous or existing data in that array. After updating the state, clear the value of the input field `name`, and display in the UI by setting it back to an empty string.

I urge you to add at least one list of item. You would not get any confirmation right now from the API whether the data field has been added to the GraphQL backend or not.

## Run Query to fetch data

If you want to read data (_and render it in the UI of the app_), the process is known as a _query_. To fetch all the data from GraphQL API and display it on the device's screen, let us use the query from amplify GraphQL pre-generated file inside `src/graphql/queries.js` (_just like we did with mutation_).

```js
// eslint-disable
// this is an auto generated file. This will be overwritten

export const getTodo = `query GetTodo($id: ID!) {
  getTodo(id: $id) {
    id
    name
    description
  }
}
`;
export const listTodos = `query ListTodos(
  $filter: ModelTodoFilterInput
  $limit: Int
  $nextToken: String
) {
  listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {
    items {
      id
      name
      description
    }
    nextToken
  }
}
`;
```

Import `listTodos` inside `App.js` from the above file.

```js
//App.js
import { listTodos } from './src/graphql/queries';
```

We need to fetch the data at the time where the component gets rendered. For this, let us a lifecycle method called `componentDidMount`. Since this is going to be an asynchronous operation `async/await` is being used here too. Just after the state is defined in the `App` component, add the following snippet of code.

```js
// App.js
async componentDidMount() {
        try {
            const todos = await API.graphql(graphqlOperation(listTodos))
            console.log("todos: ", todos)
            this.setState({ todos: todos.data.listTodos.items })
        } catch (err) {
            console.log("error: ", err)
        }
    }
```

Refresh the app by saving the file you will notice that on UI screen nothing happens. That's because we haven't added the rendering logic to display this list of items. However, you can verify that data is being fetched using `console` statement and by looking quickly at the Expo CLI.

<img src='https://cdn-images-1.medium.com/max/800/1*jY4FwniW2IJtfpGxoXxNgQ.png' />

During the previous step, I did add an item to the list. That's the proof of that. Now let us display this item on the device's screen. Inside the render method, add this after the `TouchableOpacity` component. We are going to use JavaScript's `map` function to traverse the `todos` array.

```js
// App.js

    {this.state.todos.map((todo, index) => (
                    <View key={index} style={styles.todo}>
                        <Text style={styles.name}>{todo.name}</Text>
                    </View>
                ))}

// Corresponding styles for above jsx

todo: {
        borderBottomWidth: 1,
        borderBottomColor: "#ddd",
        paddingVertical: 10
    },
    name: { fontSize: 16 }
```

On running `npm start` (_or if it is already running, just the save the App.js file_) you will get the following output.

<img src='https://cdn-images-1.medium.com/max/800/1*uOotu-Fbfy7FnfDRwQXNOw.png' />

## Conclusion

This tutorial is complete. I am sure by now you have gained enough knowledge to build your own React Native app with AWS Amplify and AppAsync. Also, did you notice the amount of code written inside `App.js`? It is far less than a traditional app that uses self-backend techniques. This bare minimum demo can serve you a lot better.

You can find the complete code for this post in this [Github repository](https://github.com/amandeepmittal/expo-amplify-demo).

[Originally published at Heartbeat](https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e)

---

## Building a REST API with Koajs
Slug: building-a-rest-api-with-koajs

![cover](https://i.imgur.com/ohg3d3s.png)

> [Originally published at Crowdbotics](https://medium.com/crowdbotics/building-a-rest-api-with-koajs-417c276929e2)

There are quite a few [Node.js](http://crowdbotics.com/build/node-js?utm_source=medium&utm_campaign=nodeh&utm_medium=node&utm_content=koa-rest-api) frameworks available for web development to build a back-end server for a web or a mobile application. The most popular framework is ExpressJS, which has been used widely in the industry for a long time.

In this article, however, **we are going to discuss** [**Koa**](http://koajs.com)**, to write server-side code that uses Node.js as the runtime engine. In this tutorial, I will show how to build a** [**small REST API**](https://blog.crowdbotics.com/how-to-write-an-api-in-3-lines-of-code-with-django-rest-framework/) **then test it using a REST Client.**

### What isÂ Koa?

Koa is designed and built by the team behind ExpressJS with additions such as promises and `async/await` support in its core. These ES2015 features are used to tackle API's asynchronous calls. Distributed as a lightweight Node.js framework, Koa provides a minimal interface for developing web applications and APIs.

Koa has features that help JavaScript developers who want to use and leverage Node.js to accelerate the development of APIs and web applications. I have been using Koa for some of my latest back-end applications and I would love to share my knowledge to get you started.

### Features ofÂ Koa

Some of the features of the Koa framework include:

- Designed as a lightweight and flexible framework for Node.js
- Support for ECMAScript 6 (/ES2015) by default
- Developers can use generators as functions to stop and resume the code execution
- Simplifies the use of Error handling by using middleware more effectively
- Identifies and understands all HTTP methods
- Even before Express, Koa had support for `async/await`

To use this framework, the only two requirements for running the code examples below are to have Node.js installed in your local machine along with `npm` to access and install it as a dependency. The second requirement is to have a general understanding of JavaScript as a programming language.

### Getting Started

To start using Koa as a server-side framework you will have to first install it. Create a directory where you will want to place all the project-related files. We will first initialize it as a Node.js project.

```shell
# First initialize an empty directory
npm init -y
```

This will help us generate a `package.json` file that holds all the records of dependencies we add to our project using `npm`. I am using the `-y` flag to skip the questionnaire prompted by npm. You will get a similar result once it is done.

The next step is to add Koa as a local dependency. I am sure you know what a local dependency here means. If not, please refer to `[npm](https://docs.npmjs.com/)` [documentation](https://docs.npmjs.com/).

```shell
npm install -S koa
```

So far so good. Now we can get started and build our application. However, please note that to use Koa either on your local machine or deploy any server-side project that uses it, _you need to have a Node.js version equal to or greater than_ `_v7.6.0_`_._

### Our First KoaÂ App

To understand Koa better, and point out the differences with a commonly used framework such as ExpressJS, we are going to first write an obligatory _Hello World_ program.

Below, we create a route in a file called `app.js`.

```js
// app.js
const Koa = require('koa');
const app = new Koa();

// Our First Route
app.use(async ctx => {
  ctx.body = 'Hello World';
});

// Bootstrap the server
app.listen(3000);
```

Now, open the terminal and run the following command:

```js
node app.js
```

If you are not prompted with an error, that means the server ran successfully.

Right now, we are not getting anything exciting from the terminal. If you go to `http://localhost:3000` in your browser window, you should see a `Hello World` message greeting you!

<img src='https://cdn-images-1.medium.com/max/800/1*vmF-dRrg83Uq4Zt6BbkAEg.png' />

To understand more about what is happening, letâ€™s import the Koa library into our `app.js` file.

Next, we define an instance called `app` that will access all the methods that are included in Koa's API such as `use()` and `listen()`. `app.use()` is how th middleware function is defined. We are using this middleware function as a route. The `app.listen()` is how the server knows to run on a port number specified such as `3000`.

### Wait, what isÂ ctx?

Another important feature that we use in our bare minimum example is `ctx`. I do hope you noticed it there.

We are using `ctx` as an argument to the asynchronous middleware function. It is called **Context** in Koa and it encapsulates **request** and **response** objects into a single object. Unlike ExpressJS, that requires request and response as separate objects passed as arguments. For example:

```js
// request and response objects in ExpressJS

app.use((request, response) => {
  // ... rest of the route
});
```

In Koa, a context is created for every request that comes to the server and is always referenced as middleware.

```js
// request and response as context in Koa
app.use(async ctx => {
  ctx.request;
  ctx.response;
});
```

### Side Tip: Installing nodemon

Before I start on REST APIs, the core of the article, I want to introduce a great tip that is helpful in building a Node.js application. During the development mode, irrespective of the framework I am using, I use `nodemon` as a dependency to watch for file changes and automatically restart the application. This eliminates the need to run `node [`filename].js` command again and again. You can totally, skip this step and move on to the next one where I show the steps for writing the REST API.

This small utility has such an impact on my workflow that it saves hours of development chores. So let me show you how to set it up in our demo application. I am using the same project as previous **Hello World** example to demonstrate this. Write the following command to install it.

```shell
npm install -D nodemon
```

`-D` flag is used to tell npm to install the current dependency as a `devDependency`. The difference between it and a normal dependency is that `devDependencies` tend to work only in development environment. They are not installed in a production environment since there is no use of them there. Other types of `devDependencies` you might come across when writing Node applications are linting tools such as ESLint.

Once, `nodemon` is installed, append the `package.json` file and an npm script.

```json
"scripts":{
  "dev": "nodemon app.js"
}
```

Point this script to the initial file of the Koa application, in our case, it is `app.js`. To run the application now, all you have to type is `npm run dev` command in your terminal. This time, you will see a few messages suddenly prompted in the terminal. These messages are provided by `nodemon`.

### Building the RESTÂ API

Finally, you have arrived at the point where you can start building the REST API. You have to install dependencies for the API to work. Letâ€™s install them.

```shell
npm i -S koa-body koa-router
```

> What are these dependencies for?

**koa-body** is a body-parser middleware. It supports `urlencoded`, multi-part and `json` request bodies. Basically, it helps to create and respond to HTTP `POST` requests which are available as a form field, or a file upload, etc. It tells the server that the incoming request from the client has a body of data. ExpressJS uses the same approach in handling body requests.

**koa-router** is the routing middleware that provides ExpressJS style routing using HTTP verbs. It has methods that you can directly use in the application Such as `app.get()`, `app.post()`, etc.

**Note:** I will be mocking data in this application for the sake of brevity and a clear understanding of the frameworkâ€™s concepts. If you want to, you can use the database of your choice. The structure of the data is not complex.

Write the following code in the `app.js` file.

```js
// app.js

const Koa = require('koa');
const koaBody = require('koa-body');

// create app instance
const app = new Koa();

// middleware functions
app.use(koaBody());

// Require the router here

// use the router here

app.listen(3000);
```

After body-parser middleware, you are going to have the routes. I am using another file to describe the routes to separate the code for a clear understanding. Create a new file called `books.js`. Define the following inside that file with the data to mock.

```js
// books.js

const Router = require('koa-router');

// Prefix all routes with: /books
const router = new Router({
  prefix: '/books'
});

let books = [
  { id: 101, name: 'Fight Club', author: 'Chuck Palahniuk' },
  { id: 102, name: 'Sharp Objects', author: 'Gillian Flynn' },
  { id: 103, name: 'Frankenstein', author: 'Mary Shelley' },
  { id: 101, name: 'Into The Wild', author: 'John Krakauer' }
];

// Routes will go here

module.exports = router;
```

First, I am importing the necessary dependency to create routes: `koa-router`. The next step is to create an instance of this newly imported dependency. Notice the prefix part: `/books`. Using a prefix for the routes is how you can define and categorize different routes. You can also use this technique to classify the different API versions such as `v1`, `v2`, etc.

The `books` array is the mock data. It contains information about books and each book is represented by a separate object inside the array. Each object further has three data fields: `id`, `name`, and `author`.

Letâ€™s build the first route of our API.

### Creating a route to handle GETÂ request

Below is the code for handling a `GET` request in Koa. Add the following code to `books.js`.

```js
// books.js
router.get('/', (ctx, next) => {
  ctx.body = books;
  next();
});
```

The callback function that is attached to the `router.get()` contains two arguments. I have already explained to you what `ctx` or context is. The last argument is `next()`. This is often used in middleware functions. Any middleware function invokes this function to indicate the current middleware function has suspended running and the next middleware function available must be invoked.

This callback function traverses through the `books` array when to send the response. To run this, you have to first include the routes file in `app.js` and invoke them.

```js
// app.js
const Koa = require('koa');
const koaBody = require('koa-body');

const app = new Koa();

// Set up body parsing middleware
app.use(koaBody());

// Require the Router we defined in books.js
let books = require('./books.js');

// Use the Router on the sub route /books
app.use(books.routes());

app.listen(3000);
```

Next step is to run the command: `npm run dev` and visit the url `http://localhost:3000/books` to see the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*d-GFucqnhOEIeORSytPH4w.png' />

> _Congratulations! ðŸŽ‰ You just build your first route usingÂ Koa._

Next step is to create a route to fetch a book by its `id`. It is going to use the similar approach as the previous route, plus we see how to extract information from `request.params` object of an incoming request.

```js
// books.js
router.get('/:id', (ctx, next) => {
  let getCurrentBook = books.filter(function (book) {
    if (book.id == ctx.params.id) {
      return true;
    }
  });

  if (getCurrentBook.length) {
    ctx.body = getCurrentBook[0];
  } else {
    ctx.response.status = 404;
    ctx.body = 'Book Not Found';
  }
  next();
});
```

Routing parameters are named segments that are used to capture the values specified in the URL. In our case, such as`:id`. Above, we define a routing middleware function that can handle incoming requests from URLs such as `http:localhost:3000/books/103`. Enter this URL in your browser window and you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*-F6g2j_QsvwBjXUdrVsZhw.png' />

In case of when `id` does not exist or is invalid, you have to send an error message with an HTTP status of `404`.

<img src='https://cdn-images-1.medium.com/max/800/1*BKDmJ80xYVoOsVQTNaMiKw.png' />

### Handling a POSTÂ request

The last route you are going to build for this demonstration is going to handle `POST` requests.

```js
// books.js

router.post('/new', (ctx, next) => {
  // Check if any of the data field not empty
  if (
    !ctx.request.body.id ||
    !ctx.request.body.name ||
    !ctx.request.body.author
  ) {
    ctx.response.status = 400;
    ctx.body = 'Please enter the data';
  } else {
    let newBook = books.push({
      id: ctx.request.body.id,
      name: ctx.request.body.name,
      author: ctx.request.body.author
    });
    ctx.response.status = 201;
    ctx.body = `New book added with id: ${ctx.request.body.id} & name: ${ctx.request.body.name}`;
  }
  next();
});
```

The `/new` route is used for creating a new book and adding it to our `books` array. I am using this to mock data and not a real database so restarting the application will delete the newly added books. In the above routing middleware, the Koa Context object first checks if any of the data fields required in `request.body` is present or not. If one of them is missing, this routing middleware will be terminated and sends back an error to the user.

If everything is fine, this routing middleware accepts the data and returns a success message with the correct HTTP status of code for creating a new record. To run this URL, I am using `curl` command from my terminal but you can use any REST client such as Postman or Insomnia.

<img src='https://cdn-images-1.medium.com/max/800/1*qbXL75_xqOrtgE0UTXEPPw.png' />

For our all routes to be more descriptive and follow the REST API pattern, I have re-written every `ctx.body` object from each routing middleware function. Here is how the complete routing file looks so far.

```js
// books.js
const Router = require('koa-router');

// Prefix all routes with /books
const router = new Router({
	prefix: '/books'
});

let books = [
	{ id: 101, name: 'Fight Club', author: 'Chuck Palahniuk' },
	{ id: 102, name: 'Sharp Objects', author: 'Gillian Flynn' },
	{ id: 103, name: 'Frankenstein', author: 'Mary Shelley' },
	{ id: 104, name: 'Into The Willd', author: 'Jon Krakauer' }
];

// Routes will go here
router.get('/', (ctx, next) => {
	ctx.body = {
		status: 'success',
		message: books
	};
	next();
});

router.get('/:id', (ctx, next) => {
	let getCurrentBook = books.filter(function(book) {
		if (book.id == ctx.params.id) {
			return true;
		}
	});

	if (getCurrentBook.length) {
		ctx.body = getCurrentBook[0];
	} else {
		ctx.response.status = 404;
		ctx.body = {
			status: 'error!',
			message: 'Book Not Found with that id!'
		};
	}
	next();
});

router.post('/new', (ctx, next) => {
	// Check if any of the data field not empty
	if (
		!ctx.request.body.id ||
		!ctx.request.body.name ||
		!ctx.request.body.author
	) {
		ctx.response.status = 400;
		ctx.body = {
			status: 'error',
			message: 'Please enter the data';
    }
	} else {
		let newBook = books.push({
			id: ctx.request.body.id,
			name: ctx.request.body.name,
			author: ctx.request.body.author
		});
		ctx.response.status = 201;
		ctx.body = {
			status: 'success',
			message: `New book added with id: ${ctx.request.body.id} & name: ${
				ctx.request.body.name
			}`
		};
	}
	next();
});

module.exports = router;
```

<img src='https://cdn-images-1.medium.com/max/800/1*R2_CY-WOiEM2pqE-bLQbRg.png' />

This completes the basics of building a REST API using Koa as a Node.js framework. Itâ€™s a pretty minimal framework with all the necessary ways to tackle incoming requests and send the response back from the server. Koa also supports ready-made middleware functions to make use of logging, handling errors, testing, compression, and security.

> You can find the complete code used in this tutorial at [this Github repository](https://github.com/amandeepmittal/koa-rest-api-tut)

---

## Building offline React Native apps with AsyncStorage
Slug: building-offline-react-native-apps-with-asyncstorage

![cover](https://i.imgur.com/5eoYxcI.png)

> [Originally published at Heartbeat](https://heartbeat.fritz.ai/building-offline-react-native-apps-with-asyncstorage-dcb4b0657f93)

As developers, we love exploring concepts and mechanisms while working with a new framework. React Native as a cross-platform development framework has come quite far in terms of a mature framework since I started playing around with it and then using it for its purpose. Understanding the fundamentals when learning it is something very helpful, and I consider, important.

Thus, applying basic fundamentals of React Native knowledge, in this tutorial, I am going to walk you through how to build a todo list application using an offline storage functionality. This storage functionality is provided by a native module in React Native, called `AsyncStorage`.

In the journey of building this application, you are going to use a UI component library known as [Native Base](https://docs.nativebase.io/docs/GetStarted.html), which is one of the most popular libraries to build user interfaces among React Native developers. Out of the box, this library speeds up the development process by providing pre-defined UI components that can either be used as they are available or customize them according to our needs.

## What are we building?

The outcome from following this tutorial is going to be a complete React Native application that works with realtime offline data from the storage of the device.

<img src='https://cdn-images-1.medium.com/max/800/1*FBBSWT3Xztc0G9wAGnz1yA.gif' />

## Table of Contents

- Prerequisites
- Create an Expo app
- Exploring AsyncStorage
- Utilizing AsyncStorage API
- Adding Navigation
- Creating a Floating Action Button (FAB)
- Navigating between Two Screens
- Customize the Header Component
- Rendering a list of items using FlatList
- Reading Data using AsyncStorage API
- Adding a Todolist Item
- Deleting a Todolist Item
- Mark an Item Check or Uncheck on completion
- Passing Data between different screens using the navigation
- Display each todo list item
- Bonus Section: Adding a Segment
- Conclusion

## Prerequisites

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- [Node.js](https://nodejs.org/en/) (>=`8.x.x`) with npm/yarn installed.
- [expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli/?) (>=`3.0.4`), previously known as create-react-native-app.

It will be best if you use the same exact versions or higher of each utility tool described above. To run and test the React Native application, all you need is an Expo client installed either on your device or an iOS simulator or an Android emulator. Please note that, throughout this tutorial, I will be using an iOS simulator to demonstrate the application.

## Create an Expo app

To get started, all you require is to generate a new Expo project. This could be done by opening a terminal window, navigating to a suitable location where you develop projects and running the following commands in the order they are described.

```shell
expo init offline-todolist-app

# navigate inside the app folder
cd offline-todolist-app

# install the following dependencies
yarn add react-navigation native-base
expo-font@5.0.1 lodash.values uuid
```

The last command, as described in the above snippet installs five dependencies that the application is going to use. `yarn` is currently being used as the package manager. You can also use `npm` instead of `yarn`. The use of each dependency will be made clear as throughout this tutorial as they are used. If this is your first time building a React Native application, try not to get overwhelmed by them.

## Exploring AsyncStorage

`AsyncStorage` is a simple, asynchronous key-value pair used in React Native applications. It is used for a variety of scenarios but mainly to store data when your app is not using any cloud services, or you want to implement some features in your app that require data storage.

It operates globally in a React Native and comes with its own limitations. As a React Native developer, you have to know what these limitations. The first limitation of an `AsyncStorage` API is that the size of the database is set to `6MB` limit. Also, `AsyncStorage` storage is based on SQLite. Thus, it is important to keep [SQLite limitations](https://www.sqlite.org/limits.html) in mind too. Also, it is hard to store complex and nested data structures in form of key-value pairs. Knowing about these limitations, only help you to opt for the persistent solution when developing a mobile app.

According to the [React Native's official documentation](https://facebook.github.io/react-native/docs/asyncstorage):

> On iOS, AsyncStorage is backed by native code that stores small values in a serialized dictionary and larger values in separate files. On Android, AsyncStorage will use either RocksDB or SQLite based on what is available.

## Utilizing AsyncStorage API

Before you dive deep in building the Todolist app, in this section, let us build a small app that saves a value to the `AsyncStorage`, fetches the value from the storage in the client-side React Native app. This will help you how to write basic operations using the storage API. Lastly, you will learn about how to clear the storage completely.

Open `App.js` file and add the following snippet. Start by importing the necessary components from React Native API. The most important one here is `AsyncStorage`. After that, define a variable named `STORAGE_KEY`. This variable will be used to store and retrieve the stored data using the `AsyncStorage` API. Think of it as an identifier for the value being stored or name of the key in the key-value pair. Since you are going to store only one value at the moment, there is only the requirement for one key.

```js
import React from 'react';
import {
  StyleSheet,
  Text,
  View,
  TextInput,
  AsyncStorage,
  TouchableOpacity
} from 'react-native';

const STORAGE_KEY = '@save_name';
```

Next, let us define an initial state with two empty strings. They are going to be used to save the value of the user input and then retrieve the value to display it on the app screen. After defining the initial state, there is going to be a lifecycle method that is going to load the data when the application starts for the first time or the App component renders.

```js
class App extends React.Component {
  state = {
    text: '',
    name: ''
  };

  componentDidMount() {
    this.retrieveData();
  }

  // ...
}
```

In the above snippet, do note that the `App` component is actually a class component and not the default functional component that comes with boilerplate Expo app. Now, there are going to be three methods that will help to store the data, retrieve the data, and clear the app data that is stored. This is going to be done by creating three asynchronous methods. Each of the methods is going to utilize the appropriate API method from `AsyncStorage` API. Every method in the `AsyncStorage` API is a promise-based, hence, let us use `async/await` syntax to follow good practice.

```js
retrieveData = async () => {
  try {
    const name = await AsyncStorage.getItem(STORAGE_KEY);

    if (name !== null) {
      this.setState({ name });
    }
  } catch (e) {
    alert('Failed to load name.');
  }
};
```

In the above snippet, the name of the method implies what they are going to do in the app. The `retrieveData` method is what fetches the data from the storage if it exists. It uses the same identifier that you defined previously, outside the class function component. It utilises the parameter in the state object `name`. Later in the app, you are going to use this parameter to display its stored value. Note that, there is an `if` condition inside this method. This condition says that to fetch the data only when there is a value for the `name` variable exists. This method also uses `try/catch` as they are part and parcel of writing functions with modern `async/await` syntax. Lastly, this method is being invoked inside the lifecycle method.

The next function is going to save the data. In the below snippet, you will find that it uses a parameter `name` which on success, is the value that is stored. An alert message will be shown when the input data is saved.

```js
save = async name => {
  try {
    await AsyncStorage.setItem(STORAGE_KEY, name);
    alert('Data successfully saved!');
    this.setState({ name });
  } catch (e) {
    alert('Failed to save name.');
  }
};
```

The last method that you are going to utilize from the `AsyncStorage` API is called `clear()`. This deletes everything that is previously saved. It is not recommended to use this method directly if you want to delete only a specific item from the storage. For that, there are methods like `removeItem` or `multiRemove` available by the API. You can read more about them in the official documentation [here](https://facebook.github.io/react-native/docs/asyncstorage#clear) or later when building the Todolist application.

```js
removeEverything = async () => {
  try {
    await AsyncStorage.clear();
    alert('Storage successfully cleared!');
  } catch (e) {
    alert('Failed to clear the async storage.');
  }
};
```

This snippet will throw an `Alert` box on the device screen when everything is cleared from the storage.

The last two methods are going to be used to create a controlled input.

```js
onChangeText = text => this.setState({ text });

onSubmitEditing = () => {
  const onSave = this.save;
  const { text } = this.state;

  if (!text) return;

  onSave(text);
  this.setState({ text: '' });
};
```

After that, add the code snippet for the `render` method, followed by the styles for each UI component. Lastly, do not forget to export `App` component for it to run on the simulator or the real device.

```js
render() {
        const { text, name } = this.state
        return (
            <View style={styles.container}>
                <TextInput
                    style={styles.input}
                    value={text}
                    placeholder='Type your name, hit enter, and refresh'
                    onChangeText={this.onChangeText}
                    onSubmitEditing={this.onSubmitEditing}
                />
                <Text style={styles.text}>Hello {name}!</Text>
                <TouchableOpacity onPress={this.removeEverything} style={styles.button}>
                    <Text style={styles.buttonText}>Clear Storage</Text>
                </TouchableOpacity>
            </View>
        )
    }
} // class component App ends here

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center'
    },
    text: {
        fontSize: 20,
        padding: 10,
        backgroundColor: '#00ADCF'
    },
    input: {
        padding: 15,
        height: 50,
        borderBottomWidth: 1,
        borderBottomColor: '#333',
        margin: 10
    },
    button: {
        margin: 10,
        padding: 10,
        backgroundColor: '#FF851B'
    },
    buttonText: {
        fontSize: 14,
        color: '#fff'
    }
})

export default App
```

Now to run the application, go to the terminal window and execute the command `expo start`. After that, you will see the following screen on the simulator.

<img src='https://cdn-images-1.medium.com/max/800/1*92vU3B3f_FmUCXk8xKwtSg.png' />

Since there is no data stored right now, the text after the word `Hello` is empty. Use the input field to save a string or a name or anything and then press the enter key. You will get the following output. Whatever input you entered, it will be displayed next to the word `Hello`.

<img src='https://cdn-images-1.medium.com/max/800/1*twgilQew9SwvBq2YnEbIqg.png' />

Even if you refresh the Expo client, the value stored does not go away. Only when pressing the button below `Hello` statement that says `Clear Storage` is the way to delete the stored value.

<img src='https://cdn-images-1.medium.com/max/800/1*6yeaeFLns1JwU0wyeqMptQ.png' />

Refresh the Expo client after you clear the storage to get the following output.

<img src='https://cdn-images-1.medium.com/max/800/1*CRhOwbo1d-iTUOEb0v-MAQ.png' />

This complete the section where you learned about how to utilize `AsyncStorage` API to save and fetch the data. From the next section onwards, you will be building the Todolist application.

## Organizing the application

Since a React Native application was already generated in the previous step, you can continue to utilize that app by modifying everything inside the `App.js` file. Or create a new one if it serves you well.

You have already installed the necessary npm modules. This is the time to start utilizing them in order to build the offline todo list app. Before beginning with the development of the app, create the following folders and files inside them. This will give a structure to manage the app later or if you want to extend by adding new features to it.

<img src='https://cdn-images-1.medium.com/max/800/1*kg7x_WrXqP6U13af4OBJsA.png' />

From the structure, notice that there are three new folders being created. This structure is the separation of concerns between the different aspect of a mobile app. Such as files or configuration related to navigation should be separated from the screens. The above structure is also a common pattern that many React Native developers have started to follow in their work.

## Adding Navigation

Inside the `navigation` folder, there is an `index.js` file that is going to hold all the configuration there is to be defined. The reason `react-navigation` module is used is to create a stack navigator that allows the user to visit the two screens the following application has. The navigation mode is going to be `modal`. Yes, you can utilize `pre-defined` navigation modes or animation patterns.

Let us start by importing the necessary components inside the `index.js` file.

```js
import React from 'react';
import { createStackNavigator, createAppContainer } from 'react-navigation';
import HomeScreen from '../screens/HomeScreen';
import AddTaskScreen from '../screens/AddTaskScreen';
```

From the above snippet, notice that the `createStackNavigator` is a function that returns a React component. It takes a route configuration object. The `createAppContainer` is responsible for linking the current React Native app while maintaining the navigation state from the top-level component. The top-level component in your app is `App`.

With the help of `createAppContainer`, you are going to create a provider and wrap the `App` component inside it. This will benefit the entire application as every screen or component defined is going to have a navigation state. You will learn some of the many benefits provided by the navigation state later.

Lastly, in the above snippet, there are going to be a screen component. These screen components are going to hold the business logic necessary to run the todo list app. You can think of them as containers.

Right now, the route configuration object is going to be as the following snippet.

```js
const StackNav = createStackNavigator(
  {
    Home: {
      screen: HomeScreen
    },
    AddTask: {
      screen: AddTaskScreen
    }
  },
  {
    mode: 'modal'
  }
);
```

The `mode` is important to specify here. It defines the style for rendering the next screen component. In the above case, it is `AddTask` screen. In an iOS or Android app, the default transition is always a `card`. You are changing this default transition by specifying the `mode` property and setting its value to `modal`.

The `modal` pattern Make the screens slide in from the bottom, which is a common iOS pattern. Only works on iOS but has no effect on Android.

Lastly, you have to export the app container that utilizes the `StackNav`. Here is the code for that.

```js
const RootNavigator = createAppContainer(StackNav);

export default RootNavigator;
```

Now, open `App.js` file and add the following content.

```js
import React from 'react';
import RootNavigator from './navigation';

export default function App() {
  return <RootNavigator />;
}
```

Before running the app, make sure there is a mock component to render inside the files `HomeScreen.js` and `AddTaskScreen.js`. Otherwise, it will throw an error. You can add the dummy component for now.

```js
// HomeScreen.js
import React, { Component } from 'react';
import { Text, View } from 'react-native';

export class HomeScreen extends Component {
  render() {
    return (
      <View>
        <Text> Offline Todolist App</Text>
      </View>
    );
  }
}

export default HomeScreen;

// AddTaskScreen.js
import React, { Component } from 'react';
import { Text, View } from 'react-native';

export class AddTaskScreen extends Component {
  render() {
    return (
      <View>
        <Text>Add Task Screen</Text>
      </View>
    );
  }
}

export default AddTaskScreen;
```

Now run the app using `expo start` command, and you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*Mz6vFfwIwz7rWNIa9o-F4Q.png' />

This completes the navigation section.

## Create a Floating button

Inside the `components/FloatingButton.js` file, you are going to create a floating action button or in mobile development, commonly known as FABs. These type of buttons are often distinguished by a circled icon floating above the UI in a fixed position. If you are an Android user or have seen a mobile app following any material design specification, you might have noticed them.

In the current app, this `FloatingButton` is going to be responsible for navigating from the `HomeScreen` to the `AddTaskScreen`. Since it is going to be a presentation component, you should define it as a functional component that accepts only one prop. This prop `actionOnPress` is going to be a method defined inside the `HomeScreen.js` file that will contain the logic of navigating between the two screens later.

One important thing to notice in the snippet below is that the component library `native-base` is being used to create the FAB button. It saves a good amount of time and lines of code to create and style a component like below.

```js
import React from 'react';
import { StyleSheet } from 'react-native';
import { Icon, Fab } from 'native-base';

const FloatingButton = ({ actionOnPress }) => (
  <Fab
    direction="up"
    style={styles.button}
    position="bottomRight"
    onPress={actionOnPress}
  >
    <Icon name="ios-add" />
  </Fab>
);

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#5859f2'
  }
});

export default FloatingButton;
```

## Navigating Between Two Screens

Once you have defined it, go to the file `HomeScreen.js` and the following snippet of code.

```js
import React, { Component } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { AppLoading } from 'expo';
import * as Font from 'expo-font';
import FloatingButton from '../components/FloatingButton';

export class HomeScreen extends Component {
  state = {
    isDataReady: false
  };
  componentDidMount = () => {
    this.loadFonts();
  };

  loadFonts = async () => {
    try {
      await Font.loadAsync({
        Roboto: require('../node_modules/native-base/Fonts/Roboto.ttf'),
        Roboto_medium: require('../node_modules/native-base/Fonts/Roboto_medium.ttf'),
        Ionicons: require('../node_modules/native-base/Fonts/Ionicons.ttf')
      });
      this.setState({ isDataReady: true });
    } catch (err) {
      alert('Application Error. Cannot load fonts.');
    }
  };

  onPressFab = () => {
    this.props.navigation.navigate('AddTask');
  };

  render() {
    const { isDataReady } = this.state;

    if (!isDataReady) {
      return <AppLoading />;
    }
    return (
      <View style={styles.container}>
        <Text>Home Screen</Text>
        <FloatingButton actionOnPress={this.onPressFab} />
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  }
});

export default HomeScreen;
```

In the above snippet, the first and important thing to notice is the `loadFonts` method. This asynchronous method is a requirement to make Native Base UI library to work in any React Native, and Expo generated application. NativeBase use some custom fonts that are loaded using `Font.loadAsync` function. This function is provided by the expo module `expo-font` which allows you to use any fonts or icons in React Native components.

The `AppLoading` method is a React component that tells Expo to keep the app loading screen visible until `Font.loadAsync()` the method has run successfully. In general, this a useful method to utilize when your app is using custom fonts, logos, icons, and so on. In the current application, you are going to utilize this React component again when fetching data from `AsyncStorage` API (_that you will see in action later in this tutorial_). The `AppLoading` will only stop running when the boolean value for the state variable `isDataReady` is set to true. This boolean value is only set to true when `Font.loadAsync()` has finished running.

Once the application has loaded all necessary fonts and icons, you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*AJUj06CEsej1vn7YUtj-Ow.png' />

From the above snippet, take a look at the method `onPressFab` which is being passed to the `FloatingButton` component as the prop `actionOnPress`. This function utilizes a navigation method provided called `navigation.navigate()` with the value of the screen being passed as the argument: `AddTask`. Do note that, the value of the argument being passed should be the exact name of the screen defined earlier when configuring `StackNavigator`. Click on the button, and you will be directed to the next screen.

<img src='https://cdn-images-1.medium.com/max/800/1*Zfx3sB6akHo9tEILTQbHQg.gif' />

Did you notice the `back` button on the `AddTaskScreen`? This is again where `react-navigation` comes in handy. While working on a real-time React Native application, you often want to use the `react-navigation` library if it suits your requirements. It provides simple solutions out of the box.

## Customize the Header Component

With Native Base components library, it is easy to customize a header component in few lines of code. Inside the file `Header.js` add the following snippet. Again, this is a functional component since it is going to enhance the UI and is not running business logic.

```js
import React from 'react';
import { Header as NBHeader, Body, Title } from 'native-base';

const Header = () => {
  return (
    <NBHeader style={{ backgroundColor: '#5859f2' }}>
      <Body>
        <Title style={{ color: '#ffffff' }}>Header</Title>
      </Body>
    </NBHeader>
  );
};

export default Header;
```

The `Header` component from the `native-base` library takes a `Body` as an input. The body can further contain the rendering logic to modify the existing default `Header` component from the native base library itself. You can use inline styles or even `StyleSheet` object from `react-native` to customize the `Header` component as above, or any other native base UI component in general. Take a look at the `backgroundColor` and the `color` to the `Title`. `Title` is where the text to be displayed on this component goes.

Import this component inside the `HomeScreen.js` file. Also, import the `StatusBar` component from the `react-native`. Since the background of the `Header` component is going to be a customize blue color, it is better to change the default dark `StatusBar` style into something pleasing and light.

```js
import { View, Text, StyleSheet, StatusBar } from 'react-native';
import Header from '../components/Header';
```

Inside the class component, the first thing you have to do is hide the header that is being provided by the stack navigator from `react-navigation` library. The object `navigationOptions` is how to customize the default navigators that `react-navigation` renders.

```js
    static navigationOptions = {
        header: null
  }
```

Next, inside the `render()` method add the following before the omnipresent `Text` component.

```js
<Header />
<StatusBar barStyle='light-content' />
<Text>Home Screen</Text>
```

The rest of the code inside the `HomeScreen.js` file remains unchanged. The `StatusBar` is modified by defining the a value using its pre-defined prop `barStyle`. When using a Header component from Native Base UI library, the `StatusBar` from React Native comes after you define the JSX code for the header. Notice this in the above snippet. This is how it works with Native Base library. The following screen is what you get as the result of the above snippets.

<img src='https://cdn-images-1.medium.com/max/800/1*5m9TTlsGA60IeijZz4OfzA.png' />

## Rendering a list of items using FlatList

In this section, you are going to set up a List component that accepts mock or dummy data from an array defined as a property to the initial state. Open `HomeScreen.js` file and modify the state for now.

```js
state = {
  isDataReady: false,
  mockItems: ['First Item', 'Second Item', 'Third Item']
};
```

_Why dummy data?_ Later when you are going to hook `AsyncStorage` API to save and fetch the data from the database, in other words, playing around with real-time data operations, there are going to be separate methods that are going to handle each of the data operations. For now, let us hook up the business logic to display a list of items as well as the ability to add a new item using the modal screen you have set up in the previous steps.

The `FlatList` component is the ideal way to display a list of items in a React Native application.
It is a cross-platform component, and by default a vertical way to display a list of data items. It requires two props: `data` and `renderItem`. The `data` is the source of information for the list in the form of an array. The `renderItem` takes one item from the source, iterates over them, and returns a formatted component to render those items.

Styles that can be applied to a FlatList component is done by the prop `contentContainerStyle` that accepts the value of Stylesheet object. The reason to use `FlatList` is that it is performance effective. Of course, you can use `ScrollView` but it renders items from memory, which is not a very performant effective way to display a lengthy list of items. `ScrollView` is a wrapper on the View component that provides the user interface for scrollable lists inside a React Native app.

In the file `HomeScreen.js` replace the `Text` component with following `FlatList` and do not forget to import it and custom presentational component `Item` that is going to display each item in the list.

```js
// import statements
import { View, FlatList, StyleSheet, StatusBar } from 'react-native';
import Item from '../components/Item';

// in render method, replace <Text> with the following
<FlatList
  data={this.state.mockItems}
  contentContainerStyle={styles.content}
  renderItem={row => {
    return <Item text={row.item} />;
  }}
  keyExtractor={item => item.id}
/>;
```

Now open the file `components/Item.js` and add the following snippet.

```js
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions
} from 'react-native';

const { width } = Dimensions.get('window');

const Item = ({ text }) => {
  return (
    <View style={styles.container}>
      <View style={styles.rowContainer}>
        <Text style={styles.text}>{text}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderBottomColor: '#5859f2',
    borderBottomWidth: StyleSheet.hairlineWidth,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  rowContainer: {
    flexDirection: 'row',
    width: width / 2,
    alignItems: 'center'
  },
  text: {
    color: '#4F50DC',
    fontSize: 18,
    marginVertical: 20,
    paddingLeft: 10
  }
});

export default Item;
```

Another new React Native component to notice in the above snippet is `Dimensions`. It helps to set the initial `width` and `height` of a component before the application runs. We are using its `get()` method to acquire the current device's width and height.

In the simulator, you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*33XlaFACBb_SE4IsyLzIfg.png' />

## Reading Data using AsyncStorage API

In this section, you are going to add all methods that will contain business logic to save and fetch the data from the `AsyncStorage`. This logic will be composed of three operations:

- add a todolist item
- fetch all items to display
- delete an item from the list
- also, check the state of each list item whether it is marked as completed or not

These operations are going to communicate with the realtime data on the device. You are going to use objects instead of an array to store these items. `AsyncStorage` operates on key-value pairs and not arrays. Each object is going to be identified through a unique ID. In order to generate unique IDs, you are going to use a module called `uuid` which was installed earlier.

The structure of each todo item is going to be like this:

```js
45745c60-7b1a-11e8-9c9c-2d42b21b1a3e: {
  id: 45745c60-7b1a-11e8-9c9c-2d42b21b1a3e,           // same id as the object
  textValue: 'New item',     // name of the ToDo item
  isCompleted: false,   // by default, mark the item unchecked
  createdAt: Date.now()
}
```

But if you are going to use Objects instead of an array, how are you going to iterate over each item in the object? `FlatList` component only takes an array to iterate. Well, do you remember installing a utility package called `lodash.values`? That package is going to be really helpful in converting the object into an array.

First, let us start by importing all components and custom components required in order to build the application inside `HomeScreen.js` file.

```js
import React, { Component } from 'react';
import {
  FlatList,
  View,
  StatusBar,
  StyleSheet,
  AsyncStorage
} from 'react-native';
import uuidv1 from 'uuid/v1';
import _values from 'lodash.values';
import { Button, Text as NBText } from 'native-base';
import { AppLoading } from 'expo';
import * as Font from 'expo-font';
import Header from '../components/Header';
import Item from '../components/Item';
import FloatingButton from '../components/FloatingButton';
```

After writing these import statements, let us modify the initial state.

```js
state = {
  todos: {},
  isDataReady: false
};
```

From the above snippet, do take a note that the dummy array of data is replaced by the object `todos`. Next, you are going to write an asynchronous method to load the todos items from the object that is stored using `AsyncStorage` API. Also, let us merge the previous asynchronous method to load all the fonts with this method, such as the value of the initial state `isDataReady` is set to the boolean `true` only once. You will also have to modify the contents of the lifecycle method.

```js
componentDidMount = () => {
  this.loadTodos();
};

loadTodos = async () => {
  try {
    await Font.loadAsync({
      Roboto: require('../node_modules/native-base/Fonts/Roboto.ttf'),
      Roboto_medium: require('../node_modules/native-base/Fonts/Roboto_medium.ttf')
    });

    const getTodos = await AsyncStorage.getItem('todos');
    const parsedTodos = JSON.parse(getTodos);
    this.setState({ isDataReady: true, todos: parsedTodos || {} });
  } catch (err) {
    alert('Application Error. Cannot load data.');
  }
};
```

`AsyncStorage.getItem()` reads anything saved on the device database. It is essential to parse the data incoming from the storage into JSON. If you are not parsing the data, the application is going to crash. When setting the state in the above snippet, the `todos` object is getting the default value of an empty object is there is no data from the storage. This is also an essential step to perform and keep in mind for other use cases with similar scenarios.

## Adding a Todolist Item

Now, let us add the second method `addTodo` that is actually going to add the new item in the storage. The method defines before `addTodo` is actually storing the items in the storage. Again, you are using `JSON.stringify()` since AsyncStorage requires the data to be a string inside the single object. So when saving the item if you are not using `JSON.stringify()` your app is going to crash.

The `AsyncStorage.setItem()`is the function from the API that is similar to any key-value paired database. It takes the first argument, `todos` in the snippet below. This argument value is going to be the name of the store.

The parameter `newTask` passed to the `addTodo` function is going to be the object. Using `if` statement, there is a check whether the todo item being entered is not empty. `this.setState` uses a callback method that has access to `prevState` object. It gives any todo item that has been previously added to the list.

Inside the callback, you are first creating a new ID using `uuidv1` method. Then create an object called `newTodoObject` which uses the ID as a variable for the name. This object represents each item in the todo list.

Further, create a new object called `newState` which uses the `prevState` object, and finally adds `newTodoObject` object in todoliist of items. It might sound overwhelming since a lot is going on but try implementing the code, you will understand it better.

```js
saveTodos = newToDos => {
  const saveTodos = AsyncStorage.setItem('todos', JSON.stringify(newToDos));
};

addTodo = newTask => {
  const newTodoItem = newTask;

  if (newTodoItem !== '') {
    this.setState(prevState => {
      const ID = uuidv1();
      const newToDoObject = {
        [ID]: {
          id: ID,
          isCompleted: false,
          textValue: newTodoItem,
          createdAt: Date.now()
        }
      };
      const newState = {
        ...prevState,
        todos: {
          ...prevState.todos,
          ...newToDoObject
        }
      };
      this.saveTodos(newState.todos);
      return { ...newState };
    });
  }
};
```

## Deleting a Todolist Item

Similar to the `addTodo` method, you are going to add another method called `deleteTodo`. This will take care of removing an individual item from the list on the basis of `id` of that item object. Since you are using the `id` of the object both to identify the object inside the bigger object `todos` and assign each individual object the same `id`, the following code saves a lot of time. At last, using the `saveTodos` method, the storage is being updated with a remaining number of items.

```js
deleteTodo = id => {
  this.setState(prevState => {
    const todos = prevState.todos;
    delete todos[id];
    const newState = {
      ...prevState,
      ...todos
    };
    this.saveTodos(newState.todos);
    return { ...newState };
  });
};
```

## Mark a Todo Item Check or Uncheck on completion

The last two methods that are going to take care of whether each individual item is checked or not are going to be represented by `inCompleteTodo` and `completeTodo` methods. Both of these methods are going track which items in the to-do list have been marked completed by the user or have been unmarked.

They are going to act as a toggle and only update the value of `isCompleted` instead rather updating the whole todo list item object. This is again, possible because of a unique `id` for each object. Again in the last, before each of the methods returns the new state, using the `saveTodos` method, the storage gets an update.

```js
inCompleteTodo = id => {
  this.setState(prevState => {
    const newState = {
      ...prevState,
      todos: {
        ...prevState.todos,
        [id]: {
          ...prevState.todos[id],
          isCompleted: false
        }
      }
    };
    this.saveTodos(newState.todos);
    return { ...newState };
  });
};

completeTodo = id => {
  this.setState(prevState => {
    const newState = {
      ...prevState,
      todos: {
        ...prevState.todos,
        [id]: {
          ...prevState.todos[id],
          isCompleted: true
        }
      }
    };
    this.saveTodos(newState.todos);
    return { ...newState };
  });
};
```

## Passing Data between different screens using the navigation

In this section, you are going to edit each render method that is responsible for displaying the interface for the operations you defined in the previous sections, to happen in realtime. Let us start by editing `onPressFab` method inside the `HomeScreen.js`.

This method right navigates to the `AddTaskScreen`. By passing an object with to add a new item to the list (_hence, pass the method addTodo_) you are going to utilize another advantage that a sleek library `react-navigation` provides. That is, to pass data between different screens.

First, edit the `onPressFab` method like the below snippet.

```js
onPressFab = () => {
  this.props.navigation.navigate('AddTask', {
    saveItem: this.addTodo
  });
};
```

Next, open `AddTaskScreen.js` and add the following snippet.

```js
import React, { Component } from 'react';
import { View } from 'react-native';
import { Form, Item, Input, Button, Text as NBText } from 'native-base';

export class AddTaskScreen extends Component {
  state = {
    text: ''
  };

  onChangeText = event => {
    this.setState({ task: event.nativeEvent.text });
  };

  onAddTask = () => {
    this.props.navigation.state.params.saveItem(this.state.task);
    this.props.navigation.goBack();
  };

  render() {
    return (
      <View>
        <View style={{ marginRight: 10 }}>
          <Form>
            <Item>
              <Input
                value={this.state.task}
                placeholder="Enter a new task..."
                autoFocus
                clearButtonMode="always"
                autoCorrect={false}
                onChange={this.onChangeText}
                onSubmitEditing={this.onAddTask}
                returnKeyType={'done'}
              />
            </Item>
          </Form>
        </View>
        <View style={{ marginTop: 20 }}>
          <Button
            style={{
              backgroundColor: '#5067FF',
              margin: 25,
              justifyContent: 'center'
            }}
            onPress={this.onAddTask}
          >
            <NBText style={{ fontWeight: 'bold' }}>Add Task</NBText>
          </Button>
        </View>
      </View>
    );
  }
}

export default AddTaskScreen;
```

The snippet above uses the native base library to create a controlled input form to let the user add a new item to the todo list. Next, it has a button to add the item. Since the `Input` component from Native Base is based on the React Native's `TextInput`, you can use all the props that are available to `TextInput`.

Also, take a note that, to create an input field when using Native base as the UI library, the `Input` component has to be wrapped by an `Item` which is further wrapped inside `Form` element.

Here is a brief overview of the props used in the above snippet.

- **value**: the value of the text input. By default, it will be an empty string since we are using the local state to set it. As the state updates, the value of the text input updates.
- **placeholder**: just like in HTML, a placeholder is to define a default message in the input field indicating as if what is expected.
- **onChange**: is a callback that is called when the text input's text changes. Changed text is passed as an argument to the callback handler `onChangeText`. This handler accepts the text value from `event.nativeEvent`.
- **clearButtonMode**: a clear button should appear on the right side of the text view. The default value is `never` that you are modifying to `always` in the above component.
- **returnKeyType**: determines how the return key on the device's keyboard should look. You can find more values or platform-specific values here. Some of the values are specific to each platform.
- **autoCorrect**: this prop let us decide whether to show the autocorrect bar along with keyboard or not. In the current case, you have set it to false.
- **onSubmitEditing**: contains the business the logic in the form of a callback as to what to do when the return key or input's submit button is pressed. We will be defining this callback in Main.js.

Lastly, take a look at the method `onAddTask` which uses navigation state to save the text value of the todo item. After use presses the button or the handler `onSubmitEditing` triggers, it is going to further run the method `addTodo` from `HomeScreen` and navigate back to the `HomeScreen` itself, using the navigation props method `goBack()`.

On Clicking the Fab button, you get the following screen.

<img src='https://cdn-images-1.medium.com/max/800/1*DZNwtEddDkxQz8ZCDwqB5w.png' />

## Display each todo list item

To display each todo list item, you will have first to pass the props as shown below using the `renderItem` in the `FlatList`.

```js
<Item
  isCompleted={row.item.isCompleted}
  textValue={row.item.textValue}
  id={row.item.id}
  deleteTodo={this.deleteTodo}
  completeTodo={this.completeTodo}
  inCompleteTodo={this.inCompleteTodo}
/>
```

Next, go to `Item.js` file and add the following snippet.

```js
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions
} from 'react-native';
import { Icon } from 'native-base';

const { width } = Dimensions.get('window');

const Item = ({
  inCompleteTodo,
  completeTodo,
  textValue,
  id,
  deleteTodo,
  isCompleted
}) => {
  toggleItem = () => {
    if (isCompleted) {
      inCompleteTodo(id);
    } else {
      completeTodo(id);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.rowContainer}>
        <TouchableOpacity onPress={this.toggleItem}>
          <Icon
            name={isCompleted ? 'checkmark-circle' : 'radio-button-off'}
            style={{ paddingLeft: 10, color: '#7A7AF6' }}
          />
        </TouchableOpacity>

        <Text
          style={[
            styles.text,
            {
              opacity: isCompleted ? 0.5 : 1.0,
              textDecorationLine: isCompleted ? 'line-through' : 'none',
              color: isCompleted ? '#7A7AF6' : '#4F50DC'
            }
          ]}
        >
          {textValue}
        </Text>
      </View>
      <TouchableOpacity onPressOut={() => deleteTodo(id)}>
        <Icon name="md-trash" style={{ color: '#ABADF9', paddingRight: 10 }} />
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderBottomColor: '#5859f2',
    borderBottomWidth: StyleSheet.hairlineWidth,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  text: {
    color: '#4F50DC',
    fontSize: 18,
    marginVertical: 20,
    paddingLeft: 10
  },

  rowContainer: {
    flexDirection: 'row',
    width: width / 2,
    alignItems: 'center'
  }
});

export default Item;
```

In the above snippet, the key points to note are, using Native Base, you can use the `Icon` component (_since you are already loading the Ionicons library in the parent component asynchronously_). Next, the props `Item` components receive are to toggle an item's state of whether it is complete or not, display the text value of the item and lastly, a button to delete the item itself.

Save the component file, hop back on the simulator file, and try adding one or many items in this list.

<img src='https://cdn-images-1.medium.com/max/800/1*dceKxEqQMGXk0h_-J75gFg.gif' />

See everything works. Even on refreshing the app, and the items do not disappear.

## Bonus Section: Adding a Segment

In this section, you are going to separate the UI for managing the completed list of items and items that are pending to be done. To provide this feature, you are going to use Native Base library solely.

Keeping the data source same from the storage API, let modify the state by adding one more property. Open `HomeScreen.js` file and add the following.

```js
// add "filter" to existing the state
state = {
  todos: {},
  isDataReady: false,
  filter: 'Todo'
};
```

The value of the `filter` is going to be `Todo` by default. This means it is going to show the pending todo list items as the home screen to the user.

Next, you are going to add another handler function called `filteredItems`. This method will evaluate the value of the state and filter the values from the `todos` to match the state. Again, to use JavaScript filter method, you are going to convert `todos` object using lodash method `_values`.

```js
filteredItems = () => {
  if (this.state.filter === 'Todo') {
    return _values(this.state.todos).filter(i => {
      return !i.isCompleted;
    });
  }
  if (this.state.filter === 'Complete') {
    return _values(this.state.todos).filter(i => {
      return i.isCompleted;
    });
  }
  return this.state.todos;
};
```

Next, let us modify the render method to achieve the desired result. Inside the render method, you are going to add a new UI element from Native base called `Segment`. This is going to display two buttons, each of which can be activated when pressed. The activation of each this button depends on the value of the state property `filter`.

```js
// import Segment from Native Base
import { Button, Text as NBText, Segment } from 'native-base'

// inside the render method...

const { isDataReady, filter } = this.state

// just before flatlist add a new view

    <View style={styles.contentHeader}>
        <Segment style={{ backgroundColor: '#ffffff' }}>
            <Button active={filter === 'Todo'} onPress={() => this.setState({ filter: 'Todo' })}>
                <NBText>Todo</NBText>
            </Button>
            <Button
                last
                active={filter === 'Complete'}
                onPress={() => this.setState({ filter: 'Complete' })}
            >
                <NBText>Complete</NBText>
            </Button>
        </Segment>
    </View>

// styles corresponding to the new View element

contentHeader: {
    alignItems: 'center',
    justifyContent: 'center'
}
```

Lastly, change the value of the `data` prop on `FlatList` and set it to the item returned from the method `filteredItems()`.

```js
<FlatList
  data={_values(this.filteredItems())}
  // rest remains same
/>
```

You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*FBBSWT3Xztc0G9wAGnz1yA.gif' />

## Conclusion

_Congratulations!_ You have just learned how to build an offline mobile application using latest tech stack and libraries like React Native, Expo, and Native Base component UI. You have learned many key points in this tutorial, and I hope you enjoyed following it, and reading it. Use the knowledge you have gained in this tutorial in a realtime application and show it to your peers. The possibilities to enhance this application or the use the knowledge is endless.

---

## Bypass CORS to fetch files when working with localhost
Slug: bypass-cors-when-working-with-localhost

Sometime back I learned about [opening files or directories using the `open` command from the CLI on a Mac](/blog/how-to-open-any-folder-from-terminal-in-finder-on-mac/). It's simple yet effective.

Another use case that I've been using it for is to open the current project when in `localhost` in the browser and bypass the CORS policy to fetch files that are also available locally.

```shell
open -a "Google Chrome Canary"  --args --user-data-dir="/tmp/chrome_dev_test" --disable-web-security
```

The argument passed in the above command overrides the browser's default behavior.

---

## Change the color of hidden files and folders in VS Code
Slug: change-color-of-hidden-files-folders-in-vscode

> **Last update:** 17 December, 2023

I often switch between dark and light themes in VS Code to keep my coding environment fresh and engaging. My preference leans towards [light themes](https://amanhimself.dev/blog/setup-macbook-m1/#themes), such as pre-installed Quiet Light.

## Customizing the morgan.code theme

My latest choice is the [morgan.code theme](https://marketplace.visualstudio.com/items?itemName=morgan-codes.morgan-codes-vscode-theme), crafted by [Morgan Richardson](https://www.instagram.com/morgan.codes/). Its contrasting colors are particularly soothing for my eyes.

After using this theme for some time, I noticed a longing for a familiar sight &mdhash; files and folders ignored by git displayed in a specific shade of gray. The **morgan.code** theme, however, presents these items in a blue-ish tone, possibly Cyan or Aqua.

![Original theme](https://i.imgur.com/J6hik7g.jpg)

## Changing ignored files and folders color

VS Code has a property named `gitDecoration.ignoredResourceForeground` for customizing the color of ignored files and folders. This property when used in conjunction with [`workbench.colorCustomizations`](https://code.visualstudio.com/api/references/theme-color) allows overriding the default theme color.

Here is how I adjusted the color setting in my `settings.json`:

```json
{
  // ...
  "workbench.colorCustomizations": {
    // select theme you want to apply color customization value
    "[morgan.codes]": {
      "gitDecoration.ignoredResourceForeground": "#434343"
    }
  }
}
```

With this simple tweak, the ignored files and folders now appear in a familiar gray. My optic nerves are happy again.

![customized theme](https://i.imgur.com/sk0tFYi.jpg)

## Conclusion

The level of customization in VS Code allows, never ceases to amaze me.

---

## Change comment color visibility in a VS Code theme
Slug: change-comment-color-visibility-in-a-vs-code-theme

Switching to a different theme in VS Code can often lead to a mismatch in personal preferences. I enjoy personalizing themes with subtle modifications, especially when I find one theme that suits my taste.

I recently started using [Digi-Angler Dark theme](https://marketplace.visualstudio.com/items?itemName=Digi-Angler.digi-angler-dark-theme), a variant of the renowned [Dracula color scheme](https://draculatheme.com/). Returning to a dark theme after a while felt like familiar territory, reminiscent of my years using the Dracula theme in VS Code.

## The issue with the comment color

Using Digi-Angler, one thing that is a bit too much for me is the color value used for code comments. I prefer comment colors that blend into the background, a preference shaped by my experiences across various code editors, terminal apps, and even while reading code on documentation sites. The sharp, eye-catching color used for comments in this theme didn't sit well with me.

## Customizing comment color in VS Code

To address this, I stumbled upon `editor.tokenColorCustomizations` in VS Code. It is a feature that allows altering specific color values in the active theme. You add this property to your editor's `settings.json` file and specify the scope for the desired change.

## Using textMateRules for Token Customization

VS Code's tokenization engine is based on [TextMate grammars](https://macromates.com/manual/en/language_grammars), and the customization is done within `textMateRules`. Here's how you can change the comment color:

```json
{
  "editor.tokenColorCustomizations": {
    "textMateRules": [
      {
        "scope": "comment",
        "settings": {
          "foreground": "#9c9c9c"
        }
      }
    ]
  }
}
```

The above code snippet applies the comment color `#9c9c9c` to all themes you use inside VS Code. It also means when you switch from one theme to another, this comment will remain consistent.

## Theme specific customization

To tweak the token value for a particular theme, wrap `textMateRules` with the theme name. The following examples demonstrate defining the name of the `[theme]` only applies the comment color `#9c9c9c` for that theme.

```json
{
  "editor.tokenColorCustomizations": {
    "[Digi-Angler Dark Theme]": {
      "textMateRules": [
        {
          "scope": "comment",
          "settings": {
            "foreground": "#9c9c9c"
          }
        }
      ]
    }
  }
}
```

## Conclusion

VS Code's flexibility in customization is a significant advantage. It allows you to tailor any theme to your liking. To learn more about syntax highlighting, tokens, and scopes, see [VS Code documentation](https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#textmate-tokens-and-scopes).

---

## Change cursor color in VS Code to use a linear gradient
Slug: change-cursor-color-in-vscode

> **Note**: With the latest VS Code version, it seems the options to tweak cursor has been disabled, so the following the strategy will not work.

Until yesterday, I was unaware that I could change the cursor color in VS Code. Not only just change the color but also use a linear gradient.

All thanks to VS Code's customizability. It gets this behavior from the Monaco editor. You can find extensive [documentation and a playground](https://microsoft.github.io/monaco-editor/) for Monaco Editor's API.

## Install APC Customize UI++

The extension [APC Customize UI++](https://marketplace.visualstudio.com/items?itemName=drcika.apc-extension) allows customizations that are beyond VS Code's abilities. Mostly because VS Code is an electron app and like any other electron app, uses CSS and JS.

After [installing the extension](https://marketplace.visualstudio.com/items?itemName=drcika.apc-extension), open command palette in VS Code and then run: Enable APC extension. This will enable this extension and any custom settings you're going to apply in the next session, VS Code will automatically ask to restart the editor.

## Find a gradient

Find a gradient combination. For my use case, I used [webgradients.com](https://webgradients.com/) which has a collection of free 180 linear gradients.

## Customize the color of the cursor

To use APC extension, open `settings.json` file in the VS Code editor. Then, create a block to define the additional stylesheet definitions.

```json
{
  "apc.stylesheet": {
    ".monaco-editor .cursor":
  }
}
```

The `.monaco-editor .cursor` accepts a CSS value. You can set the `linear-gradient()` function value on the `background` property:

```json
{
  "apc.stylesheet": {
    ".monaco-editor .cursor": "background: linear-gradient(to bottom, #FF8F00 0%, #FF204E 100%);"
  }
}
```

That's it! On restarting the VS Code editor, the blinking cursor has the linear gradient value is applied to it.

![Linear gradient applied to cursor in VS Code.](/images/change-cursor-color-vscode.png)

---

## Change PICO-8 cart storage location on macOS
Slug: change-pico-8-cart-storage-location

PICO-8 stores its configuration and cartridges on macOS by default in the user Library directory:

```bash
/Users/Username/Library/Application Support/pico-8/carts/
```

While this location might work for some enthusiasts and game developers, I prefer to keep all of my hobby project's source code and saved files in a single directory. This approach makes it easier to manage backups without searching in multiple locations on my macOS.

**This default directory path is also defined in the PICO-8 configuration file** (`pico-8/config.txt`) under the `-root-path` parameter:

```plain
// Location of pico-8's root folder
root_path /Users/Username/Library/Application Support/pico-8/carts/
```

To change this location, you can edit the PICO-8 configuration file to point to your desired directory for storing cartridges. For example, I change it to:

```plain
root_path /Users/Username/Documents/Code/pico-8-carts/
```

Before making this change, close the PICO-8 app before editing the configuration file. Additionally, you must have opened the PICO-8 app at least once. Otherwise, there will be no `config.txt` file created if you have only copied the `PICO-8.app` to your `Applications` directory without launching it.

Finally, backing up your cartridges before changing the storage locations is important.

---

## Chat app with React Native (Part 1) - Build reusable UI form elements using react-native-paper
Slug: chat-app-with-react-native-part-1

![cover](https://i.imgur.com/ROYjoYo.jpg)

This year, the React Native community has seen a lot of changes. Starting from community adaption of React Hooks, the official documentation having [new domain](http://reactnative.dev/), one of the most popular library `react-navigation` adopting a more dynamic and component-based approach to add routes to your apps and lastly, `react-native-firebase` the go-to package to use Firebase SDK, released its sixth version with some improvements.

In this tutorial series, I am going to use all of the latest version packages described previously to showcase how to build an app with React Native in 2020. You are going to learn a lot about these libraries while following along as well as build a chat app.

The purpose of this tutorial is to get you familiar with all the latest updates in React Native world and its libraries such as `react-navigation` and `react-native-firebase` that are often the choice. If you wish to add a new feature that is not covered in this tutorial, feel free to do that and follow along at your own pace.

## Requirements

The following requirements are going to make sure you have a suitable development environment:

- Node.js above `10.x.x` installed on your local machine
- JavaScript/ES6 basics
- watchman the file watcher installed
- `react-native-cli` installed through npm or access via npx
- [`react-navigation`](https://reactnavigation.org/docs/getting-started)
- [`Firebase`](http://console.firebase.google.com/) project
- [`react-native-firebase`](https://rnfirebase.io/)
- [`react-native-paper`](https://reactnativepaper.com/)

For a complete walkthrough on how you can set up a development environment for React Native, you can go through official documentation here.

Also, do note that the following tutorial is going to use the react-native version `0.61.5`. Please make sure you are using a version of React Native above `0.60.x`.

## Installing libraries

To begin, start by creating a new React Native project and installing libraries as described in the following steps. You are going to need to open a terminal window for this process.

```shell
npx react-native init ChatApp

# navigate inside the project directory
cd ChatApp

# install following libraries for navigationOptions
yarn add @react-navigation/native @react-navigation/stack react-native-reanimated
react-native-gesture-handler react-native-screens
react-native-safe-area-context
@react-native-community/masked-view
react-native-paper react-native-vector-icons
```

After installing the dependencies, please make sure to follow instructions given in their official documentation to configure their native binaries to make it work with React Native.

- [`react-native-paper`](https://callstack.github.io/react-native-paper/getting-started.html)
- [`react-navigation`](https://reactnavigation.org/docs/getting-started)

These instructions may change in the future, so it is better to follow the official documentation.

iOS users, make sure to install pods via [cocoapods](https://cocoapods.org/) where ever necessary.

## Creating reusable form elements

In this section, let us create some reusable form components such as `FormInput` and `FormButton`. These UI components are going to be used in two screens: Login and Signup.

The advantage these reusable form components are going to give is that you do not have to write the same common code again and again for both screen components.

At the root of this React Native app, create a new directory called `src/` and inside it create a new directory called `components/`.

Inside this directory, create a new file called `FormInput.js`. This component is going to provide a Text Input field for the screen components to use and for the user to enter the credentials.

Start by importing the following statements.

```js
import React from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import { TextInput } from 'react-native-paper';
```

[`Dimensions`](https://reactnative.dev/docs/dimensions) from React Native core API, provides a way to get the screen width and height. Instead of giving the fix width and height to a text input field, let this API calculate it for us. You can get the application's screen and height by adding the following snippet.

```js
const { width, height } = Dimensions.get('screen');
```

Next, export the default function `FormInput` that is going to have some props.

```js
export default function FormInput({ labelName, ...rest }) {
  return (
    <TextInput
      label={labelName}
      style={styles.input}
      numberOfLines={1}
      {...rest}
    />
  );
}
```

The `...rest` props must be the last prop passed as a parameter, otherwise, you are going to get an error. The purpose of passing this prop is to allow the component to have other props value.

Lastly, define the corresponding styles for this reusable component.

```js
const styles = StyleSheet.create({
  input: {
    marginTop: 10,
    marginBottom: 10,
    width: width / 1.5,
    height: height / 15
  }
});
```

The next reusable component is going to be in a separate file called `FormButton.js`. It is similar to `FormInput` except that this component is going to be used to display a button on the screen.

It is also going to use the width and height of the screen using `Dimensions` from React Native.

Here is the complete code snippet:

```js
import React from 'react';
import { StyleSheet, Dimensions, Text } from 'react-native';
import { Button } from 'react-native-paper';

const { width, height } = Dimensions.get('screen');

export default function FormButton({ title, modeValue, ...rest }) {
  return (
    <Button
      mode={modeValue}
      {...rest}
      style={styles.button}
      contentStyle={styles.buttonContainer}
    >
      {title}
    </Button>
  );
}

const styles = StyleSheet.create({
  button: {
    marginTop: 10
  },
  buttonContainer: {
    width: width / 2,
    height: height / 15
  }
});
```

The `react-native-paper` UI library, has three modes to display a button.

- `text`: a flat button without background or outline
- `outlined`: a button with the outline
- `contained`: a button with background color and elevation shadow

For different purposes, you are going to make use of different button modes. You will see them in screen components later. That is why it is better to accept the value as a prop (_as mentioned in the above snippet: `modeValue`_).

## Create a login screen

To being implementing screens in the current app, start by creating the most essential screen called `LoginScreen`. This is going to be the initial route when the user is not authenticated or authorized to enter the app and use its features.

Here is a demo of the screen you are going to achieve in this section.

<img src='https://miro.medium.com/max/700/1*IGoOjbiB5pWNogRPqfl7rA.png' />

Inside `src/`, create another directory called `screens/`. In this directory, we are going to store all screen components. Inside it, also create `LoginScreen.js`.

The Login screen is going to have four main UI elements:

- two text input fields for user's email and password
- one login button and one button to navigate to sign up screen (_in case the end-user is not registered to use the app_)

Start by importing the following statements.

```js
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Title } from 'react-native-paper';
import FormInput from '../components/FormInput';
import FormButton from '../components/FormButton';
```

Inside the `LoginScreen` functional component, define two state variables:

- `email`
- `password`

Both of these variables are going to be used with the `FormInput` component to obtain the value of the user credentials. By default, they are going to have an empty string as its value.

```js
export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  return (
    <View style={styles.container}>
      <Title style={styles.titleText}>Welcome to Chat app</Title>
      <FormInput
        labelName="Email"
        value={email}
        autoCapitalize="none"
        onChangeText={userEmail => setEmail(userEmail)}
      />
      <FormInput
        labelName="Password"
        value={password}
        secureTextEntry={true}
        onChangeText={userPassword => setPassword(userPassword)}
      />
      <FormButton
        title="Login"
        modeValue="contained"
        labelStyle={styles.loginButtonLabel}
      />
      <FormButton
        title="New user? Join here"
        modeValue="text"
        uppercase={false}
        labelStyle={styles.navButtonText}
      />
    </View>
  );
}
```

Do note that each of the `FormInput` elements has different props being passed. For example, The email component has `autoCapitalize` set to `none`. The password component has `secureTextEntry` set to boolean true. Including others, this is where `...rest` becomes helpful (_as you have seen in the previous section_).

The `onChangeText` prop accepts a callback that is invoked whenever the text of the input field changes.

Lastly, here are the styles.

```js
const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f5f5f5',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  titleText: {
    fontSize: 24,
    marginBottom: 10
  },
  loginButtonLabel: {
    fontSize: 22
  },
  navButtonText: {
    fontSize: 16
  }
});
```

Do notice that, you are using a JavaScript object to define styles for each component so far. `StyleSheet` in React Native provides an API to create styles inside the component file. It takes a JavaScript object as it does above, and returns a new `Stylesheet` object from it. There are no _classes_ or _ids_ in React Native like in web development. To create a new style object you use `StyleSheet.create()` method.

The way you have defined styles by creating an object is the preferred way. Not only it helps you organize styles and keep them separate, but these styles when defined in this manner are also sent through the native render bridge only once (_unlike inline styles_).

## Create a signup screen

If the user is not registered to use the app but wants to make a new account to get authorized, this where the signup screen becomes useful.

<img src='https://miro.medium.com/max/700/1*a_LZfux_VkejnIgdZ0MjIQ.png' />

Create a new file called `SignupScreen.js` inside `src/screens/` directory. It is going to be similar to the login screen that you created in the previous section in many ways. I am going to leave it to you to find similarities and differences between the two screens. Take a look at the code snippet for the signup screen below.

```js
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Title, IconButton } from 'react-native-paper';
import FormInput from '../components/FormInput';
import FormButton from '../components/FormButton';

export default function SignupScreen({ navigation }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  return (
    <View style={styles.container}>
      <Title style={styles.titleText}>Register to chat</Title>
      <FormInput
        labelName="Email"
        value={email}
        autoCapitalize="none"
        onChangeText={userEmail => setEmail(userEmail)}
      />
      <FormInput
        labelName="Password"
        value={password}
        secureTextEntry={true}
        onChangeText={userPassword => setPassword(userPassword)}
      />
      <FormButton
        title="Signup"
        modeValue="contained"
        labelStyle={styles.loginButtonLabel}
      />
      <IconButton
        icon="keyboard-backspace"
        size={30}
        style={styles.navButton}
        color="#6646ee"
        onPress={() => navigation.navigate('Login')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f5f5f5',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  titleText: {
    fontSize: 24,
    marginBottom: 10
  },
  loginButtonLabel: {
    fontSize: 22
  },
  navButtonText: {
    fontSize: 18
  },
  navButton: {
    marginTop: 10
  }
});
```

The major difference in the above component snippet is that you are going to use an `IconButton` to navigate from the signup screen to log in screen. This is provided by `react-native-paper` and is actually a button that displays an icon without any label.

## Create an auth stack navigator

There are going to be two stack navigators in the current app. The first navigator is going to be called `AuthStack`.

It is going to contain only those screens which allow the user to add their credentials or create credentials. Thus, login screen and sign up screen as routes, where the login screen is going to the initial route. You will learn more about the second stack later.

Create a new directory `src/navigation/`. This directory is going to contain all the routes and other necessary components to build the navigation in the app.

Inside this directory, create a new file called `AuthStack.js`. This file is going to have a stack navigator.

Start by importing the following statements including both screen components.

```js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import SignupScreen from '../screens/SignupScreen';
import LoginScreen from '../screens/LoginScreen';
```

A **Stack Navigator** provides the React Native app to transit between different screens similar to how the navigation in a web browser works. It pushes or pops a screen when in the navigational state.

Next, create an instance of a stack navigator as below.

```js
const Stack = createStackNavigator();
```

Navigators are defined declaratively using version 5 of `react-navigation`. It follows a more component based approach, similar to that of `react-router` in web development using Reactjs (if you are familiar with it).

The `createStackNavigator` is a function used to implement a stack navigation pattern. This function returns two React components: `Screen` and `Navigator`, that help us configure each component screen as shown below.

```js
export default function AuthStack() {
  return (
    <Stack.Navigator initialRouteName="Login" headerMode="none">
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen name="Signup" component={SignupScreen} />
    </Stack.Navigator>
  );
}
```

The `Stack.Navigator` takes those prop values that are common to each screen route. For example, generally, the stack navigator adds a header to each screen inside it. For the current stack, you are not going to require a header on each screen. Thus, setting `headerMode` to the value of `none` fulfills it.

The `headerMode` prop specifies how the header should be rendered for each screen in the stack. Setting it to `none`, specifies that it should not be rendered at all. You can find the other values for this mode [here](https://reactnavigation.org/docs/stack-navigator/#headermode).

The `initialRouteName` is the name of the route to render on the first load of the navigator.

You can learn more Stack Navigator and its common properties in the post [here](https://heartbeat.fritz.ai/getting-started-with-stack-navigator-using-react-navigation-5-in-react-native-and-expo-apps-4c516becaee1).

To make the navigation between Login to sign up screen work, you have to add the `navigation` prop to each component. Go to the `LoginScreen.js` file and pass the `navigation` prop reference as a parameter.

```js
export default function LoginScreen({ navigation }) {
  // ...
}
```

This prop reference provides a set of functions ready to dispatch as actions for each screen component. Do note that, you can only pass it those screen components that are routes for one of the navigators.

For example, in the login screen component, to navigate to sign up screen, add the `onPress` prop to the last `FormButton`. The `navigation.navigate` accepts the value of the screen to navigate to, from the current screen.

```js
<FormButton
  title="New user? Join here"
  modeValue="text"
  uppercase={false}
  labelStyle={styles.navButtonText}
  onPress={() => navigation.navigate('Signup')}
/>
```

Similarly, open `SignupScreen.js` screen file, and pass the prop reference for `navigation`.

```js
export default function SignupScreen({ navigation }) {
  // ...
}
```

Next, add the `onPress` prop to the `IconButton`.

```js
<IconButton
  icon="keyboard-backspace"
  size={30}
  style={styles.navButton}
  color="#6646ee"
  onPress={() => navigation.goBack()}
/>
```

The `goBack()` action closes the active screen (Signup screen) and moves back in the stack (Login screen).

For more information on the `navigation` prop, check out the official reference [here](https://reactnavigation.org/docs/navigation-prop/).

## Add a navigation container

Both of our screen components are now configured for the navigation to work. In this section, let us add the missing piece called `NavigationContainer` to make sure the current navigation in the auth stack works.

Create a new file called `Routes.js` inside `src/navigation/` directory. This file is going to contain all the stacks that the app is going to have, but for now, the auth stack.

```js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import AuthStack from './AuthStack';

export default function Routes() {
  return (
    <NavigationContainer>
      <AuthStack />
    </NavigationContainer>
  );
}
```

The `NavigationContainer` is a component that manages the navigation tree. It also allows the screen components to refer to the `navigation` prop reference. This is done by wrapping all the navigatorâ€™s structure.

## Wrapping with the paper provider

Create a file called `index.js` inside `src/navigation/` directory.

To make UI components from `react-native-paper` to work, you have to wrap all the routes inside `PaperProvider` as shown below.

```js
import React from 'react';
import { Provider as PaperProvider } from 'react-native-paper';
import Routes from './Routes';

/**
 * Wrap all providers here
 */

export default function Providers() {
  return (
    <PaperProvider>
      <Routes />
    </PaperProvider>
  );
}
```

The `PaperProvider` component provides the theme to all the components in the framework. It also acts as a portal to components that need to be rendered at the top level.

This is a mandatory step. The reason to create a separate `Providers` component and wrap `Routes` and not wrap the `App` component (as mentioned in official docs [here](https://callstack.github.io/react-native-paper/getting-started.html#usage)) is that there going to be some custom providers later in this app. So to manage all the providers, it is better if you create a separate file.

## Conclusion

The form of screen components is now complete. To make sure they are working as desired, open up a terminal window and build the app for a specific mobile platform.

```shell
# for ios
npx react-native run-ios

# for android
npx react-native run-android
```

Then, go to the simulator and you are going to get the following result.

<img src='https://miro.medium.com/max/684/1*7UqfiUWxFDtSyR2_CQoigQ.gif' />

---

## Whatâ€™s Next?

In part one of this tutorial series, youâ€™ve successfully built a navigation flow using the react-navigation library, set up a stack navigator, and learned how to use pre-defined UI components from react-native-paper to create reusable custom form components.

In the [next part](https://amanhimself.dev/blog/chat-app-with-react-native-part-2) of this series, weâ€™ll learn how to install the Firebase SDK, how to generate and add Firebase credentials and API keys for iOS apps, implement an email sign-in provider with Firebase, and thus, use the navigation flow with a real-time backend service.

You can find the complete source code for this project at [this Github repo](https://github.com/amandeepmittal/react-native-examples/tree/master/ChatApp).

---

ðŸ‘‰ Here is a list of resources used in this tutorial.

- Learn more about [`navigation prop reference`](https://reactnavigation.org/docs/navigation-prop/)
- [`Dimensions`](https://reactnative.dev/docs/dimensions) API in React Native
- Getting started with stack navigator using `react-navigation` v5 [here](https://heartbeat.fritz.ai/getting-started-with-stack-navigator-using-react-navigation-5-in-react-native-and-expo-apps-4c516becaee1)

---

ðŸ’™ To learn more about React Native, check out these resources:

- [Official documentation](http://reactnative.dev/)

Originally published at [Heartbeat.Fritz.Ai](https://heartbeat.fritz.ai/chat-app-with-react-native-part-1-build-reusable-ui-form-elements-using-react-native-paper-75d82e2ca94f)

---

## Chat app with React Native (Part 2) - Firebase Email Authentication with react-native-firebase
Slug: chat-app-with-react-native-part-2

![cover](https://i.imgur.com/ROYjoYo.jpg)

In [the first part of this tutorial series](https://amanhimself.dev/blog/chat-app-with-react-native-part-1) to build a chat-based app in React Native, we learned how to create reusable form elements using the react-native-paper UI library. Along with that, we learned how to install the navigation library react-navigation and configure a basic authentication stack navigator using two routes.

In this tutorial, let us start using a backend service to add real-time features to the Chat app. For backend services, I am going to use Firebase. You are going to learn how to install and configure Firebase SDK in a react native app with the help of [`react-native-firebase`](https://rnfirebase.io/) module as well as set up and configure Email authentication. In order to follow this tutorial and future posts, you are required to use a Firebase project.

## Create a new Firebase project from console

To access the Firebase credentials for each mobile OS platform and configure them to use Firebase SDK, create a new Firebase project or use one if you have access already from [Firebase console](http://console.firebase.google.com/), you can skip this step.

Create a new project as shown below.

<img src='https://miro.medium.com/max/1400/1*wYi5SITEofv4nuIAPnQglg.png' />

Complete the details of your Firebase project:

<img src='https://miro.medium.com/max/1090/1*UDDFg0ZBF7w1jwRRIqxcwA.png' />

Click the button **Create project** and you are going to be redirected to the dashboard screen. That's it. You have successfully created a new Firebase project.

Now make sure that the **Email** **Sign-in method** is enabled. From the Firebase console and navigate to **Authentication** section from the side menu.

<img src='https://miro.medium.com/max/257/1*mGwJz9i3SAzboUgZhs21Ng.png' />

Go to the second tab **Sign-in method** and make sure to enable the **Email** sign-in provider.

<img src='https://miro.medium.com/max/1400/1*lYvrmJXPQBRrs8Xpvqn05w.png' />

## Add Firebase SDK to React Native app

If you have used `react-native-firebase` version 5 or below, you must have noticed that it was a monorepo that used to manage all Firebase dependencies from one module.

Version 6 of this library wants you to only install those dependencies based on Firebase features that you want to use. For example, in the current app, to support the email authentication feature you are going to install the auth and core app package.

From the terminal window execute the following command.

```shell
yarn add @react-native-firebase/app @react-native-firebase/auth
```

## Add Firebase credentials to your iOS app

Firebase provides a file called `GoogleService-Info.plist` that contains all the API keys as well as other credentials for iOS devices to authenticate the correct Firebase project.

To get these credentials, go to back to the [Firebase console](http://console.firebase.google.com/) in a browser window. From the dashboard screen of your Firebase project, open **Project settings** from the side menu.

<img src='https://miro.medium.com/max/241/1*Vh9zbrjZEGjKJl0XDCfFQQ.png' />

Go to **Your apps** section and click on the icon iOS to select the platform.

<img src='https://miro.medium.com/max/1396/1*nYRgVjO8DFSOdOJhPU-1DA.png' />

Enter the application details and click on **Register app**.

<img src='https://miro.medium.com/max/1270/1*Z1v4E3vhPGXmwfwrFtaxsA.png' />

Then download the `GoogleService-Info.plist` file as shown below.

<img src='https://miro.medium.com/max/1400/1*mKKqIHaDcv2UQsG-3idn7Q.png' />

Open Xcode, then open the file `/ios/ChatApp.xcodeproj` file. Right-click on the project name and **Add Files** option, then select the file to add to this project.

<img src='https://miro.medium.com/max/273/1*800RInfgPmKJXt_k58xQ4w.png' />

Then open `ios/ChatApp/AppDelegate.m` and add the following header.

```c
#import <Firebase.h>
```

In the same file, within the `didFinishLaunchingWithOptions` method, add the following configure method.

```c
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    if ([FIRApp defaultApp] == nil) {
      [FIRApp configure];
    }
```

Lastly, go back to the terminal window to install pods.

```js
cd ios/ && pod install
# after pods are installed
cd ..
```

Make sure you build the iOS app.

```js
npx react-native run-ios
```

That's it. The configuration to set up a Firebase SDK and credentials in a React Native app is complete.

## Create a home screen

In the previous post, you have successfully configured an Auth stack that displays those screens when the end-user is not authorized or logged in inside the app. There are a set of screens that are only going to be accessible to the user when they are logged in. Let us call the group of screens that are visible after login, home stack.

One such screen is going to be a home screen where all the chat rooms are going to be listed. In this section, let us start by creating a basic home screen such that you can complete navigational flow between the home stack and the auth stack.

Create a new screen component called `HomeScreen.js` inside `src/screens/` directory with the following code snippet.

```js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Title } from 'react-native-paper';

export default function HomeScreen() {
  return (
    <View style={styles.container}>
      <Title>Home Screen</Title>
      <Title>All chat rooms will be listed here</Title>
      <FormButton modeValue="contained" title="Logout" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f5f5f5',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
```

## Create home stack navigator

Create a new stack navigator file called `HomeStack.js` inside `src/navigation.js` that is going to have those routes which are only available after logging in. You can think of these routes as protected routes.

Open this file and add the following code snippet. Nothing new is going in terms of creating a stack navigator as shown below.

```js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import HomeScreen from '../screens/HomeScreen';

const Stack = createStackNavigator();

export default function HomeStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Home" component={HomeScreen} />
    </Stack.Navigator>
  );
}
```

## Create an auth provider

In this section, you are going to create an authentication provider to check whether the user is logged in or not and access them if they are logged in.

Create a new file called `AuthProvider.js` inside `src/navigation/`. Start by importing the following statements.

```js
import React, { createContext, useState } from 'react';
import auth from '@react-native-firebase/auth';
```

Then create an `AuthContext` and make sure to export it since you are going to use it on several different screens.

```js
export const AuthContext = createContext({});
```

In Reactjs, the [Context API](https://reactjs.org/docs/context.html#reactcreatecontext) is designed to share data that is considered global for a tree of React components. When you are creating a context (like above), there is a requirement to pass a default value. This value is used when a component does not have a matching Provider.

The Provider allows the React components to subscribe to the context changes. To create an auth provider, export a function called `AuthProvider`. This provider is going to allow the screen components to access the current user in the application. Define a state variable called `user`.

```js
export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  return (
    <AuthContext.Provider
      value={{
        user,
        setUser,
        login: async (email, password) => {
          try {
            await auth().signInWithEmailAndPassword(email, password);
          } catch (e) {
            console.log(e);
          }
        },
        register: async (email, password) => {
          try {
            await auth().createUserWithEmailAndPassword(email, password);
          } catch (e) {
            console.log(e);
          }
        },
        logout: async () => {
          try {
            await auth().signOut();
          } catch (e) {
            console.error(e);
          }
        }
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};
```

In the `value` prop above, also define some functions. These functions are now available to be used anywhere in the screens component tree using React Context.

Each of the functions is consuming Firebase methods to interact with real-time Firebase backend service. Both the login and register functions require the user's `email` and `password` to verify/save credentials. The logout method invokes a simple `signOut()` method. All these Firebase methods are available from the `@react-native-firebase/auth` package. Do note that, all these functions are asynchronous actions and thus, using `async await` syntax helps.

## Wrapping routes with auth provider

Now, that the provider is created, but how to use for a set of components in the current app tree? Well, you have to wrap this provider around the `Routes` such as to use the helper functions as well as the value of current `user` (as described above) in the screen components.

Open `navigation/index.js` file and modify it as follows.

```js
import React from 'react';
import { Provider as PaperProvider } from 'react-native-paper';
import { AuthProvider } from './AuthProvider';
import Routes from './Routes';

/**
 * Wrap all providers here
 */

export default function Providers() {
  return (
    <PaperProvider>
      <AuthProvider>
        <Routes />
      </AuthProvider>
    </PaperProvider>
  );
}
```

Remember, from the previous post, we added that comment that to wrap all components using all providers in this file? Well, that's what this file is for.

## Check if the user is logged in or not

To check if the user is logged or not, let us modify the `navigation/Routes.js` file. Using the value of the `user` from the auth provider, you are going to switch between the stack navigators. To start, make sure you imported the following statements.

```js
import React, { useContext, useState, useEffect } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import auth from '@react-native-firebase/auth';
import AuthStack from './AuthStack';
import HomeStack from './HomeStack';
import { AuthContext } from './AuthProvider';
import Loading from '../components/Loading';
```

From the above snippet, ignore the `Loading` component for now. You are going to create it at the end of this section.

Now, inside the `Routes` function, you are two define two state variables `initializing` and `loading` to check whether the user's state is logged in or not. Also, from the context value, fetch `user` and `setUser`.

Then, define a function called `onAuthStateChanged` which is going to handle user state changes. Using `useEffect` hook, you can subscribe to this state change function and make sure you unsubscribe it when the component unmounts. This method allows you to subscribe to real-time events when the user performs an action. The action here can be, logging in, signing out, and so on.

```js
export default function Routes() {
  const { user, setUser } = useContext(AuthContext);
  const [loading, setLoading] = useState(true);
  const [initializing, setInitializing] = useState(true);

  // Handle user state changes
  function onAuthStateChanged(user) {
    setUser(user);
    if (initializing) setInitializing(false);
    setLoading(false);
  }

  useEffect(() => {
    const subscriber = auth().onAuthStateChanged(onAuthStateChanged);
    return subscriber; // unsubscribe on unmount
  }, []);

  if (loading) {
    return <Loading />;
  }

  return (
    <NavigationContainer>
      {user ? <HomeStack /> : <AuthStack />}
    </NavigationContainer>
  );
}
```

Lastly, create a new component file called `Loading.js` inside `src/components/` directory. This component is going to be responsible to display a loading spinner.

```js
import React from 'react';
import { View, ActivityIndicator, StyleSheet } from 'react-native';

export default function Loading() {
  return (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" color="#6646ee" />
    </View>
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

## Completing the app

In order for the user to perform auth actions in the app, you have to use the context in each of the screen components for different actions.

Start by opening `LoginScreen.js`. Import `useContext` from react and `AuthContext` from `AuthProvider`.

```js
import React, { useState, useContext } from 'react';
// rest of the import statements remain same
import { AuthContext } from '../navigation/AuthProvider';

export default function LoginScreen({ navigation }) {
  const { login } = useContext(AuthContext);

  // rest remains statements
}
```

Inside the `LoginScreen` function, make sure to add an `onPress` prop as shown below.

```js
<FormButton
  title="Login"
  modeValue="contained"
  labelStyle={styles.loginButtonLabel}
  onPress={() => login(email, password)}
/>
```

Similarly, you have to modify the `SignupScreen.js` file.

```js
import React, { useState, useContext } from 'react';
// rest of the import statements remain same
import { AuthContext } from '../navigation/AuthProvider';

export default function SignupScreen({ navigation }) {
  const { register } = useContext(AuthContext);
  // rest remains statements
}

// Add the onPress prop to <FormButton />

<FormButton
  title="Signup"
  modeValue="contained"
  labelStyle={styles.loginButtonLabel}
  onPress={() => register(email, password)}
/>;
```

Lastly, modify the `HomeScreen` to add a sign out button and when the user is in the logged-in state, display their user `uid` (_the unique identifier in Firebase to differentiate and store different users_).

```js
import React, { useContext } from 'react';
import { View, StyleSheet } from 'react-native';
import { Title } from 'react-native-paper';
import { AuthContext } from '../navigation/AuthProvider';
import FormButton from '../components/FormButton';

export default function HomeScreen() {
  const { user, logout } = useContext(AuthContext);

  return (
    <View style={styles.container}>
      <Title>Home Screen</Title>
      <Title>All chat rooms will be listed here</Title>
      <Title>{user.uid}</Title>
      <FormButton
        modeValue="contained"
        title="Logout"
        onPress={() => logout()}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f5f5f5',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
```

Go to the simulator, and you are going to get similar results as shown below. Perform these steps. Try creating a new user from the sign-up screen, and you are going to get their `uid` on the home screen.

<img src='https://miro.medium.com/max/684/1*2HWlA1jyqJzAIhxgHDB0sg.gif' />

You can verify the `uid` of the current user by going to the dashboard screen from Firebase console.

<img src='https://miro.medium.com/max/1400/1*NVUhPQOP2YjgYF_qmCdXBQ.png' />

## Conclusion

_Congratulations!_ You've completed this tutorial and successfully added an authentication flow between the two stack navigators. In the next part of this series, we'll explore more features such as creating and storing chat rooms in a collection in Firestore, as well as displaying all chat rooms on the home screen. To create a new chat room, we'll create a new modal screen and make changes to the current home stack accordingly.

---

## What's Next?

In the [next post](https://amanhimself.dev/blog/chat-app-with-react-native-part-3) of this series, we are going to explore how to create a modal screen using `react-navigation` stack navigator. This modal screen is going to have separate navigator as well as to be used to create a new chat room.

Then, we are going to add Firebase NoSQL database Firestore and add a query to store the name of a chat room in a collection.

You can find the complete source code for this project at [this Github repo](https://github.com/amandeepmittal/react-native-examples/tree/master/ChatApp).

---

ðŸ‘‰ Here is a list of resources used in this tutorial:

- Reactjs [Context API](https://reactjs.org/docs/context.html#reactcreatecontext)
- [Firebase Authentication reference](https://invertase.io/oss/react-native-firebase/v6/auth/quick-start) from `react-native-firebase`
- Getting started with stack navigator using `react-navigation` v5 [here](https://heartbeat.fritz.ai/getting-started-with-stack-navigator-using-react-navigation-5-in-react-native-and-expo-apps-4c516becaee1)

Originally published at [Heartbeat.Fritz.Ai](https://heartbeat.fritz.ai/chat-app-with-react-native-part-2-firebase-user-authentication-with-react-native-firebase-533352870497).

---

## Chat app with React Native (Part 3) - Create Firestore collections to store chat rooms
Slug: chat-app-with-react-native-part-3

![cover](https://i.imgur.com/ROYjoYo.jpg)

In [part 2](https://amanhimself.dev/blog/chat-app-with-react-native-part-2) of this series, we made progress with the chat app by adding email authentication using the real-time auth service from Firebase. This ensures that we have a system in place to authenticate users.

In part 3, let's extend our progress by creating and storing chat rooms in real-time using Firestore data storage, provided by the Firebase. We'll continue to explore different tips and best practices for using `react-navigation`. For example, we'll create a modal screen and expand the home stack created in the previous post.

## How to share common header options styles using screenOptions

Let us start with a simple yet a very common technique to modify header bar options across various screens in a stack navigator. This technique is a common practice that you will find using yourself with `react-navigation`.

Start by modifying the header in the home stack such that any route that is wrapped by `HomeStack` navigator is going to have a similar background color, header tint color, and font size.

This is a common practice to configure the header bar and share style properties among different routes in the same stack navigator.

Open `src/navigation/HomeStack.js` file and add a `screenOptions` prop to `Stack.Navigator`.

```js
export default function HomeStack() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#6646ee'
        },
        headerTintColor: '#ffffff',
        headerTitleStyle: {
          fontSize: 22
        }
      }}
    >
      <Stack.Screen name="Home" component={HomeScreen} />
    </Stack.Navigator>
  );
}
```

Go back to the simulator and you are going to get the following result.

<img src='https://miro.medium.com/max/940/1*Jxk6KkKBzhv_rc9kXD6iMA.png' />

## Add a separate stack navigator for modal screen

In this section, you are going to create a modal screen that will allow the user in the app to create a new chat room. Later in this tutorial, the name of the chat room entered from this screen is going to be stored in the Firestore collection.

A _modal screen_ displays the content that temporarily blocks interactions with the main view. It is like a popup and usually has a different transition in terms of opening and closing of the screen. This mode of the screen is generally used to display one specific piece of information.

Here's a flowchart to help visualize the navigation flow we're trying to achieve by the end of this section.

<img src='https://miro.medium.com/max/1400/1*kU6S7zzWSrtwgkNI0eygiQ.jpeg' />

Start by creating a new screen file called `AddRoomScreen.js` inside `src/screens` directory with the following content.

```js
import React from 'react';
import { View, Text } from 'react-native';
import FormButton from '../components/FormButton';

export default function AddRoomScreen({ navigation }) {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>Create a new chat room</Text>
      <FormButton
        mode="contained"
        title="Close Modal"
        onPress={() => navigation.goBack()}
      />
    </View>
  );
}
```

Right now, focus adding this modal screen to the Home stack navigator rather than its contents.

Also, add a temporary button to open the modal screen in the `HomeScreen.js` file.

```js
import React, { useContext } from 'react';
import { View, StyleSheet } from 'react-native';
import { Title } from 'react-native-paper';
import { AuthContext } from '../navigation/AuthProvider';
import FormButton from '../components/FormButton';

export default function HomeScreen({ navigation }) {
  const { user, logout } = useContext(AuthContext);

  return (
    <View style={styles.container}>
      <Title>Home Screen</Title>
      <Title>All chat rooms will be listed here</Title>
      <Title>{user.uid}</Title>
      <FormButton
        modeValue="contained"
        title="Logout"
        onPress={() => logout()}
      />
      <FormButton
        modeValue="contained"
        title="Add Room"
        onPress={() => navigation.navigate('AddRoom')}
      />
    </View>
  );
}
```

Now open `src/navigation/HomeStack.js` file. In order to keep the modal as a separate route from other home stack routes (such as `HomeScreen`), let us create two new stack navigators in this file.

Start by importing the modal screen with the rest of the routes and create two new stack navigator instances. You can give a custom name to each instance.

```js
// ... rest of the import statements
import AddRoomScreen from '../screens/AddRoomScreen';

// create two new instances
const ChatAppStack = createStackNavigator();
const ModalStack = createStackNavigator();
```

From the snippet, the `ChatAppStack` is going to contain those screens routes that are do not require the use of a modal screen and focus only on the chat app features.

```js
function ChatApp() {
  return (
    <ChatAppStack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#6646ee'
        },
        headerTintColor: '#ffffff',
        headerTitleStyle: {
          fontSize: 22
        }
      }}
    >
      <ChatAppStack.Screen name="Home" component={HomeScreen} />
    </ChatAppStack.Navigator>
  );
}
```

The Modal stack is going to wrap both the `ChatAppStack` and the modal screen as routes. Modify the exported `HomeStack` as below. Make sure to set the mode of `ModalStack.Navigator` to `modal` and `headerMode` to `none`.

```js
export default function HomeStack() {
  return (
    <ModalStack.Navigator mode="modal" headerMode="none">
      <ModalStack.Screen name="ChatApp" component={ChatApp} />
      <ModalStack.Screen name="AddRoom" component={AddRoomScreen} />
    </ModalStack.Navigator>
  );
}
```

Go to the simulator. You are going to find the `Add room` button on the home screen as shown below.

<img src='https://miro.medium.com/max/940/1*pLjnE31zjSqkUwGiRS3ldA.png' />

Click on the button and notice the transition when the modal screen pops up.

<img src='https://miro.medium.com/max/684/1*iwaMYjCAkCv1Gf0UcnEiag.gif' />

## How to add an icon in the header bar

The modal stack is working as per the requirement. But the way the user would navigate from the home screen to modal is not by clicking a button in the center of the home screen. This action is going to be done by clicking an icon button from the header.

<img src='https://miro.medium.com/max/636/1*nA9W978m4sziQwKeepKSow.png' />

Luckily, the `react-navigation` library provides props for us to implement this action without any hassle. Import `IconButton` from `react-native-paper` UI library inside the file `src/navigation/HomeStack.js`.

```js
// rest of the imports
import { IconButton } from 'react-native-paper';
```

Then add an `options` prop with a function such that you are able to pass `navigation` prop reference. Add the following code to the `HomeScreen` route.

```js
<ChatAppStack.Screen
  name="Home"
  component={HomeScreen}
  options={({ navigation }) => ({
    headerRight: () => (
      <IconButton
        icon="message-plus"
        size={28}
        color="#ffffff"
        onPress={() => navigation.navigate('AddRoom')}
      />
    )
  })}
/>
```

Also, remove `FormButton` in `HomeScreen.js` you create in the previous section.

Here is how the home screen in the simulator looks like after this step.

<img src='https://miro.medium.com/max/940/1*x40CeNj7FEFO6Exg8mLa2Q.png' />

## Complete the modal screen

Right now the modal screen just displays a line of text and a close button but the real functionality this screen has to provide is to allow the user to enter the name of the chat room using an input field. Then, using a form button, add the chat room name in a Firestore collection.

Open `AddRoomScreen.js` and start by modifying the import statements.

```js
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { IconButton, Title } from 'react-native-paper';
import FormInput from '../components/FormInput';
import FormButton from '../components/FormButton';
```

Then, to add a chat room, define a state variable called `roomName` inside a functional component `AddRoomScreen`.

To modify the JSX returned from this component. Make sure to add a close button at the right corner of the screen and using custom components you can add the input field as well as the submit button.

```js
export default function AddRoomScreen({ navigation }) {
  const [roomName, setRoomName] = useState('');
  // ... Firestore query will come here later

  return (
    <View style={styles.rootContainer}>
      <View style={styles.closeButtonContainer}>
        <IconButton
          icon="close-circle"
          size={36}
          color="#6646ee"
          onPress={() => navigation.goBack()}
        />
      </View>
      <View style={styles.innerContainer}>
        <Title style={styles.title}>Create a new chat room</Title>
        <FormInput
          labelName="Room Name"
          value={roomName}
          onChangeText={text => setRoomName(text)}
          clearButtonMode="while-editing"
        />
        <FormButton
          title="Create"
          modeValue="contained"
          labelStyle={styles.buttonLabel}
          onPress={() => handleButtonPress()}
          disabled={roomName.length === 0}
        />
      </View>
    </View>
  );
}
```

Do not worry about the `handleButtonPress` method on `onPress` prop for `FormButton`. This is going to execute the Firestore query and that is what you are going to do from the next section.

The corresponding styles of the above component are defined as below.

```js
const styles = StyleSheet.create({
  rootContainer: {
    flex: 1
  },
  closeButtonContainer: {
    position: 'absolute',
    top: 30,
    right: 0,
    zIndex: 1
  },
  innerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  title: {
    fontSize: 24,
    marginBottom: 10
  },
  buttonLabel: {
    fontSize: 22
  }
});
```

If you go to the modal screen, you are going to get the following result.

<img src='https://miro.medium.com/max/940/1*ylHD71PivqxothYaSrypfg.png' />

Here is the complete flow of the `HomeStack` navigator so far.

<img src='https://miro.medium.com/max/684/1*7d5TY6H9ZznNmdJ5QRG1UQ.gif' />

The **Create** button will remain disabled unless the user starts typing.

## Add Firestore to the Chat app

To store messages as well as user information, let us use the Firestore data storage service from Firebase. Firestore has similarities to a NoSQL database (if you are familiar with NoSQL types).

To use the Firestore database, all you have to do is install the `@react-native-firebase/firestore` package and run the command to build the app again. Open up a terminal window and execute the following command.

```shell
yarn add @react-native-firebase/firestore

# do not forget to install pods for ios
cd ios / && pod install

# after pods have been installed
cd ..
```

Do note that, the Firestore package from `react-native-firebase` depends on two other packages:

- `@react-native-firebase/app`
- `@react-native-firebase/auth`

This means that these two packages are required to install to use Firestore. For the current app, you have already installed these packages so you do not have to install them again.

The last step in this section is to rebuild the app for each OS.

```shell
# for iOS
npx react-native run-ios

# for Android

npx react-native run-android
```

That's it to install Firestore.

## Create a collection in firestore to store chat rooms

Each chat room is going to contain `x` number of messages between different users. To store a chat room in the Firestore, let's create a collection called `THREADS`.

Start by importing `firestore` in the `AddRoomScreen.js` file.

```js
// after other import statements
import firestore from '@react-native-firebase/firestore';
```

Inside the functional component `AddHomeScreen` add a handler method called `handleButtonPress`.

This method is going to have the business logic to store the name of the chat room under the collection `THREADS`. The unique id of each chat room is going to be created by the Firestore itself.

```js
function handleButtonPress() {
  if (roomName.length > 0) {
    firestore()
      .collection('THREADS')
      .add({
        name: roomName
        }
      })
      .then(() => {
        navigation.navigate('Home');
      });
  }
}
```

Go back to the simulator and try to create a new chat room.

<img src='https://miro.medium.com/max/684/1*hJ5PwM-DWhfRpunWSX4fYg.gif' />

After that, go to the Firebase database console and verify if the `THREADS` collection has a room called `Room 1` or not.

<img src='https://miro.medium.com/max/1400/1*HHM2H9Y2e2yIsDdBCk-8bg.png' />

## Display a list of chat rooms on the home screen

To display chat rooms from Firestore you are going to make use of `FlatList` form React Native. Start by adding the following the import statements inside the `src/screens/HomeScreen.js` file.

```js
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, FlatList } from 'react-native';
import { List, Divider } from 'react-native-paper';
import firestore from '@react-native-firebase/firestore';

import Loading from '../components/Loading';
```

Inside the functional component `HomeScreen`, define two state variables:

- `threads` that is going to be used as the source of data for the FlatList component after the data has been fetched from the Firestore.
- `loading` variable is going to keep track of whether the data is being fetched or not.

```js
export default function HomeScreen() {
  const [threads, setThreads] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = firestore()
      .collection('THREADS')
      .onSnapshot(querySnapshot => {
        const threads = querySnapshot.docs.map(documentSnapshot => {
          return {
            _id: documentSnapshot.id,
            // give defaults
            name: '',
            ...documentSnapshot.data()
          };
        });

        setThreads(threads);

        if (loading) {
          setLoading(false);
        }
      });

    /**
     * unsubscribe listener
     */
    return () => unsubscribe();
  }, []);

  if (loading) {
    return <Loading />;
  }

  // ...rest of the component
}
```

Using the hook `useEffect` in the above snippet you can query the Firestore to fetch the name of chat rooms from the collection `THREADS`.

When the component loads, to fetch the existing chat rooms or in other words, to read the data from the Firestore, start by declaring a `unsubscribe` listener to the query. This listener is going to subscribe to any updates. These updates can be new or existing chat rooms. Declaring a listener here is important because when the screen unmounts, it is important to unsubscribe from this listener.

Using the `querySnapShot`, you are going fetch every document or the chat thread is going to be the part of the the state variable threads. At this point, data is returned from the query, as well as a default object that contains the `_id`(required as unique if for each item in the `FlatList` component), and the name of the chat room.

Here is the complete JSX rendered by this component.

```js
<View style={styles.container}>
  <FlatList
    data={threads}
    keyExtractor={item => item._id}
    ItemSeparatorComponent={() => <Divider />}
    renderItem={({ item }) => (
      <List.Item
        title={item.name}
        description="Item description"
        titleNumberOfLines={1}
        titleStyle={styles.listTitle}
        descriptionStyle={styles.listDescription}
        descriptionNumberOfLines={1}
      />
    )}
  />
</View>
```

The [`Divider` component](https://callstack.github.io/react-native-paper/divider.html) is a lightweight separator provided by UI library `react-native-paper`. Here are the styles associated with the above JSX.

```js
const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f5f5f5',
    flex: 1
  },
  listTitle: {
    fontSize: 22
  },
  listDescription: {
    fontSize: 16
  }
});
```

Go back to the simulator device and you are going to get the following result.

<img src='https://miro.medium.com/max/684/1*5owHh4tZ5mmOyVfsn9kOwA.gif' />

## Conclusion

The main objective of this tutorial is to create and store chat room names in a Firestore cloud database collection as well as integrate the configure the Firestore in our current app. This objective has been completed among other tips and techniques to create a modal screen and share header bar modifications among different route screens.

## What's Next?

In the [next part](https://amanhimself.dev/blog/chat-app-with-react-native-part-4) of this series, we are going to explore how to integrate and use [`react-native-gifted-chat`](https://github.com/FaridSafi/react-native-gifted-chat) which is one of the most important, open source, and actively maintained library to use when building a chat app using React Native. The "out of the box" features it provides in terms of mere props are so helpful and saves a ton of development time.

You can find the complete source code for this project at [this Github repo](https://github.com/amandeepmittal/react-native-examples/tree/master/ChatApp).

ðŸ‘‰ Here is a list of resources used in this tutorial:

- Reactjs [Context API](https://reactjs.org/docs/context.html#reactcreatecontext)
- [Firebase Authentication reference](https://invertase.io/oss/react-native-firebase/v6/auth/quick-start) from `react-native-firebase`
- Getting started with stack navigator using `react-navigation` v5 [here](https://heartbeat.fritz.ai/getting-started-with-stack-navigator-using-react-navigation-5-in-react-native-and-expo-apps-4c516becaee1)

---

## Chat app with React Native (Part 4) - A guide to create Chat UI Screens with react-native-gifted-chat
Slug: chat-app-with-react-native-part-4

![cover](https://i.imgur.com/ROYjoYo.jpg)

In [part 3](https://amanhimself.dev/blog/chat-app-with-react-native-part-3), we completed the task of integrating the Firestore to the current React Native app. The database now stores a chat room name. A new chat room can be created using a modal stack, only if the user is authenticated.

In part 4, let us proceed with further and a new screen that allows the user to send and receive messages as well as display those messages inside a chat room.

To fulfill this purpose, let us use an open-source library called [`react-native-gifted-chat`](https://github.com/FaridSafi/react-native-gifted-chat). You are going to learn how to integrate it within the current React Native app and learn how to use its "out of the box" features as props to save saves a ton of development time.

To begin, make sure to install this module by executing the following command from a terminal window.

```shell
yarn add react-native-gifted-chat
```

## Add a new screen to display messages

Start by adding a new screen file called `RoomScreen.js` inside `src/screens/` directory. This file is going to be used to display messages inside each chat room.

Then, let us add a mock chat UI screen elements to this screen. This can be done in the following steps:

- import `GiftedChat` from `react-native-gifted-chat`. This component is going to be essential in adding UI and chat functionalitie

  s

- Create a functional component `RoomScreen`, inside it, define a state variable called `messages`. This variable is going to have an empty array as its default value.
- Add some mock message data objects. Display two types of messages in each object. The first object is going to be a system message which showcases information like "The following chat room was created at X time...". The second object is going to hold a `text` message that is going to have a `user` object associated and contains user information, such as user name. Both of these messages are going to have a unique `_id`.
- Create a helper method called `handleSend` that is going to be used when sending a message in a particular chat room.
- Lastly, return the following code snippet. The `newMessage` is concatenated with previous or the initial messages using `GiftedChat.append()` method.

```js
import React, { useState } from 'react';
import { GiftedChat } from 'react-native-gifted-chat';

export default function RoomScreen() {
  const [messages, setMessages] = useState([
    /**
     * Mock message data
     */
    // example of system message
    {
      _id: 0,
      text: 'New room created.',
      createdAt: new Date().getTime(),
      system: true
    },
    // example of chat message
    {
      _id: 1,
      text: 'Henlo!',
      createdAt: new Date().getTime(),
      user: {
        _id: 2,
        name: 'Test User'
      }
    }
  ]);

  // helper method that is sends a message
  function handleSend(newMessage = []) {
    setMessages(GiftedChat.append(messages, newMessage));
  }

  return (
    <GiftedChat
      messages={messages}
      onSend={newMessage => handleSend(newMessage)}
      user={{ _id: 1 }}
    />
  );
}
```

## Change RoomScreen to stack Navigator

Each message thread is only going to be displayed when the user enters the chat room. Open `src/navigation/HomeStack.js` and add the `RoomScreen` component as the second screen to the `ChatApp` stack as shown below.

```js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { IconButton } from 'react-native-paper';
import HomeScreen from '../screens/HomeScreen';
import AddRoomScreen from '../screens/AddRoomScreen';

// Add this
import RoomScreen from '../screens/RoomScreen';

const ChatAppStack = createStackNavigator();
const ModalStack = createStackNavigator();

function ChatApp() {
  return (
    <ChatAppStack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#6646ee'
        },
        headerTintColor: '#ffffff',
        headerTitleStyle: {
          fontSize: 22
        }
      }}
    >
      <ChatAppStack.Screen
        name="Home"
        component={HomeScreen}
        options={({ navigation }) => ({
          headerRight: () => (
            <IconButton
              icon="message-plus"
              size={28}
              color="#ffffff"
              onPress={() => navigation.navigate('AddRoom')}
            />
          )
        })}
      />
      {/* Add this */}
      <ChatAppStack.Screen name="Room" component={RoomScreen} />
    </ChatAppStack.Navigator>
  );
}

// rest of the code remains same
```

Then, open `src/screebs/HomeScreen.js` file, and make sure to pass the `navigation` reference as prop to the function component: `export default function HomeScreen({ navigation }) {...}`.

Each chat room is displayed as an item in the FlatList. You will have to make it pressable to allow the user to enter the chat room and display the `RoomScreen` component.

Each list item can be wrapped in the `TouchableOpacity` component such that using `navigation` prop reference as the value of `onPress`, the user is allowed to navigate to the next screen.

Here is the complete code snippet after the modifications.

```js
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, FlatList, TouchableOpacity } from 'react-native';
import { List, Divider } from 'react-native-paper';
import firestore from '@react-native-firebase/firestore';
import Loading from '../components/Loading';

export default function HomeScreen({ navigation }) {
  const [threads, setThreads] = useState([]);
  const [loading, setLoading] = useState(true);

  /**
   * Fetch threads from Firestore
   */
  useEffect(() => {
    const unsubscribe = firestore()
      .collection('THREADS')
      // .orderBy('latestMessage.createdAt', 'desc')
      .onSnapshot(querySnapshot => {
        const threads = querySnapshot.docs.map(documentSnapshot => {
          return {
            _id: documentSnapshot.id,
            // give defaults
            name: '',
            ...documentSnapshot.data()
          };
        });

        setThreads(threads);

        if (loading) {
          setLoading(false);
        }
      });

    /**
     * unsubscribe listener
     */
    return () => unsubscribe();
  }, []);

  if (loading) {
    return <Loading />;
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={threads}
        keyExtractor={item => item._id}
        ItemSeparatorComponent={() => <Divider />}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => navigation.navigate('Room', { thread: item })}
          >
            <List.Item
              title={item.name}
              description="Item description"
              titleNumberOfLines={1}
              titleStyle={styles.listTitle}
              descriptionStyle={styles.listDescription}
              descriptionNumberOfLines={1}
            />
          </TouchableOpacity>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#f5f5f5',
    flex: 1
  },
  listTitle: {
    fontSize: 22
  },
  listDescription: {
    fontSize: 16
  }
});
```

Go to the simulator window and you are going to get the following result.

<img src='https://miro.medium.com/max/684/1*us9hK50YmGKMfhLHR62RjQ.gif' />

Great! The chat UI for each room is now accessible. Try to send a message, of course, it won't get saved since there is no database connected yet.

<img src='https://miro.medium.com/max/684/1*Z90LuoopOAmDJ6XEDNMouA.gif' />

Once the user exits the room and comes back later, only the mock message is displayed. Do notice that the system message `New room created` is displayed as well.

## Display title of each room

When you enter the chat room, did you notice that the name of the room is not being displayed correctly? It just says `Room` whereas the complete name of the first room should be `Room 1`. Let us fix this in the current section.

Open `HomeStack.js` file and modify the route for the `RoomScreen` component by adding `options` to it. The value of the title for each chat room is going to be the name of that chat room.

This can be obtained using `route` props as shown below.

```js
<ChatAppStack.Screen
  name="Room"
  component={RoomScreen}
  options={({ route }) => ({
    title: route.params.thread.name
  })}
/>
```

When using the `react-navigation` library for routing, each screen component is provided with the `route` prop automatically. This prop contains various information regarding the current route such as a place in navigation hierarchy the route component lives.

`route.params` allows access to a set of params defined when navigating. These sets of params have the name of the same chat room as stored in Firestore because in the previous section you did pass the object `thread`.

```js
<TouchableOpacity onPress={() => navigation.navigate('Room', { thread: item })}>
```

Here is the output you are going to get on the device.

<img src='https://miro.medium.com/max/684/1*EU5dtN80Hfm9DkVcrptWxw.gif' />

## Modifying the Chat screen UI: Changing the chat bubble

Gifted chat module gives an advantage for creating a Chat UI in a React Native app over building the UI from scratch. This advantage comes in the form of [props available](https://github.com/FaridSafi/react-native-gifted-chat#props) in this package.

Right now the chat bubble appears as shown below.

<img src='https://miro.medium.com/max/222/1*HDpbiswqzzq-7gWbeaUG3Q.png' />

Let us change the background color of this bubble to reflect the same color as in the header bar (which is used at many instances in the app). This is going to be done in the following steps:

- Start by importing the `Bubble` from the gifted chat module.
- Create a helper method `renderBubble` inside function component `RoomScreen`
- Return the `<Bubble/>` component from the helper function with new styles. The style properties are defined in the Gifted chat module so make sure to use the same property names.
- Lastly, on the `GiftedChat` component, enter the prop `renderBuble`.

```js
// Step 1: modify the import statement
import { GiftedChat, Bubble } from 'react-native-gifted-chat';

export default function RoomScreen() {
  // ...

  // Step 2: add a helper method

  function renderBubble(props) {
    return (
      // Step 3: return the component
      <Bubble
        {...props}
        wrapperStyle={{
          right: {
            // Here is the color change
            backgroundColor: '#6646ee'
          }
        }}
        textStyle={{
          right: {
            color: '#fff'
          }
        }}
      />
    );
  }

  return (
    <GiftedChat
      messages={messages}
      onSend={newMessage => handleSend(newMessage)}
      user={{ _id: 1, name: 'User Test' }}
      renderBubble={renderBubble}
    />
  );
}
```

With that done, here is the output you are going to get.

<img src='https://miro.medium.com/max/177/1*k-uFSzdbiXLtwEyg6CCYGw.png' />

## Adding other modifications to Chat UI

You can modify the placeholder text using the prop `placeholder` as shown below.

```js
<GiftedChat
  messages={messages}
  onSend={newMessage => handleSend(newMessage)}
  user={{ _id: 1, name: 'User Test' }}
  renderBubble={renderBubble}
  placeholder="Type your message here..."
/>
```

Previously the placeholder text says:

<img src='https://miro.medium.com/max/636/1*2lsV60N_T2aPPFeRTmEYcA.png' />

After adding the `placeholder` prop, it looks like:

<img src='https://miro.medium.com/max/654/1*JaJ8K1w8W2pbud6i9Tj7qw.png' />

You can add the prop `showUserAvatar` to always display the user avatar of the current user.

```js
<GiftedChat
  messages={messages}
  onSend={newMessage => handleSend(newMessage)}
  user={{ _id: 1, name: 'User Test' }}
  renderBubble={renderBubble}
  placeholder="Type your message here..."
  showUserAvatar
/>
```

<img src='https://miro.medium.com/max/744/1*ZmQvR95wG7tAGdPtbdtNtg.png' />

Right now, the send button only appears when the user is typing a message. Add the prop `alwaysShowSend` to always show the send button to the current user.

```js
<GiftedChat
  messages={messages}
  onSend={newMessage => handleSend(newMessage)}
  user={{ _id: 1, name: 'User Test' }}
  renderBubble={renderBubble}
  placeholder="Type your message here..."
  showUserAvatar
  alwaysShowSend
/>
```

<img src='https://miro.medium.com/max/748/1*390BD7LTZ5G2Ew_h8BYQrw.png' />

## Add a custom send button

You can also modify this send button to show a custom text or icon. Let us do that to show a custom send icon. This is going to be done in the following steps.

- Import the `Send` component form Gifted chat API.
- Import `IconButton` from `react-native-paper`.
- INside the functional component `RoomScreen`, add a helper method `renderSend` that is going to return the `IconButton` component.
- Add the prop `renderSend` to `<GiftedChat/>`.
- Add corresponding styles if any.

```js
// Step 1: import Send
import { GiftedChat, Bubble, Send } from 'react-native-gifted-chat';
// Step 2: import IconButton
import { IconButton } from 'react-native-paper';
import { View, StyleSheet } from 'react-native';

export default function RoomScreen() {
  // ...

  // Step 3: add a helper method

  function renderSend(props) {
    return (
      <Send {...props}>
        <View style={styles.sendingContainer}>
          <IconButton icon="send-circle" size={32} color="#6646ee" />
        </View>
      </Send>
    );
  }

  return (
    <GiftedChat
      messages={messages}
      onSend={newMessage => handleSend(newMessage)}
      user={{ _id: 1, name: 'User Test' }}
      renderBubble={renderBubble}
      placeholder="Type your message here..."
      showUserAvatar
      alwaysShowSend
      // Step 4: add the prop
      renderSend={renderSend}
    />
  );
}

// Step 5: add corresponding styles
const styles = StyleSheet.create({
  sendingContainer: {
    justifyContent: 'center',
    alignItems: 'center'
  }
});
```

Here is the output you are going to get after this step.

<img src='https://miro.medium.com/max/742/1*qol2YSd4FJH13CP_NWep1g.png' />

## Add a scroll to the bottom button

Right now, in the Chat UI, there is no way for the current user to scroll to the latest message. They have to manually scroll down to see the latest message in the thread. Here is a demo of the problem.

<img src='https://miro.medium.com/max/684/1*XSF9AJNiqT08s1mBiJxvDQ.gif' />

This can be solved by adding prop `scrollToBottom`.

```js
<GiftedChat
  messages={messages}
  onSend={newMessage => handleSend(newMessage)}
  user={{ _id: 1, name: 'User Test' }}
  renderBubble={renderBubble}
  placeholder="Type your message here..."
  showUserAvatar
  alwaysShowSend
  renderSend={renderSend}
  scrollToBottom
/>
```

Take a look at the down caret sign at the right side of the app shown below.

<img src='https://miro.medium.com/max/700/1*5wo3Pu65wxWdATlsTxqs3A.png' />

This is not pleasing at all with the current background of the screen. Let us modify this button with a custom background. This can be done in three simple steps.

- Add a helper method inside `RoomScreen` functional component and call this helper method `scrollToBottomComponent()`. Use `IconButton` component from `react-native-paper` to customize this button.
- Add the prop `scrollToBottomComponent` to `<GiftedChat />`.
- Add corresponding styles to the `styles` object.

```js
export default function RoomScreen() {
  // ...

  // Step 1: add helper method

  function scrollToBottomComponent() {
    return (
      <View style={styles.bottomComponentContainer}>
        <IconButton icon="chevron-double-down" size={36} color="#6646ee" />
      </View>
    );
  }

  return (
    <GiftedChat
      messages={messages}
      onSend={newMessage => handleSend(newMessage)}
      user={{ _id: 1, name: 'User Test' }}
      renderBubble={renderBubble}
      placeholder="Type your message here..."
      showUserAvatar
      alwaysShowSend
      renderSend={renderSend}
      // Step 2: add the prop
      scrollToBottomComponent={scrollToBottomComponent}
    />
  );
}

// Step 3: add corresponding styles
const styles = StyleSheet.create({
  // rest remains same
  bottomComponentContainer: {
    justifyContent: 'center',
    alignItems: 'center'
  }
});
```

Here is the output.

<img src='https://miro.medium.com/max/684/1*dDTq0Wpr_aFMyN_RWttPIg.gif' />

## Add a loading spinner when the room screen initializes

Initializing a new screen or in the current case, a chat room may take some time. It is good practice to add a loading indicator to convey the message to the user when they enter the chat room. This can be done by adding a prop called `renderLoading` which returns an `ActivityIndicator` from `react-native` core API.

- Import the `ActivityIndicator` from `react-native` core API.
- Add helper method `renderLoading()` to functional component `RoomScreen`.
- Add the prop `renderLoading` to `<GiftedChat />`.
- Add corresponding styles.

```js
// Step 1: import ActivityIndicator
import { ActivityIndicator, View, StyleSheet } from 'react-native';

export default function RoomScreen() {
  // ...

  // Step 2: add a helper method

  function renderLoading() {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6646ee" />
      </View>
    );
  }

  return (
    <GiftedChat
      messages={messages}
      onSend={newMessage => handleSend(newMessage)}
      user={{ _id: 1, name: 'User Test' }}
      renderBubble={renderBubble}
      placeholder="Type your message here..."
      showUserAvatar
      alwaysShowSend
      renderSend={renderSend}
      scrollToBottomComponent={scrollToBottomComponent}
      // Step 3: add the prop
      renderLoading={renderLoading}
    />
  );
}

// Step 4: add corresponding styles
const styles = StyleSheet.create({
  // rest remains same
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

On the current screen you might see a loading indicator when you refresh the app for the first time or when the screen initializes for the first time.

<img src='https://miro.medium.com/max/684/1*Ztwt_qL30dreUv_JMvhhwg.gif' />

## What's Next?

In [part 5 of this series](https://amanhimself.dev/blog/chat-app-with-react-native-part-5), we are going to create messages in real-time using the Firestore database. We will be covering how using react-navigation you can get the current room's id. Then, use it with the current user from the `AuthContext` we created earlier, to add real-time message information such as a text field and a timestamp associated with it.

We will then add another real-time feature to display the latest message on the home screen under each room name's description using Firestore queries.

You can find the complete source code for this project at [this Github repo](https://github.com/amandeepmittal/react-native-examples/tree/master/ChatApp).

---

ðŸ‘‰ Here is a list of resources used in this tutorial:

- [React Native Gifted Chat module](https://github.com/FaridSafi/react-native-gifted-chat)
- [Props available for `react-native-gifted-chat`](https://github.com/FaridSafi/react-native-gifted-chat#props)

## Further Reading

- [React - Separation of Concerns by Andrei Calazans](https://www.g2i.co/blog/react-separation-of-concerns)

[Originally Published at Heartbeat.Fritz.ai](https://heartbeat.fritz.ai/chat-app-with-react-native-part-4-create-chat-ui-screens-with-react-native-gifted-chat-7ef428a60d30)

---

## Chat app with React Native (Part 5) - Create and Fetch Real-Time Messages with Firestore
Slug: chat-app-with-react-native-part-5

![cover](https://i.imgur.com/ROYjoYo.jpg)

In [part 4](https://amanhimself.dev/blog/chat-app-with-react-native-part-4), we built the foundation of creating a chat app by adding UI screens that are focused on sending, receiving and displaying chat messages. We used `react-native-gifted-chat` an amazing open source library and dived deep to use its "out of the box" props to add features to the chat app.

In part 5, we are going to connect every chat functionality that we built so far with a real-time database service from Firebase, called Firestore. You are going to learn

- store chat messages of each thread/chat room in Firestore collection
- how to create sub collections inside a Firestore collection
- add a feature to display most recent message for each chat room on home screen
- fetch data from a Firestore collection

And few other things along the way. Let's get started.

## How to get current user information in the app?

Remember, in [part 2](https://amanhimself.dev/blog/chat-app-with-react-native-part-2), when configuring Email authentication between the chat app and the Firebase service, you set the following `AuthProvider` that gives access to the current user as well other methods that are already being used in components `LoginScreen` and `SignupScreen`. Here is the ode for `src/navigation/AuthProvider.js` for your reference.

```js
import React, { createContext, useState } from 'react';
import auth from '@react-native-firebase/auth';

/**
 * This provider is created
 * to access user in whole app
 */

export const AuthContext = createContext({});

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  return (
    <AuthContext.Provider
      value={{
        user,
        setUser,
        login: async (email, password) => {
          try {
            await auth().signInWithEmailAndPassword(email, password);
          } catch (e) {
            console.log(e);
          }
        },
        register: async (email, password) => {
          try {
            await auth().createUserWithEmailAndPassword(email, password);
          } catch (e) {
            console.log(e);
          }
        },
        logout: async () => {
          try {
            await auth().signOut();
          } catch (e) {
            console.error(e);
          }
        }
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};
```

To fetch the logged in user information (aka the current user), start by importing `AuthContext` in the file `RoomScreen.js`.

```js
// ... rest of the import statements
import React, { useContext, useEffect } from 'react';
import { AuthContext } from '../navigation/AuthProvider';
```

Next, to verify that the you are getting the current user information, inside the `RoomScreen` component, add the following two lines.

```js
export default function RoomScreen({ route }) {
  const { user } = useContext(AuthContext);
  const currentUser = user.toJSON();

  // ...
}
```

You have to convert the user data being fetched in JSON object. To check that the user data is incoming, let us temporarily add a `useEffect` hook after the previous code snippet, as shown below.

```js
useEffect(() => {
  console.log({ user });
}, []);
```

## How to use Chrome Dev tools with a React Native app?

There are two ways to check the output of console statements in a React Native app. First, a console statement triggers, in the terminal window, the will be a `LOG` entry like below with desired result.

<img src='https://miro.medium.com/max/1400/1*vgS3rCFKAkxb6WHHbESkvA.png' />

However, for better complete control over [debugging](https://reactnative.dev/docs/debugging), you can use Chrome dev tools. This can be done by opening the in-app developer menu, either by shaking the device or if you are using an iOS simulator press `command + d`. On Android, you have to press `command + m` on mac (for windows, press `control + m`).

A developer menu like below will popup.

<img src='https://miro.medium.com/max/700/1*eQVIYyJTWubyIp20NSTpiQ.png' />

Select the option `Debug`. In your default Chrome browser, it is going to open like below.

<img src='https://miro.medium.com/max/1066/1*t-56v6dq-N4T955hoj28cw.png' />

Go to **Console** tab. Enter a chat room from the app. If you do not have to created a chat room yet, create one. On the Console tab, you are going to get the following result.

<img src='https://miro.medium.com/max/1400/1*rl94NSCpjYETiy0HAKYk4A.png' />

That's it. Now, from the above image, you can definitely verify that a user is logged in and their email credentials can be verified.

## How to store messages in Firestore?

In this section, you are going to add the business logic as well as the ability to store the chat conversation between multiple users in a chat room. These messages are going to be stored in a sub collection.

The main reason to create a sub collection is that when a new chat room is created, storing every data associated to that chat room in its own collection is a good idea. That said, when a new chat room is created, inside the collection `THREADS` a new document with a unique identifier is generated.

Inside that, you are going to add another collection called `MESSAGES` that is only going to store chat conversation that happens in that chat room. This will get clear as you proceed in this section.

Start by importing the some necessary React Hooks as shown below. Also, import `firestore` to make queries to create new sub-collection, and fetch data.

```js
import React, { useState, useContext, useEffect } from 'react';
import firestore from '@react-native-firebase/firestore';
```

To get the `id` of the current chat room (_this is important_) you have to pass the `route` as a parameter to the `RoomScreen` functional component. Since, from the previous screen, a `thread` object is passed which gives the chat room id (_or thread id_) store in the Firebase collection `THREADS`. Using `route.params` you can get the whole `thread` object. This is possible because of `react-navigation`.

```js
export default function RoomScreen({ route }) {
  // ... rest of the code
  const { thread } = route.params;
}
```

Next, modify the asynchronous helper method `handleSend`. This method is used to send a message as you might have already seen in part 4.

Inside this helper method, get the text of each message send by the user. Then, create the sub collection `MESSAGES` by referencing the correct id of the current thread the user is conversing in. Using `add()` you can add anew document with an auto-generated unique id for each message inside the sub collection.

Pass on an object with fields like `text` that represents the text of each message, the timestamp it is being send or created at, and the user information (such as user's `uid`, and `email`).

```js
async function handleSend(messages) {
  const text = messages[0].text;

  firestore()
    .collection('THREADS')
    .doc(thread._id)
    .collection('MESSAGES')
    .add({
      text,
      createdAt: new Date().getTime(),
      user: {
        _id: currentUser.uid,
        email: currentUser.email
      }
    });
}
```

Go back to the simulator, create a new room, and send a message.

<img src='https://miro.medium.com/max/684/1*Bw1kO21guUat419nn5Gd-A.gif' />

In Firebase console, you are going to notice that the inside the `THREADS` collection, a sub-collection called `MESSAGES` is created as shown below.

<img src='https://miro.medium.com/max/1400/1*88BW7XRZjeFhSrUqvaxA0A.png' />

Ignore the `latestMessage` field, we will cover that in the next section. The image below displays that the messages are being stored with correct information.

<img src='https://miro.medium.com/max/1400/1*t-vcelQcGA_HI9cvutPZ_g.png' />

## Display the latest message for each chat room on homeÂ screen

In this section, you are going to update the `THREADS` collection with a new field called `latestMessage` that you have already seen in the previous section, in Firebase console.

The advantage this field is going to give us (which we will complete later) is to show the last or the latest message send in a particular chat room, to be displayed on the home screen where a room's description field already exists. This will save the user time to glance at the last message without opening the room to see if there are any new messages or not.

To begin, all you have to do is refer the current thread using its id, then `set` an object that has field `latestMessage` with `text` and `createdAt` timestamp properties. Then pass on the second object that has a property of `merge`.

```js
async function handleSend(messages) {
  // ...

  await firestore()
    .collection('THREADS')
    .doc(thread._id)
    .set(
      {
        latestMessage: {
          text,
          createdAt: new Date().getTime()
        }
      },
      { merge: true }
    );
}
```

In Firestore, when `set` is used with `merge`, it update fields in a document or create that document if it does not exists. If you use `set` here without `merge`, it will overwrite the whole document.

## How to fetch messages from Firestore to display in chat room?

To display messages in a chat room once they send by a user, these messages have to be fetched from the Firestore sub-collection created previous sections, `MESSAGES`.

To fetch the data, let us use `useEffect` hook. [The effect hook](https://reactjs.org/docs/hooks-effect.html) lets you add side-effects to functional components. In the previous versions of React and React Native, this could be done by using lifecycle methods such as `componentDidMount()` and other different methods in class components. The `useEffect` hook can perform multiple side-effects such as data fetching and more in different ways.

To fetch the messages, first you have to traverse inside the current thread using its id, then the sub-collection `MESSAGES`. When traversing the sub-collection, make sure to order the messages to display them in descending order according to the time they were sent.

Then using a `querySnapshot` you can `map` the messages array from the sub collection. A Query Snapshot in Firestore contains zero objects or more objects inside an array representing the results of a query.

Create a data object that is going to contain the `id` of the document being fetched, the text of the message and its timestamp, and any other data associated with the message or in the document. The last step is required to identify that if the message is send by the user or is system generated.

In part 4 you have seen how a system generated message looks like. This means, if the message is generated when the chat room was created or not.

If the message is not system generated, that means it is send by the user. You will have to add the user's email (or any other details can be added such as user's display name)to the `data` object. Add the following snippet.

```js
async function handleSend(messages) {
  // ...

  useEffect(() => {
    const messagesListener = firestore()
      .collection('THREADS')
      .doc(thread._id)
      .collection('MESSAGES')
      .orderBy('createdAt', 'desc')
      .onSnapshot(querySnapshot => {
        const messages = querySnapshot.docs.map(doc => {
          const firebaseData = doc.data();

          const data = {
            _id: doc.id,
            text: '',
            createdAt: new Date().getTime(),
            ...firebaseData
          };

          if (!firebaseData.system) {
            data.user = {
              ...firebaseData.user,
              name: firebaseData.user.email
            };
          }

          return data;
        });

        setMessages(messages);
      });

    return () => messagesListener();
  }, []);
}
```

The messages in chat room are going to be displayed as the following.

<img src='https://miro.medium.com/max/700/1*WDL3DnVJPQPUNMIpD0NHTg.png' />

In order to make all this work, make sure to modify the following two props in return statement.

```js
<GiftedChat
      messages={messages}
      // Modify the following
      onSend={handleSend}
      user={{ _id: currentUser.uid }}
      // ...rest remains same
    />
  );
```

## How to set a system message as latest message in a chat room?

Right now the `THREADS` collection for each chat room can display the latest message sent by the user but when a thread is created, you might want to display a system, generated message to convey the same message to the user entering the chat room. To do this, open `AddRoomScreen.js` file and modify its its helper method `handleButtonPress` to add the following snippet.

First you are going to add the `latestMessage` object with its text field saying that a room is created. Do not forget to add a timestamp field along with the text field.

Second step is to add a `docRef` or a document reference to the sub-collection `MESSAGES`. Note that, at this point, when the user creates a new room, this sub-collection will be created for each chat room.

A document reference in Firestore is used to write, read or listen to a particular location or a sub-collection inside a Firestore collection.

The document or in the current case, the collection `MESSAGES` might not exist but adding this step will create the collection. This first message in a chat room is also going to be the system generated message.

```js
function handleButtonPress() {
  if (roomName.length > 0) {
    firestore()
      .collection('THREADS')
      .add({
        name: roomName,
        latestMessage: {
          text: `You have joined the room ${roomName}.`,
          createdAt: new Date().getTime()
        }
      })
      .then(docRef => {
        docRef.collection('MESSAGES').add({
          text: `You have joined the room ${roomName}.`,
          createdAt: new Date().getTime(),
          system: true
        });
        navigation.navigate('Home');
      });
  }
}
```

Now, when you create a new room through the app, here is the complete overview of how it gets reflected in Firestore.

<img src='https://miro.medium.com/max/1400/1*-P8qzzB9hQZjHljwfBym6w.png' />

<img src='https://miro.medium.com/max/1400/1*FqFGH5woXMLdH0MnlNLUtg.png' />

And here is the system message displayed in the new chat room.

<img src='https://miro.medium.com/max/700/1*eGiETDWsXMKgnczQ6nAUfA.png' />

## Customizing the system message in react-native-gifted-chat

Right now the system message generated is not as appealing and conveying inside a chat room. In this short section, let us learn how to customize that in `react-native-gifted-chat`.

Start by importing `SystemMessage` component from `react-native-gifted-chat` inside `RoomScreen.js` file.

```js
import {
  GiftedChat,
  Bubble,
  Send,
  // Add this
  SystemMessage
} from 'react-native-gifted-chat';
```

Create a new helper method called `renderSystemMessage` inside the screen component with the following snippet. In the current scenario, you are going to change the background of the system message display as well as the text styles. For that you need to edit the props `wrapperStyle` and `textStyle` of `SystemMessage` component.

Do modify the `StyleSheet` object to add styles as shown below.

```js
function renderSystemMessage(props) {
  return (
    <SystemMessage
      {...props}
      wrapperStyle={styles.systemMessageWrapper}
      textStyle={styles.systemMessageText}
    />
  );
}

// appropriate styles

const styles = StyleSheet.create({
  // ... rest of the styles remain unchanged
  systemMessageText: {
    fontSize: 14,
    color: '#fff',
    fontWeight: 'bold'
  }
});
```

Lastly, add the prop `renderSystemMessage` to `GiftedChat` component.

```js
return (
  <GiftedChat
    // rest of the props remain same
    renderSystemMessage={renderSystemMessage}
  />
);
```

Here is the output you are going to get after this step.

<img src='https://miro.medium.com/max/700/1*k8b2ObpU4FoiMfRVmXwvQw.png' />

## How to display latest message on home screen?

For every chat room on home screen there is description field that says a static message `Item description`. In this section let us change that to dynamically display the real-time latest message fetched from the Firestore collection.

Open `HomeScreen.js` and `orderBy()` when fetching name of chat rooms in the Effect hook. Then, when returning the documentSnapShot data, there is an object that contain fields like `_id` and `name`. Add another object as a field called `latestMessage` as shown below.

```js
useEffect(() => {
  const unsubscribe = firestore()
    .collection('THREADS')
    // add this
    .orderBy('latestMessage.createdAt', 'desc')
    .onSnapshot(querySnapshot => {
      const threads = querySnapshot.docs.map(documentSnapshot => {
        return {
          _id: documentSnapshot.id,
          name: '',
          // add this
          latestMessage: {
            text: ''
          },
          // ---
          ...documentSnapshot.data()
        };
      });

      setThreads(threads);

      if (loading) {
        setLoading(false);
      }
    });

  return () => unsubscribe();
}, []);
```

Next, go to the `List.Item` inside the `FlatList` component and modify the description field as shown below.

```js
description={item.latestMessage.text}
```

Go back to the simulator and you are going to see the latest message displayed.

<img src='https://miro.medium.com/max/940/1*wc1bhW2LavbuiM3dw0QCXA.png' />

Try sending a new message and that is going to be the latest message displayed on the home screen for the chat room.

<img src='https://miro.medium.com/max/684/1*JKTyv7WO-_TOtOcHPmlfBw.gif' />

There is a benefit of ordering the chat rooms according to the latest message for each room. Now the home screen is going to display that chat room on top which received it the most recent message according the timestamp (createdAt)that is associated with the message.

<img src='https://miro.medium.com/max/684/1*nDaN1lXF75iWEWg6X-0sqQ.gif' />

## What's Next?

In the [next part](https://amanhimself.dev/blog/chat-app-with-react-native-part-6) of the series we are going to fix a small bug related of status bar styles for every screen component in the current app. This is going to be done by creating a custom hook and using `react-navigation`.

ðŸ˜º **You can find the complete code here at this [GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/ChatApp).**

## Further Reading

- [React Nativeâ€™s New Architecture â€” Glossary of terms by Gabe Greenberg](https://www.g2i.co/blog/react-natives-new-architecture-glossary-of-terms)
- [The Effect hook in React](https://reactjs.org/docs/hooks-effect.html)
- [Debugging React Native apps](https://reactnative.dev/docs/debugging)

[Originally Published at Heartbeat.Fritz.ai](https://heartbeat.fritz.ai/chat-app-with-react-native-part-5-create-and-fetch-real-time-messages-with-firestore-86fb012edaf5)

---

## Chat app with React Native (Part 6) - Create a custom hook to change status bar styles
Slug: chat-app-with-react-native-part-6

![cover](https://i.imgur.com/ROYjoYo.jpg)

In [part 5](https://amanhimself.dev/blog/chat-app-with-react-native-part-5), we successfully connected real-time database service Firestore to store chat messages in a collection where each collection would represent a separate chat room. Further, we built sub-collections in each chat room collection to store and identify latest messages from all other messages in a chat room.

This part is going to be a bit different. Instead of writing code to communicate with any real-time service, we are going to fix a bug by creating a custom hook.

Here is a screen shot of the type of bug I am talking about it. Notice how the status bar remains dark in color on both lighter and darker backgrounds.

<img src='https://miro.medium.com/max/714/1*JwA7n-QlUjayTGgb2m1tfw.gif' />

Do notice that the status bar looks fine when the background is light in colour. This happens when the modal screen to create a new chat room is displayed. But on rest of the screens, when chat rooms are displayed or inside a chat room, the status bar does not matches well with the coloured background of header on both of these screens.

React Native has a core component in its API called `StatusBar` that is used to control the app status bar behavior and its styles. However, manually adding `StatusBar` to each screen is not our goal in this tutorial.

The navigation library `react-navigation` is going to help us to solve this. We are going to create a custom hook that is going to track the status bar color and change it accordingly whenever a screen changes. That is, on the lighter background, a dark status bar is displayed and on a darker background of the screen, a light status bar is displayed.

To begin you need `react-navigation` library to be installed. Since we have already done that in [part 1](https://heartbeat.fritz.ai/chat-app-with-react-native-part-1-build-reusable-ui-form-elements-using-react-native-paper-75d82e2ca94f) of this chat app series. If you just came across this tutorial, please have a look at part 1 and instructions mentioned on how to install and configure `react-navigation` library.

Otherwise, you can follow the instructions from `react-navigation` library official docs [here](https://reactnavigation.org/).

## Create a custom Status bar hook

The `react-navigation` library provides a hook called `useFocusEffect` that helps to run side-effects when a specific screen is focused. A side effect can be described as fetching data, updating a title, running an event listener and so on. This hooks is similar to `useEffect` hook from React with the difference being between the two is that side-effects in `useFocusEffect` run only when a screen component is focused.

Let us begin to develop this custom hook. Create a new file called `useStatusBar.js` inside `src/utils/` directory. Import the following statements.

```js
import React, { useCallback } from 'react';
import { StatusBar } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
```

Export a custom function called `useStatusBar`. This function is going to be act as a custom hook that is going to provide a simple way to change the color of the status bar when applied. Pass the `style` as the only parameter for now. The value of the style is going to be determined on the screen component this hook is used.

```js
export default function useStatusBar(style) {
  useFocusEffect(
    useCallback(() => {
      StatusBar.setBarStyle(style);
    }, [])
  );
}
```

It is important to wrap the `StatusBar` with `React.useCallback` hook to avoid triggering the side-effect after every render when the screen is focused.

## Application of the custom hook

To apply this hook for the first time, open `screen/HomeScreen.js` file, import the custom hook and apply it as shown below.

```js
// rest of the import statements
import useStatsBar from '../utils/useStatusBar';

export default function HomeScreen({ navigation }) {
  useStatsBar('light-content');
  // rest of the code remains same
}
```

Go back to the simulator and you are going to notice the changes now.

<img src='https://miro.medium.com/max/692/1*jaEgKwnoaiLeMCs2bkmsIg.png' />

It works. If you look closely at the header bar of the `Home` screen, you are going to see that the status bar has the value of light styles applied. However, this style is also applied to all of the other screens, even on those screens such as `AddRoomScreen` where a darker status bar would be preferred.

<img src='https://miro.medium.com/max/714/1*JSa1Ndh9tYt4BzdBUJG4mA.gif' />

To fix this, you have to explicitly mention the styles of the status bar for each component using the custom hook we created in the previous section.

```js
/**
 * screens/AddRoomScreen.js
 */

// rest of the import statements
import useStatsBar from '../utils/useStatusBar';

export default function AddRoomScreen({ navigation }) {
  useStatsBar('dark-content');
  // rest of the code remains same
}

/**
 * screens/RoomScreen.js
 */

// rest of the import statements
import useStatsBar from '../utils/useStatusBar';

export default function RoomScreen({ route }) {
  useStatsBar('light-content');
  // rest of the code remains same
}
```

Now, go back to the simulator and you are going to find everything is in order and works as expected.

<img src='https://miro.medium.com/max/714/1*laUY_xJJwoI079wS0NKI3Q.gif' />

## Animate the value for smoother transitions

For better transitions between different screens in a stack navigator, you can pass the second parameter to the `useStatusBar`. This second parameter is going to be called `animated`. Passing a default value of boolean true is going to help and avoid any explicit mentions. Otherwise you can explicitly pass the value of the parameter as well.

```js
export default function useStatusBar(style, animated = true) {
  useFocusEffect(
    useCallback(() => {
      StatusBar.setBarStyle(style, animated);
    }, [])
  );
}
```

The animation used by the hook itself is going to the default transition of native platform the app is currently being run since the hook `useFocusEffect` is imported from `@react-navigation/native`.

Now you can go back to the simulator (_the below demo is using iOS simulator_) and notice the difference between the previous section and this one.

<img src='https://miro.medium.com/max/714/1*_X5Ye5IJpkOYbUsED8ELYg.gif' />

## A last challenge

The purpose of this series is to make yourself familiar with integration process of Firebase in a React Native app and implementing a navigation flow with `react-navigation` library and how to use components from `react-native-paper` UI library. This purpose is now complete with this part.

Though I leave you with a small challenge. Implement the logout button in the header bar of the Home screen. Just like you have used the `IconButton` component from `react-native-paper` to open a modal screen. Hint, changes are to be done in the `HomeStack.js` file and we have already written the `logout` function in `AuthProvider.js` file.

Here is a little demo showcasing what has to be implement:

<img src='https://miro.medium.com/max/664/1*5XHPu7A9R9s9d_lYKcd1sw.gif' />

Try to do it yourself and try to think other ways you can implement log out functionality in this app. If you feel stuck or want to jump ahead to the the GitHub commit [**here**](https://github.com/amandeepmittal/react-native-examples/commit/b1383ccc9fca20214b6c91bfe5a2a5d72a1f8d16).

Otherwise, you can find the complete code at this [GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/ChatApp).

---

ðŸ‘‰ Here is a list of resources used in this tutorial:

- [The complete documentation useFocusEffect hook](https://reactnavigation.org/docs/use-focus-effect/)
- [Do understand the difference between using `focus` event and useFocusEffect](https://reactnavigation.org/docs/use-focus-effect/#how-is-usefocuseffect-different-from-adding-a-listener-for-focus-event)

[Originally Published at Heartbeat.Fritz.ai](https://heartbeat.fritz.ai/chat-app-with-react-native-part-6-create-a-custom-hook-to-change-status-bar-styles-da7073c5fa8d)

---

## How to clear global npx cache
Slug: clear-global-npx-cache

Recently, I've seen myself running into the following message whenever I'm using a certain CLI tool with `npx`.

```bash
A new version of "x-package" is available
You can update by running: npm install -g x-package
```

I don't want to install the CLI tool globally and go into the rabbit hole of maintaining it as a dependency.

One way I've found that works on macOS to clear the global `npx` cache:

```bash
rm -rf ~/.npm/_npx
```

This will clear the global `npx` cache and you'll be able to use the latest version of the CLI tool.

Also, you can add an alias to your `.zshrc` or `.bashrc` file to make it easier to run:

```bash
alias clearnpx="rm -rf ~/.npm/_npx"
```

If you've trouble finding where npm stores `npx` cache on your system, run the following command to find out the exact path to the `_npx` directory:

```bash
npm config get cache
```

---

## Common Prop Types in TypeScript and React
Slug: common-proptypes-in-react-and-typescript

All **primitives in JS** are available in TS.

```ts
type Props = {
  size: number;
  name: string;
  disabled: boolean;
};
```

An **object** **type** is simply an empty object or an object with keys. An empty object can have any number of properties and values.

If the object is defined explicitly with keys, it will only accept those values. The shape of the object will remain certain.

```ts
type Props = {
  emptyObject: {};
  product: {
    id: string;
    price: number;
  };
};
```

Using square brackets `[]`, an **array type** is defined:

```ts
type ListProps = {
  items: string[];
};
```

The prop `items` here only expects values in the array of `string` type. To define an array of objects of a certain shape:

```ts
type ListProps = {
  items: {
    id: string;
    name: string;
    price: number;
  }[];
};
```

TypeScript does not asks you to define the shape of each object. Although, refactoring `ListProps` as below is valid:

```ts
type Item = {
  id: string;
  name: string;
  price: number;
};

type ListProps = {
  item: Item;
  items: Item[];
};
```

Using **[union type](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#union-types-and-type-guarding)**, certain values for a prop can be described as:

```ts
type Button = {
  variant: 'primary' | 'danger' | 'info';
  value: string | number;
};
```

TypeScript cares when it comes to passing arguments on a function.

```ts
type Props = {
  onEventListener: () => void; // some times event listeners do not have return type
  onChangeText: (title: string) => void;
};
```

On a function, it is possible to define return type as inline type declaration:

```ts
function add(x: number, y: number): number {
  return a + b;
}
```

---

## How to configure ESLint and Prettier in an Expo project
Slug: configure-eslint-prettier-expo-project

> Make sure to see the official Expo documentation for latest details on using [ESLint](https://docs.expo.dev/guides/using-eslint/) in your React Native project.

When writing JavaScript, I spend a good amount of time fixing basic mistakes. Different project files sometimes end up following different syntax and formatting conventions.

Using ESLint rescues me from those mistakes. It is a linter for the JavaScript programming language that helps keep the code syntax consistent and match conventions and warns against the possible source of problems. It is written in Node.js.

Also, I like to use some specific set of Prettier rules in my projects. ESLint configures well with it.

## Create a new project

To create a new React Native project, I use `create-expo-app`:

```shell
npx create-expo-app projectName

# Navigate inside the project folder
cd projectName
```

## Install ESLint and Prettier dev dependencies

After creating a new project, the next step is to install ESLint and Prettier as dev dependencies.

The Expo team has been awesome to provide a package called [eslint-config-universe](https://github.com/expo/expo/tree/master/packages/eslint-config-universe) that comes with basic and shared ESLint configuration for Node.js, React Native and web projects. This is useful because I don't have to set up and define the ESLint configuration from scratch.

Run the following command in the terminal:

```shell
yarn add --dev eslint-config-universe eslint prettier
```

These packages are installed as `devDependencies` since they are only required during the development of the project.

## Configure ESLint

Start by creating a new file called `.eslintrc.js` at the root of the project. This file is responsible to contain all the configuration and linting rules.

Here is the minimal configuration I use:

```js
module.exports = {
  extends: ['universe', 'universe/native'],
  rules: {
    'import/order': 0,
    'react-native/no-inline-styles': 0,
    'import/namespace': 0,
    'no-duplicate-imports': 'error'
  }
};
```

Sometimes I extend this configuration or tweak with rules but for most of the projects I start with this configuration.

In the above snippet, the `extends` is used to apply the pre-defined set of rules from `universe` and `universe/native`.

The `universe` contains basic config JavaScript projects. The `universe/native` contains the config for React Native and Expo projects, with support for React and JSX.

## Configure Prettier

Prettier is a code formatter that ensures that all the code files follow a consistent styling. If you are into Web development, chances are you are already using it.

Create a new file called `.prettierrc` and inside it add the following (_minimal_) configuration:

```json
{
  "printWidth": 100,
  "tabWidth": 2,
  "singleQuote": true,
  "bracketSameLine": true,
  "trailingComma": "es5",
  "arrowParens": "avoid"
}
```

## Ignore files

I also created two new files to ignore trivial or other configurable files and folders from both linting and formatting. Both `.eslintignore` and `.prettierignore` have the following snippet:

```shell
node_modules/**
package.json
yarn.lock
ios/**
android/**
assets/**
.vscode
.expo-shared
.prettirrc
.eslintrc.js
```

## Conclusion

There are about a dozen ways one can configure ESLint rules. However, in this post, I wanted to share this minimal configuration for my future self.

---

## How to Upload a File with Reactjs and Nodejs
Slug: connecting-a-node-js-and-reactjs-example

![cover](https://i.imgur.com/X7ju8yL.jpg)

> [Originally this article was published on Zeolearn.com](https://www.zeolearn.com/magazine/connecting-reactjs-frontend-with-nodejs-backend)

Uploading Files might seem a task that needs to be conquered especially if you are getting into web development. In this tutorial, simple AJAX based file uploads using Reactjs on front-end and Node.js back-end. This is easy to accomplish with the following technologies since the whole source code will be in one language, JavaScript. In this example, to demonstrate for connecting a Reactjs application with Node.js backend, we will be making the use of a simple file upload example. The topics we will be covering are going to be:

- Setting up a Back-end of our app using `express-generator`
- Using `create-react-app` to scaffold a front-end Reactjs app
- Using `axios` for cross-origin API calls
- Handling POST requests on our server
- Using `express-fileupload`, a promise based library
- Lastly, making a connection between Reactjs and Node.js

### Getting Started

We will be starting without back-end first. We will write a server application with necessary configurations required to accept cross-origin requests and uploading files. First, we need to install `express-generator` which is the official and quickest way to start with an Express back-end application.

```shell
npm install -g express-generator
```

We will install this module globally from our terminal. After installing this global `npm` module, we have an instance of it named `express` to generate our project structure.

```shell
mkdir fileupload-example
express server
cd server
```

When changing the current directory to the project `express` command just scaffolded, we can observe the following structure and files:

<img src='https://cdn-images-1.medium.com/max/800/0*x6livl3bk3Wc8OX6.png' />

To run this backend server on default configuration, we have to install the dependencies mentioned in `package.json` first.

```js
npm install
npm start
```

Express-generator comes with following dependencies. Some of them are essential to use such as `morgan` and `body-parser` and some we can leave out for this project.

```json
"dependencies": {
    "body-parser": "~1.18.2",
    "cookie-parser": "~1.4.3",
    "debug": "~2.6.9",
    "express": "~4.15.5",
    "jade": "~1.11.0",
    "morgan": "~1.9.0",
    "serve-favicon": "~2.4.5"
  }
```

I will be adding two more packages for our configurable back-end application to behave in the way we want to.

```shell
npm install --save cors express-fileupload
```

`cors` provide a middleware function for Express applications to enable various Cross-Origin Resource Sharing options. CORS is a mechanism that allows restricted resources (in our case, API or AJAX requests) on a web page from another domain. It helps a browser and a server to communicate and can be hosted on separate domains. You will understand it more when you will see it in action.

The other module, `express-fileupload` is a bare minimum express middleware function for uploading files. The advantages it has it that it has support for Promises and can handle multiple file uploads.

With these two important packages added as dependencies in our project, we can now start by modifying the default Express back-end in `app.js` file.

```js
const express = require('express');
const path = require('path');
const favicon = require('serve-favicon');
const logger = require('morgan');
const cookieParser = require('cookie-parser');
const bodyParser = require('body-parser');
const cors = require('cors'); // addition we make
const fileUpload = require('express-fileupload'); //addition we make

const index = require('./routes/index');
const users = require('./routes/users');

const app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');

// uncomment after placing your favicon in /public
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cookieParser());

// Use CORS and File Upload modules here
app.use(cors());
app.use(fileUpload());

app.use('/public', express.static(__dirname + '/public'));

app.use('/', index);

// catch 404 and forward to error handler
app.use(function (req, res, next) {
  const err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handler
app.use(function (err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;
```

In the above code, you would notice that we made some additions. The first addition we did is to import packages `cors` and `express-fileupload` in `app.js` after other dependencies are loaded.

```js
const cors = require('cors'); // addition we make
const fileUpload = require('express-fileupload'); //addition we make
```

Then just after other middleware functions, we will instantiate these two newly imported packages.

```js
// Use CORS and File Upload modules here
app.use(cors());
app.use(fileUpload());
```

Also, we need to allow data coming from a form. For this, we have to enable `urlencoded` options of `body-parser` module and specify a path as to store the image file coming from the client.

```js
app.use(bodyParser.urlencoded({ extended: true }));

// below, also change this to
app.use('/public', express.static(__dirname + '/public'));
```

With this, we can see if our server is working correctly by running:

```shell
npm start
```

If you get the screen below by navigation on port `http://localhost:3000`, it means that our server is running.

<img src='https://cdn-images-1.medium.com/max/800/0*Tgeuf8qKcqzzwfSZ.png' />

Before we move to generate our front-end application, we need to change to port for our backend since front-end application generated using `create-react-app` will also be running on port `3000`. Open `bin/www` file and edit:

```js
/**
 * Get port from environment and store in Express.
 */

// 3000 by default, we change it to 4000

var port = normalizePort(process.env.PORT || '4000');
app.set('port', port);
```

### Setting up Front-end

`create-react-app` is another command line utility that to generate a default Reactjs front-end application.

```shell
create-react-app node-react-fileupload-front-end
```

We will also install the required library we are going to use for making API calls to our backend server.

```shell
yarn add axios
```

`index.js` is the starting point of our application in the `src/` directory. It registers the render function using `ReactDOM.render()` by mounting `App` component. Components are the building blocks in any Reactjs application. This `App` component comes from `src/App.js`. We will be editing this file in our front-end source code.

### File UploadÂ Form

We will be using the HTML `form` element that has an input which provides access to the value, that is the file, using `refs`. `Ref` is a special attribute that can be attached to any component in React. It takes a callback function and this callback will be executed immediately after the component is mounted. It can be also be used on an HTML element and the callback function associated will receive the DOM element as the argument. This way, `ref` can be used to store a reference for that DOM element. That is exactly what we are going to do.

```js
class App extends Component {
  // We will add this part later

  render() {
    return (
      <div className="App">
        <h1>FileUpload</h1>
        <form onSubmit={this.handleUploadImage}>
          <div>
            <input
              ref={ref => {
                this.uploadInput = ref;
              }}
              type="file"
            />
          </div>
          <br />
          <div>
            <input
              ref={ref => {
                this.fileName = ref;
              }}
              type="text"
              placeholder="Enter the desired name of file"
            />
          </div>
          <br />
          <div>
            <button>Upload</button>
          </div>
          <hr />
          <p>Uploaded Image:</p>
          <img src={this.state.imageURL} alt="img" />
        </form>
      </div>
    );
  }
}
```

The `input` element must have the `type="file"` otherwise it would not be able to recognize what type we are using it for. It is similar to the values like `email`, `password`, and so on.

The `handleUploadImage` method will take care of the API calls that we need to request to the server. If that call is successful, the local state of our React application will be set to let the user know that the upload was successful. Inside this function, to make the API call, we will be using `axios` library we installed when setting up our front end app.

```js
constructor(props) {
		super(props);

		this.state = {
			imageURL: ''
		};

		this.handleUploadImage = this.handleUploadImage.bind(this);
	}

	handleUploadImage(ev) {
		ev.preventDefault();

		const data = new FormData();
		data.append('file', this.uploadInput.files[0]);
		data.append('filename', this.fileName.value);

		fetch('http://localhost:4000/upload', {
			method: 'POST',
			body: data
		}).then(response => {
			response.json().then(body => {
				this.setState({ imageURL: `http://localhost:4000/${body.file}` });
			});
		});
	}
```

The FormData object lets you compile a set of key/value pairs to send using XMLHttpRequest. It is primarily intended for use in sending form data but can be used independently from forms in order to transmit keyed data. To build a FormData object, instantiating it then appending fields to it by calling its `append()` method like we did above.

<img src='https://cdn-images-1.medium.com/max/800/0*Xa5qBk-hqFkJsTIW.png' />

Since we are not using any styling, our form looks bare minimum and ugly. But you can go ahead and make it look more professional. For brevity, I am going to keep things simple. I recommend you to always enter a file uname, other wise it will store the file on the with `undefined.jpg` name.

### Updating the server to handle AJAXÂ Request

Right now, we do not have in our server code to handle the `POST` request React app makes a request to. We will add the route in our `app.js` in our Express application where the default route is defined.

```js
app.post('/upload', (req, res, next) => {
  // console.log(req);
  let imageFile = req.files.file;

  imageFile.mv(`${__dirname}/public/${req.body.filename}.jpg`, err => {
    if (err) {
      return res.status(500).send(err);
    }

    res.json({ file: `public/${req.body.filename}.jpg` });
    console.log(res.json);
  });
});
```

```shell
npm start
```

This route gets triggered when a request is made to `/upload/`. The callback associated using the route contain `req`, `res` objects and access to `next`, a standard way of defining a middleware function in an Express application. The `req` object has the file and the filename that was uploaded during form submission from the client application. If any error occurs, we return the 500 server error code. Otherwise we return the path to the actual file and console the `response` object to check if everything is work as we expect it.

`.mv` file is promise-based and provided to us by the `express-fileupload` package we installed earlier. Try uploading an image file from the client now. Make sure both the client and server are running from different terminal tabs at this point. If you get a success message like this in your terminal:

```shell
POST /upload 200 98.487 ms - 25
GET /public/abc.jpg 200 6.231 ms - 60775
```

At the same time, the client is requesting to view the file on the front-end with a `GET` HTTP method. That means the route `/upload` from the browser is successfully called and everything is working fine. Once the file is uploaded on the server and it will be sent back to the client to reflect that the user has successfully uploaded the file.

<img src='https://cdn-images-1.medium.com/max/800/0*cWOzuejEhEOtSQV8.png' />

You can find the complete code for this example at [**FileUpload-Example**](https://github.com/amandeepmittal/fileupload-example) Github Repository.

---

## Content insets with FlatList in React Native
Slug: content-insets-in-flatlist

In this quick post, let's explore how to use content insets available within FlatList in React Native to ensure that the content is properly presented behind the header. This post is a continuation of [Header blur effect in Expo Router](/blog/blur-effect-in-header-with-expo-router).

## Current approach: using `useHeaderHeight` hook

In React Native apps, `FlatList` is a component that renders a list of items. It is a common component that can be used to render a list of items in a scrollable container.

In previous tutorial, `useHeaderHeight` hook was used to get the height of the header and then use it to offset the content for iOS devices.

```tsx
import { useHeaderHeight } from '@react-navigation/elements';

export default function HomeScreen() {
  const headerHeight = useHeaderHeight();

  return (
    <FlatList
      contentContainerStyle={{
        paddingTop: Platform.OS === 'ios' ? headerHeight : 0
      }}
    />
  );
}
```

The `headerHeight` is then applied as `paddingTop` to the `FlatList` component's `contentContainerStyle` and it is made available using `@react-navigation/elements` library.

There's nothing wrong with the approach of calculating the header height manually using `useHeaderHeight` hook. However, the core list view component in React Native provides a way to handle content insets by passing a couple of props to the `FlatList` component. However, `FlatList`, and more over the underlying `ScrollView` component, has a property called `contentInsetAdjustmentBehavior` that can be used to adjust the content insets of the `FlatList` component.

## Using `contentInsetAdjustmentBehavior` and `automaticallyAdjustContentInsets`

Content insets define padding or margins that should be applied to scrollable content to prevent it from being obscured by system elements like the status bar, notches, or navigation bars. Without proper inset management, your content might extend under these UI elements, making parts of it inaccessible.

The `FlatList` component uses the same two props that `ScrollView` does: `contentInsetAdjustmentBehavior` and `automaticallyAdjustContentInsets`. The `contentInsetAdjustmentBehavior` prop can be set to `automatic` to automatically adjust the content insets based on the safe area and navigation bars. The `automaticallyAdjustContentInsets` prop can be set to `true` to enable this automatic adjustment.

```tsx
<FlatList
  data={trendingManga}
  renderItem={renderMangaItem}
  showsVerticalScrollIndicator={false}
  contentInsetAdjustmentBehavior="automatic"
  automaticallyAdjustContentInsets={true}
  ListHeaderComponent={<Text style={styles.sectionTitle}>Trending Manga</Text>}
/>
```

You won't need to use `useHeaderHeight` hook anymore. The `contentInsetAdjustmentBehavior` and `automaticallyAdjustContentInsets` work together to ensure that the content starts at the appropriate position, accounting for the transparent header, without requiring manual height calculations. This change results in the same behavior as the previous approach:

<img src="/images/react-native/manga-list-08.png" width="540" />

---

## Using Context API with React Native
Slug: context-api-react-native-firebase

![cover](https://i.imgur.com/tEzuwkP.png)

The React Context API lets you avoid passing props from parent to child at every level of the component tree. Neither you have to unnecessarily increase the complexity of the codebase using state management libraries like Redux. Consuming something like Firebase authentication and storage services with the Context API in a React Native or Expo apps is a great use case to try.

In this tutorial, I am going to show you how to setup Firebase email authentication in an Expo app using Context API. Before we get started, please note that I am going to use an Expo project that has:

- [navigation setup with `react-navigation` 4.x.x](https://amanhimself.dev/authentication-navigation-flow-in-react-native-apps)
- caching local images/assets
- [login and signup screen setup with formik and yup](https://amanhimself.dev/build-validate-forms-with-react-native-formik-yup)
- [handle different field types in React Native forms with formik and yup](https://amanhimself.dev/handle-different-field-types-in-react-native-forms)

You can download the **source code** in its current state from [**this Github repo**](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.5.0) before you begin.

After installing the source code, please navigate inside the project directory and install dependencies by running the following command:

```shell
yarnÂ install

#Â or

npmÂ install
```

## Table of Contents

- Requirements
- Add Firebase Config & integrate Firebase SDK
- Enable Firestore
- Add Context API
- Signup with Firebase
- Handle Real-time/Server Errors
- Login a Firebase user
- Add a signout button
- Check user auth state for automatic login
- Conclusion

## Requirements

To follow this tutorial, please make sure you following installed on your local development environment and access to the services mentioned below.

- Nodejs (>= `10.x.x`) with npm/yarn installed
- expo-cli (>= `3.x.x`), (previously known as create-react-native-app)
- Firebase account, free tier will do

## Add Firebase Config & integrate Firebase SDK

> If you already know how to obtain Firebase API and storage keys, you can skip this section. Otherwise, you can follow along.

Create a new [Firebase project from Firebase Console](https://console.firebase.google.com).

![1](https://i.imgur.com/7TSnVLL.png)

Next, fill in the suitable details regarding the Firebase project and click on **Create project** button.

![2](https://i.imgur.com/oXFOQBd.png)

You will be re-directed towards the dashboard of the Firebase project. Go to **Project settings** from the sidebar menu and copy the `firebaseConfig` object. It has all the necessary API keys that we need in order to use a Firebase project as the backend for any React Native or Expo app.

![3](https://i.imgur.com/XbVjdkB.png)

Next, go inside the [Expo app](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.5.0) and create a new directory called `config`. This folder will contain all the configuration files. Inside it, create `Firebase/firebaseConfig.js` file and paste the contents of the config object as below.

```js
// Replace all Xs with real Firebase API keys

export default {
  apiKey: 'XXXX',
  authDomain: 'XXXX',
  databaseURL: 'XXXX',
  projectId: 'XXXX',
  storageBucket: 'XXXX',
  messagingSenderId: 'XXXX',
  appId: 'XXXX'
};
```

Next, from the terminal window, install Firebase SDK.

```shell
yarn add firebase
```

Back to the `config/Firebase/` directory. Create a new file `firebase.js`. This will hold all the configuration related to integrate the Firebase SDK and the function it provides for authentication, real time database and so on.

Also, define a `Firebase` object with some initial methods that you are going to use in the tutorial. These methods are going to conduct real-time events such as user authentication, sign out from the app, and store the user details based on the reference to `uid` (_unique user id Firebase creates for every registered user_) in real-time NoSQL database called **Cloud Firestore**.

```js
import * as firebase from 'firebase';
import 'firebase/auth';
import 'firebase/firestore';
import firebaseConfig from './firebaseConfig';

// Initialize Firebase
firebase.initializeApp(firebaseConfig);

const Firebase = {
  // auth
  loginWithEmail: (email, password) => {
    return firebase.auth().signInWithEmailAndPassword(email, password);
  },
  signupWithEmail: (email, password) => {
    return firebase.auth().createUserWithEmailAndPassword(email, password);
  },
  signOut: () => {
    return firebase.auth().signOut();
  },
  checkUserAuth: user => {
    return firebase.auth().onAuthStateChanged(user);
  },

  // firestore
  createNewUser: userData => {
    return firebase
      .firestore()
      .collection('users')
      .doc(`${userData.uid}`)
      .set(userData);
  }
};

export default Firebase;
```

This approach used with React's Context API will eliminate the use of Redux state management (which is the approach I worked with [previously](https://amanhimself.dev/how-to-build-an-email-authentication-app-with-firebase-firestore-and-react-native)) library and simply use React principles. Populating the `Firebase` object with Context, you will be able to access all the functions as well as the user throughout this React Native app as props.

## Enable Firestore

There are two types of cloud-based database services provided by Firebase. One is called Cloud Firestore, and the other one is known as Realtime Database. Realtime Database stores data as one large JSON tree. Complex and scalable data is hard to organize in it.

Cloud Firestore follows proper NoSQL terminology when it comes to storing data. It stores data in documents, and each document can have sub-collectionsâ€”thus, making it suitable for scalable and complex data scenarios.

Go back to the Firebase console and in the Database section, choose the Cloud Firestore and click on the button **Create database**.

![4](https://i.imgur.com/k7Ecql7.png)

Then, choose the option Start in **test mode** and click the button **Next** as shown below.

![5](https://i.imgur.com/jLWPy9K.png)

## Add Context API

The common reason to use Context API in a React Native app is that you need to share some data in different places or components in the component tree. Manually passing props can be tedious as well as hard to keep track of.

The Context API consists of three building blocks:

- creating a context object
- declaring a provider that gives the value
- declaring a consumer that allows a value to be consumed (_provided by the provider_)

Create a new file inside the `Firebase` directory called `context.js`. Declare a `FirebaseContext` that is going to be an object.

```js
import React, { createContext } from 'react';

const FirebaseContext = createContext({});
```

After creating the context, the next step is to declare a provider and a consumer.

```js
export const FirebaseProvider = FirebaseContext.Provider;

export const FirebaseConsumer = FirebaseContext.Consumer;
```

Lastly, let us declare an HoC (_High Order Component_) to generalize this Firebase Context. An HoC in React is a function that takes a component and returns another component. What this HoC will do is instead of importing and using `Firebase.Consumer` in every component necessary, all there is to be done is just pass the component as the argument to the following HoC.

```js
export const withFirebaseHOC = Component => props => (
  <FirebaseConsumer>
    {state => <Component {...props} firebase={state} />}
  </FirebaseConsumer>
);
```

You will understand with more clarity in the next section when modifying the existing `Login` and `Signup` component with this HoC. Now, create a new file `index.js` to export both the `Firebase` object from the `firebase.js` file, the provider and the HoC.

```js
import Firebase from './firebase';
import { FirebaseProvider, withFirebaseHOC } from './context';

export default Firebase;

export { FirebaseProvider, withFirebaseHOC };
```

The provider has to grab the value from the context object for the consumer to use that value. This is going to be done in `App.js` file. The value for the `FirebaseProvider` is going to be the `Firebase` object with different strategies and functions to authenticate and store the user data in real-time database. Wrap the `AppContainer` with it.

```js
import React from 'react';
import AppContainer from './navigation';
import Firebase, { FirebaseProvider } from './config/Firebase';

export default function App() {
  return (
    <FirebaseProvider value={Firebase}>
      <AppContainer />
    </FirebaseProvider>
  );
}
```

That's it for setting up the Firebase SDK.

## Signup with Firebase

In this section, you are going to modify the existing `Signup.js` component in order to register a new user with the firebase backend and store their data in Firestore. To start, import the `withFirebaseHOC`.

```js
import { withFirebaseHOC } from '../config/Firebase';
```

Replace the `handleSubmit()` method with `handleOnSignup()`. Since all the input values are coming from Formik, you have to edit `onSubmit` prop on the `Formik` element too. The `signupWithEmail` is coming from firebase props and since you are already wrapping the navigation container with `FirebaseProvider`, `this.props.firebase` will make sure any method inside the `Firebase` object in the file `config/Firebase/firebase.js` is available to be used in this component.

The `signupWithEmail` method takes two arguments, `email` and `password` and using them, it creates a new user and saves their credentials. It then fetches the user id (_`uid`_) from the response when creating the new user. The `createNewUser()` method stores the user object `userData` inside the collection `users`. This user object contains the `uid` from the authentication response, the name, and email of the user entered in the signup form.

```js
handleOnSignup = async values => {
    const { name, email, password } = values

    try {
      const response = await this.props.firebase.signupWithEmail(
        email,
        password
      )

      if (response.user.uid) {
        const { uid } = response.user
        const userData = { email, name, uid }
        await this.props.firebase.createNewUser(userData)
        this.props.navigation.navigate('App')
      }
    } catch (error) {
      console.error(error)
    }
  }

// replace with handleOnSignup

onSubmit={values => {
  this.handleOnSignup(values)
}}
```

The logic behind saving the user object is the following:

```js
// config/Firebase/firebase.js
createNewUser: userData => {
  return firebase
    .firestore()
    .collection('users')
    .doc(`${userData.uid}`)
    .set(userData);
};
```

Lastly, do not forget to export the `Signup` component inside the `withFirebaseHOC`.

```js
export default withFirebaseHOC(Signup);
```

Let see how it works.

![f1](https://i.imgur.com/r40CEuW.gif)

Since it is going to the Home screen, means that use is getting registered. To verify this, visit the Database section from Firebase Console Dashboard. You will find a `users` collection have one document with the `uid`.

![6](https://i.imgur.com/Q1aoXx2.png)

To verify the `uid`, visit **Authentication** section.

![7](https://i.imgur.com/QXX3tXM.png)

## Handle Real-time/Server Errors

To handle real-time or server errors, Formik has a solution to this. Now, understand that something valid on the client-side can be invalid on the server. Such as, when registering a new user with an already existing email in the Firebase storage should notify the user on the client-side by throwing an error.

To handle this, edit the `onSubmit` prop at the `Formik` element bypassing the second argument called `actions`.

```js
onSubmit={(values, actions) => {
  this.handleOnSignup(values, actions)
}}
```

Next, instead of just console logging the error values, to display the error, you will have to use `setFieldError`. This will set an error message in the `catch` block. Also, add a `finally` block that will avoid the form to submit in case of an error.

```js
handleOnSignup = async (values, actions) => {
  const { name, email, password } = values;

  try {
    const response = await this.props.firebase.signupWithEmail(email, password);

    if (response.user.uid) {
      const { uid } = response.user;
      const userData = { email, name, uid };
      await this.props.firebase.createNewUser(userData);
      this.props.navigation.navigate('App');
    }
  } catch (error) {
    // console.error(error)
    actions.setFieldError('general', error.message);
  } finally {
    actions.setSubmitting(false);
  }
};
```

Lastly, do display the error on the app screen, add an `ErrorMessage` just after the `FormButton` component.

```js
<View style={styles.buttonContainer}>
  <FormButton
    buttonType='outline'
    onPress={handleSubmit}
    title='SIGNUP'
    buttonColor='#F57C00'
    disabled={!isValid || isSubmitting}
    loading={isSubmitting}
  />
</View>
<ErrorMessage errorValue={errors.general} />
```

Now go back to the Signup form in the app and try registering the user with the same email id used in the previous step.

![f2](https://i.imgur.com/XXK3D7N.gif)

_Voila!_ It works! The error message is shown and it does not submit the form.

## Login a Firebase user

As the previous section, similar number of steps have to be performed for the Login form to work. Instead of going through them individually, here is the complete `Login` component.

```js
import React, { Component, Fragment } from 'react';
import { StyleSheet, SafeAreaView, View, TouchableOpacity } from 'react-native';
import { Button } from 'react-native-elements';
import { Ionicons } from '@expo/vector-icons';
import { Formik } from 'formik';
import * as Yup from 'yup';
import { HideWithKeyboard } from 'react-native-hide-with-keyboard';
import FormInput from '../components/FormInput';
import FormButton from '../components/FormButton';
import ErrorMessage from '../components/ErrorMessage';
import AppLogo from '../components/AppLogo';
import { withFirebaseHOC } from '../config/Firebase';

const validationSchema = Yup.object().shape({
  email: Yup.string()
    .label('Email')
    .email('Enter a valid email')
    .required('Please enter a registered email'),
  password: Yup.string()
    .label('Password')
    .required()
    .min(6, 'Password must have at least 6 characters ')
});

class Login extends Component {
  state = {
    passwordVisibility: true,
    rightIcon: 'ios-eye'
  };

  goToSignup = () => this.props.navigation.navigate('Signup');

  handlePasswordVisibility = () => {
    this.setState(prevState => ({
      rightIcon: prevState.rightIcon === 'ios-eye' ? 'ios-eye-off' : 'ios-eye',
      passwordVisibility: !prevState.passwordVisibility
    }));
  };

  handleOnLogin = async (values, actions) => {
    const { email, password } = values;
    try {
      const response = await this.props.firebase.loginWithEmail(
        email,
        password
      );

      if (response.user) {
        this.props.navigation.navigate('App');
      }
    } catch (error) {
      actions.setFieldError('general', error.message);
    } finally {
      actions.setSubmitting(false);
    }
  };

  render() {
    const { passwordVisibility, rightIcon } = this.state;
    return (
      <SafeAreaView style={styles.container}>
        <HideWithKeyboard style={styles.logoContainer}>
          <AppLogo />
        </HideWithKeyboard>
        <Formik
          initialValues={{ email: '', password: '' }}
          onSubmit={(values, actions) => {
            this.handleOnLogin(values, actions);
          }}
          validationSchema={validationSchema}
        >
          {({
            handleChange,
            values,
            handleSubmit,
            errors,
            isValid,
            touched,
            handleBlur,
            isSubmitting
          }) => (
            <Fragment>
              <FormInput
                name="email"
                value={values.email}
                onChangeText={handleChange('email')}
                placeholder="Enter email"
                autoCapitalize="none"
                iconName="ios-mail"
                iconColor="#2C384A"
                onBlur={handleBlur('email')}
              />
              <ErrorMessage errorValue={touched.email && errors.email} />
              <FormInput
                name="password"
                value={values.password}
                onChangeText={handleChange('password')}
                placeholder="Enter password"
                secureTextEntry={passwordVisibility}
                iconName="ios-lock"
                iconColor="#2C384A"
                onBlur={handleBlur('password')}
                rightIcon={
                  <TouchableOpacity onPress={this.handlePasswordVisibility}>
                    <Ionicons name={rightIcon} size={28} color="grey" />
                  </TouchableOpacity>
                }
              />
              <ErrorMessage errorValue={touched.password && errors.password} />
              <View style={styles.buttonContainer}>
                <FormButton
                  buttonType="outline"
                  onPress={handleSubmit}
                  title="LOGIN"
                  buttonColor="#039BE5"
                  disabled={!isValid || isSubmitting}
                  loading={isSubmitting}
                />
              </View>
              <ErrorMessage errorValue={errors.general} />
            </Fragment>
          )}
        </Formik>
        <Button
          title="Don't have an account? Sign Up"
          onPress={this.goToSignup}
          titleStyle={{
            color: '#F57C00'
          }}
          type="clear"
        />
      </SafeAreaView>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    marginTop: 50
  },
  logoContainer: {
    marginBottom: 15,
    alignItems: 'center'
  },
  buttonContainer: {
    margin: 25
  }
});

export default withFirebaseHOC(Login);
```

Let us see how it works. For a successful login, use registered credentials.

![f3](https://i.imgur.com/DrqOjct.gif)

## Add a signout button

Sign out button at this point is essential but since there is no app interface right now, I am going to put a simple button on the home screen. Open, `Home.js` file and import `Button` from `react-native-elements`.

Also, import `withFirebaseHOC` and add the `Button` component below the text.

```js
import React, { Component } from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { Button } from 'react-native-elements';
import { withFirebaseHOC } from '../config/Firebase';

class Home extends Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>Home</Text>
        <Button
          title="Signout"
          onPress={this.handleSignout}
          titleStyle={{
            color: '#F57C00'
          }}
          type="clear"
        />
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export default withFirebaseHOC(Home);
```

Here is out the output.

![8](https://i.imgur.com/YLzeMt6.png)

Right now, this button doesn't do anything. You will have to add the `handleSignout` method as below.

```js
handleSignOut = async () => {
  try {
    await this.props.firebase.signOut();
    this.props.navigation.navigate('Auth');
  } catch (error) {
    console.log(error);
  }
};
```

Go back to the home screen and login into the app. Once the home screen is displayed, click the button `Signout`.

![f4](https://i.imgur.com/qo3v0BF.gif)

## Check user auth state for automatic login

Right now, whenever the user successfully logs in or registers it does lead to the Home screen of the app but on refreshing the simulator, the navigation pattern takes back to the login screen.

In this section, you are going to add a small authentication check using Firebase method `onAuthStateChanged()` that takes the current user as the argument if they are logged in.

The auth check is going to do at the same point when the application is loading assets, that is, the `Initial` screen component. It has been already hooked in the navigation pattern to be the first screen or the initial route.

```js
// navigation.js

import { createSwitchNavigator, createAppContainer } from 'react-navigation';
import Initial from '../screens/Initial';
import AuthNavigation from './AuthNavigation';
import AppNavigation from './AppNavigation';

const SwitchNavigator = createSwitchNavigator(
  {
    Initial: Initial,
    Auth: AuthNavigation,
    App: AppNavigation
  },
  {
    initialRouteName: 'Initial'
  }
);

const AppContainer = createAppContainer(SwitchNavigator);

export default AppContainer;
```

Using the lifecycle method inside the `Initial.js`, the authentication status of whether is user is logged in the app or not can be checked.

Start by importing the Firebase HoC in the file `screens/Initial.js`.

```js
import { withFirebaseHOC } from '../config/Firebase';
```

Next, inside the `componendDidMount` method add the following. If the user has previously logged in, the navigation flow will directly take the user to the Home screen. If the is not logged in, it will show the Login screen.

```js
componentDidMount = async () => {
  try {
    // previously
    this.loadLocalAsync();

    await this.props.firebase.checkUserAuth(user => {
      if (user) {
        // if the user has previously logged in
        this.props.navigation.navigate('App');
      } else {
        // if the user has previously signed out from the app
        this.props.navigation.navigate('Auth');
      }
    });
  } catch (error) {
    console.log(error);
  }
};

// Don't forget to export
export default withFirebaseHOC(Initial);
```

Let us see it in action. Even after refreshing the app, the authenticated user stays logged in.

![f5](https://i.imgur.com/toxtKit.gif)

## Conclusion

_Congratulations! ðŸŽ‰_ If you have come this far, I am hope enjoyed reading this post. These are some of the strategies I try to follow with any Firebase + React Native + Expo project. I hope any of the codebase used in this tutorial helps you.

To find the complete code, you will have to visit [this Github repo release](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.6.0).

---

## Convert png to jpg using ffmpeg
Slug: convert-png-to-jpg-using-ffmpeg

As a documentarian, I've used [ffmpeg](https://ffmpeg.org/) command-line tool for a while now. It is a powerful tool that can do a lot of things. At work, I use it to convert videos and images.

## Prerequisites

Install [`ffmpeg` using homebrew](https://formulae.brew.sh/formula/ffmpeg).

## Why use ffmpeg?

On macOS, Cleanshot X app by default captures the screenshot in **png** format. These files are large in file size and have a large resolution (not usually suitable for a web page).

## How to use ffmpeg to convert png to jpg?

A **jpg** can have a smaller file size and is preferred for web pages. To convert a **png** to **jpg** using ffmpeg, use the following command:

```shell
ffmpeg -i input.png -preset ultrafast output.jpg
```

---

## Converting a Buffer to JSON and Utf8 Strings in Nodejs
Slug: converting-a-buffer-to-json-and-utf8-strings-in-nodejs

Nodejs and browser based JavaScript differ because Node has a way to handle binary data even before the ES6 draft came up with `ArrayBuffer`. In Node, `Buffer` class is the primary data structure used with most I/O operations. It is a raw binary data that is allocated outside the V8 heap and once allocated, cannot be resized.

Before Nodejs v6.0, to create a new buffer you could just call the constructor function with `new` keyword:

```js
let newBuff = new Buffer('New String');
```

To create a new buffer instance, in latest and current stable releases of Node:

```js
let newBuff = Buffer.from('New String');
```

The `new Buffer()` constructor have been deprecated and replaced by separate `Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()` methods.

More information can be read through [**official documentation**](https://nodejs.org/api/buffer.html).

### Convert a Buffer toÂ JSON

Buffers can convert to JSON.

```js
let bufferOne = Buffer.from('This is a buffer example.');
console.log(bufferOne);

// Output: <Buffer 54 68 69 73 20 69 73 20 61 20 62 75 66
// 66 65 72 20 65 78 61 6d 70 6c 65 2e>

let json = JSON.stringify(bufferOne);
console.log(json);

// Output: {"type":"Buffer","data":[84,104,105,115,32,105,
// 115,32,97,32,98,117,102,102,101,114,32,101,120,97,109,
// 112,108,101,46]}
```

The JSON specifies that the type of object being transformed is a `Buffer`, and its data.

### Convert JSON toÂ Buffer

```js
let bufferOriginal = Buffer.from(JSON.parse(json).data);
console.log(bufferOriginal);

// Output: <Buffer 54 68 69 73 20 69 73 20 61 20 62 75 66
// 66 65 72 20 65 78 61 6d 70 6c 65 2e>
```

### Convert Buffer to Utf-8Â String

```js
console.log(bufferOriginal.toString('utf8'));

// Output: This is a buffer example.
```

`.toString()` is not the only way to convert a buffer to a string. Also, it by defaults converts to a utf-8 format string.

The other way to convert a buffer to a string is using `StringDecoder` core module from Nodejs API.

---

## Create a copy as markdown button for LLMs in an MDX documentation site
Slug: create-a-copy-as-markdown-for-mdx-documentation

Using MDX for writing and managing content for a documentation site provides flexibility if you are deep into the "docs-as-code" workflow. This flexibility allows you to mix Markdown with React components, use dynamic data and stitch them together at runtime.

However, this flexibility also comes with challenges. MDX files often contain components that render content at runtime and these components are not included in the raw Markdown output:

- Scene/custom components that load _wizard_ steps or reusable content from separate files
- Schema-driven tables that read JSON configurations
- API documentation generated from TypeDoc/JSDoc output
- Embedded code blocks and media content components

Using raw `.mdx` files on their own to add a feature such as a "copy as markdown" button on each page of your documentation site won't include the dynamic content stitched at runtime.

> **Note:** This article is not a comprehensive guide to implementing the "copy as markdown" button. It is a high-level overview of the solution and implementation details for a Next.js based documentation site that I work on.

## Solution overview

One way to solve this problem and implement the "copy as markdown" button is to identify the key tasks. In a typical MDX documentation site, the key tasks are:

- Locate the source MDX file for the current page
- Fetch the raw MDX and run it through a conversion pipeline
- Expand every dynamic component (scene, JSON-driven tables, TypeDoc/JSDoc output) into Markdown
- Copy the result to the clipboard or allow opening it in an AI tool

At a high level, the flow looks like this:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     fetch raw .mdx     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Copy Button   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ prepareMarkdownâ€¦     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚ 1. strip imports     â”‚
      â”‚                                  â”‚ 2. expand scenes     â”‚
      â”‚ write Markdown                   â”‚ 3. render schemas    â”‚
      â–¼                                  â”‚ 4. render API JSON   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚ 5. final assembly    â”‚
â”‚ Clipboard /   â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ returns Markdown     â”‚
â”‚ AI tools      â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Everything happens on the client-side using static resources shipped with the site. Implementing this flow requires using regular expressions to strip out the React imports and expand the dynamic components into Markdown.

The solution will be custom to each documentation site and the data sources it uses. However, the core idea of solving this problem is to identify the key tasks. From the next section onwards, I will share my implementation of the solution for a Next.js based documentation site.

## Implementation overview

Here is an overview of how I implemented the above solution for a Next.js based documentation site.

### Create a React component

Initially, your page will require a button to trigger the "copy as markdown" action. This button can be in a dropdown that renders other available actions such as "open in X AI tool".

The component needs to know which MDX file corresponds to the current page. In a documentation site powered by Next.js, you can fetch the MDX file from the `router`:

```ts
export function MarkdownActionsDropdown() {
  const router = useRouter();
  const pathname = router?.pathname;
  const asPath = router?.asPath;

  // Build the raw GitHub URL for the current page's MDX file
  const rawMarkdownUrl = useMemo(() => {
    if (!pathname) {
      return null;
    }
    // Convert route pathname to file path (e.g., /sdk/abc â†’ pages/sdk/abc.mdx)
    const filePath = getPageMdxFilePath(pathname);
    // Generate raw GitHub content URL
    return filePath ? githubRawUrl(pathname) : null;
  }, [pathname]);

  const handleCopyMarkdown = useCallback(async () => {
    if (!rawMarkdownUrl) return;

    // Fetch the raw MDX file from GitHub or your CDN
    const response = await fetch(rawMarkdownUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch markdown: ${response.status}`);
    }

    const mdx = await response.text();

    // Convert MDX to Markdown, passing the current path for context
    // This helps resolve versioned URLs (if any) like /versions/v1.0.0/sdk/abc
    const markdown = await prepareMarkdownForCopyAsync(mdx, {
      path: asPath ?? pathname ?? ''
    });

    await navigator.clipboard.writeText(markdown);
  }, [rawMarkdownUrl, asPath, pathname]);

  // Render dropdown items (Copy as Markdown, Open in ChatGPT, Open in Claude, etc.)
}
```

Some documentation sites might have versioned content such as `/versions/v1.0.0/sdk/abc`. In such cases, you can use the `path` parameter to resolve the versioned URL to the raw MDX file. Furthermore, these versioned URLs might also contain the TypeDoc/JSDoc output for API documentation. It is important to know which version to fetch for which page. The `path` parameter allows our converter to extract the version number and load the correct data files.

Another important function from the above code snippet is `prepareMarkdownForCopyAsync()`. It is the heart of the pipeline and orchestrates all the conversions.

### Parsing frontmatter and normalizing Markdown

The `prepareMarkdownForCopyAsync()` function begins by processing the raw MDX files in stages. In each stage, it handles a specific type of content transformation:

````ts
export async function prepareMarkdownForCopyAsync(
  rawContent: string,
  context: { path?: string } = {}
) {
  if (!rawContent) return '';

  // Step 1: Extract YAML front matter (title, description, etc.)
  // This separates metadata from content so you can use it as headings
  let { content, title, description } = extractFrontMatter(rawContent);

  // Step 2: Find all schema imports before you remove them
  // Example: import abcSchema from '~/public/static/schemas/abc.ts'
  // You need to track these because schema components reference them by name
  const schemaImports = extractSchemaImports(content);

  // Step 3: Remove all import statements
  // MDX imports React components, but you're converting to plain Markdown
  content = content.replace(IMPORT_STATEMENT_PATTERN, '');

  // Step 4: Convert custom React components to Markdown equivalents
  // Each function handles a specific component type
  content = convertBoxLinksToMarkdown(content); // <BoxLink title="Guides" href="/guides" /> â†’ [Guides](/guides)
  content = convertContentSpotlight(content); // <ContentSpotlight file="screenshot.png" /> â†’ ![Screenshot](https://example.com/static/images/screenshot.png)
  content = convertTerminalsToCodeBlocks(content); // <Terminal cmd={['$ npm install']} /> â†’ ```bash\n$ npm install\n```

  // Step 5: Expand dynamic components that load external content
  // These are async because they need to fetch additional files
  content = await replaceSceneComponentsAsync(content, schemaImports);
  content = await replaceSchemaComponentsAsync(content, schemaImports, context);
  content = await replaceApiSectionsAsync(content, context);

  // Step 6: Reassemble the complete document with front matter as headings
  return assembleDocument({ title, description, content });
}
````

Processing easier components like the frontmatter of the page, code blocks, links, embedded images, and so on, before processing complex ones takes care of most of the edge cases. This prevents intermediate transformations from interfering with pattern matching in later stages.

Let's look at one of the simpler conversions to understand the pattern:

````ts
function convertTerminalsToCodeBlocks(content: string): string {
  // Match: <Terminal cmd={['$ npm install', '$ npm start']} />
  const terminalPattern = /<Terminal\s+cmd=\{(\[[^\]]+\])\}\s*\/>/g;

  return content.replace(terminalPattern, (match, cmdArray) => {
    // Parse the JavaScript array of commands
    // cmdArray is a string like "['$ npm install', '$ npm start']"
    const commands = JSON.parse(cmdArray.replace(/'/g, '"'));

    // Convert to a bash code block
    return '```bash\n' + commands.join('\n') + '\n```';
  });
}
````

This pattern repeats throughout the converter: find a component pattern with regex, extract its props, and return the Markdown equivalent.

### Expanding scene and reusable components

A _scene_ component lives inside a separate file. Its purpose is to provide consistency when creating documentation pages that follow a specific UI/content pattern. They can be either custom to a page or reused across multiple pages with different input values. MDX files often render entire wizards or multi-step flows through these custom components. Here's an example:

```md
<!-- Page: Integration guide -->
<Prerequisites />
<Configuration />
<Steps />
```

When rendered live, these custom components inject the content of the separate files into the current page. The raw MDX only contains the component tag, not the actual instructions. You need to load all the scene variations and include them in the output.

```ts
export async function generateEnvironmentInstructionsMarkdownAsync() {
  // List all the different instruction variants
  const sectionPaths = [
    'scenes/prerequisites.mdx',
    'scenes/configuration.mdx',
    'scenes/steps.mdx'
    // ... other combinations
  ];

  const sections = [];

  for (const relativePath of sectionPaths) {
    // Fetch the scene's MDX content from your static assets
    const raw = await fetchSceneMdx(relativePath);

    // Transform the scene MDX just like we transform the main page:
    // - Remove imports
    // - Convert <Prerequisites>, <Configuration>, <Steps> components to Markdown
    const markdown = transformSceneMdx(raw);

    // Create a descriptive heading from the file path
    // 'scenes/prerequisites.mdx' â†’ 'Prerequisites'
    const heading = headingFor(relativePath);

    sections.push(`## ${heading}\n\n${markdown}`);
  }

  // Join all sections with blank lines
  return sections.join('\n\n');
}
```

The transformation function (`transformSceneMdx()`) for scene MDX reuses the existing patterns:

```ts
function transformSceneMdx(raw: string): string {
  let content = raw;

  // Remove imports and front matter from the scene file
  content = content.replace(IMPORT_STATEMENT_PATTERN, '');
  content = extractFrontMatter(content).content;

  // Convert scene-specific components
  // <Prerequisites /> becomes "## Prerequisites"
  content = convertPrerequisitesToMarkdown(content);

  // <Step> becomes numbered headings: "### Step 1: Install dependencies"
  content = convertStepComponents(content);

  // <Terminal> and other standard components use the same converters
  content = convertTerminalsToCodeBlocks(content);

  return content;
}
```

Now when `prepareMarkdownForCopyAsync()` encounters `<Steps />`, it replaces it with this pre-rendered Markdown. You can apply this same pattern to other scene/custom componentsâ€”the key is identifying what external content they load and fetching it during conversion.

## Converting TypeDoc/JSDoc API Sections

API documentation is often the most complex content to convert. A documentation site can use TypeDoc/JSDoc to generate JSON from TypeScript/JavaScript source code, then render that JSON. Your MDX might include a component that renders the API classes, methods, types, and properties:

```ts
<APISection packageName="api-name" />
```

This tells the site to load TypeDoc JSON (like `/public/static/data/v1.0.0/api-name.json`) and render all its classes, methods, types, and properties. The core challenge is to convert the JSON into Markdown since TypeDoc generates deeply nested JSON structures with classes, interfaces, methods, and other element types. Each element needs to be formatted appropriately for Markdown while preserving all the documentation details developers expect.

The conversion process involves identifying the key rendering patterns. For each TypeDoc element type, you can extract structured information and format it consistently. Here are the key rendering patterns:

- **Classes**: Render as H3 heading with properties (as bulleted lists) and methods (with signatures and descriptions)
- **Methods**: Show signature with parameters and return type, followed by indented description, parameter docs, return value description, and examples
- **Properties**: Display as inline code with type annotation, followed by description
- **Types**: Convert TypeDoc's nested type structures to readable strings (handling unions, arrays, objects, and more)
- **Comments**: Extract JSDoc tags like `@param`, `@returns`, `@example`, `@platform` and format appropriately

This conversion approach looks like:

```ts
export async function generateApiSectionMarkdownAsync(
  options: {
    packageName?: string | string[];
    apiName?: string;
    forceVersion?: string;
  },
  context: { path?: string }
) {
  // 1. Resolve the correct version from the URL path
  const version = resolveVersion(options.forceVersion, context.path);

  // 2. Normalize package names to an array
  const packages = Array.isArray(options.packageName)
    ? options.packageName
    : options.packageName
      ? [options.packageName]
      : [];

  // 3. Fetch TypeDoc JSON for the specified packages
  const dataFiles = await Promise.all(
    packages.map(pkg => fetchPackageDataAsync(version, pkg))
  );

  // 4. Extract all exported items (classes, interfaces, functions, etc.)
  const entries = dataFiles.flatMap(file => file?.children ?? []);

  // 5. Convert each entry to Markdown based on its type
  const sections = entries.map(entry => renderEntryMarkdown(entry, version));

  const displayName = Array.isArray(options.packageName)
    ? options.packageName.join(', ')
    : options.packageName || 'API';

  return `## API: ${displayName}\n\n${sections.join('\n\n')}`;
}
```

Example output structure:

````md
## API: api-name

### API Name

A class representing an API in your app.

#### Properties

- `uri?: string`
  The URI of the image.

- `width?: number`
  Width of the image in pixels.

#### Methods

- `loadAsync(): Promise<Image>`
  Loads the image asynchronously
  **Returns:** A promise that resolves to the loaded image
  **Example:**
  ```typescript
  const image = await Image.loadAsync(require('./image.png'));
  ```
````

The TypeDoc conversion follows the same pattern as other components: detect the component tag, fetch the necessary data (TypeDoc JSON), transform it systematically (classes â†’ Markdown, methods â†’ Markdown, types â†’ strings), and replace the original tag with the generated content.

TypeDoc's JSON is structured and predictable. Once you understand the schema (classes have children, methods have signatures, types have type fields), you can write straightforward transformation functions that handle each case.

## The Pattern in Practice

At this point, you've seen concrete examples of the conversion pipeline in action:

- Scene/Custom components: Load external MDX files and transform their custom components
- API Documentation: Transform TypeDoc JSON into formatted API references

The beauty of this approach is its extensibility. Every new component type you need to handle follows the same pattern:

```ts
async function replaceCustomComponentAsync(content: string, context: any) {
  // 1. Pattern matching - Find the component tags
  const componentPattern = /<CustomComponent\s+prop="([^"]+)"\s*\/>/g;

  // 2. Data fetching - Load any external data the component needs
  const data = await fetchComponentData(componentPattern);

  // 3. Transformation - Convert the data to Markdown
  const markdown = transformDataToMarkdown(data);

  // 4. Replacement - Swap the component tag with Markdown
  return content.replace(componentPattern, markdown);
}
```

This pipeline architecture means you're not locked into handling only the components we've discussed. As your documentation evolves and you add new interactive elements, you can extend the converter by adding new transformation functions.

## Wrap up

Implementing a "copy as markdown" button for MDX documentation involves identifying the key tasks and writing helper functions to transform the dynamic parts of the page into raw Markdown. This approach should allow you to handle new components and data sources as they are added to the documentation site. Treat MDX components as structured data sources rather than opaque black boxes.

---

## Create a Simple Twitter Bot with Node.js
Slug: create-a-simple-twitter-bot-with-node-js

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/create-a-simple-twitter-bot-with-node-js-5b14eb006c08)

How about a Twitter Bot that retweets, favorites, on the basis of hashtags and replies to other users if they follow it? I made a similar kind of a Twitter Bot [(@nodejstweet)](https://x.com/nodejstweet) that feeds me the latest or the ongoing news/articles/how-toâ€™s on a set of hashtags such as #Nodejs, #MongoDB, #AngularJS, #IonicFramework, et cetera. At the time I never expected it having more followers than me but that has been surpassed.

<img src='https://cdn-images-1.medium.com/max/800/1*DcLASOdtPlO8p86oUg86JA.png' />

### What this bot willÂ do?

This is a simple Twitter bot and will retweet, favorite/like randomly on the basis of hashtags as a query that we will use and continue to do so after a certain period of time interval.

## What youÂ need?

- You must have [Node.js](http://nodejs.org) installed on your system.
- A Twitter Account.
- Your bot will be using [`twit`](https://www.npmjs.com/package/twit) which is an npm module to manipulate tweets and streams, and to communicate with the [Twitter API](https://dev.twitter.com/docs).

## Letâ€™s Start

Setup an empty directory and initialise it with:`$ npm init` to configure this web application with `package.json` file. Then create two new files: `bot.js` & `config.js` in that directory.

`bot.js` will be our main app file in which we will be writing the source code of our Twitter Bot, and so in `package.json` edit the `main` field to:

```json
{
  "main": "bot.js"
}
```

Your current directory structure should look like this:

```shell
root/project-name
|- bot.js
|- config.js
|- package.json
```

## Configuring and granting permissions from TwitterÂ API

After logging to to your Twitter account, follow to this link: [https://apps.twitter.com/app/new](https://apps.twitter.com/app/new) to create a new application. Fill out the necessary fields in the form click on the button _Create Your Twitter Application._ After creating the application, look for `Keys and Access Tokens` under the nav-panes and click on `Generate Token Actions\` and then copy:

- Consumer Key
- Consumer Secret
- Access Token
- Access Token Secret

Open the `config.js` file and paste all four values inside it. Expose those values using `module.export`:

```js
//config.js
/* TWITTER APP CONFIGURATION
 * consumer_key
 * consumer_secret
 * access_token
 * access_token_secret
 */

module.exports = {
  consumerconsumer_key: '',
  consumerconsumer_secret: '',
  accessaccess_token: '',
  accessaccess_tokenaccess_token_secret: ''
};
```

Now, the Twitter botâ€™s configuration is step is complete. _Please note,_ for every different application, the `consumer key`, `consumer secret`, `access_token` and `access_token_secret` will differ.

## Building theÂ bot

Since the configuration step is complete, now letâ€™s install our third requisite that is [Twitter API client for node](https://www.npmjs.com/package/twit) and will help us to communicate to Twitter API and provide an API for all necessary actions _(such as retweet and favorite a tweet)._

We will start by installing the dependency we need for our application.

```shell
$ npm install --save twit
```

After the dependency has finished installing, go to the `bot.js` file and require the dependency and `config.js` file.

```js
var twit = require(â€™twitâ€™);
var config = require(â€™./config.jsâ€™);
```

Pass the configuration (_consumer and access tokens_) of our Twitter application in `config.js` to `twit:`

```js
var Twitter = new twit(config);
```

So far, so good?

**PLEASE NOTE: You must refer to** [twit documentation](https://www.npmjs.com/package/twit) **for a deep reference.**

#### Retweet Bot

Letâ€™s write a function expression that finds the latest tweets according to the query passed as a parameter. We will initialise a `params` object that will hold various properties to search a tweet, but most importantly `query` or `q` property that will refine our searches. Whatever value you feed in this property, our bot will search the tweets to retweet based on this criteria. You can feed this property values like a twitter handler, to monitor a specific twitter account or a #hashtag. For our example bot, we have find latest tweets on #nodejs.

This is how the functionality of the retweet bot starts:

```js
var retweet = function() {
  var params = {
    q: '#nodejs, #Nodejs',
    result\_type: 'recent',
    lang: 'en'
  }
```

The other two properties: `result_type` and `lang` are optional. On defining the `result_type: 'recent'` notifies bot to only search for the latest tweets, tweets that have occurred in the time period since our bot has started or it made the last retweet.

[There is a list of parameters provided by the Twitter API](https://dev.twitter.com/rest/reference/get/search/tweets).

Our next step is to search for the tweets based on our parameters. For this, we will use `Twitter.get` function provided by `twit` API to GET any of the REST API endpoints. The REST API endpoint is a reference to the T[witter API endpoint](https://dev.twitter.com/docs) we are going to make a call to search for tweets. The `Twitter.get` function accepts three arguments: API endpoint, params object (defined by us) and a callback.

```js
// RETWEET BOT ==========================

// find latest tweet according the query 'q' in params
var retweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  // for more parameters, see: https://dev.twitter.com/rest/reference/get/search/tweets

  Twitter.get('search/tweets', params, function (err, data) {
    // if there no errors
    if (!err) {
      // grab ID of tweet to retweet
      var retweetId = data.statuses[0].id_str;
      // Tell TWITTER to retweet
      Twitter.post(
        'statuses/retweet/:id',
        {
          id: retweetId
        },
        function (err, response) {
          if (response) {
            console.log('Retweeted!!!');
          }
          // if there was an error while tweeting
          if (err) {
            console.log(
              'Something went wrong while RETWEETING... Duplication maybe...'
            );
          }
        }
      );
    }
    // if unable to Search a tweet
    else {
      console.log('Something went wrong while SEARCHING...');
    }
  });
};
```

To post or to retweet the tweet our bot has found we use `Twitter.post()` method to _POST any of the REST API endpoints_. It also takes the same number of arguments as `Twitter.get()`.

Now to automate this action we defined above, we can use JavaScriptâ€™s timer function `setInterval()` to search and retweet after a specific period of time.

```js
// grab & retweet as soon as program is running...
retweet();
// retweet in every 50 minutes
setInterval(retweet, 3000000);
```

Please note that all JavaScriptâ€™s Timer functions take the _amount of time_ argument in milliseconds.

#### Favorite Bot

Similar to `retweet` bot we can define and initialise another function expression that will search and _favorite_ a tweet randomly. Yes, the difference here is to search and grab the tweet randomly. We will start by creating a parameter object `params` that will consist of three properties as in `retweet()` function expression. The bot will search for tweets using the sameÂ `.get()` function provided by `twit` API to GET any of the Twitter API endpoints. In our case, we need `search/tweets`. Then we will store the status of the search for tweet to _favorite_ in a variable and in a another variable we will apply the random function by passing the â€œstatus of the searchâ€ variable as an argument.

```js
// FAVORITE BOT====================

// find a random tweet and 'favorite' it
var favoriteTweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  // for more parameters, see: https://dev.twitter.com/rest/reference

  // find the tweet
  Twitter.get('search/tweets', params, function (err, data) {
    // find tweets
    var tweet = data.statuses;
    var randomTweet = ranDom(tweet); // pick a random tweet

    // if random tweet exists
    if (typeof randomTweet != 'undefined') {
      // Tell TWITTER to 'favorite'
      Twitter.post(
        'favorites/create',
        { id: randomTweet.id_str },
        function (err, response) {
          // if there was an error while 'favorite'
          if (err) {
            console.log('CANNOT BE FAVORITE... Error');
          } else {
            console.log('FAVORITED... Success!!!');
          }
        }
      );
    }
  });
};
// grab & 'favorite' as soon as program is running...
favoriteTweet();
// 'favorite' a tweet in every 60 minutes
setInterval(favoriteTweet, 3600000);

// function to generate a random tweet tweet
function ranDom(arr) {
  var index = Math.floor(Math.random() * arr.length);
  return arr[index];
}
```

Note that the tweets searched by our bot are all stored in an array. Again, we use JavaScriptâ€™s timer function `setInterval()`to search and favorite the tweet after a specific period of time in milliseconds.

The complete module: `bot.js`Â :

```js
// Dependencies =========================
var twit = require('twit'),
  config = require('./config');

var Twitter = new twit(config);

// RETWEET BOT ==========================

// find latest tweet according the query 'q' in params
var retweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  Twitter.get('search/tweets', params, function (err, data) {
    // if there no errors
    if (!err) {
      // grab ID of tweet to retweet
      var retweetId = data.statuses[0].id_str;
      // Tell TWITTER to retweet
      Twitter.post(
        'statuses/retweet/:id',
        {
          id: retweetId
        },
        function (err, response) {
          if (response) {
            console.log('Retweeted!!!');
          }
          // if there was an error while tweeting
          if (err) {
            console.log(
              'Something went wrong while RETWEETING... Duplication maybe...'
            );
          }
        }
      );
    }
    // if unable to Search a tweet
    else {
      console.log('Something went wrong while SEARCHING...');
    }
  });
};

// grab & retweet as soon as program is running...
retweet();
// retweet in every 50 minutes
setInterval(retweet, 3000000);

// FAVORITE BOT====================

// find a random tweet and 'favorite' it
var favoriteTweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  // find the tweet
  Twitter.get('search/tweets', params, function (err, data) {
    // find tweets
    var tweet = data.statuses;
    var randomTweet = ranDom(tweet); // pick a random tweet

    // if random tweet exists
    if (typeof randomTweet != 'undefined') {
      // Tell TWITTER to 'favorite'
      Twitter.post(
        'favorites/create',
        { id: randomTweet.id_str },
        function (err, response) {
          // if there was an error while 'favorite'
          if (err) {
            console.log('CANNOT BE FAVORITE... Error');
          } else {
            console.log('FAVORITED... Success!!!');
          }
        }
      );
    }
  });
};
// grab & 'favorite' as soon as program is running...
favoriteTweet();
// 'favorite' a tweet in every 60 minutes
setInterval(favoriteTweet, 3600000);

// function to generate a random tweet tweet
function ranDom(arr) {
  var index = Math.floor(Math.random() * arr.length);
  return arr[index];
}
```

## Usage

To run this bot, go to your terminal:

```shell
$ node bot.js
```

To avoid this monotonous process you can use `npm scripts` or `nodemon.` You can also deploy this app on `Heroku` for a continuous integration.

To use npm scripts, make this edit under `scripts` in `package.json`Â :

```json
{
  "scripts": {
    "start": "node bot.js"
  }
}
```

Then from terminal:

```shell
$ npm start
```

There are various ways to write a Twitter Bot, this is just one way. Your bot can be smart and you can do various things with it. You just have to refer to [twit documentation](https://www.npmjs.com/package/twit) for other RESTful API methods to manipulate [Twitter API endpoints](http://REST%20API%20Endpoints:%20https://dev.twitter.com/rest/public).

For further reading check out [Botwiki.org](https://botwiki.org/bots/twitterbots/) for various types of bots on vast amount of platforms. For advanced reading, check out [Botwikiâ€™s list of tutorials of Twitter Bots in different programming languages](https://botwiki.org/tutorials/twitterbots/).

---

## Changing app themes using React Native, Styled Components and Redux
Slug: create-app-themes-styled-components-redux

![cover](https://i.imgur.com/RSo1BSr.jpg)

> [Originally published at Jscrambler](https://jscrambler.com/blog/changing-app-themes-using-react-native-styled-components-and-redux)

If you are getting into React Native or have already dipped your toes, you know that there are different ways you can style a React Native app. React Native uses JavaScript objects to style by default. If you have some experience with the CSS of the web, you know that styling a component is nothing more than writing code by using proper styling syntax.

This tutorial is going to be about styling your React Native apps using ðŸ’… [Styled Components](https://www.styled-components.com/) and switching between two themes using Redux as state management library with it. It is a third-party open-source library. Using it is a matter of choice, but also another way to add styling to your app, and many might find it easy to use, especially if you have used this library before with other frameworks.

## Requirements

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- Nodejs (>=`10.x.x`) with npm/yarn installed.
- `react-native-cli`
- Mac users must be running an iOS simulator.
- Windows/Linux users must be running an Android emulator.

To know more about how to setup a development environment for React Native using `react-native-cli` please refer to the [official documentation here](https://facebook.github.io/react-native/docs/getting-started).

You can find the complete code for this tutorial at [this Github repository](https://github.com/amandeepmittal/StyledThemeApp).

## Installing styled-components

Assuming that you have created a new React Native project using the command `react-native init StyledThemeApp` from a terminal window, please navigate inside the newly generated directory. When inside it, please execute the following command to install `styled-components` library.

```shell
npm install styled-components
```

_That's all you need to do to use it in your React Native app!_

Styled Components is a CSS-in-JS library that enables developers to write each component with their styles and allows the code to be in a single location. By coupling your styles with the components, it results in optimizing developer experience and output.

Let us create a simple component that will act as a primary screen of the app. Create a new file inside `screens/HomeScreen.js`. It is a class component that displays a text inside a box. The visual components are created using `styled-components`. To consume this library, you start by writing an import statement from `styled-components/native`.

```js
import React from 'react';
import styled from 'styled-components/native';

const Container = styled.SafeAreaView`
  flex: 1;
  background-color: papayawhip;
  justify-content: center;
  align-items: center;
`;

const TextContainer = styled.View`
  padding: 15px;
  border-radius: 5px;
  border: 1px solid palevioletred;
`;

const Title = styled.Text`
  padding: 20px;
  font-size: 24px;
  font-weight: 500;
  color: palevioletred;
`;

class HomeScreen extends React.Component {
  render() {
    return (
      <Container>
        <TextContainer>
          <Title>Themed App with React Native & Styled Components</Title>
        </TextContainer>
      </Container>
    );
  }
}

export default HomeScreen;
```

`styled-components` utilizes tagged template literals to style your components using backtick. The `Container` and the `TextContainer` are React Native `View` and have styling attached to them. The `Title` uses `Text` from React Native. The `styled-components` library uses the same `flexbox` model that React Native Layouts. The advantage here is that you get to write styles in the same understandable syntax that you have been using in web development and standard CSS.

Import the `HomeScreen` component inside the entry point file, `App.js`. Replace its existing content with the following.

```js
import React from 'react';

import HomeScreen from './screens/HomeScreen';

const App = () => {
  return <HomeScreen />;
};

export default App;
```

Open the app in a simulator. You can execute either of the commands from the terminal window depending on the mobile platform you are using.

```shell
# for ios
react-native run-ios

# for android
react-native run-android
```

You will get the following result.

![ss1](https://i.imgur.com/4IsQKiW.png)

## Define Themes

In the current React Native app, you have are going to make use of the classic example of a dark and a light mode.

Create a new file called `/styles/theme.js`. It is going to contain the style attributes that are going to be changed when setting a theme at the run time.

These attributes are nothing but colors for different React Native components. In a later section, using `props` from `styled-components` you learn how to extend the current styles of `HomeScreen` component.

```js
export const darkTheme = {
  mode: 'dark',
  PRIMARY_BACKGROUND_COLOR: '#353c51',
  PRIMARY_TEXT_COLOR: '#767d92',
  SECONDARY_TEXT_COLOR: '#ffffff',
  PRIMARY_BUTTON_COLOR: '#152642',
  SECONDARY_BUTTON_COLOR: '#506680'
};
export const lightTheme = {
  mode: 'light',
  PRIMARY_BACKGROUND_COLOR: '#ffefd5',
  PRIMARY_TEXT_COLOR: '#DB7093',
  SECONDARY_TEXT_COLOR: '#333333',
  PRIMARY_BUTTON_COLOR: '#b9d6f3',
  SECONDARY_BUTTON_COLOR: '#a1c9f1'
};
```

## Adding Redux

To manage to switch between two themes, let us use Redux. With the help of this state management library, you are going to create a store that will keep an initial value of a theme. Redux will help to change switch between two themes (_defined in the previous section_) at the run time. This means you do not have to hard code these values every time you want to add a new theme. Every time a theme is changed, the component or the screen will be re-rendered to display the new style attributes.

First, you will have to install the following libraries to create a store.

```shell
yarn add redux react-redux redux-thunk
```

Apart from `redux`, the other two packages have important uses. `react-redux` lets your React Native components connect with the Redux store. `redux-thunk` is a middleware that enables you to make Redux actions return asynchronous operations. A `thunk` is a function that wraps an expression to delay its evaluation.

## Creating actions and reducer

In Redux, the state of the whole application is represented by one JavaScript object. Think of this object as read-only, since you cannot make changes to this state (which is represented in the form of a tree) directly. That is what `actions` are for.

Actions are like events in Redux. They can be triggered in the form of a user's touch on a button, key presses, timers, or network requests. The nature of each event mentioned is mutable. An action is a JavaScript object. To define an action, thereâ€™s one requirement. Each action has its type property. Every action needs a type property for describing how the state should change.

Create a new folder called `redux` in the root of your project. This directory is going to contain all the files related to Redux. To define an action, create a new file called `action.js` inside this folder.

There is the only action required right now called `switchTheme`. It will accept one parameter, the value of the theme.

```js
// define type
export const SWITCH_THEME = 'SWITCH_THEME';

// dispatch actions
export const switchTheme = BaseTheme => {
  return dispatch => {
    dispatch({
      type: SWITCH_THEME,
      baseTheme: BaseTheme
    });
  };
};
```

To change the state of the app when using Redux, or in our case, to change the state of the value of the theme, dispatching the theme from the action `switchTheme` is the only way.

Next, let us define `themeReducer` that will take the initial state of the application's theme and action to change that theme.

```js
import { lightTheme } from '../styles/theme';
import { SWITCH_THEME } from './actions';

const initialState = {
  theme: { ...lightTheme }
};

const themeReducer = (state = initialState, action) => {
  switch (action.type) {
    case SWITCH_THEME:
      let newState = {
        ...state,
        theme: { ...state.theme, ...action.baseTheme }
      };
      return newState;
    default:
      return state;
  }
};

export default themeReducer;
```

A reducer is a pure function that calculates the next state based on the initial or previous state. It always produces the same output if the state is unchanged. In the above snippet, the current state of this application is the light theme. This theme will change whenever the user is going to press the button to switch it to the dark theme.

## Creating Store

To create the store, you will have to modify the `App.js` file. Start by adding the following import statements.

```js
import React from 'react';
import { Provider } from 'react-redux';
import { createStore, applyMiddleware, combineReducers } from 'redux';
import thunk from 'redux-thunk';

import themeReducer from './redux/themeReducer';
import HomeScreen from './screens/HomeScreen';
```

A store is an object that brings actions and reducers together. It provides and holds state at the application level instead of individual components. Redux is not an opinionated library in terms of which framework or library should use it or not.

Next, create the following store.

```js
const store = createStore(
  combineReducers({ themeReducer }),
  applyMiddleware(thunk)
);
```

To bind a React Native application with Redux, you do it with `react-redux` module. This is done by using the high ordered component `Provider`. It basically passes the store down to the rest of the React Native application.

```js
const App = () => {
  return (
    <Provider store={store}>
      <HomeScreen />
    </Provider>
  );
};
```

## Updating HomeScreen Component

In this section, you are going write the logic to consume the state from redux's store as well as make use of `ThemeProvider`.

`styled-components` has gives React Native components theming support by a `ThemeProvider` wrapper component. In the render tree all `styled-components` such as `Container`, `Title` and so on, will have access to the provided theme. Open `HomeScreen.js` file adds the following import statements.

```js
import styled, { ThemeProvider } from 'styled-components/native';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { switchTheme } from '../redux/actions';
import { darkTheme, lightTheme } from '../styles/theme';
```

In the above code snippet, do note that you are also importing both the theme objects from `styles/theme.js` file. This is necessary because, initially, you will have to pass a theme value for `ThemeProvider` to know and display the components accordingly. Then, the redux action `switchTheme` that is responsible for the change theme, expects a parameter of the current theme value.

Next, modify the render function inside the `HomeScreen` component. Wrap all of its previous contents inside `ThemeProvider` wrapper and then add a new component called `Button` which will be display the contents to change the current theme.

```js
class HomeScreen extends React.Component {
  render() {
    return (
      <ThemeProvider theme={this.props.theme}>
        <Container>
          <TextContainer>
            <Title>Themed App with React Native & Styled Components</Title>
          </TextContainer>
          {this.props.theme.mode === 'light' ? (
            <Button onPress={() => this.props.switchTheme(darkTheme)}>
              <ButtonText>Switch to Dark Theme</ButtonText>
            </Button>
          ) : (
            <Button onPress={() => this.props.switchTheme(lightTheme)}>
              <ButtonText>Switch to Light Theme</ButtonText>
            </Button>
          )}
        </Container>
      </ThemeProvider>
    );
  }
}
```

Now, a question you may ask, how come `this.props.theme` & `this.props.switchTheme` are available to the above component. In `App.js`, which is the parent component for `HomeScreen`, is not passing any props down the component tree.

Well, from the previous import statements, you are importing two important Redux methods: `bindActionCreators` and `connect`. The bindActionCreators maps actions to an object using the names of the action functions. These functions automatically dispatch the action to the store when the function is invoked. As we learned earlier, to change the data, we need to dispatch an action.

To enable this, you further need two things: `mapStateToProps` and `mapDispatchToProps`. You have to connect both of them with `HomeScreen` component. This connection is done by using the `connect()` method from the `react-redux` package which connects the current React Native component to the Redux store.

Add the following at the end of component file:

```js
const mapStateToProps = state => ({
  theme: state.themeReducer.theme
});

const mapDispatchToProps = dispatch => ({
  switchTheme: bindActionCreators(switchTheme, dispatch)
});

export default connect(mapStateToProps, mapDispatchToProps)(HomeScreen);
```

## Using Props in styled-components

By passing an interpolated function `${props => props...}` to a styled component's template literal you can extend that component's styles. Take a look at the following code snippet, and modify the styles wherever necessary.

```js
const Container = styled.SafeAreaView`
  flex: 1;
  background-color: ${props => props.theme.PRIMARY_BACKGROUND_COLOR};
  justify-content: center;
  align-items: center;
`;

const TextContainer = styled.View`
  padding: 15px;
  border-radius: 5px;
  border: 1px solid ${props => props.theme.PRIMARY_TEXT_COLOR};
`;

const Title = styled.Text`
  padding: 20px;
  font-size: 24px;
  font-weight: 500;
  color: ${props => props.theme.PRIMARY_TEXT_COLOR};
`;

const Button = styled.TouchableOpacity`
  margin-top: 20px;
  background-color: ${props => props.theme.SECONDARY_BUTTON_COLOR};
  border-radius: 5px;
  padding: 10px;
`;

const ButtonText = styled.Text`
  font-size: 20px;
  color: ${props => props.theme.SECONDARY_TEXT_COLOR};
`;
```

Now, go to the simulator running and you will notice a new button with a text that says `Switch to ...` name of the next theme. If you have been following this tutorial, you will notice that the initial or current theme is the light mode. By pressing the button, you can switch to the dark mode.

![ss2](https://i.imgur.com/W6offhJ.gif)

## Conclusion

_Congratulations!_ You have successfully integrated redux and styled-components in a React Native app to create style attributes for React Native and manage themes. Using `props` in styled-components you learned how to manage and write composable components. This is just one of the way to create a themeable React Native app.

To dwell more into styled-components, please refer to the official documentation [**here**](https://www.styled-components.com/docs/basics#react-native).

---

## How to create custom wavy headers with react-native-svg
Slug: create-custom-headers-with-react-native-svg

> [Originally Published at Heartbeat.Fritz.ai](https://heartbeat.fritz.ai/creating-custom-wavy-headers-using-react-native-svg-639ce0861327)

In React Native apps, the support for SVG graphics is provided by an open-source module called [`react-native-svg`](https://github.com/react-native-community/react-native-svg) that is maintained by React Native community.

Using SVG can enhance an appâ€™s design when it comes to displaying different patterns. It can make a difference in how the look and feel of the app might appear to the end-user, as well how it is easy to edit the pattern built using SVG. SVG is mainly found on the web, and while they have similar uses to JPEG, PNG, and WebP image types, SVG is not resolution-dependent. Hence, the definition according to [Wikipedia](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics):

<blockquote>
  Scalable Vector Graphics (SVG) is an Extensible Markup Language (XML)-based
  vector image format for two-dimensional graphics with support for
  interactivity and animation.
</blockquote>

This format consists of shapes rather than pixels which can further be concluded that an SVG graphic can be scaled indefinitely in terms of resolution.

In this post, let us learn how to use `react-native-svg` in React Native and Expo apps and create some custom examples such as wavy header shown below.

<img src='https://miro.medium.com/max/598/1*aivsFUf_OF6mYBSfOCGrTQ.gif' />

## Requirements

Ensure your dev environment includes the following required packages:

- [Node.js](https://nodejs.org/) above `12.x.x` installed on your local machine
- JavaScript/ES6 basics
- [`expo-cli`](https://expo.io/tools)

## Installing react-native-svg library

Start by creating a new project using expo-cli. Navigate inside the project directory when the CLI has finished generating the new project. Then install all the required dependencies to integrate the `react-native-svg` library.

```shell
expo init [PROJECT NAME]

cd [PROJECT NAME]

expo install react-native-svg
```

The reason to use `expo install` command when building a React Native app using Expo SDK instead of package managers like `npm` or `yarn` is that it is going to install the most compatible version of the package available to be used with Expo SDK. This avoids unnecessary errors.

That's it for installing this library. The `react-native-svg` library contains common shapes and elements such as `Svg`, `Rect`, `Circle`, `Line`, `Polygon`, `Path`, and so on as components to be used. You are going to see `Svg` and `Path` in action, in this post.

## Create a header component

In the next few sections, let us try to create a custom header background that has a bottom border with the form of a wave as shown below.

<img src='https://miro.medium.com/max/700/1*mf6AmpW-7j4nS1nixMDiVQ.png' />

Start by creating a new screen component inside `src/screens/ScreenOne.js` file that displays a heading on the screen. (_Create the directory if it doesn't exist._)

Add the following code snippet to this file.

```js
import React from 'react';
import { StyleSheet, View, Text, Dimensions } from 'react-native';

export default function ScreenOne() {
  return (
    <View style={styles.container}>
      <View style={styles.headerContainer}>
        <Text style={styles.headerText}>Custom Header</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  },
  headerContainer: {
    marginTop: 50,
    marginHorizontal: 10
  },
  headerText: {
    fontSize: 30,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginTop: 35
  }
});
```

Next, go to `App.js` file and modify it to render the `ScreenOne` functional component as below.

```js
import React from 'react';
import ScreenOne from './src/screens/ScreenOne';
import { StatusBar } from 'react-native';

export default function App() {
  return (
    <>
      <StatusBar hidden={true} />
      <ScreenOne />
    </>
  );
}
```

Lastly, to see this simple header text on a device's screen, from the terminal window, execute the command `expo start`. You should results similar to the screenshot below:

<img src='https://miro.medium.com/max/700/1*kwennRzVGQSDL0fASGCC5g.png' />

## Create a custom header component with waves

The motive of this section is to add a custom header using the svg component in the background in the `ScreenOne.js` file.

The SVG component that we intend to create is going to wrap the path drawing primitive. This primitive is the outline of a shape that can be filled or stroked. It primitive is represented by the `Path` component from `react-native-svg` library and makes use of different commands such as `elliptical Arc`, `moveto`, `lineto`and so on. You can read more about [Paths here](https://www.w3.org/TR/SVG/paths.html).

To generate the SVG background as you have seen in the previous section, I am going to make use of [getwaves.io](https://getwaves.io/). This web tool allows you to generate custom wave patterns in SVG format. Check out their website, it is simple and fulfils the purpose. You can create different patterns using this tool.

<img src='https://miro.medium.com/max/984/1*NzoVM40QM6VUNSGyCQLZ7g.gif' />

Make sure to copy the values of properties such as `viewbox` and `d` as shown above.

Next, create a file called `WavyHeader.js` inside `src/components/` directory. Import the following statements.

```js
import React from 'react';
import { View } from 'react-native';
import Svg, { Path } from 'react-native-svg';
```

Create a functional component called `WavyHeader` that is going to have a prop passed from the parent (_the screen component_) it is going to be used. Let us call this prop `customStyles`. The main reason to pass this prop here is to define the dimensions of the screen component in its own file and keep the style value dynamic for different screens.

Here is the complete code snippet for this custom component. Notice the properties of the `Path` component are the same as copied from getwaves.io.

```jsx
export default function WavyHeader({ customStyles }) {
  return (
    <View style={customStyles}>
      <View style={{ backgroundColor: '#5000ca', height: 160 }}>
        <Svg
          height="60%"
          width="100%"
          viewBox="0 0 1440 320"
          style={{ position: 'absolute', top: 130 }}
        >
          <Path
            fill="#5000ca"
            d="M0,96L48,112C96,128,192,160,288,186.7C384
            ,213,480,235,576,213.3C672,192,768,128,864,
            128C960,128,1056,192,1152,208C1248,224,1344,192,
            1392,176L1440,160L1440,0L1392,0C1344,0,1248,0,
            1152,0C1056,0,960,0,864,0C768,0,672,0,576,0C480,0,
            384,0,288,0C192,0,96,0,48,0L0,0Z"
          />
        </Svg>
      </View>
    </View>
  );
}
```

Now, go back to the `ScreenOne.js` file and import this custom component after the rest of the import statements.

```js
// rest of the import statements
import WavyHeader from '../components/WavyHeader';
```

Add this component before the `<View>` that represents `headerContainer`.

```js
export default function ScreenOne() {
  return (
    <View style={styles.container}>
      <WavyHeader customStyles={styles.svgCurve} />
      <View style={styles.headerContainer}>
        <Text style={styles.headerText}>Custom Header</Text>
      </View>
    </View>
  );
}
```

Lastly, define the style reference `svgCurve` in the `StyleSheet` object as shown in the snippet below.

```js
const styles = StyleSheet.create({
  // rest of the styles
  svgCurve: {
    position: 'absolute',
    width: Dimensions.get('window').width
  },
  headerText: {
    fontSize: 30,
    fontWeight: 'bold',
    // change the color property for better output
    color: '#fff',
    textAlign: 'center',
    marginTop: 35
  }
});
```

From the snippet, you can notice that using the `Dimensions` API from `react-native` we are going to get the width of the current window. The `position` property is set to `absolute` such that the header component that contains the heading is displayed and does not hide behind this wavy background.

The final result is going to be as the following.

<img src='https://miro.medium.com/max/700/1*mf6AmpW-7j4nS1nixMDiVQ.png' />

## Make WavyHeader component reusable

So far, you have completed the task of displaying the wavy header background on a screen component. But what if the scenario changes and you have two screens both require wavy header backgrounds but with some customization such as each having a different height as well as different wave pattern?

In this section, let us customize the `WavyHeader` component to accept more props in order to make it a reusable component.

First, let us customize the `WavyHeader.js` file to accept more props.

```js
export default function WavyHeader({
  customStyles,
  customHeight,
  customTop,
  customBgColor,
  customWavePattern
}) {
  return (
    <View style={customStyles}>
      <View style={{ backgroundColor: customBgColor, height: customHeight }}>
        <Svg
          height="60%"
          width="100%"
          viewBox="0 0 1440 320"
          style={{ position: 'absolute', top: customTop }}
        >
          <Path fill={customBgColor} d={customWavePattern} />
        </Svg>
      </View>
    </View>
  );
}
```

Now the `<Path />` component is going to accept values (such as `backgroundColor`, `height`) in the form of props passed to the `WavyHeader` component.

Next, go to the `ScreenOne.js` file and pass in the values for the props for the `WavyHeader` component.

```jsx
export default function ScreenOne() {
  return (
    <View style={styles.container}>
      <WavyHeader
        customStyles={styles.svgCurve}
        customHeight={160}
        customTop={130}
        customBgColor="#5000ca"
        customWavePattern="M0,96L48,112C96,128,192,160,288,
        186.7C384,213,480,235,576,213.3C672,192,768,128,864,
        128C960,128,1056,192,1152,208C1248,224,1344,192,1392,
        176L1440,160L1440,0L1392,0C1344,0,1248,0,1152,0C1056,
        0,960,0,864,0C768,0,672,0,576,0C480,0,384,0,288,0C192,
        0,96,0,48,0L0,0Z"
      />
      <View style={styles.headerContainer}>
        <Text style={styles.headerText}>Custom Header</Text>
      </View>
    </View>
  );
}
```

You wonâ€™t see a difference in the result on the deviceâ€™s screen unless you change the values of these props.

<img src='https://miro.medium.com/max/700/1*mf6AmpW-7j4nS1nixMDiVQ.png' />

## Conclusion

You can try adding more custom screens to have different wave patterns and try to use the `WavyHeader` component as reusable for different screens. Here is an example below that displays two different screens with different wave patterns as well as background color and height.

<img src='https://miro.medium.com/max/700/1*ZmqxTfYO5jfv24ktveRzxg.png' />

<img src='https://miro.medium.com/max/598/1*aivsFUf_OF6mYBSfOCGrTQ.gif' />

- [Source code](https://github.com/amandeepmittal/wavySVGExample).
- Or try using an Expo client [here](https://expo.io/@amanhimself/rnwavysvg).
- Or check out [Leandro Favreâ€™s](https://x.com/FavreLeandro) [Whicecream](https://github.com/AtilaDev/whicecream) example based on this tutorial!

Here is the list of resources used in order to create this post:

- [react-native-svg](https://github.com/react-native-community/react-native-svg)
- [getwaves.io](https://getwaves.io/)
- [What are Paths?](https://www.w3.org/TR/SVG/paths.html)

---

## How to create a custom hook to change status bar styles for every screen using React Navigation
Slug: create-custom-status-bar-hook-react-navigation

React Native has a component called `StatusBar` that is used to control the app status bar. Using the `react-navigation` library you might have a scenario where you don't have a header bar and on different screens, you would like to ensure the color of the status bar is correctly rendered. Such as on the light background, a dark status bar is displayed and on a darker background of the screen, a light status bar is displayed.

In this tutorial, let us create a custom hook that is going to keep track of the status bar color change whenever a screen changes. For this, you are also going to create mock screens with different background colors and integrate a tab bar.

I am going to use Expo to create a new React Native app but you can use React Native cli to generate a new project too.

## Requirements

Ensure your dev environment includes the following required packages:

- Node.js above `10.x.x` installed on your local machine
- JavaScript/ES6 basics
- `expo-cli`

## Installing and configuring react-navigation

Start by creating a new project using `expo-cli`. Navigate inside the project directory when the CLI has finished generating the new project. Then install all the required dependencies to integrate `react-navigation` library and bottom tabs.

```shell
expo init customStatusBarHook

cd customStatusBarHook

yarn add @react-navigation/native @react-navigation/bottom-tabs

expo install react-native-gesture-handler
react-native-reanimated react-native-screens
react-native-safe-area-context
@react-native-community/masked-view
```

That's it to configure the `react-navigation` library.

## Create bottom Tabs

Create a new file called `AppTabs.js` inside `src/navigation/` directory. This file is going to be the sole routes file for this demo. Inside it, you are going to create two tab components called `HomeScreen` and `SettingsScreen.

Start by importing all the necessary components.

```js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { View, Text } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
```

I am using `@expo/vector-icons` to display icons for each tab but if you are using react-native cli to generate this project, you will have to install `react-native-vector-icons` library.

Create the functional component `HomeScreen` with a `View` and a `Text` as shown in the snippet below. This is going to be the first tab screen in the tab navigator.

```js
function HomeScreen() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text style={{ fontSize: 20, color: '#333333' }}>Home Screen</Text>
    </View>
  );
}
```

Also, add the following code snippet for the tab screen, `SettingsScreen`.

```js
function SettingsScreen() {
  useStatusBar('light-content');
  return (
    <View
      style={{
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#be79df'
      }}
    >
      <Text style={{ fontSize: 20, color: 'white' }}>Settings Screen</Text>
    </View>
  );
}
```

Next, add the following snippet to create the tab navigator with the previous two screens. The following tab navigator is also going to use have tab icons that are going to have different tint colors based on whether being active or not. This can be done by using `screenOptions`.

```js
const Tabs = createBottomTabNavigator();

export default function AppTabs() {
  return (
    <NavigationContainer>
      <Tabs.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName;

            if (route.name === 'Home') {
              iconName = focused
                ? 'ios-information-circle'
                : 'ios-information-circle-outline';
            } else if (route.name === 'Settings') {
              iconName = focused ? 'ios-list-box' : 'ios-list';
            }
            return <Ionicons name={iconName} size={size} color={color} />;
          }
        })}
        tabBarOptions={{
          activeTintColor: 'tomato',
          inactiveTintColor: 'gray'
        }}
      >
        <Tabs.Screen name="Home" component={HomeScreen} />
        <Tabs.Screen name="Settings" component={SettingsScreen} />
      </Tabs.Navigator>
    </NavigationContainer>
  );
}
```

Go to the terminal window and trigger the command `expo start`. You are going to get the following output in a simulator.

![ss3](https://i.imgur.com/h4ZpdMF.gif)

As you can notice from the above demo that on each the tab screen the color of the status bar is dark. On the second tab, since it has a darker background than the first tab, there should be a way to change the status bar for each screen component as it is mounted.

## Create a custom Status bar hook

The `react-navigation` library provides a hook called `useFocusEffect` that helps to run side-effects when a specific screen is focused.

It is similar to `useEffect` hook from React with the difference being between the two is that side-effects in `useFocusEffect` run only when a screen component is focused.

Also, it is important to wrap the side-effect in `React.useCallback` hook to avoid triggering the effect after every render when the screen is focused.

Create a new file called `Hooks.js` inside `src/utils/` directory. Import the following statements.

```js
import React, { useCallback } from 'react';
import { StatusBar } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
```

Then export a custom function called `useStatusBar` that is going to provide a simple way to change the color of the status bar when applied. Pass the `style` as the only parameter.

```js
export const useStatusBar = style => {
  useFocusEffect(
    useCallback(() => {
      StatusBar.setBarStyle(style);
    }, [])
  );
};
```

## Apply custom hook to change the status bar color

Open `src/navigation/AppTabs.js` file and import `useStatusBar`. Also, inside both function components, add the following statements with appropriate bar style value.

```js
// after other import statements
import { useStatusBar } from '../utils/Hooks';

function HomeScreen() {
  useStatusBar('dark-content');
  // rest of the code remains same
}

function SettingsScreen() {
  useStatusBar('light-content');
  // rest of the code remains same
}
```

Go back to the simulator or Expo client and you are going to notice the changes now.

![ss4](https://i.imgur.com/EuVkbSG.gif)

For a better transition between two tabs, you can pass on another parameter called `animate` with a default value of boolean `true` in the `useStatusBar` custom hook.

Open `src/utils/Hooks.js` and add the following.

```js
export const useStatusBar = (style, animated = true) => {
  useFocusEffect(
    useCallback(() => {
      StatusBar.setBarStyle(style, animated);
    }, [])
  );
};
```

Now, go back to the Expo client to see the changes.

![ss5](https://i.imgur.com/sS9ASUg.gif)

## Conclusion

To read more about the `useFocusEffect` hook provided by the `react-navigation` library take a look at this [link](https://reactnavigation.org/docs/use-focus-effect/).

You can also set a status bar configuration based on different routes when using `react-navigation`. Take a look at this [link](https://reactnavigation.org/docs/status-bar/) to read more.

I hope this short tutorial was useful to you. Thanks for reading it!

---

## How to Create a Custom Tab Bar in React Native
Slug: create-custom-tab-bar-in-react-native

[React Native](https://reactnative.dev/) is an amazing tool for creating beautiful and high performing mobile applications that run on both iOS and Android. Developing these apps, you might need navigation to navigate from one screen to another. To implement navigation in a React Native app, [React Navigation](https://reactnavigation.org/docs/getting-started) library does an awesome job of providing various navigation patterns such as stack, tabs, and drawer that can be utilized and customize based on the UI design of the app.

In this post, let's create a custom tab bar using React Navigation library bottom tabs component. We are going to create a simple tab bar and then learn how to make it translucent using a [Blur view](https://github.com/Kureev/react-native-blur).

## Pre-requisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements in your local dev environment:

- [Node.js](https://nodejs.org/) version >= `12.x.x` installed.
- Have access to one package manager such as npm or yarn or npx.
- [react-native-cli](https://www.npmjs.com/package/react-native-cli) installed, or use npx.

## Installing react-navigation library

To create a new React Native app, please execute the following command from a terminal window on your local dev environment. Navigate inside the project directory created by `react-native-cli` and then install the dependencies:

```shell
npx react-native init customTabBar

cd customTabBar

# install dependencies
yarn add @react-navigation/native @react-navigation/bottom-tabs react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view react-native-vector-icons @react-native-community/blur
```

Do note that to demonstrate the example described in this article, we are using React Navigation v5 library. After installing these dependencies, please import the Gesture Handler library at the top of the `index.js` file of your React Native app:

```js
import 'react-native-gesture-handler';
```

Then, for iOS, install the Cocoapods for all these dependencies by navigating inside the `ios` directory in a terminal window and executing the following command. Do note that, if you do not have the Cocoapods installed on your local dev machine, please follow the alternate command as described below:

```shell
cd ios && pod install

# after pods are installed
cd ..

# alternate command
npx pod-install ios
```

## Installing react-native-vector-icons

The `react-native-vector-icons` module needs a bit more configuration steps for the iOS and Android platforms.

For iOS, you need to add the following inside `ios/customTabBar/Info.plist`:

```c
<key>UIAppFonts</key>
<array>
  <string>AntDesign.ttf</string>
  <string>Entypo.ttf</string>
  <string>EvilIcons.ttf</string>
  <string>Feather.ttf</string>
  <string>FontAwesome.ttf</string>
  <string>FontAwesome5_Brands.ttf</string>
  <string>FontAwesome5_Regular.ttf</string>
  <string>FontAwesome5_Solid.ttf</string>
  <string>Foundation.ttf</string>
  <string>Ionicons.ttf</string>
  <string>MaterialIcons.ttf</string>
  <string>MaterialCommunityIcons.ttf</string>
  <string>SimpleLineIcons.ttf</string>
  <string>Octicons.ttf</string>
  <string>Zocial.ttf</string>
  <string>Fontisto.ttf</string>
</array>
```

Then, the following to the `ios/Podfile` and run `cd ios && pod update` from a terminal window:

```js
pod 'RNVectorIcons', :path => '../node_modules/react-native-vector-icons'
```

For Android, add the following snippet in the file: `android/app/build.gradle`:

```java
apply from: "../../node_modules/react-native-vector-icons/fonts.gradle"
```

That's it to setup the react-native-vector-icons library.

Since we have installed and configured everything we need to build and run the React Native app, you can now edit the `App.js` file which is the entry point of the React native app.

To build the app for iOS, please execute the command `npx react-native run-ios` from a terminal window. Similarly, the build command for Android is `npx react-native run-android`.

Here is the default app running after the building for iOS:

![cb1](/images/cb/img6.png)

## Add mock screens

The tab bar of this example app is going to display three different tabs. The first tab is used to display a list of items with images such that when the tab bar is added to the app, we can configure its translucency.

Let's create them inside a separate directory called `screens/` and create the first file called `data.js` that contains the mock data to display inside the list view in the first tab. Add the following code snippet:

```js
// Images in this example demo are being used from Unsplash
// Manarola - https://unsplash.com/photos/rknrvCrfS1k
// Venezia - https://unsplash.com/photos/hFXZ5cNfkOk
// Prague - https://unsplash.com/photos/pz0P5piDQXs

export const data = [
  {
    id: '1',
    title: 'Manarola, Italy',
    description: 'The Cliffs of Cinque Terre',
    image_url:
      'https://images.unsplash.com/photo-1516483638261-f4dbaf036963?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=633&q=80',
    iconName: 'location-pin'
  },

  {
    id: '2',
    title: 'Venezia, Italy',
    description: 'Rialto Bridge, Venezia, Italy',
    image_url:
      'https://images.unsplash.com/photo-1523906834658-6e24ef2386f9?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=630&q=80',
    iconName: 'location-pin'
  },
  {
    id: '3',
    title: 'Prague, Czechia',
    description: 'Tram in Prague',
    image_url:
      'https://images.unsplash.com/photo-1513805959324-96eb66ca8713?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=634&q=80',
    iconName: 'location-pin'
  },
  {
    id: '4',
    title: 'Venezia, Italy',
    description: 'Rialto Bridge, Venezia, Italy',
    image_url:
      'https://images.unsplash.com/photo-1523906834658-6e24ef2386f9?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=630&q=80',
    iconName: 'location-pin'
  }
];
```

In the above code snippet, you can see that `data` is an array that has different objects. Let's create the first tab screen called `Home.js` where this array of mock data will be used. Import the following statements inside it and then define a custom and width and height of the image card. This image card is displayed inside the list view as the item. Using React Native's `Dimensions` API, the width and height of the image are calculated based on the width of the device's screen.

```js
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  Image,
  Dimensions,
  ScrollView
} from 'react-native';

import { data } from './data';

const { width } = Dimensions.get('screen');

const ITEM_WIDTH = width * 0.9;
const ITEM_HEIGHT = ITEM_WIDTH * 0.9;
```

Using a `Text` component, the title of the tab is displayed. Using the `ScrollView` the list of items is implemented by using JavaScript's `map()` method that allows to iterate over each item. After importing the statements, add the following snippet:

```js
const Home = () => {
  const tabBarheight = useBottomTabBarHeight();
  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>Home</Text>
      </View>

      {/* Scrollable Content */}
      <View style={styles.scrollContainer}>
        <ScrollView
          indicatorStyle="white"
          contentContainerStyle={[
            styles.scrollContentContainer,
            { paddingBottom: tabBarheight }
          ]}
        >
          {data.map(item => (
            <View key={item.id} style={styles.imageContainer}>
              <Image
                style={styles.imageCard}
                source={{ uri: item.image_url }}
                resizeMode="cover"
              />
            </View>
          ))}
        </ScrollView>
      </View>
    </View>
  );
};

export default Home;
```

Lastly, the add the styles reference for each component in the above snippet:

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0f0f0f'
  },
  contentContainer: {
    marginTop: 50,
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingBottom: 20
  },
  title: {
    fontSize: 20,
    color: '#fff'
  },
  scrollContainer: {
    flex: 1
  },
  scrollContentContainer: {
    alignItems: 'center'
  },
  imageContainer: {
    marginBottom: 14
  },
  imageCard: {
    borderRadius: 14,
    width: ITEM_WIDTH,
    height: ITEM_HEIGHT
  }
});
```

The other two tab screens are created inside `Browse.js` and `Library.js` and they do not render much information other than the name of the tab screen. Let's keep them bare minimum for the brevity of this example.

Inside the file `Browse.js`, add the following code snippet:

```js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const Browse = () => {
  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>Browse</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0f0f0f'
  },
  contentContainer: {
    marginTop: 50,
    alignItems: 'center',
    paddingHorizontal: 20
  },
  title: {
    fontSize: 20,
    color: '#fff'
  }
});

export default Browse;
```

Inside the `Library.js` file, add the following snippet:

```js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const Library = () => {
  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>Library</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0f0f0f'
  },
  contentContainer: {
    marginTop: 50,
    alignItems: 'center',
    paddingHorizontal: 20
  },
  title: {
    fontSize: 20,
    color: '#fff'
  }
});

export default Library;
```

That's it for the tab screens and mocking data inside one of the tab screen components.

## How to create a tab bar

Create a new directory called `navigation/` at the root of the React Native project. In this directory, we are going to keep all the navigation configuration files. Inside it create a new directory called `TabNavigator`. It is going to have two separate files:

- `index.js` to initiate the complete Tab Bar configuration
- `CustomTabBar.js` to render the custom tab bar

Inside the file `TabNavigator/index.js` import the `createBottomTabNavigator` from `@react-navigation/bottom-tabs` package. Using this, a `Tab` object is initialized. This object allows defining the structure of the routes using `Tab.Navigator` and the define each route using the `Tab.Screen` component.

```js
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

import Home from '../../screens/Home';
import Browse from '../../screens/Browse';
import Library from '../../screens/Library';

const Tab = createBottomTabNavigator();

const TabNavigator = () => {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={Home} />
      <Tab.Screen name="Browse" component={Browse} />
      <Tab.Screen name="Library" component={Library} />
    </Tab.Navigator>
  );
};

export default TabNavigator;
```

The simple tab bar configuration is done. To see it in action, let's wrap it with the `NavigationContainer` component inside the new file called `navigation/RootNavigator.js`. This component manages the navigation tree. It contains the navigation state prop.

```js
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';

import TabNavigator from './TabNavigator';

const RootNavigator = () => {
  return (
    <NavigationContainer>
      <TabNavigator />
    </NavigationContainer>
  );
};

export default RootNavigator;
```

The last step is to import and render the Root Navigator from inside the `App.js` file:

```js
import React from 'react';
import { StatusBar } from 'react-native';

import RootNavigator from './navigation/RootNavigator';

const App = () => {
  return (
    <>
      <StatusBar hidden />
      <RootNavigator />
    </>
  );
};

export default App;
```

On an iOS simulator, the tab bar is shown as below. There are no custom styles currently applicable on the tab bar. The way it looks is because the tab bar component from React Navigation library has some default styles.

![cb1](/images/cb/img7.png)

## Add icons to the tab bar

To add icons to each tab, first import the `Icon` component from react-native-vector-icons` library inside the`navigation/TabNavigator/index.js` file. For this example, let's use AntDesign based icons.

```js
// after other import statements
import Icon from 'react-native-vector-icons/AntDesign';
```

Using the `screenOptions` object on `Tab.Navigator`, the configuration to display icons for each tab is enabled. This object has different methods and properties to enable different configurations. One such method is called `tabBarIcon` that allows us to display a custom icon for each tab. This function returns an `Icon` component that has props like `color` and `size` to apply tint color on the icon for each tab and define a numeric value for the size of the icon. It also has a prop called `name`
that allows defining which icon to be used for which screen.

Add the following code snippet:

```js
const screenOptions = (route, color) => {
  let iconName;

  switch (route.name) {
    case 'Home':
      iconName = 'home';
      break;
    case 'Browse':
      iconName = 'appstore-o';
      break;
    case 'Library':
      iconName = 'folder1';
      break;
    default:
      break;
  }

  return <Icon name={iconName} color={color} size={24} />;
};

const TabNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ color }) => screenOptions(route, color)
      })}
    >
      {/* rest remains same */}
    </Tab.Navigator>
  );
};
```

Go back to the iOS simulator and you will notice that the icons for each tab route are now displayed.

![cb1](/images/cb/img8.png)

## Customizing the tab bar

To customize a tab bar, more options using the `tabBarOptions` object can be applied. This options object has properties to set active and inactive tint color for each tab, the background color for the whole tab bar, and so on.

Add the following options object on `Tab.Navigator`:

```js
<Tab.Navigator
// ...
tabBarOptions={{
  activeTintColor: 'white',
  inactiveTintColor: '#d9d9d9',
  style: {
    borderTopColor: '#66666666',
    backgroundColor: 'transparent',
    elevation: 0,
  },
}}
>
```

The property `elevation` is set to zero in the above code snippet such that there are no shadows overlap on Android when we will make the custom tab bar translucent in the next section.

## Making the tab bar translucent

To make the tab bar translucent, we are going to use `BlurView` component from [@react-native-community/blur](https://github.com/Kureev/react-native-blur) component. It is used to add a blur view effect on iOS and Android. It is going to wrap a component called `BottomTabBar` from @react-navigation/bottom-tabs library. This component is a React element that is used to display the actual tab bar. It is provided by a prop called `tabBar` on `Tab.Navigator`. Using this React element, the tab bar can be defined explicitly inside the `CustomTabBar.js` component file.

Start by adding the following snippet inside `TabNavigator/CustomTabBar.js` file:

```js
import React from 'react';
import { BottomTabBar } from '@react-navigation/bottom-tabs';
import { BlurView } from '@react-native-community/blur';

const CustomTabBar = props => {
  return <BottomTabBar {...props} />;
};

export default CustomTabBar;
```

The `props` received by this custom React component are passed from `tabBar` option. Add it on the `Tab.Navigator` inside `TabNavigator/index.js` file:

```js
<Tab.Navigator
  // ... rest remains same
  tabBar={(props) => <CustomTabBar {...props} />}
>
```

Using the `props` you can further modify the configuration of a bottom tab bar. We are not going to get into that since it's out of the scope of this article.

Inside the `CustomTabBar.js` file, wrap the `BottomTabBar` with `<BlurView>` component. It has a different set of props for iOS and Android to add the blur view effect.

For iOS, to create a blur view effect, add `blurType` which accepts the type of blur effect as a string value. On an iOS device, different values such as `light`, `dark`,` xlight`, `regular` etc. are available.

Another property `blurAmount` is applied to adjust the intensity of the blur effect. Similarly, for Android, in addition to these props, props such as `overLayColor` to set a custom overlay and `blurRadius` to manually adjust the blur effect radius are used.

To make sure to apply styles on the `BlurView` component such that the tab bar is displayed over the content of each screen, set its `position` to `absolute`.

Here is the final snippet for `CustomTabBar` component:

```js
<BlurView
  style={{
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0
  }}
  blurType="dark"
  blurAmount={10}
  blurRadius={25}
  overlayColor="transparent"
>
  <BottomTabBar {...props} />
</BlurView>
```

The tab bar is now translucent. Here is the example app running on an iOS simulator.

![cb1](/images/cb/img9.gif)

Do notice that, since the `BlurView` component has the position set to `absolute` we need to apply the `paddingBottom` property at the `ScrollView` component inside the `Home.js` tab screen. The value of this property is going to be the height of the whole tab bar. To get the height of the current tab bar, the @react-navigation/bottom-tabs module has a hook called `useBottomTabBarHeight` that gives this value.

Add the import statement in the `screens/Home.js` file and inside it, use the hook to get the height as shown below and apply it as the value of the `paddingBottom` style property at the `ScrollView` component:

```js
import {useBottomTabBarHeight} from '@react-navigation/bottom-tabs';

// ...

const Home = () => {
  const tabBarheight = useBottomTabBarHeight();

  // ...

  return (
    // ...
    <ScrollView
      indicatorStyle="white"
      contentContainerStyle={[
        styles.scrollContentContainer,
        {paddingBottom: tabBarheight},
    ]}>
  )
}
```

Back in the iOS simulator, you will notice that it works fine now:

![cb1](/images/cb/img10.gif)

Running the app build on an Android device, the results are similar:

![cb1](/images/cb/img11.gif)

## Conclusion

We have discussed only one scenario of customizing the bottom tab bar. The main objective here is to get familiar with the component-based configuration of the Tab Navigator in the latest version of the react-navigation library and learn the steps to create a custom tab bar.
Originally Published on [Crowdbotics's Blog](https://crowdbotics.com/posts/blog/how-to-create-a-custom-tab-bar-in-react-native/).

---

## Creating a GraphQL server with Nodejs
Slug: creating-a-graphql-server-with-nodejs-in-2018

![cover](https://i.imgur.com/kcItwPv.png)

> [Originally published at Crowdbotics](https://medium.com/crowdbotics/creating-a-graphql-server-with-nodejs-ef9814a7e0e6)

When it comes to network requests between a client and a server application, REST (which stands for _Representational state transfer_) is one of the most popular choices for connecting the two. In the world of [REST APIs](https://blog.crowdbotics.com/how-to-build-a-rest-api-with-koajs/), everything revolves around the idea of having resources as accessible URLs. We then use CRUD operations (Create, Read, Update, Delete), which are basically HTTP methods such as GET, POST, PUT & DELETE, to interact with the data.

Here is an example of a typical REST request:

```json
// example of a request
https://swapi.co/api/people/

// response of the above request in JSON
{
	"results": [
		{
			"name": "Luke Skywalker",
			"gender": "male",
			"homeworld": "https://swapi.co/api/planets/1/",
			"films": [
				"https://swapi.co/api/films/2/",
				"https://swapi.co/api/films/6/",
				"https://swapi.co/api/films/3/",
				"https://swapi.co/api/films/1/",
				"https://swapi.co/api/films/7/"
			],
    }
		{
			"name": "C-3PO",
			"gender": "n/a",
			"homeworld": "https://swapi.co/api/planets/1/",
			"films": [
				"https://swapi.co/api/films/2/",
				"https://swapi.co/api/films/5/",
				"https://swapi.co/api/films/4/",
				"https://swapi.co/api/films/6/",
				"https://swapi.co/api/films/3/",
				"https://swapi.co/api/films/1/"
			],
		}
  ]
}
```

The response format for a REST API is not necessarily JSON, but this is the preferred method these days with most APIs. **Apart from REST, another way to handle network requests has emerged: GraphQL. Open sourced in 2015, GraphQL is changing the way developers write an API on the server side and handle it on the client side.** GraphQL was developed and is actively maintained by Facebook.

### Shortcomings ofÂ REST

GraphQL is a query language to develop an API. In contrast to REST, which is an architecture or â€˜a way of doing thingsâ€™, graphQL was developed with a concept in mind that a client requests only the desired set of items from the server in a single request.

In REST architecture or like on our above example, when fetching the films Luke Skywalker appeared in in Star Wars movies, we are getting an array of `films` or the name of `homeworld` which further consists different API URLs that lead us to details of different sets of JSON data. This is certainly an example of over fetching. The client side, in order to get the details of films in which the character Luke Skywalker appeared, and the name of his home planet, will have to send multiple requests to the server.

With GraphQL, this can be resolved into a single network request. Hop on to the API url: `https://graphql.github.io/swapi-graphql/` and see run the following query.

_Note: In the example below, you can ignore how the GraphQL API is working behind the scenes. I will be walking you step by step to build your own (maybe the first) GraphQL API later in this tutorial._

```graphql
{
  allPeople {
    edges {
      node {
        name
        gender
        homeworld {
          name
        }
        filmConnection {
          edges {
            node {
              title
            }
          }
        }
      }
    }
  }
}
```

We are going to fetch the data that we need such as the name of the character, their `gender`, `homeworld`, and the title of the `films` they appeared. After running the above query, you will get the following result:

```json
{
  "data": {
    "allPeople": {
      "edges": [
        {
          "node": {
            "name": "Luke Skywalker",
            "gender": "male",
            "homeworld": {
              "name": "Tatooine"
            },
            "filmConnection": {
              "edges": [
                {
                  "node": {
                    "title": "A New Hope"
                  }
                },
                {
                  "node": {
                    "title": "The Empire Strikes Back"
                  }
                },
                {
                  "node": {
                    "title": "Return of the Jedi"
                  }
                },
                {
                  "node": {
                    "title": "Revenge of the Sith"
                  }
                },
                {
                  "node": {
                    "title": "The Force Awakens"
                  }
                }
              ]
            }
          }
        },
        {
          "node": {
            "name": "C-3PO",
            "gender": "n/a",
            "homeworld": {
              "name": "Tatooine"
            },
            "filmConnection": {
              "edges": [
                {
                  "node": {
                    "title": "A New Hope"
                  }
                },
                {
                  "node": {
                    "title": "The Empire Strikes Back"
                  }
                },
                {
                  "node": {
                    "title": "Return of the Jedi"
                  }
                },
                {
                  "node": {
                    "title": "The Phantom Menace"
                  }
                },
                {
                  "node": {
                    "title": "Attack of the Clones"
                  }
                },
                {
                  "node": {
                    "title": "Revenge of the Sith"
                  }
                }
              ]
            }
          }
        }
      ]
    }
  }
}
```

If the client side of an application is triggering the above GraphQL URL, it will only send one request on the network to get the desired result, thus eliminating any possibility of over fetching or sending multiple requests.

### Pre-requisites

To follow this tutorial, all you need is `Nodejs` and `npm` installed on your local machine.

- [Nodejs](http://nodejs.org) `^8.12.0`
- npm `^6.4.1`

### GraphQL in aÂ nutshell

In a nutshell, **GraphQL** is a syntax that elucidates how to ask for _data_ and is generally used to retrieve data (aka, a _query_) or make changes to it (aka _mutation)_ from a server to a client.

GraphQL has few defining characteristics:

- It lets the client specify exactly what data it needs. This is also known as declarative data fetching.
- It is not opinionated about the network layer
- It makes easier to combine several sets of data from multiple sources
- It uses a strongly typed system when declaring the structure of data in the form of both the schema and the query. This helps to validate the queries even before the network requests are sent.

### Building Blocks of a GraphQLÂ API

A GraphQL API has four building blocks:

- schema
- query
- mutations
- resolvers

**Schema** is defined at the server in the form of objects. Each object corresponds to data types such that they can be queried upon. For example:

```graphql
type User {
  id: ID!
  name: String
  age: Int
}
```

The schema above defines the shape of a user object with a required field `id` denoted by theÂ `!` sign. Other fields such as the`name` which is of type _string_ and age which is of type _integer_ are also included. This also validates the schema when querying for the data.

**Queries** are what you use to make a request to a GraphQL API. For instance, in our example above, when we are fetching the data related to a Star Wars character. Let us simplify this. To query in GraphQL, it is about asking for specific fields on objects. For example, using the same API as we did above, we fetch the name of all the characters in Star Wars. Below you can see the difference. On left-hand side of the image, is the query and on the right-hand side is the image.

<img src='https://cdn-images-1.medium.com/max/1200/1*L-Z_EF1tNkq4jUhsopHasw.png' />

The good thing about GraphQL queries is that they can be nested to go as deep as youâ€™d like. This is hard to do in a REST API. The operation becomes much more complex.

Below is another example of a nested query, a more complex one

<img src='https://cdn-images-1.medium.com/max/1200/1*ug3h4hZmAeuNHyy93Ygy2Q.png' />

**Mutations:** In REST architecture, to modify the data we either use `POST` to add data or `PUT` to update the existing fields with the data. In GraphQL, the overall concept is similar. You will send a query to cause the write operations on the server side. However, this form of the query is called a Mutation.

**Resolvers** are the link between the schema and the data. They provide functionality that can be used to interact with databases through different operations.

_In this tutorial, you will learn how to setup a GraphQL server with_ [_Nodejs_](https://www.crowdbotics.com/build/node-js?utm_source=medium&utm_campaign=nodeh&utm_medium=node&utm_content=koa-rest-api) _using the same building blocks we have just learned._

### Hello World! withÂ GraphQL

Lets now write our first GraphQL server. For this tutorial, we are going to use [Apollo Server.](https://www.apollographql.com/docs/apollo-server/) We need to install three packages in total for the Apollo Server to work with our existing Express application as a middleware. The good thing about Apollo Server is that it can be used with several popular frameworks for Node.js: Express, [Koa](https://medium.com/crowdbotics/building-a-rest-api-with-koajs-417c276929e2), and [Hapi](https://medium.com/crowdbotics/setting-up-nodejs-backend-for-a-react-app-fe2219f26ea4). Apollo itself is kept library-agnostic, so it is possible to connect it with a lot of third-party libraries in client and server applications.

Open your terminal and install the following dependencies:

```shell
# First create a new empty directory
mkdir apollo-express-demo

# Then initialize it
npm init -y

# Install required dependencies
npm install --save graphql apollo-server-express express
```

Let us understand briefly what these dependencies do.

- `graphql` is a support library and is a required module for our purpose
- `apollo-server-express` is added to an existing application and is a corresponding HTTP server support package
- `express` web framework for Nodejs

You can take a look at the following image of all the dependencies I installed without any error.

<img src='https://cdn-images-1.medium.com/max/800/1*gCozaTuzY6DHaPG4Ya43zA.png' />

Create a new file called `index.js` at the root of your project with the following code.

```js
const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');

const typeDefs = gql`
  type Query {
    hello: String
  }
`;

const resolvers = {
  Query: {
    hello: () => 'Hello world!'
  }
};

const server = new ApolloServer({ typeDefs, resolvers });

const app = express();
server.applyMiddleware({ app });

app.listen({ port: 4000 }, () =>
  console.log(`ðŸš€ Server ready at http://localhost:4000${server.graphqlPath}`)
);
```

This is our initial server file in which we start by simply requiring the `express` module. The `gql` is a template literal tag that is used for writing GraphQL schema as types. The schema consists of type definitions with a mandatory _Query_ type for reading data. It can further have fields and nested fields representing other data fields. In our above example, we are defining `typeDefs` to write a graphQL schema.

Then `resolvers` come into picture. Resolvers are used to return data for the fields from a schema. We are defining one resolver in our example which maps the function `hello()` to implement on our schema. Next, we create a `server` that uses the `ApolloServer` class to instantiate and start the server. Since we are using Express, we need to integrate the `ApolloServer` class. We are passing it by the method `applyMiddleware()` as the`app` to add the Apollo Serverâ€™s middleware. `app` here represents the existing application and is an instance of Express.

Lastly, we bootstrap the server by using `app.listen()` which is provided by the Express module itself. To run the server, open up your terminal and run the command `node index.js`. Now, from a browser window, visit the url: `http://localhost:4000/graphql` to see it action.

Apollo Server sets up GraphQL Playground for you so that you can start running queries and exploring schemas quickly as shown below.

<img src='https://cdn-images-1.medium.com/max/1200/1*ba4JULFAk5VbSFRsNxof8g.png' />

To run a query, type the following query on the left-hand side which is the editable space and then press the â–¶ (play) button in the middle.

<img src='https://cdn-images-1.medium.com/max/1200/1*SGaIF-GZ0E0QLg2K6sJ7CA.png' />

The schema tab on the right-hand side describes the data type of our query `hello`. This is coming straight from the `typeDefs` we defined in our server.

<img src='https://cdn-images-1.medium.com/max/800/1*3v_Uh_k2gjC-XueD9PhWvQ.png' />

_Voila!_ You just created your first GraphQL server. Now let us extend our current knowledge for the real world.

### Building an API withÂ GraphQL

So far we have put together all the modules and whatever necessary terminology that comes with it. In this section, we are going to create a small _Star Wars API_ for our own demonstration purpose using Apollo Server. You might have guessed by now that Apollo server is a library that helps you to connect a GraphQL schema to an HTTP server using Nodejs. It is not bound to only a specific Node framework, for example, we used ExpressJS in the previous section. It supports [Koa](https://medium.com/crowdbotics/building-a-rest-api-with-koajs-417c276929e2), Restify, [Hapi](https://medium.com/crowdbotics/setting-up-nodejs-backend-for-a-react-app-fe2219f26ea4), and Lambda too. For our API, letâ€™s continue to use Express.

### Compiling withÂ Babel

If you want to start from scratch, go ahead and.install all the libraries from the section `Hello World! With GraphQL`. Here are dependencies the we installed in the previous section:

```json
"dependencies": {
		"apollo-server-express": "^2.1.0",
		"express": "^4.16.4",
		"graphql": "^14.0.2"
	}
```

I am going to use the same project and the same file `index.js` to bootstrap the server. But before we start building our API, I want you to show you how to use ES6 modules in our demo project. Working with front-end libraries like React and Angular which already have support for ES6 features such as `import` and `export default` statements. Nodejs version `8.x.x` has way around this. All we need is a transpiler which allows us to write JavaScript using ES6 features. You can totally skip this step and use the good old `require()` statements.

What is a _transpiler_ though?

> Transpilers are also known as â€˜source-to-source compilersâ€™ that read code from source written in one programming language and produce an equivalent code in another language.

In the case of Nodejs, we are not switching programming languages, rather we need to use new language features that are not supported by the LTS version of Node I am using. I am going to setup [**Babel**](https://babeljs.io/) **compiler** and enable it in our project by going through the following configuration process.

First, you will have to install few dependencies and do mind `-D` flag as we only need these dependencies for our development environment.

```shell
npm install -D babel-cli babel-preset-env babel-watch
```

Once you have installed them, add aÂ `.babelrc` file to the root of the project and add the following config:

```json
{
  "presets": [env]
}
```

The last step in the configuration process is to add a `dev` `script` in `package.json`. This will take care of running the babel compiler on its own (automate) once there is a change. This done by `babel-watch` that also takes care of re-starting [Nodejs](https://www.crowdbotics.com/build/node-js?utm_source=medium&utm_campaign=nodeh&utm_medium=node&utm_content=koa-rest-api) web server.

```json
"scripts": {
	"dev": "babel-watch index.js"
}
```

To see it action add the following code to your `index.js` and see if everything is working fine.

```js
import express from 'express';

const app = express();

app.get('/', (req, res) => res.send('Babel Working!'));

app.listen({ port: 4000 }, () =>
  console.log(`ðŸš€ Server ready at http://localhost:4000`)
);
```

From terminal write `npm run dev`. If there are no errors, you will get the following:

<img src='https://cdn-images-1.medium.com/max/800/1*Cix-Zl8mbZf90qpuHxEB8g.png' />

You can also visit `http://localhost:4000/` in a browser window to see it action.

### Adding aÂ Schema

We need a schema to start our GraphQL API. Let us create a new file called `api/schema.js` inside the directory `api`. Add the following the schema.

```js
import { gql } from 'apollo-server-express';

const typeDefs = gql`
  type Person {
    id: Int
    name: String
    gender: String
    homeworld: String
  }
  type Query {
    allPeople: [Person]
    person(id: Int!): Person
  }
`;

export default typeDefs;
```

Our schema consists of two queries in total. The first is `allPeople` through which all characters in our API can be fetched and listed. The second query `person` is to retrieve one person using their id. Both of these query types are dependent on a custom type called `Person` object which contains four properties.

### Add aÂ Resolver

We have already learned about the importance of a resolver. It is based on a simple mechanism that it has to link the schema and the data. Resolvers are functions that contain the logic behind a query or mutation. They are used then to retrieve data and return it on the relevant request.

If you have built servers before using Express, you can think of a resolver as a controller where each controller is built for a specific route. Since we are not using any database behind our server, we must provide some dummy data to mock our API.

Create a new file called `resolvers.js` and add the following code.

```js
onst defaultData = [
	{
		id: 1,
		name: 'Luke SkyWaler',
		gender: 'male',
		homeworld: 'Tattoine'
	},
	{
		id: 2,
		name: 'C-3PO',
		gender: 'bot',
		homeworld: 'Tattoine'
	}
];

const resolvers = {
	Query: {
		allPeople: () => {
			return defaultData;
		},
		person: (root, { id }) => {
			return defaultData.filter(character => {
				return (character.id = id);
			})[0];
		}
	}
};

export default resolvers;
```

First, we define the `defaultData` array which contains details of two characters from Star Wars. Both of these objects inside the array have four properties as per our schema. Next is our `resolvers` object which contains two functions. `allPeople()` here can be used later to retrieve all the data inside the`defaultData` array. The `person()` arrow function, uses an argument `id` to retrieve the person object with the requested ID. This we have already defined in our query.

You have to export both resolvers and schema objects to use them with Apollo Server middleware.

### Implementing theÂ Server

Now that we have defined our schema and resolver, we will implement the server inside the file `index.js`. Start by importing Apollo Server from `apollo-server-express`. We also need to import our schema and resolvers object from the `api/` folder. Then, use GraphQL middleware from the Apollo Server Express library to instantiate the GraphQL API.

```js
import express from 'express';
import { ApolloServer } from 'apollo-server-express';

import typeDefs from './api/schema';
import resolvers from './api/resolvers';

const app = express();

const PORT = 4000;

const SERVER = new ApolloServer({
  typeDefs,
  resolvers
});

SERVER.applyMiddleware({ app });

app.listen(PORT, () =>
  console.log(`ðŸš€ GraphQL playground is running at http://localhost:4000`)
);
```

Lastly, we bootstrap our Express server using `app.listen()`. You can run the server now executing the command from the terminal `npm run dev`. Once the Node server starts, it will prompt a success message indicating the server has started.

Now to test our GraphQL API, hop on to `http://localhost:4000/graphql` URL in a browser window and run the following query.

```graphql
{
  allPeople {
    id
    name
    gender
    homeworld
  }
}
```

Hit the _play_ button and you will see a familiar result on the right side section like below.

<img src='https://cdn-images-1.medium.com/max/1200/1*BnyLxWTl_9yDpoIDLH-Xzg.png' />

This is all happening because our query type `allPeople` has custom business logic to retrieve all the data (in our case the mock data we are providing as an array inside `resolvers.js`) using a resolver. To fetch a single person object try running another query like this. Remember you have to provide the ID.

```graphql
{
  person(id: 1) {
    name
    homeworld
  }
}
```

Run the above query, and as a result, you can have the values of each field/property you have mentioned to query up on. Your result will be similar to the following.

<img src='https://cdn-images-1.medium.com/max/1200/1*DOSW6mN894ZYg498rVxNKg.png' />

Great! I am sure you must have got hold of how to create a GraphQL query and run it. Apollo Server library is a powerful one. It also enables us to edit the playground. _Suppose we want to edit the theme of the playground?_ All we have to do is provide an option when creating `ApolloServer` instance, in our case the `SERVER`.

```js
const SERVER = new ApolloServer({
  typeDefs,
  resolvers,
  playground: {
    settings: {
      'editor.theme': 'light'
    }
  }
});
```

The `playground` property has many features such defining a default endpoint for the playground to changing the theme. You can even enable the playground in the production mode. More configurable options can be found in the official documentation of Apollo Server [**here**](https://www.apollographql.com/docs/apollo-server/v2/features/graphql-playground.html)**.**

After changing the theme we get the following.

<img src='https://cdn-images-1.medium.com/max/1200/1*cZ7KO6x0FVXql9c04ZshIA.png' />

### Conclusion

If you completed this tutorial step by step, _Congratulations!ðŸŽ‰_

You have learned how to configure an Express server with Apollo library to setup your own GraphQL API. Apollo Server is an open source project and is one the most stable solution to create GraphQL APIs for full-stack applications. It also supports client-side out of the box for React, Vue, Angular, Meteor, and Ember as well as Native mobile development with Swift and Java. More information about this can be found [**here**](https://www.apollographql.com/docs/react/).

**The complete code for the tutorial at [this Github repository](https://github.com/amandeepmittal/apollo-express-demo)**

---

## Creating a /slash page
Slug: creating-a-slash-page

Last week I found about [Robb Knight's Slash page](https://slashpages.net/) site. It details common top-level URLs with each URL starting with `/url`.

Inspired by this, I created a listing of /slashes URLs that I've added on this blog recently. They can be a found under [`/slash`](/slash/). I already had an `/about`, `/blog`, `/rss`, and `/stats`. The new additions are `/now`, `/links`, `/search` and `/ai`.

In near future, I plan to add a couple more slash pages.

---

## Creating and Validating React Native Forms with Formik
Slug: creating-and-validating-react-native-form-with-formik

![cover](https://i.imgur.com/Qg4x9He.jpg)

Forms are an essential part of a mobile app â€” specifically, to handle user interactions that are available behind an authorization.

To ensure a seamless user experience, a form component consists of more than the input fields that allow users to enter their credentials. This can vary from handling form state, input field validation, handling errors, form submission, and so on.

[Formik](https://formik.org/) is an open-source React and React Native library that allows us to handle forms by:

- keeping track of a formâ€™s state;
- handling form submission via reusable methods and handlers (such as `handleChange`, `handleBlur`, and `handleSubmit`);
- handling validation and error messages out of the box.

In this post, let's take a look at how to integrate it along with [Yup](https://github.com/jquense/yup) in a React Native app to create forms and validate them. We are also going to cover how to change the focus of one input field to another using a device's keyboard by forwarding the `ref` created using a [useRef hook](https://reactjs.org/docs/hooks-reference.html#useref).

The source code is available at [this GitHub repository](https://github.com/amandeepmittal/react-native-examples/tree/master/forms-with-formik).

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements on your local dev environment:

- [Node.js](https://nodejs.org/) version >= 12.x.x installed
- Have access to one package manager such as npm or yarn or npx
- [expo-cli](https://github.com/expo/expo-cli) version installed, or use npx

To learn more about how to set up and run the simulator or the emulator on your local development environment, visit React Nativeâ€™s official documentation [here](https://reactnative.dev/docs/getting-started).

## Getting Started

Let's start by creating a simple React Native app with a new screen: `Login.js`.

Create a new React Native project using `expo-cli` and then install the dependencies required to build this demo app. Open a terminal window and execute the following commands:

```shell
npx expo-cli init formik-example

cd formik-example

yarn add formik yup
```

## Create reusable components

Create a new directory called `components/`. In this directory, we are going to keep two form components that are reusable for various types of forms such as `Login` or `SignUp`.

Let's start by creating a simple form button component which is a touchable element that allows the user to interact with the deviceâ€™s screen and perform the next action. It is going to accept two props:

- `label`: the text label on the button component;
- `onPress` that is going to be handled by the parent component.

Create a new file called `Button.js` and add the following snippet:

```js
import React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export default function Button({ label, onPress }) {
  return (
    <TouchableOpacity
      style={{
        borderRadius: 8,
        height: 50,
        width: 245,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#e94832'
      }}
      activeOpacity={0.7}
      onPress={onPress}
    >
      <Text
        style={{ fontSize: 18, color: 'white', textTransform: 'uppercase' }}
      >
        {label}
      </Text>
    </TouchableOpacity>
  );
}
```

Now, let's create the second reusable component to let users enter their credentials. Create a new file called `TextInput.js`. This component is going to be reused for every input field in a form. It is going to have an icon on the left of the input field to indicate the nature of the input field itself. It is also going to have a placeholder text that tells the user what type of form value is expected.

It is going to accept one prop and that is the name of the `icon`. Each input field may have a different icon and other props that are generally used with a `TextInput` component in a React Native app. You will see what different props are used on a `TextInput` in the next section. For now, use a [rest parameter syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) to pass down the `...otherProps`.

```js
import React from 'react';
import { TextInput as RNTextInput, View, StyleSheet } from 'react-native';
import { Entypo as Icon } from '@expo/vector-icons';

export default function TextInput({ icon, ...otherProps }) {
  const validationColor = '#223e4b';
  return (
    <View
      style={{
        flexDirection: 'row',
        alignItems: 'center',
        height: 48,
        borderRadius: 8,
        borderColor: validationColor,
        borderWidth: StyleSheet.hairlineWidth,
        padding: 8
      }}
    >
      <View style={{ padding: 8 }}>
        <Icon name={icon} color={validationColor} size={16} />
      </View>
      <View style={{ flex: 1 }}>
        <RNTextInput
          underlineColorAndroid="transparent"
          placeholderTextColor="rgba(34, 62, 75, 0.7)"
          {...otherProps}
        />
      </View>
    </View>
  );
}
```

## Create a login screen

After setting up the reusable components, let's use them in a login screen. Start by creating a new directory called `screens/` and then, inside it, create a new file called `Login.js`. This component file is going to consist of all the necessary elements and business logic behind a login form.

The first input field is going to be for an email. It is going to have properties such as:

- the name of the icon as `icon`.
- `autoCapitalize` is going to be unique to this field since we do not want any characters to auto-capitalize by default.
- `autoCompleteType` provides autocomplete hints from the device, so it can provide an autofill for the particular field. It has [different types](https://reactnative.dev/docs/textinput#autocompletetype), but the one we are going to use here is for `email`.
- `keyboardType` is set to `email-address`. It too has [different types](https://reactnative.dev/docs/textinput#keyboardtype).
- `keyboardAppearance` allows you to set the keyboard color either to the system's default or light or dark in the background
- `returnKeyType` and `returnKeyLabel` determines how the return key should look like and the label on it. There are [different values](https://reactnative.dev/docs/textinput#returnkeytype) that you can set for it. Some of them are cross-platform and some are OS-specific. For the email input field, let's set it to â€œnextâ€ since we want the user to enter their email credential and then move on to the next input field by pressing the `next` button. To programmatically move on to the next input field, we are going to handle that later in a different section.

The second input field is going to be for `password`. It is going to use similar properties to the ones we used in the input field for `email` but with different values. It has a unique property such as `secureTextEntry` set to `true` which is often used to enter text values that are sensitive, like a password.

Here is the code snippet for the `Login` component after creating these two input fields:

```js
import React from 'react';
import { Text, View } from 'react-native';

import TextInput from '../components/TextInput';
import Button from '../components/Button';

export default function Login() {
  return (
    <View
      style={{
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      <Text style={{ color: '#223e4b', fontSize: 20, marginBottom: 16 }}>
        Login
      </Text>
      <View style={{ paddingHorizontal: 32, marginBottom: 16, width: '100%' }}>
        <TextInput
          icon="mail"
          placeholder="Enter your email"
          autoCapitalize="none"
          autoCompleteType="email"
          keyboardType="email-address"
          keyboardAppearance="dark"
          returnKeyType="next"
          returnKeyLabel="next"
        />
      </View>
      <View style={{ paddingHorizontal: 32, marginBottom: 16, width: '100%' }}>
        <TextInput
          icon="key"
          placeholder="Enter your password"
          secureTextEntry
          autoCompleteType="password"
          autoCapitalize="none"
          keyboardAppearance="dark"
          returnKeyType="go"
          returnKeyLabel="go"
        />
      </View>
      <Button label="Login" onPress={() => true} />
    </View>
  );
}
```

To see the login form in action, run `expo start` or `yarn start`.

![js1](https://i.imgur.com/isPvj2w.png)

## Add Formik to a login form using the useFormik hook

`useFormik` is a custom React hook that returns the Formik state and the handler methods to be used in a form component.

To use it, we have to import it from the `formik` library in the `Login.js` file.

```js
import { useFormik } from 'formik';
```

You might have noticed by now that we are not using `useState` to handle the value of each input field in the Login form. The reason behind that is that `formik` comes with a property called `initialValues` whose value is the object containing form fields.

In the case of the current form, these values are going to be `email` and `password`. The `onSubmit` method accepts a function that has these values as the first argument to handle the form submission. We are going to use these values to verify if the user credentials provided in the demo app are correct. You can also add other handler methods such as navigating to another screen on successful form submission.

In the `Login` component, you can add the following.

```js
const { handleChange, handleSubmit, values } = useFormik({
  initialValues: { email: '', password: '' },
  onSubmit: values =>
    alert(`Email: ${values.email}, Password: ${values.password}`)
});
```

Now, add `onChangeText` on both input fields as well as `handleSubmit` as the value of `onPress` on the `Button` component.

```js
// on email input field
onChangeText={handleChange('email')}

// on password input field
onChangeText={handleChange('password')}

// change the value of onPress prop on <Button />
<Button label='Login' onPress={handleSubmit} />
```

Fill the input fields and press the login button to see an alert box returning these values.

![js2](https://i.imgur.com/4XARSpP.gif)

This means the Login form with a custom component is working and Formik has been integrated successfully.

## Add validation schema with Yup

The `yup` library is useful for managing complex validations when using Formik in either React or React Native apps. Formik supports both synchronous and asynchronous form validation. It has support for schema-based, form-level validation from Yup.

Start by importing it.

```js
import * as Yup from 'yup';
```

Since `initialValues` is an object, you have to specify `yup.object()` and define the shape of the object. Make sure that, when youâ€™re defining input fields inside the shape, their names correspond to those described in `initialValues`.

Each field in this object is supported by a chain of validation methods provided by the Yup API. The type of both `email` and `password` is going to be â€œstringâ€ since the `onChangeText` method returns the values as strings.

Add the following code snippet before the `Login` functional component.

```js
const LoginSchema = Yup.object().shape({
  email: Yup.string().email('Invalid email').required('Required'),
  password: Yup.string()
    .min(2, 'Too Short!')
    .max(10, 'Too Long!')
    .required('Required')
});
```

Using a library like Yup for validation saves a lot of time, especially when you donâ€™t have to define custom validation methods to check for an input field. For example, in the above snippet, using `.email()` automatically matches against a regex instead of defining one, to check the validity of an email input field.

To validate input fields based on the schema just defined, let's add another property to `useFormik` called `validationSchema`.

```js
const { handleChange, handleSubmit, values } = useFormik({
  validationSchema: LoginSchema,
  initialValues: { email: '', password: '' },
  onSubmit: values =>
    alert(`Email: ${values.email}, Password: ${values.password}`)
});
```

If you press the login button with blank input fields, the app wonâ€™t display an error but it won't submit the form.

## Validating input fields

If the user provides wrong credential values (_since we are not covering the backend API in this post, it is a good practice to check the validity of credentials on the server-side as well_), it's a good UX practice to indicate the error. In this section, let's turn the input field border and the left icon color to red if the defined validation schema object doesn't match.

We will be using `errors`, `touched`, and `handleBlur` to know whether the input field has been touched by the user and, if yes, will pass the prop `errors` to the custom `TextInput` to display UI changes based on that.

In the `Login` component, modify the following:

```js
const { handleChange, handleSubmit, handleBlur, values, errors, touched } =
  useFormik({
    validationSchema: LoginSchema,
    initialValues: { email: '', password: '' },
    onSubmit: values =>
      alert(`Email: ${values.email}, Password: ${values.password}`)
  });
```

Then, for the email input field, add the following properties:

```js
<TextInput
  // ... rest remains same
  onBlur={handleBlur('email')}
  error={errors.email}
  touched={touched.email}
/>
```

Similarly, modify the password field:

```js
<TextInput
  // ... rest remains same
  onBlur={handleBlur('password')}
  error={errors.password}
  touched={touched.password}
/>
```

Now, go the `TextInput` component, and pass new props: `error` and `touched`.

```js
export default function TextInput({ icon, error, ...otherProps }) {...}
```

Next, let's change the value of `validationColor` which we have defined in a previous section, based on whether the input field is touched or not and if there is an error or not by using a nested ternary operator.

```js
const validationColor = !touched ? '#223e4b' : error ? '#FF5A5F' : '#223e4b';
```

Now, go back to the simulator and, without entering the value for any input field, press the Login button. You will find that the border color and the icon color for both input fields turns red.

![js3](https://i.imgur.com/MtoCKJq.png)

Try entering new values that satisfy the `loginSchema`. Also, see what happens if you touch one input field and move on to the next without entering any value â€” it will be considered as touched and an error will be shown.

![js4](https://i.imgur.com/Xb1RZub.gif)

Try to enter a password with more than 10 characters and verify that and error is also shown.

![js5](https://i.imgur.com/S7kvcxd.png)

## Select the next text input after pressing the "next" button

The last thing we need to do is to add another property on each input field to select the next `TextInput` field when pressing the `next` button.

Since there are only two input fields, the `next` button is shown only in the email input field. This can be done by adding a property `onSubmitEditing` on the input field which accepts a callback as value. By creating a new `ref` for the password field, we can determine whether the input field in focus at any given time is the password or not. If not, that means it is the email field and we can press the next button to change the focus from the email to the password field.

In the `Login.js` file, start by importing the `useRef` hook from the React library and, inside the Login component, define the `ref` with the initial value of `null`.

```js
import React, { useRef } from 'react';

//...

export default function Login() {
  const password = useRef(null);
  // ...
}
```

Next, add the `ref` property to the password input field.

```js
<TextInput
  ref={password}
  // ...
/>
```

Then, add `onSubmitEditing` to the email input field.

```js
onSubmitEditing={() => password.current?.focus()}
```

Back to the simulator, you will encounter the following warning.

![js6](https://i.imgur.com/gElVVOR.png)

This can be solved by using a `forwardRef` on the custom `TextInput` component. Ref forwarding is a technique for automatically passing a `ref` through a component to one of its children. In our case, we need to pass the `ref` from `Login` to the `TextInput` component.

Open `TextInput.js` and import `forwardRef` from the React library.

```js
import React, { forwardRef } from 'react';
```

Then, wrap all contents of the `TextInput` functional component with `forwardRef` as shown below:

```js
const TextInput = forwardRef(({ icon, error, touched, ...otherProps }, ref) => {
  const validationColor = !touched ? '#223e4b' : error ? '#FF5A5F' : '#223e4b';
  return (
    <View
      style={{
        flexDirection: 'row',
        alignItems: 'center',
        height: 48,
        borderRadius: 8,
        borderColor: validationColor,
        borderWidth: StyleSheet.hairlineWidth,
        padding: 8
      }}
    >
      <View style={{ padding: 8 }}>
        <Icon name={icon} color={validationColor} size={16} />
      </View>
      <View style={{ flex: 1 }}>
        <RNTextInput
          underlineColorAndroid="transparent"
          placeholderTextColor="rgba(34, 62, 75, 0.7)"
          ref={ref}
          {...otherProps}
        />
      </View>
    </View>
  );
});

export default TextInput;
```

Now, by pressing the â€œnextâ€ button on the email input field, you can change the focus of the current field to â€œpasswordâ€.

![js7](https://i.imgur.com/U505VsB.gif)

The password input field shows a `go` button which indicates that, when users have finished entering their credentials, they are ready to submit the form. By adding `onSubmitEditing` with the value of `handleSubmit`, you submit the form.

Add the following to the password input field in `Login.js`:

```js
onSubmitEditing={() => handleSubmit()}
```

And thatâ€™s it! Here is the output you are going to get after completing this step:

![js8](https://i.imgur.com/01WXCni.gif)

## Conclusion

Using a form library like Formik gives us many advantages when building and handling forms to provide a pragmatic user experience.

There are many different methods available in the [Yup API](https://github.com/jquense/yup#yup) to add validation schema to a form component. This post covers the basics of Formik and Yup as well as one way of handling errors and touched fields.

The last section where we used `ref` to change the focus from one input field to the next using a device's keyboard is not a must-have but it may be worth considering if you want to provide seamless user experience.

---

## How to Create a Custom Image Gallery in React Native
Slug: custom-preview-image-gallery-in-react-native

In React Native, there are many ways to display a collection of images in a gallery view. One form is commonly known as carousel. Using an open-source library such as [react-native-swiper](https://github.com/leecade/react-native-swiper) or more advance [react-native-snap-carousel](https://github.com/meliorence/react-native-snap-carousel) serves the purpose. But what if we want to create a custom gallery view with additional functionality?

In this tutorial, let's create a custom gallery of images using `react-native-snap-carousel` and `FlatList` from React Native. The open-source library is going to display each image in a carousel view. The `FlatList` is what we will use to display the thumbnail view for each image below the carousel. The construction of the syncing part between the two is to add a functionality such that when an image in the carousel is scrolled either left or right, the thumb in the `FlatList` is also going to be scrolled along with it. Of course, to achieve this synchronization between the two, we are going to use React Hooks such that you will be able to implement such a pattern in your own React Native apps.

## Pre-requisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements in your local dev environment:

- [Node.js](https://nodejs.org/en/) version >= 12.x.x installed.
- Have access to one package manager such as npm or yarn or npx.
- [react-native-cli](https://www.npmjs.com/package/react-native-cli) installed, or use npx.

## Setup a React Native Project

To follow along with this tutorial, set up a new React Native project and install all the dependencies that are required to implement the example. Open up a terminal window and run each command as mentioned in the order:

```shell
npx react-native init rnPreviewImageGallery

cd rnPreviewImageGallery

yarn add react-native-snap-carousel
```

The reason I like to use `react-native-snap-carousel` is that it does not require any additional steps to configure to be used on native devices. Plus, it offers different layouts to configure the carousel view, out of the box.

After installing the dependencies, let's bring in the image assets to use. I am using images from [Unsplash](https://unsplash.com/s/photos/amsterdam) to demonstrate. To follow along, the images are stored at [this location](https://github.com/amandeepmittal/react-native-examples/tree/master/rnPreviewImageGallery/assets/images) in the example GitHub repo.

After setting up the source images to be used, open up the `App.js` file, and let's initiate it with a title of the screen to display. Import the following statements, then create an `IMAGES` object by importing each image using Common JS require statements.

Using the `useState` React hook, create an array of images called `images`, with each image having a unique `id` to differentiate between each object in the array.

```js
const [images, setImages] = useState([]);
```

The `useState` hook returns two values in an array. The first value is the current value of the state object, and the second value in the array is the function to update the state value of the first. This why the second value starts with a conventional prefix of a set. You can technically name it anything, but following conventions that are commonly used in the React world is a good practice to follow.

Also, define some constants that will be used throughout the example such as the overall spacing between each thumbnail and the width and height of each thumbnail to represent in the `FlatList`.

To set up the carousel view of an image for different screen sizes, let's use the `Dimensions` API from React Native.

Add the following code snippet to `App.js` and make sure to define state variables at the top of the `App` function. Hooks are always called at the top level of a functional component in React. When defining a state, they must be the first thing in the function, especially before returning a JSX.

```js
import React, { useState, useRef } from 'react';
import {
  TouchableOpacity,
  View,
  Text,
  Image,
  FlatList,
  Dimensions
} from 'react-native';

const { width } = Dimensions.get('window');
const SPACING = 10;
const THUMB_SIZE = 80;

const IMAGES = {
  image1: require('./assets/images/1.jpeg'),
  image2: require('./assets/images/2.jpeg'),
  image3: require('./assets/images/3.jpeg'),
  image4: require('./assets/images/4.jpeg'),
  image5: require('./assets/images/5.jpeg'),
  image6: require('./assets/images/6.jpeg'),
  image7: require('./assets/images/7.jpeg')
};

const App = () => {
  const [images, setImages] = useState([
    { id: '1', image: IMAGES.image1 },
    { id: '2', image: IMAGES.image2 },
    { id: '3', image: IMAGES.image3 },
    { id: '4', image: IMAGES.image4 },
    { id: '5', image: IMAGES.image5 },
    { id: '6', image: IMAGES.image6 },
    { id: '7', image: IMAGES.image7 }
  ]);

  return (
    <View style={{ flex: 1, backgroundColor: 'black', alignItems: 'center' }}>
      <Text
        style={{
          color: 'white',
          fontSize: 32,
          marginTop: 50,
          marginBottom: 25
        }}
      >
        Custom Gallery
      </Text>
      {/* Carousel View */}
      {/* Thumbnail component using FlatList */}
    </View>
  );
};

export default App;
```

To initialize the development server for iOS, please execute the command `npx react-native run-ios` from a terminal window. Similarly, the build command for Android is `npx react-native run-android`.

Here is the app running after this step on an iOS simulator:

<img src='https://miro.medium.com/max/880/0*kS7PBYWOT71qfQ-g.png' />

## Add a carousel view with react-native-snap-carousel

The component library `react-native-snap-carousel` has a vast API of properties and different layout patterns that are plug-n-use and even allows you as a developer to implement custom interpolations and animations. You can find more information on how to customize it in the official documentation [here](https://github.com/meliorence/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md).

For the current example, let's stick to the default layout pattern to display a carousel. To create a carousel view, import the component from `react-native-snap-carousel` by adding the following import statement in the `App.js` file. Let's also import the `Pagination` component offered separately by this library to display the dot indicator.

```js
// after other import statements
import Carousel, { Pagination } from 'react-native-snap-carousel';
```

Then, add a `View` component after the title in the `App.js` file. It is going to wrap the `Carousel` component which takes a set of required props to work:

- `data` the array of `images` or items to loop.
- `layout` to define the way images are rendered and animated. We will use the `default` value.
- `sliderWidth` to define the width in pixels for the carousel container.
- `itemWidth` to define the width in pixels for each item rendered inside the carousel.
- `renderItem` takes an image item from the `data` array and renders it as a list. To render the image, the `Image` component from React Native is used.

Add the following code snippet in `App.js` to see the carousel in action:

```js
return (
  <View style={{ flex: 1, backgroundColor: 'black', alignItems: 'center' }}>
    {/* Title JSX Remains same */}
    {/* Carousel View */}
    <View style={{ flex: 1 / 2, marginTop: 20 }}>
      <Carousel
        layout="default"
        data={images}
        sliderWidth={width}
        itemWidth={width}
        renderItem={({ item, index }) => (
          <Image
            key={index}
            style={{ width: '100%', height: '100%' }}
            resizeMode="contain"
            source={item.image}
          />
        )}
      />
    </View>
  </View>
);
```

In the simulator you are going to get the following result:

<img src='https://miro.medium.com/max/536/0*9-RZy5PEztyt-lEF.gif' />

## Add a dot indicator

The `Pagination` component from the `react-native-snap-carousel` is used to display a dot indicator. This dot indicator requires the following props:

- `activeDotIndex` to represent the current image shown in the carousel.
- `dotsLength` to calculate how many dots to display based on the number of items or images in the carousel.
- `inactiveDotColor` to display the dot indicator color when it is inactive.
- `dotColor` to display the dot indicator color when it is active.
- `inactiveDotScale` is used to set the value to scale the dot indicator when it's inactive.
- `animatedDuration` is used to control the length of dot animation in milliseconds. The default value for it is `250`. It is not required, but to change the value, use this prop.

Add the following code snippet after the `Carousel` component in `App.js` file:

```js
<View>
  {/* Carousel Component code remains same */}
  <Pagination
    inactiveDotColor="gray"
    dotColor={'orange'}
    activeDotIndex={indexSelected}
    dotsLength={images.length}
    animatedDuration={150}
    inactiveDotScale={1}
  />
</View>
```

The value of `activeDotIndex` is calculated based on the current index of the image item. Let's add a state variable called `indexSelected` in the `App` component with a value of zero. It is going to update when the index value of the current image changes. The initial value of this state variable is going to be `0`. Create a handler method called `onSelect()` which updates the value of the current index.

Add the following code snippet before rendering the JSX in `App` component:

```js
const App = () => {
  // code remains same
  const [indexSelected, setIndexSelected] = useState(0);

  const onSelect = indexSelected => {
    setIndexSelected(indexSelected);
  };
};
```

Now, add a prop to the `Carousel` component called `onSnapToItem`. It accepts a callback as a value. This callback is fired every time the index of the image item changes, in other words, every time the user swipes to the next image. The only argument passed to this callback is the current `index` of the item which is updated with the help of the `onSelect()` handler method.

```js
<Carousel
  // rest remains same
  onSnapToItem={index => onSelect(index)}
/>
```

In the simulator, you will get the following result. The dot indicator now syncs with the Carousel item.

<img src='https://miro.medium.com/max/588/0*hE8I2aJxoFp5UnDu.gif' />

Let's add another view component below the `View` that wraps the carousel to display the total number of images and the current image index number.

```js
// Carousel View
<View
  style={{
    marginTop: 20,
    paddingHorizontal: 32,
    alignSelf: 'flex-end'
  }}
>
  <Text
    style={{
      color: 'white',
      fontSize: 22
    }}
  >
    {indexSelected + 1}/{images.length}
  </Text>
</View>
```

Here is the result after this step:

<img src='https://miro.medium.com/max/800/0*9h1KAqUOt9LzOORL.png' />

Awesome! The configuration for the Carousel component is now complete. Let's see how to sync it with a custom FlatList component in the next section.

## Create a list of thumbnails using FlatList

Let's display a list of thumbnails using `FlatList` from React Native using the same array of `images` from the state variable. This list is going to be displayed at the bottom of the device's screen and is a horizontal list. To achieve that, let's set use `position: absolute` style property with a `bottom` of value `80`.

Each thumbnail is composed of an `Image` component. It has the width and the height of the `THUMB_SIZE` variable we declared earlier. To show the selected thumbnail or the current thumbnail, using a ternary operator, let's manipulate the style properties `borderWidth` and `borderColor` on this `Image` component.

It is going to be wrapped by a `TouchableOpacity` component because its `onPress` prop is going to fire a handler method we have yet to create, to allow a user to change the selected image by a tap.

Add the following code snippet after Carousel's View:

```js
<FlatList
  horizontal={true}
  data={images}
  style={{ position: 'absolute', bottom: 80 }}
  showsHorizontalScrollIndicator={false}
  contentContainerStyle={{
    paddingHorizontal: SPACING
  }}
  keyExtractor={item => item.id}
  renderItem={({ item, index }) => (
    <TouchableOpacity activeOpacity={0.9}>
      <Image
        style={{
          width: THUMB_SIZE,
          height: THUMB_SIZE,
          marginRight: SPACING,
          borderRadius: 16,
          borderWidth: index === indexSelected ? 4 : 0.75,
          borderColor: index === indexSelected ? 'orange' : 'white'
        }}
        source={item.image}
      />
    </TouchableOpacity>
  )}
/>
```

The list of thumbnails renders as shown below:

<img src='https://miro.medium.com/max/800/0*JyzPZ5toA-v8mg3k.png' />

In the previous image, you will see that the first image is selected. You cannot change the currently selected image yet in the FlatList.

## Syncing the Carousel view with the FlatList

The basic element that is going to allow us to sync the image change between both the Carousel view and the thumbnail is a React hook called `useRef`.

It is a function that returns a mutable ref object whose `current` property can be initialized to keep track of the current index value for each image. The index value here is the image selected. Initially, it is going to be the first thumbnail and the first image shown in the carousel.

Let's create a ref that is going to be the reference of the current image from `Carousel` component and add it to the `App.js` file:

```js
const App = () => {
  const carouselRef = useRef();
  // ...
};
```

Since the `Carousel` component keeps track of the change of the current index of the image component by triggering a callback called `snapToItem()`, we can use it to sync with the `FlatList`.

Start by adding a handler method called `onTouchThumbnail()` after defining the ref. It accepts one argument called `touched` which is the index value of the current image selected from the `TouchableOpacity` component or Carousel. If the value of the argument `touched` and `indexSelected` is the same, do nothing. Otherwise, when the value of the `touched` or `indexSelected` updates, change the current image in the `Carousel` and the `FlatList` at the same time.

```js
const onTouchThumbnail = touched => {
  if (touched === indexSelected) return;

  carouselRef?.current?.snapToItem(touched);
};
```

Add the `ref` prop on `Carousel` component:

```js
<Carousel
  ref={carouselRef}
  //...
/>
```

Next, add an `onPress` prop on the `TouchableOpacity` component:

```js
<TouchableOpacity
  onPress={() => onTouchThumbnail(index)}
  activeOpacity={0.9}
>
```

Here is the output after this step:

<img src='https://miro.medium.com/max/582/0*TdtJeFSTFtRUV5L_.gif' />

The selection sync works do you notice there is a problem with the `FlatList` component? It doesn't scroll on its own when an image from the Carousel is selected that is not in the current view on the screen.

## Scroll the FlatList using scrollToOffset

Start by creating a new ref called `flatListRef` in `App.js` and add the ref prop to `FlatList` component:

```js
const App = () => {
  // ...
  const flatListRef = useRef();

  return (
    // ...
    <FlatList
      ref={flatListRef}
      // rest remains same
    />
  );
};
```

The [scrollToOffset method](https://reactnative.dev/docs/flatlist#scrolltooffset) available on `FlatList` can be used to scroll the thumbnails to a certain offset. This method accepts two arguments. The first is called `offset` which accepts a number as a value. The second argument is the `animated` property which determines whether the scroll to even should be animated or not.

The value for the `offset` is going to be `indexSelected` of the thumbnail multiplied by the size of the thumbnail. Let's also set the value of `animated` to true.

Since the `FlatList` has to scroll on every selection, let's add mutate the ref inside the handler method `onSelect()`.

```js
const onSelect = indexSelected => {
  setIndexSelected(indexSelected);

  flatListRef?.current?.scrollToOffset({
    offset: indexSelected * THUMB_SIZE,
    animated: true
  });
};
```

Here is the output after this step:

<img src='https://miro.medium.com/max/584/0*YVetWmnrP5zLKCi5.gif' />

## Conclusion

We have discussed only one scenario of creating a custom image gallery with FlatList. The main objective here is to get familiar with the use of react-native-snap-carousel, useRef hook, and `scrollToOffset` method in FlatList.

## Further reading

- [A complete list of FlatList methods available](https://reactnative.dev/docs/flatlist#methods)
- [A complete list of props available on Carousel component from react-native-snap-carousel](https://github.com/meliorence/react-native-snap-carousel/blob/master/doc/PROPS_METHODS_AND_GETTERS.md)
- [In detail guide on how to use Hooks in React & React Native apps](https://blog.crowdbotics.com/build-a-react-app-with-localstorage-api-and-hooks/)

Originally Published at **[Crowdbotics's Blog](https://blog.crowdbotics.com/how-to-create-a-custom-tab-bar-in-react-native/)**.

---

## How to create a custom scrollbar with React Native Animated API
Slug: custom-scroll-bar-indicator-with-react-native-animated-api

> Updated on: August 4, 2021

![cover](https://i.imgur.com/ateUlTf.png)

A `ScrollView` is a component that enables to view the content on a device's screen that is not able to be displayed in one screen. Using a scroll view component, the content can either be scrolled vertically or horizontally. This depends a lot on the design of the mobile application.

In React Native, to implement a scroll view, there are two types of components available: `ScrollView` and `FlatList`. The `ScrollView` component renders all children at once. This is useful if the data to display is static or there aren't too many data items in the list. The `FlatList` component is performant and optimal for displaying a huge scrollable list of data items.

For example, this how a `ScrollView` component is implemented in a React Native app:

```js
<ScrollView style={{ backgroundColor: 'white', marginHorizontal: 20 }}>
  <Text>
    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
    tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
    quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
    consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
    cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat
    non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
  </Text>
</ScrollView>
```

Both of these scrollable components have at least one thing in common: a scroll bar indicator. By default, the scroll bar indicator is visible whether the content is displayed horizontally or vertically. To disable this vertical scroll bar indicator you would add the prop `showsVerticalScrollIndicator` with a boolean value of false:

```js
<ScrollView style={{ backgroundColor: 'white', marginHorizontal:
20 }} showsVerticalScrollIndicator={false}>
```

However, the implementation of this scroll bar indicator is not directly customizable on cross-platforms in React Native. If you are building an app whose screen design depends on displaying a customized scroll bar indicator, then let's build one in this tutorial. To implement this, we are going to use React Native [Animated](https://reactnative.dev/docs/animated.html) API.

[The source code is available at GitHub.](https://github.com/amandeepmittal/react-native-examples/tree/master/custom-scroll-indicator)

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements in your local dev environment:

- [Node.js](https://nodejs.org/) version >= `12.x.x` installed.
- Have access to one package manager such as npm or yarn or npx.
- Have a basic understanding of Redux store, actions, and reducers.
- [expo-cli](https://github.com/expo/expo-cli) installed, or use npx.

Note: All of the code mentioned in this tutorial works with the React Native CLI project as well.

## Create a new React Native project with expo-cli

To create a new React Native project using `expo-cli`, execute the following command from a terminal window:

```shell
npx expo init custom-scroll-indicator

# navigate into that directory
cd custom-scroll-indicator
```

And that's it. We are not using any third party library but the approach discussed in this post is easily integrated with any other libraries that your React Native app depends on.

Before we move onto the next section, let's start creating a mock screen. Open `App.js` file and add the following code snippet:

```js
import React, { useState, useRef } from 'react';
import { ScrollView, Text, View, Animated } from 'react-native';
import { StatusBar } from 'expo-status-bar';

export default function App() {
  return (
    <>
      <StatusBar style="light" />
      <View style={{ flex: 1, backgroundColor: '#892cdc', paddingTop: 50 }}>
        <View style={{ alignItems: 'center' }}>
          <Text style={{ color: 'white', fontSize: 24, fontWeight: '700' }}>
            Custom Scroll Bar
          </Text>
        </View>
      </View>
    </>
  );
}
```

To see the output of this step, please go back to the terminal window execute one of the following commands depending on the OS (_whether iOS or Android_) of the simulator or the real device the Expo Client app is running:

```shell
# trigger expo development server
yarn start

# for iOS
yarn run ios

# for android
yarn run android
```

When the app is up and running, here is the output you are going to get:

![js1](https://i.imgur.com/PO7yY2C.png)

## Add mock data

Inside the scroll view component, we are going to display some mock data. Let's add it to the React Native project. Create a new directory called `constants/` and inside it a new file called `data.js`.

This file is going to contain an object called `booksData` that has two properties:

- `title` of the book item.
- `description` is the long form of the text where the custom scroll bar is going to be used to scroll the text inside the `ScrollView` component.

Add the following code snippet to this file:

```js
export const booksData = {
  title: 'The Hunger Games',
  description:
    'Winning will make you famous. Losing means certain death.
    The nation of Panem, formed from a post-apocalyptic North
    America, is a country that consists of a wealthy Capitol
    region surrounded by 12 poorer districts. Early in its
    history, a rebellion led by a 13th district against the
    Capitol resulted in its destruction and the creation of an
    annual televised event known as the Hunger Games. In
    punishment, and as a reminder of the power and grace of the
    Capitol, each district must yield one boy and one girl
    between the ages of 12 and 18 through a lottery system to
    participate in the games. The tributes are chosen during the
    annual Reaping and are forced to fight to the death, leaving
    only one survivor to claim victory. When 16-year-old Katniss
    young sister, Prim, is selected as District 12 female
    representative, Katniss volunteers to take her place.'
};
```

Make sure to import object inside the `App.js` file after other import statements.

```js
// ...
import { booksData } from './constants/data';
```

## Display mock data using a ScrollView

The mock data we created in the previous section is going to be displayed inside a `ScrollView` component. The content inside this scroll view is displayed with two `Text` components. One to display the title of the book item and another to display the description.

This `ScrollView` component is not going to take the whole screen to display the content. Thus, the default scroll bar indicator is shown when the description is scrolled. We are going to add an empty `View` after the `ScrollView` component with a value of `flex: 4` such that this empty view takes slightly more than half of the screen.

There is also a `View` component that wraps the `ScrollView`. For now, it adds horizontal padding but later will be crucial to display the custom scroll bar indicator next to the `ScrollView` component. Thus, let's add the `flexDirection: 'row'` property to this wrapper `View` component.

Modify the `App.js` file and add the following JSX:

```js
export default function App() {
  return (
    <>
      <StatusBar style="light" />
      <View style={{ flex: 1, backgroundColor: '#892cdc', paddingTop: 50 }}>
        <View style={{ alignItems: 'center' }}>
          <Text style={{ color: 'white', fontSize: 28, fontWeight: '700' }}>
            Custom Scroll Bar
          </Text>
        </View>
        <View style={{ flex: 3, marginVertical: 20 }}>
          <View
            style={{ flex: 1, flexDirection: 'row', paddingHorizontal: 20 }}
          >
            <ScrollView>
              <Text
                style={{
                  fontSize: 22,
                  color: 'white',
                  fontWeight: '600',
                  marginBottom: 12
                }}
              >
                {booksData.title}
              </Text>
              <Text
                style={{
                  fontSize: 18,
                  color: 'white'
                }}
              >
                {booksData.description}
              </Text>
            </ScrollView>
          </View>
        </View>
        <View style={{ flex: 4 }} />
      </View>
    </>
  );
}
```

Output after this step:

![js2](https://i.imgur.com/5Cckr8y.gif)

Hide the default scroll indicator by adding the `showsVerticalScrollIndicator` prop to the `ScrollView` component. Also, add the `contentContainerStyle` prop with a to apply `paddingRight` to its children (_which are the content being displayed and custom scroll bar we have to create_).

```js
<ScrollView
  contentContainerStyle={{ paddingRight: 14 }}
  showsVerticalScrollIndicator={false}
>
```

![js3](https://i.imgur.com/odQD8D4.png)

## Create the custom scroll bar

Next, to the content displayed, let's add a scroll bar. Add a `View` component whose `height` is set to `100%`. This will display the scroll bar with as much height as the height of its parent container.

```js
<View style={{ flex: 1, flexDirection: 'row', paddingHorizontal: 20 }}>
  {/* ScrollView component here */}
  <View
    style={{
      height: '100%',
      width: 6,
      backgroundColor: '#52057b',
      borderRadius: 8
    }}
  ></View>
</View>
```

The `width` in the above code snippet can be customized with the value you can provide.

The output of this step:

![js4](https://i.imgur.com/8zzq2Jw.png)

## Create the custom scroll bar indicator

To display a custom scroll bar indicator, we need to calculate the size of the scroll bar indicator first. This can be done by comparing the complete height of the scroll bar and the visible height of the scroll bar that is the indicator.

In the `App` component, define two state variables using the `useState` hook and a new variable where we store the size of the bar indicator.

```js
const [completeScrollBarHeight, setCompleteScrollBarHeight] = useState(1);
const [visibleScrollBarHeight, setVisibleScrollBarHeight] = useState(0);

const scrollIndicatorSize =
  completeScrollBarHeight > visibleScrollBarHeight
    ? (visibleScrollBarHeight * visibleScrollBarHeight) /
      completeScrollBarHeight
    : visibleScrollBarHeight;
```

Next, create the scroll bar indicator inside the scroll bar. The indicator is going to have its height equivalent to the `scrollIndicatorSize`.

```js
<View style={{ flex: 1, flexDirection: 'row', paddingHorizontal: 20 }}>
  {/* ScrollView component here */}
  <View
    style={{
      height: '100%',
      width: 6,
      backgroundColor: '#52057b',
      borderRadius: 8
    }}
  >
    <View
      style={{
        width: 6,
        borderRadius: 8,
        backgroundColor: '#bc6ff1',
        height: scrollIndicatorSize
      }}
    />
  </View>
</View>
```

The scroll bar indicator is now displayed:

![js5](https://i.imgur.com/k5ak2Yi.gif)

To change the position of this indicator, we have to animate its value.

## Animate the scroll bar indicator

We are going to animate the position of the scroll bar indicator as the content inside the `ScrollView` is scrolled. To create an animation, `Animated.Value` is required. Define the `scrollIndicator` variable with an `Animated.Value` of `0`.

Add the following code snippet after state variables are declared in `App` component:

```js
const scrollIndicator = useRef(new Animated.Value(0)).current;
```

Then define a variable called `difference` that is used to calculate the height of the scroll bar indicator if it is greater than the size of the scroll indicator. This value is used to calculate the range of interpolation to change the position of the scroll bar indicator to move along the y-axis.

To change the position of the scroll bar indicator, we use the `Animated.multiply` method. This method creates a new Animated value that is composed from two values multiplied together. This new value is what the change in the position of the scroll bar indicator is going to be when the content is scrolled in the `ScrollView`. To change the position, we need to multiply the current value of the `scrollIndicator` and the visible height of the scroll bar indicator divided by the complete height of the scroll bar.

After getting the new Animate value, interpolation is applied. This is done by using the `interpolate()` function on the new Animated value and it allows an input range to map to an output range.

The interpolation must specify an `extrapolate` value. There are three different values for `extrapolate` available, but we are going to use `clamp`. It prevents the output value from exceeding the `outputRange`.

Add the following code snippet in the `App` component:

```js
const difference =
  visibleScrollBarHeight > scrollIndicatorSize
    ? visibleScrollBarHeight - scrollIndicatorSize
    : 1;

const scrollIndicatorPosition = Animated.multiply(
  scrollIndicator,
  visibleScrollBarHeight / completeScrollBarHeight
).interpolate({
  inputRange: [0, difference],
  outputRange: [0, difference],
  extrapolate: 'clamp'
});
```

Then, convert the `View` component that displays the scroll bar indicator into an `Animated.View`. We are going to add a prop called `transform`. It is going to change the position of the scroll bar indicator.

The value of this prop is going to be an array and inside it, a transformation object is defined. This object specifies the property that is transformed, as the key and its value is going to be the `scrollIndicatorPosition`.

```js
<Animated.View
  style={{
    width: 6,
    borderRadius: 8,
    backgroundColor: '#bc6ff1',
    height: scrollIndicatorSize,
    transform: [{ translateY: scrollIndicatorHeight }]
  }}
/>
```

Next, we need to set the height of the scroll bar and scroll bar indicator that is visible when the content inside the `ScrollView` changes. For this, there are two props used in combination:

- `onContentSizeChange` whose value is a handler function with the width and the height of the content. For our demo, we are going to use the height of the content to update the height of the complete scroll bar.
- `onLayout` is used to update the height of the visible scroll bar.

To animate the scroll bar indicator's position when the height of the content changes another prop called `onScroll` is used. It accepts an `Animated.event()` as the value which is used to handle gestures like panning and in our case, scrolling. The frequency of the scrolling event is controlled using a prop called `scrollEventThrottle`. It controls how often the scroll event will be fired while scrolling.

Modify the props of `ScrollView` component as shown below:

```js
<ScrollView
  contentContainerStyle={{ paddingRight: 14 }}
  showsVerticalScrollIndicator={false}
  onContentSizeChange={height => {
    setCompleteScrollBarHeight(height);
  }}
  onLayout={({
    nativeEvent: {
      layout: { height }
    }
  }) => {
    setVisibleScrollBarHeight(height);
  }}
  onScroll={Animated.event(
    [{ nativeEvent: { contentOffset: { y: scrollIndicator } } }],
    { useNativeDriver: false }
  )}
  scrollEventThrottle={16}
>
  {/* Rest remains same */}
</ScrollView>
```

Here is the output after this step on an iOS simulator:

![js6](https://i.imgur.com/06Ozy44.gif)

Here is the output after this step on an Android device:

![js7](https://i.imgur.com/D9LnLRs.gif)

## Conclusion

I hope you had fun reading this tutorial. If you are trying the Animated library from React Native for the first time, wrapping your head around it might take a bit of time and practice and that's part of the process.

**Further Reading on React Native Animated**

- [Learn how to Animate a Header View on Scroll With React Native Animated](https://amanhimself.dev/blog/animate-header-view-on-scroll-with-react-native-animated-api/)

---

## My default apps in 2023
Slug: default-apps-2023

Read about the ongoing [Default Apps](https://defaults.rknight.me/) project first at [Chris Coyier's](https://chriscoyier.net/2023/11/25/default-apps-2023/) blog. Tracing back to where it started seems to be the [Hemispheric Views](https://listen.hemisphericviews.com/097) podcast. During this back and forth of opening links on a Friday night, I got to discover so many new cool personalized blogs through the "Default Apps" list. Decided to jot down my own.

- ðŸ“¨ **Mail Client:** Gmail
- ðŸ“® **Mail Server:** [Google](https://www.google.com/gmail/about/)
- ðŸ“ **Notes:** [Notion](https://notion.so/) professionally, [Obsidian](https://obsidian.md/)
- âœ… **To-Do:** [Obsidian](https://obsidian.md/)
- ðŸ“· **Photo Shooting:** [iPhone 12 mini](https://www.apple.com/by/iphone-12/specs/) Camera app
- ðŸŸ¦ **Photo Management:** [iCloud](https://icloud.com/)
- ðŸ“† **Calendar:** [Apple Calendar](https://apps.apple.com/us/app/calendar/id1108185179) and [Google Calendar](https://calendar.google.com/) (professionally)
- ðŸ“ **Cloud File Storage:** [iCloud](https://icloud.com/) for some applications to sync between both phone and laptop
- ðŸ“– **RSS:** N/A
- ðŸ™ðŸ»â€â™‚ï¸ **Contacts:** [Contacts](https://apps.apple.com/us/app/contacts/id1069512615)
- ðŸŒ **Browser:** [Chrome](https://www.google.com/chrome/) professionally on desktop and iOS, [Brave](https://brave.com/) and [Safari](https://www.apple.com/in/safari/) personal
- ðŸ’¬ **Chat:** [Slack](https://slack.com/), [Telegram](https://web.telegram.org/)
- ðŸ”– **Bookmarks:** [Obsidian](https://obsidian.md/)
- ðŸ“‘ **Read It Later:** [Obsidian](https://obsidian.md/)
- ðŸ“œ **Word Processing:** [Google Docs](https://docs.google.com/) and (rarely) [Pages](https://www.apple.com/pages/)
- ðŸ“ˆ **Spreadsheets:** [Google Sheets](https://sheets.google.com/) and Numbers
- ðŸ“Š **Presentations:** (rarely) [Google Slides](https://slides.google.com)
- ðŸ›’ **Shopping Lists:** [Apple Notes](https://apps.apple.com/us/app/notes/id1110145109)
- ðŸ´ **Meal Planning:** N/A
- ðŸ’° **Budgeting and Personal Finance:** N/A
- ðŸ“° **News:** N/A
- ðŸŽµ **Music:** (used to be) Spotify
- ðŸŽ¤ **Podcasts:** (used to be) Spotify, now [Apple Podcasts](https://www.apple.com/in/apple-podcasts/)
- ðŸ” **Password Management:** [1Password](https://1password.com/)

**Now, there are a few categories I want to add myself:**

- ðŸ§‘â€ðŸ’» **Code Editor:** [VS Code](https://code.visualstudio.com/)
- ðŸ‘¾ **Terminal Emulator:** [iTerm](https://iterm2.com/)
- ðŸŒŒ **(Annotated) Screenshots and quick videos:** [CleanShot X](https://cleanshot.com/)

This covers app the list of apps that I use almost daily either for work or for personal use.

---

## My default apps in 2024
Slug: default-apps-2024

Most apps have stayed the same since my last year's list. The main thing that changed this year for me is to use a proper task manager app instead of storing todos in Obsidian and needing access to it all the time (I don't have Obsidian on my iPhone). I like Obsidian for note taking, storing permanent notes, or creating drafts, but setting reminders, deadlines, or quickly capturing tasks felt overwhelming. To replace this, and after trying three different apps, I returned to an old app I've used: Things 3.

The list below is mostly a revision from [last year](/blog/default-apps-2023/).

- ðŸ“¨Â **Mail Client:**Â Gmail
- ðŸ“®Â **Mail Server:**Â [Google](https://www.google.com/gmail/about/)
- ðŸ“Â **Notes:**Â [Obsidian](https://obsidian.md/)
- âœ…Â **To-Do:**Â [Things 3](https://culturedcode.com/things/) (I keep coming back to it after trying 3 different apps in this calendar year)
- ðŸ“·Â **Photo Shooting:**Â [iPhone 12 mini](https://www.apple.com/by/iphone-12/specs/)Â Camera app
- ðŸŸ¦Â **Photo Management:**Â Locally backing up in external drive on monthly basis
- ðŸ“†Â **Calendar:**Â [Apple Calendar](https://apps.apple.com/us/app/calendar/id1108185179)Â andÂ [Google Calendar](https://calendar.google.com/)Â (professionally)
- ðŸ“Â **Cloud File Storage:**Â [iCloud](https://icloud.com/)Â for some applications to sync between both phone and laptop
- ðŸ“–Â **RSS:**Â N/A
- ðŸ™ðŸ»â€â™‚ï¸Â **Contacts:**Â [Contacts](https://apps.apple.com/us/app/contacts/id1069512615)
- ðŸŒÂ **Browser:**Â [Chrome](https://www.google.com/chrome/)Â professionally on desktop and iOS,Â [Brave](https://brave.com/)Â andÂ [Safari](https://www.apple.com/in/safari/)Â personal
- ðŸ’¬Â **Chat:**Â [Slack](https://slack.com/),Â [Telegram](https://web.telegram.org/)
- ðŸ”–Â **Bookmarks:**Â [Obsidian](https://obsidian.md/)
- ðŸ“‘Â **Read It Later:**Â [Obsidian](https://obsidian.md/)
- ðŸ“œÂ **Word Processing:**Â [Google Docs](https://docs.google.com/)
- ðŸ“ˆÂ **Spreadsheets:**Â [Google Sheets](https://sheets.google.com/)Â and Numbers
- ðŸ“ŠÂ **Presentations:**Â (rarely)Â [Google Slides](https://slides.google.com/)
- ðŸ›’Â **Shopping Lists:**Â [Things 3](https://culturedcode.com/things/)
- ðŸ´Â **Meal Planning:**Â N/A
- ðŸ’°Â **Budgeting and Personal Finance:**Â N/A
- ðŸ“°Â **News:**Â N/A
- ðŸŽµÂ **Music:**Â Spotify
- ðŸŽ¤Â **Podcasts:**Â Spotify
- ðŸ”Â **Password Management:**Â [1Password](https://1password.com/)

**Now, there are a few categories I want to add myself:**

- ðŸ§‘â€ðŸ’»Â **Code Editor:**Â [VS Code](https://code.visualstudio.com/)
- ðŸ‘¾Â **Terminal Emulator:**Â [iTerm](https://iterm2.com/)
- ðŸŒŒÂ **(Annotated) Screenshots and quick videos:**Â [CleanShot X](https://cleanshot.com/)
- ðŸŒ¤ï¸ **Weather:** Weather by Apple on iOS and macOS

This covers app the list of apps that I use almost daily either for work or for personal use.

---

## My default apps in 2025
Slug: default-apps-2025

It's been a year since I last updated my [default apps list](/blog/default-apps-2024/). The main driving force behind the update in 2025 is consistently the same app for multiple use cases and switching to Android from iOS as a primary device and eliminating some apps from my professional and personal workflows.

- ðŸ“¨Â **Mail Client:**Â Gmail
- ðŸ“®Â **Mail Server:**Â [Google](https://www.google.com/gmail/about/)
- ðŸ“Â **Notes:**Â [Obsidian](https://obsidian.md/) + [Notes](https://apps.apple.com/us/app/notes/id1110145109)
- âœ…Â **To-Do:**Â [Notes](https://apps.apple.com/us/app/notes/id1110145109) + Pen and paper + Linear for work
- ðŸ“·Â **Photo Shooting:**Â [Galaxy Z Fold 7](https://www.samsung.com/in/smartphones/galaxy-z-fold7/) Camera app
- ðŸŸ¦Â **Photo Management:**Â Locally backing up in external drive on monthly basis
- ðŸ“†Â **Calendar:**Â [Google Calendar](https://calendar.google.com/)
- ðŸ“Â **Cloud File Storage:**Â [Google Drive](https://drive.google.com/)
- ðŸ“–Â **RSS:**Â [Reader](https://readwise.io/read)
- ðŸ™ðŸ»â€â™‚ï¸Â **Contacts:**Â Contacts app by Samsung
- ðŸŒÂ **Browser:**Â [Chrome](https://www.google.com/chrome/)Â professionally on desktop and Android,Â [Brave](https://brave.com/)Â andÂ [Safari](https://www.apple.com/in/safari/)Â personal
- ðŸ’¬Â **Chat:**Â [Slack](https://slack.com/),Â [Telegram](https://web.telegram.org/)
- ðŸ”–Â **Bookmarks:**Â [Readwise](https://readwise.io/read)
- ðŸ“‘Â **Read It Later:**Â [Readwise](https://readwise.io/read)
- ðŸ“œÂ **Word Processing:**Â [Obsidian](https://obsidian.md/) + [Notion](https://www.notion.so/)
- ðŸ“ˆÂ **Spreadsheets:**Â [Google Sheets](https://sheets.google.com/)
- ðŸ“ŠÂ **Presentations:**Â (rarely)Â [Google Slides](https://slides.google.com/)
- ðŸ›’Â **Shopping Lists:**Â N/A
- ðŸ´Â **Meal Planning:**Â N/A
- ðŸ’°Â **Budgeting and Personal Finance:**Â N/A
- ðŸ“°Â **News:**Â N/A
- ðŸŽµÂ **Music:** YouTube Music
- ðŸŽ¤Â **Podcasts:**Â YouTube Music
- ðŸ”Â **Password Management:**Â [1Password](https://1password.com/)
- ðŸ§‘â€ðŸ’»Â **Code Editor:**Â [Cursor](https://www.cursor.com/) I've found that I used Cursor more than VS Code, both for work and personal projects
- ðŸ‘¾Â **Terminal Emulator:**Â [iTerm](https://iterm2.com/)
- ðŸŒŒÂ **(Annotated) Screenshots and quick videos:**Â [CleanShot X](https://cleanshot.com/)
- ðŸŒ¤ï¸ **Weather:** Weather by Samsung on Android

**Now, there is one category I want to add myself:**

- âœï¸ **Blogging:** Built with [Astro](https://astro.build/) and hosted on [Netlify](https://www.netlify.com/)

This covers app the list of apps that I use almost daily either for work or for personal use.

---

## Deploy a MERN stack app on Heroku
Slug: deploy-a-mern-stack-app-on-heroku

![cover](https://i.imgur.com/IP8rrV2.png)

In this article, I will describe how to take an existing Web Application that is build using MongoDB, ExpressJS, [Node.js](http://crowdbotics.com/build/node-js?utm_source=medium&utm_campaign=nodeh&utm_medium=node&utm_content=mern), and [React](https://www.crowdbotics.com/build/react) (often called as MERN stack) on a deployment service like Heroku. If you have an existing application built using the same tech stack, you can definitely skip the process in which I show you to quickly build a web application and go straight on to the deployment part. For the rest of you, please continue to read.

### MERN Stack

MongoDB, ExpressJS, Node.js, and Reactjs are used together to build web applications. In this, Node.js and Express bind together to serve the backend, MongoDB provides a NoSQL database to store the data and the frontend is built using React that a user interacts with. All four of these technologies are open-source, cross-platform and JavaScript-based. Since they are JavaScript-based, one of the main reasons why they are often used together.

As JavaScript is used throughout to build a Fullstack application, developers do not need to learn and change the context of using different programming languages to build or work on different aspects of a web application.

To continue to follow this tutorial there are requirements that you will need to build the demo application and then deploy it on Heroku.

- Node.js/npm installed
- Heroku account

For MongoDB, we are going to use a cloud-based service like mLab which provides a database as a service. It has a free tier, and having an account there will be time-saving.

## Building a Full-stack app usingÂ MERN

### Building theÂ Backend

I am going to take you through building a web application using MERN Stack. To start, please create an empty directory and type the following commands in the order they are specified.

```shell
# to generate package.json
npm init -y

# install following dependencies
npm install -S express mongoose

npm install -D nodemon
```

Create a `server.js` file inside the root of the directory. This file will server us the backend file for us.

```js
// server.js
const express = require('express');
const app = express();

const PORT = process.env.PORT || 5000;

// configure body parser for AJAX requests
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// routes
app.get('/', (req, res) => {
  res.send('Hello from MERN');
});

// Bootstrap server
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}.`);
});
```

Now, I made following changes in `package.json` for this program to work.

```json
"main": "server.js",
	"scripts": {
    "server": "nodemon server.js",
  }
```

To see if everything is working, run the command `npm start server` that we just defined in `package.json` as a script. If there are no errors, you will get the following result. Visit the following url: `[http://localhost:5000](http://localhost:5000.)`[.](http://localhost:5000.)

<img src='https://cdn-images-1.medium.com/max/800/1*fza80DTPXuhFwJapj2ZIbQ.png' />

Please note that onwards Express version `4.16.0` body parser middleware function is a built-in middleware and there is no need to import it as a separate dependency. Body parser middleware is required to handle incoming AJAX requests that come in the form of JSON payloads or urlencoded payloads.

### Models withÂ Mongoose

When I am not writing JavaScript, I am a bibliophile. Thus, for this demonstration, I am going to build a web application that tends to take care of all the books that I want to read. If you are into books, you can think of it is as your own personal TBR manager.

I will start by creating a database model called `Book` inside the file `models/Books.js`. This will resemble a schema of what to expect from the user when adding information to our application.

```js
// Books.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const bookSchema = new Schema({
  title: {
    type: String,
    required: true
  },
  author: {
    type: String,
    required: true
  }
});

const Book = mongoose.model('Book', bookSchema);

module.exports = Book;
```

I am using `mongoose` to define the schema above. Mongoose is an ODM (Object Document Mapper). It allows you to define objects with a strongly typed schema that is mapped as a MongoDB collection. This schema architecture allows us to provide an organized shape to the document inside the MongoDB collection.

In our `bookSchema` we are defining two fields: a `title` which indicates the title of the book and an `author` representing the name of the author of the book. Both these fields are `string` type.

### Defining Routes

Our application is going to need some routes that will help the client app to communicate with the server application and perform CRUD (Create, Read, Update, Delete) operations. I am defining all the business logic that works behind every route in a different file. Conventionally, named as controllers. Create a new file `controllers/booksController.js`.

```js
// booksControllers.js
const Book = require('../models/Books');

// Defining all methods and business logic for routes

module.exports = {
  findAll: function (req, res) {
    Book.find(req.query)
      .then(books => res.json(books))
      .catch(err => res.status(422).json(err));
  },
  findById: function (req, res) {
    Book.findById(req.params.id)
      .then(book => res.json(book))
      .catch(err => res.status(422).json(err));
  },
  create: function (req, res) {
    Book.create(req.body)
      .then(newBook => res.json(newBook))
      .catch(err => res.status(422).json(err));
  },
  update: function (req, res) {
    Book.findOneAndUpdate({ _id: req.params.id }, req.body)
      .then(book => res.json(book))
      .catch(err => res.status(422).json(err));
  },
  remove: function (req, res) {
    Book.findById({ _id: req.params.id })
      .then(book => book.remove())
      .then(allbooks => res.json(allbooks))
      .catch(err => res.status(422).json(err));
  }
};
```

The business logic or you can say the controller logic behind the application is nothing but the methods that will work on a specific route. There are five functions in total. Each has its own use. I am requiring our Book model, previously created, as it provides functions for us to query CRUD operations to the database. A mongoose query can be executed in two ways, by providing a callback function or by usingÂ `.then()` function which also indicates that mongoose support promises. I am using the promising approach above to avoid the nuisance caused by nested callbacks (and commonly known as _callback hell_).

Next step is to use these methods in our routes inside `routes/` directory. Create a new file called `books.js`.

```js
// books.js

const router = require('express').Router();
const booksController = require('../controllers/booksController');

router.route('/').get(booksController.findAll).post(booksController.create);

router
  .route('/:id')
  .get(booksController.findById)
  .put(booksController.update)
  .delete(booksController.remove);

module.exports = router;
```

I have separated the concerned routes that match a specific URL. For example, routes that are starting withÂ `:id` routing parameter are defined above together in the file. Open `index.js` in the same directory and add the following.

```js
// index.js

const router = require('express').Router();
const bookRoutes = require('./books');

router.use('/api/books', bookRoutes);

module.exports = router;
```

I am adding a prefix `/api/books` before the routes. This way, you can only access them as `http://localhost:5000/api/books`.

For this to work, I am going to import book routes in the `server.js` file after every other middleware defined and before we have bootstrapped the server.

```js
// server.js

const routes = require('./routes');

// after all middleware functions

app.use(routes);
```

Also remove the default route `app.get('/')...` that was previously created. We are soon going to serve the application's front end here on the default route.

### Connecting with Database usingÂ mLab

I am going to use [**mlab**](https://mlab.com) to host the database of our application on the cloud. Once you create an account, your dashboard will look similar to mine. I already have few sandboxes running, so do not mind them.

<img src='https://cdn-images-1.medium.com/max/800/1*gnhdXtIORiT1EsMEv3MSUg.png' />

To create a new one, click on the button `Create New` under MongoDB deployments. After that, you select the plan type Sandbox which provides the free tier up to 500MB.

<img src='https://cdn-images-1.medium.com/max/800/1*LiDzbwLDCpC-e4Igs7qptg.png' />

After the MongoDB deployment is created, a database user is required by the mlab to have you connect to this database. To create one now, visit the â€˜Usersâ€™ tab and click the â€˜Add database userâ€™ button.

<img src='https://cdn-images-1.medium.com/max/800/1*GyHzO_0P76__Y6_UOG1zXA.png' />

Now copy the string provided by mlab such as:

`mongodb://<dbuser>:<dbpassword>@ds125453.mlab.com:25453/mern-example`

and add the `dbuser` and `dbpassword` you just entered to create the new user. I am going to save these credentials as well as the string given by mlab to connect to the database inside a file called `config/index.js`.

```js
// config/index.js
const dbuser = 'xxxxxxxxxx';
const dbpassword = 'xxxxxxxxx';

const MONGODB_URI = `mongodb://${dbuser}:${dbpassword}
@ds125453.mlab.com:25453/mern-example`;

module.exports = MONGODB_URI;
```

You can replace the `x`'s for `dbuser` and `dbpassword`. Now to define the connection with mlab string we are again going to use mongoose. Create a new file inside `models/index.js`.

```js
// models/index.js

const mongoose = require('mongoose');
const URI = require('../config/index');

mongoose.connect(process.env.MONGODB_URI || URI);

// When successfully connected
mongoose.connection.on('connected', () => {
  console.log('Established Mongoose Default Connection');
});

// When connection throws an error
mongoose.connection.on('error', err => {
  console.log('Mongoose Default Connection Error : ' + err);
});
```

We are importing the same database URI string that we just exported in `config`. I am going to require this file inside our `server.js` before any middleware is defined.

```js
// server.js
const express = require('express');
const app = express();

const routes = require('./routes');

const PORT = process.env.PORT || 5000;

// require db connection
require('./models');

// configure body parser for AJAX requests
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.use(routes);

// Bootstrap server
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}.`);
});
```

Now run the server again and if you get the following message, that means your database is gracefully connected to the web server.

<img src='https://cdn-images-1.medium.com/max/800/1*560qCrzs2900Z2zqwUK2oA.png' />

### Building the FrontEnd withÂ React

To build the user interface of our application, I am going to `create-react-app`. Run the following command to generate a react application inside a directory called `client`.

```shell
create-react-app client/
```

Once the scaffolding process is complete, run `npm run start` after traversing inside the client directory from your terminal, and see if everything works or not. If you get a screen like below that means everything is top-notch.

Install two dependencies from `npm` that we need to in order for the client to work.

```shell
yarn add axios react-router-dom@4.1.2
```

You are going to need **axios** to make AJAX requests to the server. `react-router-dom` is for switching between navigation routes.

I am not going to walk you through every component and reusable component I have built in this application. I am only going to take you through what needs to be done connect the React app to Node.js server, the build process and then deploying it.

The main frontend file, `App.js` looks like this:

```js
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Books from './pages/Books';
import Detail from './pages/Detail';
import NoMatch from './pages/NoMatch';
import Nav from './components/Nav';

const App = () => (
  <Router>
    <div>
      <Nav />
      <Switch>
        <Route exact path="/" component={Books} />
        <Route exact path="/books" component={Books} />
        <Route exact path="/books/:id" component={Detail} />
        <Route component={NoMatch} />
      </Switch>
    </div>
  </Router>
);

export default App;
```

Next, I have created an `API.js` inside the `utils` directory which we handle all the requests and fetching data, in simple terms AJAX requests between our client and the server.

```js
import axios from 'axios';

export default {
  // Gets all books
  getBooks: function () {
    return axios.get('/api/books');
  },
  // Gets the book with the given id
  getBook: function (id) {
    return axios.get('/api/books/' + id);
  },
  // Deletes the book with the given id
  deleteBook: function (id) {
    return axios.delete('/api/books/' + id);
  },
  // Saves a book to the database
  saveBook: function (bookData) {
    return axios.post('/api/books', bookData);
  }
};
```

We also have `pages` and a separate `components` directory. The `pages` contain those files that are going to display the content when we add a book and its author in our list using a form to submit the data to the backend. The form itself uses different reusable components which are built separately. The sole purpose of doing this is to follow best practices that are convenient to understand the source code and a common practice in the React community.

There are two pages `Books` and `Details`. Let us go through them.

```js
// Books.js

import React, { Component } from 'react';
import DeleteBtn from '../../components/DeleteBtn';
import Jumbotron from '../../components/Jumbotron';
import API from '../../utils/API';
import { Link } from 'react-router-dom';
import { Col, Row, Container } from '../../components/Grid';
import { List, ListItem } from '../../components/List';
import { Input, FormBtn } from '../../components/Form';

class Books extends Component {
  state = {
    books: [],
    title: '',
    author: ''
  };

  componentDidMount() {
    this.loadBooks();
  }

  loadBooks = () => {
    API.getBooks()
      .then(res => this.setState({ books: res.data, title: '', author: '' }))
      .catch(err => console.log(err));
  };

  deleteBook = id => {
    API.deleteBook(id)
      .then(res => this.loadBooks())
      .catch(err => console.log(err));
  };

  handleInputChange = event => {
    const { name, value } = event.target;
    this.setState({
      [name]: value
    });
  };

  handleFormSubmit = event => {
    event.preventDefault();
    if (this.state.title && this.state.author) {
      API.saveBook({
        title: this.state.title,
        author: this.state.author
      })
        .then(res => this.loadBooks())
        .catch(err => console.log(err));
    }
  };

  render() {
    return (
      <Container fluid>
        <Row>
          <Col size="md-6">
            <Jumbotron>
              <h1>What Books Should I Read?</h1>
            </Jumbotron>
            <form>
              <Input
                value={this.state.title}
                onChange={this.handleInputChange}
                name="title"
                placeholder="Title (required)"
              />
              <Input
                value={this.state.author}
                onChange={this.handleInputChange}
                name="author"
                placeholder="Author (required)"
              />

              <FormBtn
                disabled={!(this.state.author && this.state.title)}
                onClick={this.handleFormSubmit}
              >
                Submit Book
              </FormBtn>
            </form>
          </Col>
          <Col size="md-6 sm-12">
            <Jumbotron>
              <h1>Books On My List</h1>
            </Jumbotron>
            {this.state.books.length ? (
              <List>
                {this.state.books.map(book => (
                  <ListItem key={book._id}>
                    <Link to={'/books/' + book._id}>
                      <strong>
                        {book.title} by {book.author}
                      </strong>
                    </Link>
                    <DeleteBtn onClick={() => this.deleteBook(book._id)} />
                  </ListItem>
                ))}
              </List>
            ) : (
              <h3>No Results to Display</h3>
            )}
          </Col>
        </Row>
      </Container>
    );
  }
}

export default Books;
```

We are defining a local state to manage data and pass it on to the API from the component. Methods like `loadBooks` are making AJAX requests through the API calls we defined inside `utils/API.js`. Next is the details page.

```js
// Details.js
import React, { Component } from 'react';
import { Link } from 'react-router-dom';
import { Col, Row, Container } from '../../components/Grid';
import Jumbotron from '../../components/Jumbotron';
import API from '../../utils/API';

class Detail extends Component {
  state = {
    book: {}
  };

  componentDidMount() {
    API.getBook(this.props.match.params.id)
      .then(res => this.setState({ book: res.data }))
      .catch(err => console.log(err));
  }

  render() {
    return (
      <Container fluid>
        <Row>
          <Col size="md-12">
            <Jumbotron>
              <h1>
                {this.state.book.title} by {this.state.book.author}
              </h1>
            </Jumbotron>
          </Col>
        </Row>

        <Row>
          <Col size="md-2">
            <Link to="/">â† Back to Authors</Link>
          </Col>
        </Row>
      </Container>
    );
  }
}

export default Detail;
```

It shows the books I have added in my list. To use it, first we are going to connect it with Node.js.

### Connecting React andÂ Node

There are two build steps we have to undergo through in making a connection between our client side and server side. First, open the `package.json` file inside the `client` directory and enter a proxy value that points to the same URL on which server is serving the API.

```js
"proxy": "http://localhost:5000"
```

Next step is to run the command `yarn build` inside the client directory such that it builds up the project. If you haven't run this command before in this project, you will notice a new directory suddenly appears.

<img src='https://cdn-images-1.medium.com/max/800/1*K5i8irozZCKYpIodE6hgng.png' />

We also need to make two changes to our backend, to serve this `build` directory. The reason we are doing this is to deploy our full stack application later on Heroku as one. Of course, you can two deployment servers where one is serving the REST API such as our backend and the other serves the client end, the build folder we just created.

Open `routes/index.js` and add the following line.

```js
// routes/index.js
const router = require('express').Router();
const bookRoutes = require('./books');
const path = require('path');

// API routes
router.use('/api/books', bookRoutes);

// If no API routes are hit, send the React app
router.use(function (req, res) {
  res.sendFile(path.join(__dirname, '../client/build/index.html'));
});

module.exports = router;
```

Next, open the `server.js` to in which we add another line using Express built-in middleware that serves static assets.

```js
// server.js
const express = require('express');
const app = express();

const routes = require('./routes');

const PORT = process.env.PORT || 5000;

// require db connection
require('./models');

// configure body parser for AJAX requests
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// ADD THIS LINE
app.use(express.static('client/build'));

app.use(routes);

// Bootstrap server
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}.`);
});
```

Now you can open your terminal and run the following command.

```shell
npm run start
```

This will trigger our server at url `http://localhost:5000`. Visit it using a browser and see your MERN stack app in action like below. For brevity, I haven't much styled but go ahead and showcase your CSS skills.

<img src='https://cdn-images-1.medium.com/max/800/1*V3ZbTRYfdUc2jnEWHsPEdQ.png' />

To verify that the data from our application is being added to the database, go to your mlab MongoDB deployment. You will notice a collection appearing with the name of `books`. Open it and you can see the data you have just submitted through the form. Here is how mine looks like.

<img src='https://cdn-images-1.medium.com/max/800/1*mNSQyfBe_qzh_IyUZdaT_w.png' />

I already have two records.

<img src='https://cdn-images-1.medium.com/max/800/1*dfYnIQotE5nFr3UhkDIb9g.png' />

<img src='https://cdn-images-1.medium.com/max/800/1*mauB7W6yd80fS5gmWHomPA.png' />

Since everything is running locally without any problem, we can move to the next part.

### Deploying onÂ Heroku

This is our final topic in this tutorial. Now, all you need is to have a free Heroku account and [_Heroku toolbelt_](https://devcenter.heroku.com/articles/heroku-cli) to run the whole deployment process from your terminal.

> _The Heroku Command Line Interface (CLI) makes it easy to create and manage your Heroku apps directly from the terminal. Itâ€™s an essential part of using Heroku. ~_ [_Official Documentation_](https://devcenter.heroku.com/articles/heroku-cli)

To download the Heroku CLI interface visit [this link](https://devcenter.heroku.com/articles/heroku-cli). Depending on your operating system, you can download the packager. You can also choose a simpler method that is to install the cli interface using npm.

`npm install -g heroku`

After you go through the download and installation process, you can verify that everything has installed correctly.

```shell
heroku --version
# Output
heroku/7.16.0 darwin-x64 node-v8.12.0
```

Modify `package.json` by adding the following script.

```json

"scripts": {
		"start": "node server.js",
		[...]
	}
```

Login to your Heroku account with credentials by running command `heroku login` like below.

<img src='https://cdn-images-1.medium.com/max/800/1*Tfgopqciv5qCw_YzDXOM6A.png' />

Next, create a `Procfile` in the root folder with following value.

```shell
web: npm run start
```

Once you are logged in traverse to the project directory of your MERN stack application. Run the following command to create a Heroku instance of your app. Make sure you are in the main directory and not in the client folder.

Before we go on to prepare our project for Heroku, I am going to use `git` to push our current project. This is the most common and safe way to use it with Heroku cli interface. Run the following commands in the order described.

```shell
# initialize our project as git repository
git init

# prepare the stage
git add .

# Commit all changes to git
git commit -m "commit all changes"
```

Then run:

```shell
heroku create
```

When this command runs successfully, it gives you an app id like this. Remember this app id as we are going to use it set our existing mlab MongoDB URI.

<img src='https://cdn-images-1.medium.com/max/800/1*75t_1Se-SNCHrQ67CIKwmQ.png' />

Next step is to connect the existing mlab deployment from our Heroku app.

```shell
heroku config:set MONGODB_URI=mongodb://
user:password@ds125453.mlab.com:25453/mern-example -a
damp-dusk-80048
```

You can also use the free tier of mlab provided by Heroku using the following command in case you havenâ€™t deployed your database previously. This command must only be run in case you are not already using mlab for your Mongodb deployment.

```shell
heroku addons:create mongolab
```

You can verify that the configuration value has been set by running:

```shell
heroku config:get MONGODB_URI --app damp-dusk-80048

# Output

mongodb://user:password@ds125453.mlab.com:25453/mern-example
```

Note that `user` and `password` in above commands are your mlab credentials that have been discussed on how to set up them in previous sections of this article. Next step is to push the whole app to Heroku.

```shell
# Push to heroku

git push heroku master
```

This points to Heroku remote instead of `origin`. This above command sends the source code to Heroku and from then Heroku reads `package.json` only to install `dependencies`. That is the reason we defined `start` script rather using the than `server` one because Heroku or a deployment server has no use of development environment dependencies such as `nodemon`.

Finishing the building of your project may look similar to mine.

<img src='https://cdn-images-1.medium.com/max/800/1*jsmi-MziaelOUtB_2Mbn4Q.png' />

You can then visit the URL given by Heroku like below. Do notice the already existing data that we deployed using local server in the previous section.

<img src='https://cdn-images-1.medium.com/max/800/1*PQTWi9hFs29cI2B2IsRRDw.png' />

### Conclusion

There are many deployment techniques that you can try on Heroku. The technique described in this article is just one of them. I hope you have this article has helped you out.

[Originally published at Crowdbotics](https://medium.com/crowdbotics/deploy-a-mern-stack-app-on-heroku-b0c255744a70)

---

## Docs without please
Slug: docs-without-please

Technical documentation serves one purpose: to help readers accomplish tasks efficiently. Politeness markers such as "thank you" or "please", don't serve this purpose. While politeness matters in conversation to an extent, in documentation, it can create weaker critical instructions.

Documentation isn't a conversation. It's a tool to inform your readers about any actionable steps they need to take to be successful in their own endeavors. When you write, "Please update the CLI version", you're trying to inform your readers about the action they need to take. However, adding "please" doesn't make the instruction more valid or actionable.

In some cases, words like "please" can add extra ambiguity. A reader may wonder one of the following when reading a sentence that contains this marker:

- Is this step truly required?
- Or is this a polite suggestion?
- Are documentation authors being ironic or sarcastic?

The last point isn't just theoretical. See ["Can I have a cup of tea please?" Politeness markers in the Spoken BNC2014](https://www.degruyter.com/document/doi/10.1515/pr-2022-0010/html?lang=en), which demonstrates how frequently the word "please" is used insincerely or counterproductively.

I am also not a fan of using "please" or placeholder words like "please note" in instructions for the sole reason that an instruction is meant to inform the reader about the next actionable step they need to take.

For example, consider this sentence: _Please ensure you have Node.js installed on your computer._ Now, the purpose of this sentence is to inform the reader that they need to install or have installed Node.js on their system to run the program and follow the instructions from the rest of the guide. Now, this is not something you can just ask the reader. This is a requirement to follow the instructions from the rest of the guide to be successful. Instead, this sentence can be written as: _Install Node.js on your computer_, or just: _Install Node.js_, which is concise enough to tell the reader what they need to do on their end.

Good and strong technical documentation uses direct, active statements that inform readers what they need to do. These conversation artifacts make their way into docs through habit rather than purpose.

---

## How to change light and dark Shiki themes when using Astro
Slug: dual-shiki-themes-with-astro

[Shiki](https://shiki.style/) is Astro's built-in syntax highlighter. While it requires [minimum configuration](/blog/new-blog-theme-and-colors/) to set up, its real power shines when you configure dual themes to match your site's light and dark themes. It also bundles a ton of [modern themes](https://shiki.style/themes) that can be used by defining the theme's name in the configuration.

## Understanding the configuration

The key to implementing dual themes lies in two files:

- Astro configuration file (`astro.config.ts`)
- Base styles file (`src/styles/base.css`)

Let's take a look at the changes needed in each file.

### Updating Astro configuration

Inside your `astro.config.ts`, modify the Shiki configuration to support both light and dark themes. Start by changing the `theme` to `themes` object for dual theme support in `shikiConfig` and add those theme names.

```ts
export default defineConfig({
  // ...
  shikiConfig: {
    themes: {
      light: 'rose-pine-dawn',
      dark: 'rose-pine-moon'
    }
  }
});
```

This replaces the single theme approach (which earlier was set to: `theme: 'rose-pine-moon'`).

### Styling Shiki for dark mode

You need to add appropriate CSS to handle the theme switching. By default, Shiki uses the [`.shiki` class](https://shiki.style/guide/dual-themes#class-based-dark-mode) to add theme styles based on the class name. Astro provides a `.astro-code` class to add styles for dark themes.

Add the following styles in your `src/styles/base.css`:

```css
@layer base {
  :root,
  html[data-theme='dark'] pre:has(code),
  html[data-theme='dark'] pre:has(code) span {
    color: var(--shiki-dark) !important;
    background-color: var(--shiki-dark-bg) !important;
    font-style: var(--shiki-dark-font-style) !important;
    font-weight: var(--shiki-dark-font-weight) !important;
    text-decoration: var(--shiki-dark-text-decoration) !important;
  }
  /* ... */
}
```

Now, when the theme changes, these CSS variables will update automatically and appropriately for the dark theme.

## Wrapping up

With these changes, your code blocks will automatically adapt to the theme defined in your Shiki configuration.

---

## Exploring React Native: Fetching Data with Tanstack Query
Slug: fetching-data-with-tanstack-query-in-react-native

Tanstack Query (also known as React Query) is a powerful library to fetch data and manage state in React applications. It leverages the hook oriented architecture, which goes well with modern React apps. It also offers automatic data caching, managing errors internally for easier API interactions.

While building the home screen of the manga tracker app, a playground project, I decided to use this library to fetch the data from the AniList API. I am using Expo Router to handle navigation and create my React Native and Expo app.

## Installation and configuration

Inside your React Native project, install `@tanstack/react-query` library by running the following command:

```shell
bun add @tanstack/react-query
```

Now, inside the root layout file (`app/_layout.tsx`), you need to initialize `QueryClientProvider` with default option of `QueryClient`:

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Stack } from 'expo-router';

const queryClient = new QueryClient();

export default function RootLayout() {
  return (
    <QueryClientProvider client={queryClient}>
      <Stack>
        <Stack.Screen
          name="index"
          options={{
            headerTitle: 'Manga'
          }}
        />
      </Stack>
    </QueryClientProvider>
  );
}
```

The `QueryClient` is like a manager for all the data fetching operations in your app. It maintains the cache of query results, handles background refetching, and manages loading and error states.

The `QueryClientProvider` is a Context provider that makes the `QueryClient` available to all the child components in the component tree. By placing this provider at the root level of your app, you can ensure consistent data fetching behavior.

## Creating a custom hook to fetch basic data

Inside `hooks` directory, create two new files: `fetch.ts` and `index.ts`. The `fetch.ts` file will contain all the functions to fetch data from the AniList API. The `index.ts` file will contain the custom hooks.

Inside `hooks/fetch.ts`, create `fetchTrendingManga` function which will fetch the trending manga data. AniList API offer different endpoints to get list of manga which are ordered by their category (such as popularity, rating, and so on).

```ts
import { AnilistResponse } from '@/types';

export async function fetchTrendingManga() {
  const query = `
    query {
      Page(page: 1, perPage: 40) {
        media(type: MANGA, sort: TRENDING_DESC) {
          id
          title {
            romaji
            english
          }
        }
      }
    }
  `;

  const response = await fetchFromAnilist<AnilistResponse>(query);
  return response.data.Page.media;
}

export async function fetchFromAnilist<T>(
  query: string,
  variables?: Record<string, any>
): Promise<T> {
  const response = await fetch('https://graphql.anilist.co', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json'
    },
    body: JSON.stringify({
      query,
      variables
    })
  });

  if (!response.ok) {
    throw new Error(`API request failed with status ${response.status}.`);
  }

  return (await response.json()) as T;
}
```

Inside `hooks/index.ts`, create `useTrendingManga` function which will fetch the trending manga data. This function uses `useQuery` hook from `@tanstack/react-query` library to fetch the data. It returns an object with status of the query, (which includes loading, error, and success), the data fetched from the API, and iother functions to refetch the data.

```ts
import { useQuery, UseQueryResult } from '@tanstack/react-query';

import { Manga } from '@/types';
import { fetchTrendingManga } from './fetch';

export function useTrendingManga(): UseQueryResult<Manga[], Error> {
  return useQuery({
    queryKey: ['trendingManga'],
    queryFn: fetchTrendingManga
  });
}
```

The `useQuery` hook in the above example also handles caching when the key `trendingManga` is passed, after fetching the data. The `trendingManga` key is the unique identifier for the cache. When `useQuery` is called again (let's assume you refetch the data on the home screen) with the same key (`trendingManga`), Tanstack Query will return the cached data instead of performing a new fetch.

## Display a list of data

In home screen component (`app/index.tsx`), let's implement a way to display the manga data. This component fetches trending manga using the custom `useTrendingManga` hook and renders them in a scrollable list using `FlatList`. While the data is being fetched, a loading indicator is displayed, and if there's an error, an error message is shown on the screen.

```tsx
import { FlatList, StyleSheet, Text, View } from 'react-native';

// A custom loading indicator component
import Indicator from '@/components/Indicator';
import { useTrendingManga } from '@/hooks';

export default function HomeScreen() {
  const { data, isLoading, isError } = useTrendingManga();

  if (isLoading) {
    return <Indicator isLoading={isLoading} />;
  }

  if (isError) {
    return <Indicator isError={isError} />;
  }

  return (
    <View style={[styles.container]}>
      <FlatList
        data={data}
        renderItem={({ item }) => (
          <View style={styles.mangaItem}>
            <Text style={styles.mangaTitle}>{item.title.romaji}</Text>
          </View>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  errorText: {
    color: 'red',
    fontSize: 16
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    paddingHorizontal: 12
  },
  mangaItem: {
    padding: 12
  },
  mangaTitle: {
    fontSize: 16
  }
});
```

After running `npx expo start`, I get the list of mangas displayed on the home screen:

<img src="/images/react-native/manga-list-01.png" width="320" />

## Fetching data for a single item

To fetch data for a single item, you can use `useQuery` hook with the `queryKey` and `queryFn` parameters. The `queryKey` is the unique identifier for the cache, and the `queryFn` is the function that will fetch the data.

First, you need to create a function to fetch the data for a single item. Let's create `fetchMangaById` function in `hooks/fetch.ts` file.

```ts
export async function fetchMangaById(id: string) {
  const query = `
    query {
      Media(id: ${id}) {
        id
        title {
          romaji
          english
        }
        description
      }
    }
  `;

  const response = await fetchFromAnilist<AnilistResponse>(query);
  return response.data.Media;
}
```

Then, in `hooks/index.ts` file, create `useMangaById` function which fetches the manga data for a single item.

```ts
export function useMangaById(id: string): UseQueryResult<Manga, Error> {
  return useQuery({
    queryKey: ['manga', id],
    queryFn: () => fetchMangaById(id)
  });
}
```

## Adding a detail screen

In Expo Router, you can create a detail screen using dynamic routes. Add a new file `app/manga/[id].tsx` and implement the detail screen component.

```tsx
import { useLocalSearchParams } from 'expo-router';
import { ScrollView, StyleSheet, Text, View } from 'react-native';

// A custom loading indicator component
import Indicator from '@/components/Indicator';
import { useMangaById } from '@/hooks';

export default function MangaDetailsScreen() {
  const { id } = useLocalSearchParams();
  const { data, isLoading, error } = useMangaById(id as string);

  if (isLoading) {
    return <Indicator isLoading />;
  }

  if (error || !data) {
    return <Indicator isError />;
  }

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.screenTitle}>
        {data.title.english || data.title.romaji}
      </Text>
      {data.description && (
        <View style={styles.descriptionContainer}>
          <Text style={styles.descriptionTitle}>Description</Text>
          <Text style={styles.description}>{data.description}</Text>
        </View>
      )}
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5'
  },
  screenTitle: {
    fontSize: 32,
    fontWeight: 'bold',
    marginTop: 16,
    marginHorizontal: 12,
    marginBottom: 8
  },
  descriptionContainer: {
    marginBottom: 16,
    padding: 12
  },
  descriptionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#333'
  },
  description: {
    fontSize: 16,
    color: '#666',
    lineHeight: 24
  }
});
```

## Update root layout to include the detail screen

In `app/_layout.tsx` file, add the detail screen to the stack navigator.

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Stack } from 'expo-router';

const queryClient = new QueryClient();

export default function RootLayout() {
  return (
    <QueryClientProvider client={queryClient}>
      <Stack>
        <Stack.Screen
          name="index"
          options={{
            headerTitle: 'Manga'
          }}
        />
        <Stack.Screen
          name="[id]"
          options={{
            headerTitle: 'Manga Details'
          }}
        />
      </Stack>
    </QueryClientProvider>
  );
}
```

## Using Link component to navigate to the detail screen

In the home screen component (`app/index.tsx`), import `Link` component from `expo-router` and wrap the `Pressable` component with it.

```tsx
import { FlatList, Pressable, StyleSheet, Text, View } from 'react-native';

import Indicator from '@/components/Indicator';
import { useTrendingManga } from '@/hooks';
import Ionicons from '@expo/vector-icons/Ionicons';
import { Link } from 'expo-router';

export default function HomeScreen() {
  const { data, isLoading, isError } = useTrendingManga();

  if (isLoading) {
    return <Indicator isLoading={isLoading} />;
  }

  if (isError) {
    return <Indicator isError={isError} />;
  }

  return (
    <View style={[styles.container]}>
      <FlatList
        data={data}
        renderItem={({ item }) => (
          <Link href={`/${item.id}`} asChild>
            <Pressable style={styles.mangaItem}>
              <Text style={styles.mangaTitle}>{item.title.romaji}</Text>
              <Ionicons name="chevron-forward" size={16} color="#ccc" />
            </Pressable>
          </Link>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  errorText: {
    color: 'red',
    fontSize: 16
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    paddingHorizontal: 12
  },
  mangaItem: {
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  mangaTitle: {
    fontSize: 16
  }
});
```

After running `npx expo start`, I get the list of mangas displayed on the home screen and then I can navigate to the detail screen by tapping on an item.

<img src="/images/react-native/manga-list-02.gif" width="320" />

## Wrapping up

I just wanted to document the simple approach of fetching data with ease using TanStack Query (React Query) and going through its basic concepts. Hopefully, this has been helpful to you as well.

---

## How To Integrate Firebase Authentication With an Expo App
Slug: firebase-authentication-with-expo

> Originally Published at [Jscrambler.com](https://jscrambler.com/blog/how-to-integrate-firebase-authentication-with-an-expo-app/).

[Firebase](https://console.firebase.google.com/) is a Backend as a Service (BaaS) that provides a variety of services for web and mobile app development. Most of the mobile apps built using React Native and Expo require knowing the identity of a user. This allows an app to securely save user data in the cloud and provide more personalized functionalities.

Firebase has an Authentication service that integrates well in a React Native and Expo app. It has a ready-to-use SDK and supports many authentication providers such as email/password, phone numbers, and federated providers (Google, Facebook, Twitter, and so on).

In this tutorial, let's take a look at how as a mobile developer building applications using Expo SDK, you can integrate and use Firebase Authentication. You are going to:

- create some sample screens to display forms (login, sign-up);
- create a home screen that only a logged-in user can access;
- create different navigators using the [react-navigation](https://reactnavigation.org/) library;
- create an auth flow by conditionally rendering between these navigators when a user is logged in or not;
- and integrate Firebase Auth with the email/password method.

[The source code for this tutorial is available on GitHub](https://github.com/amandeepmittal/react-native-examples/tree/master/expo-firebase-auth-example).

## Prerequisites

To follow this tutorial, please make sure you have the following tools and utilities installed on your local development environment and have access to the services mentioned below:

- [Nodejs](https://nodejs.org/en/) (>= 12.x.x) with a package manager installed such as npm or yarn
- [expo-cli](https://docs.expo.io/workflow/expo-cli/) (>= 4.x.x)
- Firebase account (a free â€œSparkâ€ plan is enough).

## Creating a React Native app with expo-cli

The initial step is to either create a new React Native project using expo-cli by following the steps mentioned below or, if you know the lexicons of creating projects with Expo, integrate [Firebase JS SDK](https://github.com/firebase/firebase-js-sdk).

Yes, this guide is using Firebase JS SDK and [Expo managed workflow](https://docs.expo.io/introduction/managed-vs-bare/#managed-workflow).

Open your favorite terminal window, and execute the following command (where `firebase-auth` is an example name of the project directory)

```shell
expo init firebase-auth

# navigate inside the directory

cd firebase-auth
```

Then, install the following libraries:

```shell
npm install @react-navigation/native @react-navigation/stack

# OR is using yarn

yarn add @react-navigation/native @react-navigation/stack

# after the above dependencies install successfully

expo install firebase dotenv expo-constants react-native-gesture-handler react-native-reanimated react-native-screens react-native-safe-area-context @react-native-community/masked-view
```

**Side-note:** This example guide is using React Navigation library version 5. Make sure to check out the [official documentation](https://reactnavigation.org/docs/getting-started/), as some of the installation instructions might have changed since the writing of this tutorial.

## Create a Firebase Project

To get started, youâ€™re going to need a Firebase app. Once youâ€™ve created a new account with Firebase and logged in, create a new project by clicking on the **Add Project** button.

![ss2](https://i.imgur.com/QRL6R6K.png)

Next, add the name of the new Firebase project and then click **Continue**.

![ss3](https://i.imgur.com/679tjgf.png)

You can disable Google Analytics as it won't be used in this example. Then click **Create Project**

![ss4](https://i.imgur.com/PQZ6MYx.png)

Expo Managed workflow apps can run inside a client app Expo Go (in development mode). The Expo Go app currently supports Firebase JS SDK and not the react-native-firebase library. More information in [official Expo documentation](https://docs.expo.io/guides/using-firebase/).

On the Dashboard screen, in the left side menu, click the settings icon, and then go to the _Project Settings_ page and then look for the section _General > Your apps_. If it's a new project, there won't be any apps.

![ss5](https://i.imgur.com/s5o5gsj.png)

Click the Web button. It will prompt you to enter the details of your app. Enter the appâ€™s nickname, and then click the _Register app_ button.

![ss6](https://i.imgur.com/PRJmfvH.png)

Then, Firebase will provide configuration objects with API keys and other keys that are required to use different Firebase services.

![ss7](https://i.imgur.com/ZY40Mh4.png)

These API keys can be included in your React Native app as they are not used to access Firebase servicesâ€™ backend resources. [That can only be done by Firebase security rules](https://firebase.google.com/docs/projects/api-keys).

This does not mean that you should expose these keys to a version control host such as GitHub. We will learn how to set up environment variables in an Expo app in the next section.

Let's enable the email/password sign-in method. From the left side menu, go to the _Authentication_ page. If you are using this service for the first time in your Firebase project, click the _Get Started_ button.

Then, in the _Sign-in method_ tab, click the status of _Email/Password_, enable it, and then click _Save_.

![ss8](https://i.imgur.com/SQlngt6.png)

## Using Environment Variables

To add environment variables to an Expo app, the initial step is to install the [dotenv](https://github.com/motdotla/dotenv#config) package (which should be already installed if you have been following along).

Create a `.env` file at the root of your project and add the following:

```shell
API_KEY=XXXX
AUTH_DOMAIN=XXXX
PROJECT_ID=XXXX
STORAGE_BUCKET=XXXX
MESSAGING_SENDER_ID=XXXX
APP_ID=XXXX
```

Replace all `X's` in the above file with actual values for each key you get from the `firebaseConfig` object.

Next, rename the `app.json` file to `app.config.js` at the root of your project. Add the import statement to use the `dotenv` configuration. Since it's a JSON file, you will have to export all Expo configuration variables and also add an `extra` object that contains Firebase configuration keys. Here is how the file should look like after this step:

```js
import 'dotenv/config';

export default {
  expo: {
    name: 'expo-firebase-auth-example',
    slug: 'expo-firebase-auth-example',
    version: '1.0.0',
    orientation: 'portrait',
    icon: './assets/icon.png',
    splash: {
      image: './assets/splash.png',
      resizeMode: 'contain',
      backgroundColor: '#ffffff'
    },
    updates: {
      fallbackToCacheTimeout: 0
    },
    assetBundlePatterns: ['**/*'],
    ios: {
      supportsTablet: true
    },
    android: {
      adaptiveIcon: {
        foregroundImage: './assets/adaptive-icon.png',
        backgroundColor: '#FFFFFF'
      }
    },
    web: {
      favicon: './assets/favicon.png'
    },
    extra: {
      apiKey: process.env.API_KEY,
      authDomain: process.env.AUTH_DOMAIN,
      projectId: process.env.PROJECT_ID,
      storageBucket: process.env.STORAGE_BUCKET,
      messagingSenderId: process.env.MESSAGING_SENDER_ID,
      appId: process.env.APP_ID
    }
  }
};
```

Now, all the keys inside the `extra` object are readable app-wide using `expo-constants`. This package allows reading values from `app.json` &mdash; or in this case, the `app.config.js` file.

Open the Expo-generated project in your code editor, create a new directory in the root called `config/` and add a file called `firebase.js`. Edit the file as shown below:

```js
import firebase from 'firebase/app';
import 'firebase/auth';
import Constants from 'expo-constants';

// Initialize Firebase
const firebaseConfig = {
  apiKey: Constants.manifest.extra.apiKey,
  authDomain: Constants.manifest.extra.authDomain,
  projectId: Constants.manifest.extra.projectId,
  storageBucket: Constants.manifest.extra.storageBucket,
  messagingSenderId: Constants.manifest.extra.messagingSenderId,
  appId: Constants.manifest.extra.appId
};

let Firebase;

if (firebase.apps.length === 0) {
  Firebase = firebase.initializeApp(firebaseConfig);
}

export default Firebase;
```

## Creating reusable components

The example app we are building in this tutorial will require some reusable components. These are visual components that can be used on different screens. Instead of writing them from scratch on every screen inside the app, let's create them once and re-use them whenever required.

Create a new directory called `components/` and the following files:

- Button.js: contains a configurable `<Pressable/>` component;
- IconButton.js: contains an icon button composed of a `<Pressable/>` component and the `@expo/vector-icons` library;
- ErrorMessage.js: a text component that is used to display an error message when authenticating a user;
- InputField.js: contains a configurable `<TextInput />` component.

Add the following code snippet to the `Button.js` file:

```js
// components/Button.js
import React from 'react';
import { StyleSheet, Pressable, Text } from 'react-native';

const Button = ({
  title,
  backgroundColor = '#000',
  titleColor = '#fff',
  titleSize = 14,
  onPress,
  width = '100%',
  containerStyle
}) => {
  return (
    <Pressable
      onPress={onPress}
      style={args => {
        if (args.pressed) {
          return [
            styles.base,
            {
              opacity: 0.5,
              backgroundColor,
              width
            },
            containerStyle
          ];
        }

        return [
          styles.base,
          {
            opacity: 1,
            backgroundColor,
            width
          },
          containerStyle
        ];
      }}
    >
      <Text style={[styles.text, { color: titleColor, fontSize: titleSize }]}>
        {title}
      </Text>
    </Pressable>
  );
};

const styles = StyleSheet.create({
  text: {
    fontWeight: '600'
  },
  base: {
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 42,
    borderRadius: 4,
    paddingHorizontal: 12
  }
});

export default Button;
```

Add the following code snippet in `IconButton.js`:

```js
// components/IconButton.js

import React from 'react';
import { Pressable, StyleSheet } from 'react-native';
import { AntDesign } from '@expo/vector-icons';

const IconButton = ({ color, size, onPress, name }) => {
  return (
    <Pressable
      style={args => {
        if (args.pressed) {
          return [
            styles.base,
            {
              opacity: 0.5,
              backgroundColor: 'transparent'
            }
          ];
        }

        return [styles.base, { opacity: 1, backgroundColor: 'transparent' }];
      }}
      onPress={onPress}
    >
      <AntDesign name={name} size={size} color={color} />
    </Pressable>
  );
};

const styles = StyleSheet.create({
  base: {
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export default IconButton;
```

Add the following code snippet in `ErrorMessage.js`. This component will be used to display error messages either when signing up or logging in to the app. These messages are human-readable and thrown by the Firebase Auth service. You can go through the complete list of messages in the [Firebase official documentation](https://firebase.google.com/docs/auth/admin/errors).

```js
// components/ErrorMessage.js

import React from 'react';
import { StyleSheet, Text } from 'react-native';

const ErrorMessage = ({ error, visible }) => {
  if (!error || !visible) {
    return null;
  }

  return <Text style={styles.errorText}>âš ï¸ {error}</Text>;
};

const styles = StyleSheet.create({
  errorText: {
    color: '#fdca40',
    fontSize: 20,
    marginBottom: 10,
    fontWeight: '600'
  }
});

export default ErrorMessage;
```

Add the following code snippet in `InputField.js`:

```js
// components/InputField.js
import React from 'react';
import { View, StyleSheet, TextInput, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

const InputField = ({
  leftIcon,
  iconColor = '#000',
  rightIcon,
  inputStyle,
  containerStyle,
  placeholderTextColor = '#444',
  handlePasswordVisibility,
  ...rest
}) => {
  return (
    <View style={[styles.container, containerStyle]}>
      {leftIcon ? (
        <MaterialCommunityIcons
          name={leftIcon}
          size={20}
          color={iconColor}
          style={styles.leftIcon}
        />
      ) : null}
      <TextInput
        {...rest}
        placeholderTextColor={placeholderTextColor}
        style={[styles.input, inputStyle]}
      />
      {rightIcon ? (
        <TouchableOpacity onPress={handlePasswordVisibility}>
          <MaterialCommunityIcons
            name={rightIcon}
            size={20}
            color={iconColor}
            style={styles.rightIcon}
          />
        </TouchableOpacity>
      ) : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 4,
    flexDirection: 'row',
    padding: 12
  },
  leftIcon: {
    marginRight: 10
  },
  input: {
    flex: 1,
    width: '100%',
    fontSize: 18
  },
  rightIcon: {
    alignSelf: 'center',
    marginLeft: 10
  }
});

export default InputField;
```

Lastly, create an `index.js` file that will expose all these components from the directory itself:

```js
import IconButton from './IconButton';
import Button from './Button';
import ErrorMessage from './ErrorMessage';
import InputField from './InputField';

export { IconButton, Button, ErrorMessage, InputField };
```

## Creating screens in the app

The sole focus of this tutorial is to integrate Firebase SDK and not to teach how to create app screens in React Native from scratch. While we go briefly over which screen is going to be composed of what React Native elements, please make sure you have basic knowledge of what [core components](https://reactnative.dev/docs/components-and-apis) are included in React Native.

Let's start by creating the structure of the screens directory. Once you have opened the Expo project in your preferred code editor, you will be welcomed by the default directory structure as shown below:

![ss1](https://i.imgur.com/rqcklse.png)

Create a new directory called `/screens` and add the following screen files:

- HomeScreen.js
- LoginScreen.js
- SignupScreen.js

After creating these screen files, let's create the screens one by one. Start by modifying `HomeScreen.js`. This screen will show the user's email and their UID when the user has either successfully signed up or logged in.

The UID is generated and assigned to every user who registers with the Firebase Auth service.

Both the user's email and UID will come from `AuthenticatedUserContext`. We will get into those details later.

The `firebase.auth().signOut()` function is a method provided by the Firebase auth service to log out the user from the app.

Add the following code snippet to `HomeScreen.js`.

```js
import { StatusBar } from 'expo-status-bar';
import React, { useContext } from 'react';
import { StyleSheet, Text, View } from 'react-native';

import { IconButton } from '../components';
import Firebase from '../config/firebase';
import { AuthenticatedUserContext } from '../navigation/AuthenticatedUserProvider';

const auth = Firebase.auth();

export default function HomeScreen() {
  const { user } = useContext(AuthenticatedUserContext);
  const handleSignOut = async () => {
    try {
      await auth.signOut();
    } catch (error) {
      console.log(error);
    }
  };
  return (
    <View style={styles.container}>
      <StatusBar style="dark-content" />
      <View style={styles.row}>
        <Text style={styles.title}>Welcome {user.email}!</Text>
        <IconButton
          name="logout"
          size={24}
          color="#fff"
          onPress={handleSignOut}
        />
      </View>
      <Text style={styles.text}>Your UID is: {user.uid} </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#e93b81',
    paddingTop: 50,
    paddingHorizontal: 12
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    color: '#fff'
  },
  text: {
    fontSize: 16,
    fontWeight: 'normal',
    color: '#fff'
  }
});
```

Next, let's create the login screen. Add the code snippet below inside `LoginScreen.js`. It contains two input fields and a button. Each input field represents the field where the user will enter their `email` and `password`. The value of each input field is stored inside two namesake state variables using the `useState` hook.

Initially, the value for each variable is an empty string. When the user provides the value in the input field, the current value for each of these variables is updated using the corresponding update function `setEmail` and `setPassword`. The values stored by these variables will be used when sending login information to Firebase.

The three other state variables defined inside the `LoginScreen` component are:

- `passwordVisibility`: to show/hide password on the input field
- `rightIcon`: to set a default icon for the `passwordVisibility` functionality
- `loginError`: to store any incoming error when logging in from Firebase.

`onLogin` is an asynchronous method that handles whether to log in the user or not based on their `email` and `password` values. These values are passed as arguments to a method called `signInWithEmailAndPassword` provided by Firebase Auth.

```js
import { StatusBar } from 'expo-status-bar';
import React from 'react';
import { useState } from 'react';
import { StyleSheet, Text, View, Button as RNButton } from 'react-native';

import { Button, InputField, ErrorMessage } from '../components';
import Firebase from '../config/firebase';

const auth = Firebase.auth();

export default function LoginScreen({ navigation }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [passwordVisibility, setPasswordVisibility] = useState(true);
  const [rightIcon, setRightIcon] = useState('eye');
  const [loginError, setLoginError] = useState('');

  const handlePasswordVisibility = () => {
    if (rightIcon === 'eye') {
      setRightIcon('eye-off');
      setPasswordVisibility(!passwordVisibility);
    } else if (rightIcon === 'eye-off') {
      setRightIcon('eye');
      setPasswordVisibility(!passwordVisibility);
    }
  };

  const onLogin = async () => {
    try {
      if (email !== '' && password !== '') {
        await auth.signInWithEmailAndPassword(email, password);
      }
    } catch (error) {
      setLoginError(error.message);
    }
  };

  return (
    <View style={styles.container}>
      <StatusBar style="dark-content" />
      <Text style={styles.title}>Login</Text>
      <InputField
        inputStyle={{
          fontSize: 14
        }}
        containerStyle={{
          backgroundColor: '#fff',
          marginBottom: 20
        }}
        leftIcon="email"
        placeholder="Enter email"
        autoCapitalize="none"
        keyboardType="email-address"
        textContentType="emailAddress"
        autoFocus={true}
        value={email}
        onChangeText={text => setEmail(text)}
      />
      <InputField
        inputStyle={{
          fontSize: 14
        }}
        containerStyle={{
          backgroundColor: '#fff',
          marginBottom: 20
        }}
        leftIcon="lock"
        placeholder="Enter password"
        autoCapitalize="none"
        autoCorrect={false}
        secureTextEntry={passwordVisibility}
        textContentType="password"
        rightIcon={rightIcon}
        value={password}
        onChangeText={text => setPassword(text)}
        handlePasswordVisibility={handlePasswordVisibility}
      />
      {loginError ? <ErrorMessage error={loginError} visible={true} /> : null}
      <Button
        onPress={onLogin}
        backgroundColor="#f57c00"
        title="Login"
        tileColor="#fff"
        titleSize={20}
        containerStyle={{
          marginBottom: 24
        }}
      />
      <RNButton
        onPress={() => navigation.navigate('Signup')}
        title="Go to Signup"
        color="#fff"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#e93b81',
    paddingTop: 50,
    paddingHorizontal: 12
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    color: '#fff',
    alignSelf: 'center',
    paddingBottom: 24
  }
});
```

The signup screen is similar to the login screen. It uses `onHandleSignup`, which is an asynchronous method that handles the action of registering a user or not based on their `email` and `password` values. These values are passed as arguments to a method called `createUserWithEmailAndPassword` provided by Firebase Auth. Add the following code snippet to the `SignupScreen.js` file:

```js
import { StatusBar } from 'expo-status-bar';
import React from 'react';
import { useState } from 'react';
import { StyleSheet, Text, View, Button as RNButton } from 'react-native';

import { Button, InputField, ErrorMessage } from '../components';
import Firebase from '../config/firebase';

const auth = Firebase.auth();

export default function SignupScreen({ navigation }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [passwordVisibility, setPasswordVisibility] = useState(true);
  const [rightIcon, setRightIcon] = useState('eye');
  const [signupError, setSignupError] = useState('');

  const handlePasswordVisibility = () => {
    if (rightIcon === 'eye') {
      setRightIcon('eye-off');
      setPasswordVisibility(!passwordVisibility);
    } else if (rightIcon === 'eye-off') {
      setRightIcon('eye');
      setPasswordVisibility(!passwordVisibility);
    }
  };

  const onHandleSignup = async () => {
    try {
      if (email !== '' && password !== '') {
        await auth.createUserWithEmailAndPassword(email, password);
      }
    } catch (error) {
      setSignupError(error.message);
    }
  };

  return (
    <View style={styles.container}>
      <StatusBar style="dark-content" />
      <Text style={styles.title}>Create new account</Text>
      <InputField
        inputStyle={{
          fontSize: 14
        }}
        containerStyle={{
          backgroundColor: '#fff',
          marginBottom: 20
        }}
        leftIcon="email"
        placeholder="Enter email"
        autoCapitalize="none"
        keyboardType="email-address"
        textContentType="emailAddress"
        autoFocus={true}
        value={email}
        onChangeText={text => setEmail(text)}
      />
      <InputField
        inputStyle={{
          fontSize: 14
        }}
        containerStyle={{
          backgroundColor: '#fff',
          marginBottom: 20
        }}
        leftIcon="lock"
        placeholder="Enter password"
        autoCapitalize="none"
        autoCorrect={false}
        secureTextEntry={passwordVisibility}
        textContentType="password"
        rightIcon={rightIcon}
        value={password}
        onChangeText={text => setPassword(text)}
        handlePasswordVisibility={handlePasswordVisibility}
      />
      {signupError ? <ErrorMessage error={signupError} visible={true} /> : null}
      <Button
        onPress={onHandleSignup}
        backgroundColor="#f57c00"
        title="Signup"
        tileColor="#fff"
        titleSize={20}
        containerStyle={{
          marginBottom: 24
        }}
      />
      <RNButton
        onPress={() => navigation.navigate('Login')}
        title="Go to Login"
        color="#fff"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#e93b81',
    paddingTop: 50,
    paddingHorizontal: 12
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    color: '#fff',
    alignSelf: 'center',
    paddingBottom: 24
  }
});
```

## Create an authenticated user provider

In this section, you are going to create an authentication provider to check whether the user is logged in or not and access them if they are logged in.

Create a new directory called `navigation/` and inside it, create a file called `AuthenticatedUserProvider.js`.

When a user is authenticated using a sign-in method in Firebase, it returns a user object with various properties such as email, photo URL, UID, display name, and so on. To create the auth flow in the example app we are building, we need a way of knowing whether this user object exists or not. Thus, we conditionally render two different stack navigators (we will create them in the next section). So, a user will only be able to log in and access `HomeScreen` if their respective user object exists.

One way to share data that is considered global in a React app is to use the React Context API. When creating a context, we must pass a default value. This value is used when a component has a matching Provider.

The Provider allows the React components to subscribe to the context changes. It wraps all other components in the React or React Native app.

To create an authenticated user provider, export a function called `AuthenticatedUserProvider`. This provider is going to allow the screen components to access the logged-in or logged-out state of a user in the application. So, in the code snippet below, we define a state variable called `user`.

```js
import React, { useState, createContext } from 'react';

export const AuthenticatedUserContext = createContext({});

export const AuthenticatedUserProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  return (
    <AuthenticatedUserContext.Provider value={{ user, setUser }}>
      {children}
    </AuthenticatedUserContext.Provider>
  );
};
```

## Creating Home and Auth stacks

In this example app, there are two different stack navigator files to create:

- `HomeStack.js`: composed of `HomeScreen`
- `AuthStack.js`: composed of `LoginScreen` and `SignupScreen`

Create these new files inside the `navigation/` directory.

Add the following code snippet inside `HomeStack.js`:

```js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';

import HomeScreen from '../screens/HomeScreen';

const Stack = createStackNavigator();

export default function HomeStack() {
  return (
    <Stack.Navigator headerMode="none">
      <Stack.Screen name="Home" component={HomeScreen} />
    </Stack.Navigator>
  );
}
```

Next, add the following code snippet inside `AuthStack.js`:

```js
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';

import LoginScreen from '../screens/LoginScreen';
import SignupScreen from '../screens/SignupScreen';

const Stack = createStackNavigator();

export default function AuthStack() {
  return (
    <Stack.Navigator headerMode="none">
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen name="Signup" component={SignupScreen} />
    </Stack.Navigator>
  );
}
```

## Check a user's authenticated state

The Firebase Auth service provides a listener called `onAuthStateChanged` to detect changes to a user's logged-in state. It subscribes to a user's current authenticated state and receives an event whenever that state changes.

Using this listener, if the returned state of a user is `null`, it means that the user is currently logged out. If it does not return `null`, it will return a user object. This helps in persisting a user's authentication state in the app.

We will use this listener method at the top of our navigator. Create a new file called `RootNavigator.js` inside the `navigation/` directory. Start by importing the following statements:

```js
import React, { useContext, useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { View, ActivityIndicator } from 'react-native';

import Firebase from '../config/firebase';
import { AuthenticatedUserContext } from './AuthenticatedUserProvider';
import AuthStack from './AuthStack';
import HomeStack from './HomeStack';

const auth = Firebase.auth();
```

Next, create a function component called `RootNavigator`. Inside it, define a state variable called `isLoading` when a user's authenticated state is currently being checked with the Firebase Auth service.

Using the `useContext` hook, get the current value of `user` and the method `setUser` to update that value from `AuthenticatedUserContext`.

This hook will trigger a re-render whenever the value of `user` changes from the `AuthenticatedUserContext`.

The `onAuthStateChanged` listener will trigger inside the `useEffect` hook. It also returns an unsubscriber function which allows the app to stop listening for events whenever the hook is no longer in use.

Add the following code snippet inside the `RootNavigator.js` file:

```js
export default function RootNavigator() {
  const { user, setUser } = useContext(AuthenticatedUserContext);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // onAuthStateChanged returns an unsubscriber
    const unsubscribeAuth = auth.onAuthStateChanged(async authenticatedUser => {
      try {
        await (authenticatedUser ? setUser(authenticatedUser) : setUser(null));
        setIsLoading(false);
      } catch (error) {
        console.log(error);
      }
    });

    // unsubscribe auth listener on unmount
    return unsubscribeAuth;
  }, []);

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return (
    <NavigationContainer>
      {user ? <HomeStack /> : <AuthStack />}
    </NavigationContainer>
  );
}
```

In the above code snippet, note that both the stack navigators are conditionally rendered depending on the state of the user.

## Wrapping RootNavigator with AuthenticatedUserProvider

Now that `RootNavigator` is defined, the question remains on how to use `AuthenticatedUserProvider` to wrap a set of components in the current app tree.

Well, you have to wrap this provider around the `RootNavigator` in order to use the helper functions as well as the value of the current user in the screen components.

Create an `index.js` file inside the `navigation/` directory and add the following code snippet:

```js
import React from 'react';

import { AuthenticatedUserProvider } from './AuthenticatedUserProvider';
import RootNavigator from './RootNavigator';

/**
 * Wrap all providers here
 */

export default function Routes() {
  return (
    <AuthenticatedUserProvider>
      <RootNavigator />
    </AuthenticatedUserProvider>
  );
}
```

Also, modify the `App.js` file to return `Routes`.

Here is the demo of the complete authentication flow you will get after this step:

![ss9](https://i.imgur.com/aEN728J.gif)

If you head over to the Firebase console and go to the **Users** tab on the Authentication page, you will see the details of the signed up user.

![ss10](https://i.imgur.com/NEiqR2O.png)

## Conclusion

You have now successfully integrated the Firebase Auth service in a React Native app using Expo SDK.

Using Firebase JS SDK allows integrating other sign-in providers such as Phone authentication, Facebook and Google. Refer to [Expoâ€™s official documentation](https://docs.expo.io/guides/using-firebase/#login-methods) to try out other login providers.

If you need to take a look at the code for this tutorial, you can refer to this [GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/expo-firebase-auth-example).

---

## Firebase config in a React app
Slug: firebase-config-in-a-react-app

![cover](https://i.imgur.com/u3tfk7P.png)

To create or setup a new React app, I try to use `npx` from a terminal window. By executing the following command, it generates a new React app using the `create-react-app` utility.

```shell
npx create-react-app reactapp

# after the project has generated

cd reactapp
```

The name of the project `reactapp` mentioned in the command is the project name. To start this newly created React app, run the below command from the terminal window:

```shell
yarn start
```

It will trigger the default React app that is generated by `create-react-app` command-line utility and open the app in a browser window at URL `http://localhost:3000`.

![ss1](https://i.imgur.com/KMW1O19.png)

Now, setup the project as per the need. The following directory basic setup is how I like to setup a new React app (_when using Firebase as the backend service_).

![ss2](https://i.imgur.com/4EXRxj8.png)

Add an initial modification of `src/App.js` file to the file code snippet.

```js
import React from 'react';

function App() {
  return (
    <div>
      <h1>React App</h1>
    </div>
  );
}

export default App;
```

This modification is going to lead to the following change in a web browser window.

![ss3](https://i.imgur.com/fk5pNaU.png)

## Create Firebase project-based components

The basic directory structure is all setup, now let's create the Firebase project-related component folders. Each component folder inside `src/components/` is going to have an `index.js` file that is going to contain the code snippet related to that particular component.

For example, in a Firebase + React app, the sign in, sign out and sign up component is going to be three different components to handle user authentication. Thus, all are going to have separate folders. To create a component folder you can use the command-line interface or the editor or the IDE file explorer.

```shell
cd components/

mkdir SignIn SignOut SignUp
```

![ss4](https://i.imgur.com/Fh4Ha83.png)

The `./src/Pages` directory is optional. I like to separate presentation page components such as `Home` or `Landing` in a different folder but that depends on the project itself.

![ss5](https://i.imgur.com/NOdfdO3.png)

The initial components directory is done. In the next section, let us get the API keys from the Firebase project.

## Generate Firebase API keys

<blockquote display="info">
  Before you generate API keys for Firebase configuration in a React app, please
  make sure you have either set up a new Firebase app or have access to a
  Firebase app using its console.
</blockquote>

If you are new to Firebase apps, please refer to the post here that explains ðŸ‘‰ [how to create a new Firebase project?](https://amanhimself.dev/new-firebase-project/)

Once you have created or opened a Firebase project, from the dashboard screen, click on the _settings_ icon âš™ï¸ from the side menu.

![ss12](https://i.imgur.com/zkv9SNA.png)

The _Settings_ page opens as shown below.

![ss13](https://i.imgur.com/ZTgOnQk.png)

To create a new app, go to the section that says `Your apps` and click on the third icon or the Web icon. The first two icons shown are for creating keys for native platforms such as iOS and Android.

![ss16](https://i.imgur.com/FGaubt7.png)

Next, there is going to be a prompt about adding the name of the web app. Enter a name.

![ss14](https://i.imgur.com/m2mhbm6.png)

Then the API keys required by the web app are generated as shown below. The blacked-out part is the actual key values and I recommend not sharing with anyone.

![ss15](https://i.imgur.com/NGYOauf.png)

Make sure you save the `firebaseConfig` object. It is the object the contains all the API keys required to use various Firebase services such as authentication, database and so on.

Once you copied the `firebaseConfig` object, you press the button that says `Continue to console`. You are going to be taken back to the `Settings` page.

## Environment variables in a React app

Create a new file inside the React project called `.env`. Make sure to add this file to `.gitignore` and do not commit it to the [GitHub](https://github.com) repo or any other public repository on a version control platform.

This file is going to save all the Firebase API keys as shown below. All the `xxxx`'s represent the keys generated in the Firebase console. Replace them with your own keys.

```shell
DEV_API_KEY=xxxx

DEV_AUTH_DOMAIN=xxxx

DEV_DATABASE_URL=xxxx

DEV_PROJECT_ID=xxxx

DEV_STORAGE_BUCKET=xxxx

DEV_MESSAGING_SENDER_ID=xxxx

DEV_APP_ID=xxxx

DEV_MEASUREMENT_ID=xxxx
```

<blockquote display="info">
  You do not have to name each key with the prefix `DEV_`. You can either use
  their default name such as `API_KEY` or follow your own convention. I like to
  follow `DEV_` and `PROD_` prefixes to separate dev mode and production mode
  Firebase projects.
</blockquote>

## Connect Firebase with a React app

React app needs Firebase SDK installed as an npm dependency. Open terminal window, execute the following command to install the dependency.

```shell
yarn add firebase
```

For Firebase SDK to initialize with the React app and use the Firebase services further in the app, it needs to consume the API keys generated in the previous section as a configuration object. This object is a plain JavaScript object with key and value
pairs.

Create a new file `src/Firebase/firebase.js` import the `firebase` library and create a `firebaseConfig` object with appropriate keys and their values saved in `.env` file.

```js
// firebase.js

import * as firebase from 'firebase/app';

const firebaseConfig = {
  apiKey: process.env.DEV_API_KEY,
  authDomain: process.env.DEV_AUTH_DOMAIN,
  databaseURL: process.env.DEV_DATABASE_URL,
  projectId: process.env.DEV_PROJECT_ID,
  storageBucket: process.env.DEV_STORAGE_BUCKET,
  messagingSenderId: process.env.DEV_MESSAGING_SENDER_ID,
  appId: process.env.DEV_APP_ID,
  measurementId: process.env.DEV_MEASUREMENT_ID
};
```

The `firebase/app` import statement is always required when you add the Firebase SDK to a new Web app or React project. It should also be the import statement line in this file.

The current format of `firebaseConfig` object shows that all the Firebase services from its console are enabled.

<blockquote display="default">
  Side-note: To use a different set of API keys or Firebase projects such as for
  development and production, you can create two `config` objects here. For dev
  mode, create `devConfig` and for production, create `prodConfig`.
</blockquote>

```js
const prodConfig = {
  apiKey: process.env.PROD_API_KEY,
  authDomain: process.env.PROD_AUTH_DOMAIN,
  databaseURL: process.env.PROD_DATABASE_URL,
  projectId: process.env.PROD_PROJECT_ID,
  storageBucket: process.env.PROD_STORAGE_BUCKET,
  messagingSenderId: process.env.PROD_MESSAGING_SENDER_ID,
  appId: process.env.PROD_APP_ID,
  measurementId: process.env.PROD_MEASUREMENT_ID
};

const devConfig = {
  apiKey: process.env.DEV_API_KEY,
  authDomain: process.env.DEV_AUTH_DOMAIN,
  databaseURL: process.env.DEV_DATABASE_URL,
  projectId: process.env.DEV_PROJECT_ID,
  storageBucket: process.env.DEV_STORAGE_BUCKET,
  messagingSenderId: process.env.DEV_MESSAGING_SENDER_ID,
  appId: process.env.DEV_APP_ID,
  measurementId: process.env.DEV_MEASUREMENT_ID
};
```

Then using JavaScript conditional operator, you can condition between the two.

```js
const config = process.env.NODE_ENV === 'production' ? prodConfig : devConfig;
```

This way, you will prevent the mixing of data and other information between development mode app and production or deployed app.

## Initializing the Firebase SDK

Initializing the Firebase SDK with the current React app is the first step. To do this, you have to use a method called `initializeApp()` and pass the `firebaseConfig` as the only argument to this method after defining the config object.

```js
// firebase.js

firebase.initializeApp(firebaseConfig);
```

Lastly, to test that the Firebase SDK is working with the React app, let us export the `firebase` instance from `Firebase/firebase.js` file.

```js
export default firebase;
```

Open `App.js` file, import the `firebase` instance, and using `useEffect` hook let us try to see if it's initialized or not.

```js
import React, { useEffect } from 'react';

// TODO: REMOVE THIS IMPORT STATEMENT BELOW BEFORE PROCEEDING

import firebase from './Firebase/firebase';

function App() {
  // TODO: REMOVE THIS BEFORE PROCEEDING

  useEffect(() => {
    console.log(firebase);
  }, []);

  return (
    <div>
      <h1>React App</h1>
    </div>
  );
}

export default App;
```

To see the output of the console statement from the above code snippet, open Developer Tools -> Console tab in the web browser. On the initial render of `App` component or the React app, the `useEffect` hook is going to trigger.

![ss17](https://i.imgur.com/Nl4Mov8.png)

The object returned from Firebase clearly states that there are no errors with the current Firebase config in a React app.

It is important to notice that Firebase should only be initialized once in the React app. This pattern is called [singleton](https://en.wikipedia.org/wiki/Singleton_pattern). This initialization should be the top level component in the React components tree.

## Conclusion

Here is a summary of what has been done in this tutorial so far.

- Create a React app using `create-react-app`
- Create an opinionated directory structure inside React app to manage different components
- Generate Firebase API keys for configuration
- Used environment variables inside a React app to manage keys
- Install `firebase` SDK npm package
- Connect Firebase SDK to React app
- Initialize the Firebase SDK
- Why initialize a Firebase instance only once per React app?

ðŸ‘‰ **Further reading:**

- [What is `firebase.app()` and why it is read-only?](https://firebase.google.com/docs/reference/js/firebase.app.App)
- `firebase` SDK [npm package](https://www.npmjs.com/package/firebase)
- [How to create a new Firebase project?](https://amanhimself.dev/blog/new-firebase-project/)
- [Singleton Pattern](https://en.wikipedia.org/wiki/Singleton_pattern)
- [How to add custom environment variables with `create-react-app`](https://create-react-app.dev/docs/adding-custom-environment-variables)?

---

## Life at Draftbit - First 3 Months as a Developer Advocate
Slug: first-three-months-as-developer-advocate

![cover_image](https://i.imgur.com/TBebjua.jpg)

<blockquote>
Photo by <a href="https://unsplash.com/@x_prayer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Prayer X</a> on <a href="https://unsplash.com/s/photos/galaxy?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
</blockquote>

<br />

It has been 3 months since I joined [Draftbit](https://draftbit.com/). It feels like Iâ€™ve been on a journey. I was initially hired as a tech writer but the role eventually evolved (within a month) into Developer Advocate ðŸ¥‘.

On a personal level, the first thing I learned is that embrace your surroundings (new) without overthinking too much. It has been the highlight for me this year, so far.

The reason I say this is because my background is not in Developer Advocacy or Relations per se. I've been working as a contract developer/consultant for most of my time, in the last three years. I've worked with different tech stacks inside the JavaScript ecosystem such as Node.js, AngularJS, React and React Native but not on things outside it.

But for the past few years, I have been writing blog posts and tutorials. Trying to document what I am learning in a way I could go back and read the stuff myself or refer to someone else when required. I do not have an extraordinary memory and like to take notes when I am learning. I enjoy the process. It doesn't feel like "work".

## What is a Developer Advocate?

In 2019, when I first got to know about Draftbit at [App.js conf](https://appjs.co/), I was excited to learn that there's a world beyond building mobile apps inside VSCode (insert your preferred editor here). At that time though I did not know what exactly a Dev Advocate is.

What I've gathered about Dev Advocacy or understand right now is that various organizations differ in responsibilities when it comes to the role. Though there are common responsibilities or activities that most people working in Dev Advocacy share. Content creating is one. Brand awareness. Creating and sharing resources through the medium of blogging or live streams publishing videos and speaking at remote or offline events. Building community is also one aspect of it. Creating demos using the product to solve specific use cases is another aspect.

Without spreading out my unorganized thoughts around the matter too much, here are some of the resources that helped me get the context on what Developer Advocacy is:

- Sam Julien's book on [Getting Started in Developer Relations](https://learn.samjulien.com/getting-started-in-developer-relations)

A few weeks back I did share my thoughts in the [newsletter](https://amanhimself.substack.com/). I do recommend this book if you are seeking your first role or are curious about getting to know more. This is the best introduction I've found so far. It made me realize that I have been doing some of the stuff in my free time that a Dev Advocate might do.

- Mary Thengvall's [The Business Value of Developer Relations](https://www.persea-consulting.com/book)

<!-- vale off -->

It goes more in-depth and talks about the importance of nurturing a community, maintaining positive relations, building a team of DevRels, and much more. She [has an amazing post on her blog](https://www.marythengvall.com/blog/2020/6/29/the-camunda-developer-relations-career-path) sharing her own experience.

<!-- vale on -->

## Working with Draftbit

Since joining, a common question I get asked is how my day as a Developer Advocate looks like. I would say, depending on the day, that it depends. ðŸ™ƒ

It depends on some factors as to the kind of thing I am working on, in the following week. Usually, I spend a huge amount of time creating guides and tutorials for various use cases or some of the features that get released. At times, I am trying to help community members to resolve their issues.

Living in an Eastern time zone is one of the reasons that I had missed out on some of the exciting opportunities in past. But here, it is a welcoming aspect. I think it is good to have open mind about it in this ever connected world.

The experience has been a delightful one. I have huge gratitude to express for the entire team at Draftbit. They are friendly, have tons of experience, are willing to offer feedback and helpful suggestions, and allow me to express my own ideas (which I think is vital to be a part of something and be excited about it at the same time).

## Some challenges and personal obstacles

One challenge that I face at times is explaining the semantics of the product from a non-engineering point of view, in written words.

Draftbit is a visual tool to build a mobile app. It is uses React Native and Expo's ecosystem under the hood. The end-user does not have to know about that and there is no requirement for them to know React Native framework.

I've spent a lot of time in the first three months on a feature called [Custom Code](https://docs.draftbit.com/docs/custom-code). It is an advanced feature where an individual can utilize open-source libraries available with Expo and React Native to achieve custom functionalities like integrating a Camera within their app or utilize Firebase Authentication.

This requires me to create demos and write guides in a way that an individual from non-technical background or having no React Native experience can understand with little effort. One way I am trying to tackle is to explain concepts without including too much technical jargon.

If I cannot avoid mentioning something that I think is too technical, I try to provide references or links to documentation wherever necessary to provide a better context (or try improve the internal documentation). Including GIFs of the flow of work or documenting steps to achieve the desired result is another thing that has become a part of my flow.

Making cameo appearances on [Draftbitâ€™s YouTube channel](https://www.youtube.com/c/Draftbit/videos) is one more thing I am getting comfortable with. I never thought I would engage in [speaking in public](https://www.youtube.com/watch?v=YIRxTUCY0NQ) (ðŸ‘‹ hello, anxiety) but now I've done it a few times in a row. I won't say I am good at it. There is a lot of room to improve on a personal level but without doing it I wouldn't know that. Engaging in this activity has helped me realize that coming out of my shell is important.

Here is me talking about Custom Code during Draftbit office hours:

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/pMz4XRjdOd0/0.jpg)](https://www.youtube.com/watch?v=pMz4XRjdOd0)

ðŸ™Œ Shoutout to my colleague [Nick](https://x.com/nickselman) for these timely opportunities.

## Final Thoughts

Providing a value is vital and it is with this mindset I try to approach things. Working as a Developer Advocate, I get to do it more often and it is fun!

If you want to work with me, check out [draftbit.com/jobs](https://draftbit.com/jobs#openings) to see if there's a role that is exciting to you.

If you want to talk about Draftbit, have questions, or React Native, or DevRel, please DM me on [Twitter](https://x.com/amanhimself).

ðŸ’Œ To get notified about my future articles, subscribe my [personal newsletter here](https://amanhimself.substack.com/).

---

## Fine-tuning front matter scope in Vale CLI
Slug: front-matter-scope-in-vale

For a documentation site I am currently maintaining, we use a consistency substitution rule. This rule ensures that standardized terminology and proper capitalization are used for certain words across the whole documentation.

These rules substitute pre-defined patterns by automatically flagging instances where terms like "github" should be "GitHub" or "javascript" should be "JavaScript". Many other internal and third-party products and technologies are included in this substitution rule. Here's an example of the rule file:

```yaml
extends: substitution
message: "Consider using '%s' instead of '%s'"
level: error
ignorecase: true
swap:
  '\b & \b': and
  amazon appstore: Amazon Appstore
  android emulator: Android Emulator
  apple developer: Apple Developer
  cocoapods: CocoaPods
  github: GitHub
  Github: GitHub
```

## The problem

After Vale CLI `3.11.0` introduced Front Matter checks, it started flagging every instance in the front matter of the docs files (`.mdx`) as incorrect. Internally, I consider this a false positive because we have front matter fields like `"github"` to add a link to a GitHub repository for an API documentation page.

```shell
 pages/versions/unversioned/sdk/sqlite.mdx
 4:25  error  Consider using 'GitHub'         expo-docs.Consistency
              instead of 'github'

```

While there are advantages to linting front matter fields and their values, this rule might not be applicable to every context.

## The solution

The fix was surprisingly simple. You can ignore the generated scope of text in the frontmatter fields.

```yaml
scope: ~text.frontmatter
```

This line tells the Vale CLI to apply the rule to everything except the front matter. The tilde (`~`) acts as a negation operator. This helped us reduce the false positives, and the remaining errors were content issues that required fixing.

## Wrapping up

Documentation tooling often requires careful configuration to match your specific workflow. What seems like a minor setting can have major implications or, sometimes, false positives. By understanding the context (prose versus metadata in this case) and configuring tools accordingly, you can create an effective quality control system.

---

## GET Request params with Axios
Slug: get-request-with-axios

One of the popular libraries in JavaScript land to perform HTTP requests is [axios](https://github.com/axios/axios). It is promised based and allows writing code using `async await` syntax.

## Installation

Run the command below:

```bash
yarn add axios
```

## Simple GET HTTP request with axios

A simple GET HTTP request may look like:

```js
axios.get({
  url: `${BASE_URL}/movie/popular?api_key=${API_KEY}&page=1`,
  method: 'get'
});
```

This returns a promise object. Using async await syntax, the promise object can be resolved.

```js
export const getPopularMovies = async () => {
  try {
    return await axios.get(
      `${BASE_URL}/movie/popular?api_key=${API_KEY}&page=1`
    );
  } catch (error) {
    console.error(`[API RESPONSE ERROR]: ${error}`);
  }
};
```

## Adding parameters to GET requests

A GET response can contain parameters. With Axios you can add parameters to the URL:

```js
axios.get(`${BASE_URL}/movie/popular?api_key=${API_KEY}&page=1`);
```

Or can use `params` property in the options:

```js
axios.get(`${BASE_URL}/movie/popular`, {
  params: {
    api_key: API_KEY,
    page: pageNumber
  }
});
```

---

## Getting Started with Ionic Framework
Slug: getting-started-with-ionic-framework

> [Originally Published at Hackernoon.com](https://hackernoon.com/getting-started-with-ionic-framework-an-overview-6725b687779b)

I have been getting familiar with [Ionic Framework](http://ionicframework.com/) in past recent days. To start, I had a question in mind which might be similar to yours. **_Why choose Ionic Framework?_**

The reasons I chose Ionic as my next framework to elaborate my skill-set, are listed here:

- Ionic is all about **HTML**, **CSS**, **JavaScript**
- Since I have been following JavaScript closely in past months and recently worked on a freelance project using technologies and framework (I am familiar with) such as Node.js, Express.js & **AngularJS.**
- To build mobile applications using my current knowledge (that is of AngularJS)
- Learning curve is if you are familiar with AngularJS
- Ionic is cross-platform
- has its own UI components that feels _Bootstrapish_ and is easy to customize
- Itâ€™s open-source and has an active ever-growing community ([with the release of version 2, especially](http://blog.ionic.io/announcing-ionic-2-0-0-final/))

With above â€œlist of reasoningâ€ I am also including few more points that Ionic provides:

- has its own Command Line interface (CLI) to _scaffold, develop_ and _deploy_ applications.
- it gives access to mobile device APIs through two options: ngCordova & ionic-native
- application written in Ionic can be converted for a specific device (such as Android & iOS) using Apacheâ€™s Cordova.

With all that said, I am going to briefly discuss few things in this article that you should know of if/when you are planning to start developing applications using _Ionic Framework_.

### Hybrid Mobile Architecture

Did you think I am going to start this article by discussing some [**myths around Hybrid Mobile Applications**](https://devdactic.com/myth-hybrid-development/)? Well I am not because thereâ€™s already an awesome article written by Simon on [DevDactic.com](https://devdactic.com)

The genesis of Hybrid Mobile applications is to understand _what an Hybrid application is?_

> Hybrid application is a type of mobile application that uses browser window to display its interface.

This comes under the classification of **types of mobile applications** that consists of three types:

- Native: developed using platform specific programming language such as Objective C or Java
- Mobile Websites: developed using web technologies such as HTML, CSS & JavaScript and are accessible only through mobile web browser. They are actually web applications.
- Hybrid: cross-platform and have access to native APIs (mostly through plugins)

Architecture of Hybrid Mobile applications developed using Ionic Framework consists of two concepts that one must be familiar with ASAP: WebView & Apache Cordova.

### What isÂ WebView?

Think it of as a browser that runs inside the scope of a mobile application using Ionic. This browser implements code written in HTML, CSS and JavaScript.

The application on a specific mobile operating system runs via tool like [Cordova](https://cordova.apache.org/). It provides APIs written in JavaScript to interact with Native features of mobile device such as access to camera or a microphone.

WebView communicates with Cordovaâ€™s APIs which then further communicates with mobile devices.

<img src='https://cdn-images-1.medium.com/max/800/1*hdwWntqxD-qOL8vf87DmAQ.png' />

WebViews are so common these days that you can build desktop applications using [Electron](http://electron.atom.io/).

_For detailed information on Hybrid Mobile Applications, I would like you to consider reading John Bristoweâ€™s_ [_article_](http://developer.telerik.com/featured/what-is-a-hybrid-mobile-app/)_._

### Pre-requisites for developing an Ionic Application?

You will need these tools as a part of your environment setup with your Operating System.

- [Node.js](http://www.nodejs.org)

Even if you do not use Node.js as a part of your development environment, to use Ionic you have to install it to get access to command line tools such as Bower, Gulp, and Ionicâ€™s own Command Line Interface using its Nodeâ€™s package manager: [_npm_](http://www.npmjs.com).

#### Installing Ionic

Ionic is a collection of Angular.js, UI Router, Angular directives, Angular services, JS utilities, and mobile focused CSS styles. These are bundled together as ionic.bundle.js and ionic.css.

From your command line:

`$ npm install cordova ionic -g`

This will install a tool you are going make use of: Ionic CLI which is a command line utility.

For detailed information on what it can do:

`$ ionic --help` which list all the things tasks you can perform using this utility.

### Ionic App Development Process

After installing the command line utility, you can start by creating an app using Ionicâ€™s starter templates. Ionic provides three starter templates:

- blank `ionic start myApp blank`
- tabs `ionic start myApp tabs`
- sidemenu tart `myApp sidemenu`

To get a list of all Ionic templates available type in terminal:

`$ ionic start -l`

`ionic start` is the command that is used to scaffold an Ionic application.

<img src='https://cdn-images-1.medium.com/max/800/1*zYrkeFhqj6-YCDaF0LcWMg.png' />

#### Scaffolding an Ionic Application

`$ ionic start -a "Example" -i app.example example blank`

This command can help you scaffold an Ionic Project with following options:

- `-a "Example"` human readable name of application
- `-i app.example` application ID
- `example` project folderâ€™s name
- `blank` ionic template

This steps allows the config file to update with application name and its ID. (We will learn more about the config file later).

After this step, if you look closely at your terminal window, a script runs which installs six Cordova plugins mentioned `package.json` file.

- `cordova-plugin-device` to get device information
- `cordova-plugin-console` defines a global instance of `console.log()`
- `cordova-plugin-whitelist` implements whitelist policy for navigating the applicationâ€™s WebView
- `cordova-plugin-splashscreen` it shows and hides a splash screen during the start of the application on a device
- `cordova-plugin-statusbar` provides functions to customize the iOS and Android StatusBar
- `ionic-plugin-keyboard` provides functions to interact with the keyboard

So now you have an Ionic project setup and you are familiar the basic elements of a projectâ€™s setup. Itâ€™s time to run the application from the command line using `ionic serve` command to run the app locally on a port.

$ cd example
$ ionic serve

It will open a browser window in the default web browser and you will see similar to this:

<img src='https://cdn-images-1.medium.com/max/800/1*JNQywRjia3Z98oF1cdwByA.png' />

`ionic serve --lab` will run the app locally showing two instances of the app for iOS & Android.

<img src='https://cdn-images-1.medium.com/max/800/1*LMFf8hdbrt1zPB1EAfoNPg.png' />

To run the application deliberately on a different port number: `ionic serve -p 8080`

### Ionic Project Structure

Following is the root structure of an Ionic Project after scaffolding:

<img src='https://cdn-images-1.medium.com/max/800/1*k9wGw8Kg_lr2yjaGWIefPA.png' />

I will start describing what each folder/file in the root folder of the app contains, from top to bottom.

- `hooks` consists of scripts that are executed when a specific Cordova task is performed
- `plugins` contains all plugins that comes added to project
- `www` ionic app code that we write to build app
- `scss` consists base scss file (styles of ionic UI components)
- `.bowerrc` path to directory where Bower dependencies get installed
- `.editorconfig` default editor configuration for brevity
- `bower.json` list of Bower dependencies
- `config.xml` meta information needed by Cordova when converting Ionic application to platform specific. It consists of XML tags that describes the project
- `gulpfile.js` build tasks used while developing application
- `ionic.config.json` information regarding ionic application

#### www/ Folder

This folder is the main folder of our application and its where the code of our application is written. It consists of a app startup file `index.html` which act as first page of app, `css` to define custom styles, `images` to add images to app, `js` which further consists of `app.js` where we bootstrap AngularJS framework. In this file, `ionic` is passed as dependency using [Angular Dependency Injection](https://docs.angularjs.org/guide/di). `$ionicPlatform` is the service that is injected to `run` method which enables Cordova plugins discussed earlier and the app itself.

The last folder, `lib` contain the packages/dependencies that are installed using Bower. It contains a pre-loaded dependency of Ionic and Angular files.

_I guess, you now have the idea of how an Hybrid application using Ionic Framework works._

---

## Getting Started with React Native and Expo using Hooks in 2020
Slug: getting-started-with-react-native-expo-hooks-2020

We live in the world of a variety of mobile devices majorly dominated by two platforms, iOS, and Android. It is a two-horse race and I am sure we can all agree on that. Building a mobile application is not an easy task though.

For iOS, you write code using Objective-C or Swift and for Android, you will find yourself using Java or Kotlin. Apart from different programming languages used to create a mobile that can run on each of the two platforms, the toolchains are entirely different too for both of these mobile platforms.

Many modern-day developers use a specific set of technology that is used to build web applications: HTML, CSS, and JavaScript. Different frameworks fall under the category commonly known as Hybrid applications. You can use almost one set of source code for developing the application for both iOS and Android platforms.

In recent years, hybrid frameworks have evolved coming from web view to use native APIs. This cross-platform approach of developing a mobile application comes with its own pros and cons.

One great option that falls under the umbrella of cross-platform development is [React Native](https://facebook.github.io/react-native/). Developed and used by Facebook as well others such as Tesla, Walmart, Uber Eats, Instagram, Discord, Wix and so on. React Native is based on Facebookâ€™s web library ReactJS.

## What this tutorial is about?

React Hooks are available since the release version `16.8.x`. In this tutorial, you are going to get a quick introduction on how to use them in a React Native app. These functions allow using React state and a componentâ€™s lifecycle methods in a functional component. If you are familiar with React, you know that the functional component has been called as a functional stateless component since the introduction of `classes`, but not anymore.

Previously, a class component allowed you to have a local state. Using React Hooks, there is no requirement to refactor a class component React Native into a functional component only because you want to introduce local state or lifecycle methods in that component. However, they do not work with classes. React provides a few built-in Hooks such as useState and useEffect. You can also create your Hooks to re-use to manage state between different components.

## Table of contents

- Getting Started
- The entry point of a React Native app
- Setting up a stack navigation
- Adding the second screen to the stack navigator
- Adding a Floating Button component
- Adding a custom header component
- Implementing Hooks
- Adding a FlatList component to render notes
- Using Navigation parameters to update the state
- Running the app
- Conclusion

## Getting started

To quickly create a React Native app, let us use a tool called [Expo](https://expo.io/). It is a managed development toolset that provides a client to preview and make changes to React Native apps using JavaScript. You do not need tools such as Xcode or Android Studio to get started.

To generate a new app, open a terminal window and enter the following command to install the command-line tool provided by Expo itself.

```shell
npm install -g expo-cli
```

Next, step is to run `expo init` command and choose the default template `blank`.

```shell
# generate a new app
expo init expo-rnHooks

# make sure to navigate inside the project directory
cd expo-rnHooks
```

Once the project directory is generated, navigate inside it. The demo you are going to build requires the use of a navigation pattern between two screens. The first screen is going to display a list of items and through the second screen, you can add an item to the list. This is a typical stack navigation pattern and using the `react-navigation` library, you can add this to your React Native app.

The `react-navigation` library is a third party library that needs to be installed in a React Native or Expo app separately as a dependency. You can either use `npm` or `yarn` but I am going to stick with `yarn`. Each navigational pattern comes as a dependency too since the demo requires only one pattern, let us install that too.

The third library you are going to install is called [`react-native-paper`](https://callstack.github.io/react-native-paper/) that will provide a collection of custom UI components based on Material Design that you can integrate directly. Go back to the terminal window and execute the following command.

```shell
yarn add react-navigation react-navigation-stack
react-native-paper @react-native-community/masked-view
```

React Navigation is made up of some core utilities and those are then used by navigators to create the navigation structure in your app. After the above step, Expo requires you to configure these core utilities as dependencies.

```shell
expo install react-navigation
react-native-gesture-handler
react-native-reanimated react-native-screens
react-navigation-stack
```

That's all for the setup. Let us build something.

## The entry point of a React Native app

The `App.js` file in the generated app structure is what initializes the Expo app. In other words, it is the entry point of the development process. By default, it displays a text message and uses a functional component for that. Open the `App.js` file and you are going to get the following screen component file.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text>Open up App.js to start working on your app!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

Components are the visual elements that you see on the screen in a React Native app. The three major components to look for in the above code snippet are:

- `View`
- `Text`
- `StyleSheet`

A `View` component is the basic building block in a React Native component file. It maps to fundamental native iOS (`UIView`) and Android (`View`) components, hence its name. It puts a container element that supports layout styling with flexbox and other styles using a JavaScript object called `StyleSheet`. Hence, it can be said that `View` components are primarily used for styling and the layout of children elements.

The StyleSheet component in React Native provides an API to create styles inside the component file. It takes a JavaScript object as it does above, and returns a new StyleSheet object from it. There are no classes or IDs in React Native like in web development. To create a new style object, you can use the StyleSheet.create() method.

The `Text` component is in many ways just like the `View` component, except that it is specifically available to display text. Also, like the `View` component, it supports styling.

To see the default app in action, start the development server from the terminal window `expo start`. Either using a simulator or a real device (make sure it has an Expo client installed from the app store) you can test the app.

<img src='https://miro.medium.com/max/509/1*9xg5D_74gvTYRyt89JL_KA.png' />

## Setting up a stack navigation

The `react-navigation-stack` library provides an inbuilt function that returns a React component. This function, `createStackNavigator` takes a route configuration object and an options object (_which is optional_).

The `react-navigation` library provides a function called `createAppContainer` that returns a React component. It takes React component created by the `createStackNavigator` as a parameter and is be directly exported to `App.js` to be used as our App's root component.

To create the first route, you need to create the first screen. Create a new file called `ViewNotes.js` inside `src/screens` directory. This screen is going to be served as the first or home screen of the app. Right now, let us add some mock components and later we will add UI component to reflect the demo app.

```js
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Text } from 'react-native-paper';

function ViewNotes() {
  return (
    <View style={styles.container}>
      <View style={styles.titleContainer}>
        <Text style={styles.title}>You do not have any notes</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingHorizontal: 10,
    paddingVertical: 20
  },
  titleContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1
  },
  title: {
    fontSize: 20
  }
});

export default ViewNotes;
```

Next, create a new file called `index.js` inside `src/navigation/` with the following code snippet.

```js
import { createAppContainer } from 'react-navigation';
import { createStackNavigator } from 'react-navigation-stack';
import ViewNotes from '../screens/ViewNotes';

const StackNavigator = createStackNavigator(
  {
    ViewNotes: {
      screen: ViewNotes
    }
  },
  {
    initialRouteName: 'ViewNotes',
    headerMode: 'none'
  }
);

export default createAppContainer(StackNavigator);
```

In the above code snippet, the parameters such as `initialRouteName` and `headerMode` are passed as the optional object properties. The first object contains the route configuration.

To see this in action, open the `App.js` file, import the navigator created above as well as `PaperProvider` component from `react-native-paper`. This provider is going to wrap the navigator and provides the theme to all the components in the framework. I

```js
import React from 'react';
import { Provider as PaperProvider } from 'react-native-paper';
import AppNavigator from './src/navigation';

export default function App() {
  return (
    <PaperProvider>
      <AppNavigator />
    </PaperProvider>
  );
}
```

Make sure the development server is running. You are going to get the following output in an Expo client.

<img src='https://miro.medium.com/max/509/1*yVurLxAGaVp5CiEynWKl5w.png' />

## Adding the second screen to the stack navigator

To complete the navigation process, let us set up the other screen with some mock text to display. Inside `src/screens/` create another file called `AddNotes.js` and the following code snippet.

```js
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Text } from 'react-native-paper';

function AddNotes() {
  return (
    <View style={styles.container}>
      <View style={styles.titleContainer}>
        <Text style={styles.title}>Add Notes modal screen</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingHorizontal: 10,
    paddingVertical: 20
  },
  titleContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1
  },
  title: {
    fontSize: 20
  }
});

export default AddNotes;
```

Open the `navigation/index.js` file and modify the stack navigator.

```js
import { createAppContainer } from 'react-navigation';
import { createStackNavigator } from 'react-navigation-stack';
import ViewNotes from '../screens/ViewNotes';
import AddNotes from '../screens/AddNotes';

const StackNavigator = createStackNavigator(
  {
    ViewNotes: {
      screen: ViewNotes
    },
    AddNotes: {
      screen: AddNotes
    }
  },
  {
    initialRouteName: 'ViewNotes',
    headerMode: 'none',
    mode: 'modal'
  }
);

export default createAppContainer(StackNavigator);
```

Do note that in the _options_ object, adds a `mode` for stack navigator to `modal`. A modal is like a popup and displays the content but temporarily blocks the interaction from the primary screen, which in this case is `ViewNotes` screen. To access the second screen you still require to add a way to navigate.

## Adding a Floating Button component

Since `react-native-paper` provides cross-platform components to add to the app. In this section, let us add a floating button on the `ViewNotes` screen that can be used to navigate to the `AddNotes` screen. Import the component from the UI library.

```js
import { Text, FAB } from 'react-native-paper';
```

Next, modify the return function and a `FAB` component as well as corresponding styles to position it at the bottom of the screen.

```js
function ViewNotes({ navigation }) {
  return (
    <View style={styles.container}>
      <View style={styles.titleContainer}>
        <Text style={styles.title}>You do not have any notes</Text>
      </View>
      <FAB
        style={styles.fab}
        small
        icon="plus"
        label="Add new note"
        onPress={() => navigation.navigate('AddNotes')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingHorizontal: 10,
    paddingVertical: 20
  },
  titleContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1
  },
  title: {
    fontSize: 20
  },
  fab: {
    position: 'absolute',
    margin: 20,
    right: 0,
    bottom: 10
  }
});
```

In the Expo client you are going to get the following output:

<img src='https://miro.medium.com/max/509/1*o_Sco68X5QLpboYqHkg8kw.png' />

Also, when you click the FAB button, it will navigate you to the `AddNotes` screen.

<img src='https://miro.medium.com/max/378/1*G1YJr6IgxikVul-JVhNhsQ.gif' />

This is done by navigation props from `react-navigation`. Using `navigation.navigate` as the value of the button press prop `onPress`, the app will navigate to the screen with its name passed as the second parameter.

```js
onPress={() => navigation.navigate('AddNotes')}
```

## Adding a custom header component

In this section, let us build a custom header component that is reusable for both of the screens currently residing in the app. Inside the directory `src/components/` create a new file called `Header.js` file.

Import the following components from `react-native` and `react-native-paper`.

```js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Appbar, Title } from 'react-native-paper';
```

The `Appbar` is a component that displays items in a bar. Each of the items can have an action associated but for the demo app, you only require it to display a title. Add the following code snippet that consists of the component as well as the corresponding styles.

The `Header` component is going to accept one prop `titleText` that is the title of a specific screen.

```js
function Header({ titleText }) {
  return (
    <Appbar.Header style={styles.headerContainer}>
      <View style={styles.container}>
        <Title style={styles.title}>{titleText}</Title>
      </View>
    </Appbar.Header>
  );
}

const styles = StyleSheet.create({
  headerContainer: {
    backgroundColor: '#60DBC5'
  },
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  title: {
    color: '#2E7166'
  }
});

export default Header;
```

Import this component in `ViewNotes.js` and modify the contents of the component file in order to display the header.

```js
// add the following statement
import Header from '../components/Header';

// modify ViewNotes component
function ViewNotes({ navigation }) {
  return (
    <>
      <Header titleText="Simple Note Taker" />
      <View style={styles.container}>
        <View style={styles.titleContainer}>
          <Text style={styles.title}>You do not have any notes</Text>
        </View>
        <FAB
          style={styles.fab}
          small
          icon="plus"
          label="Add new note"
          onPress={() => navigation.navigate('AddNotes')}
        />
      </View>
    </>
  );
}
```

The following is going to be the output.

<img src='https://miro.medium.com/max/509/1*PbKVolX0GTycuojptMpSBQ.png' />

Similarly, modify the `AddNotes.js` file.

```js
// add the following statement
import Header from '../components/Header';

// modify AddNotes component
function AddNotes() {
  return (
    <>
      <Header titleText="Add a new note" />
      <View style={styles.container}>
        <View style={styles.titleContainer}>
          <Text style={styles.title}>Add Notes modal screen</Text>
        </View>
      </View>
    </>
  );
}
```

Here is the output:

<img src='https://miro.medium.com/max/509/1*WBDEbWvNeRd-QMWRPvqxXQ.png' />

## Implementing Hooks

To clearly understand how functional components could be leveraged to manage a stateâ€™s component, let us try to go through one of the most basic examples by leveraging one of the few built-in Hooks like `useState`.

Open `ViewNotes.js` file and start by importing `useState` from the React library.

```js
import React, { useState } from 'react';
```

Let us an array to store and display all the notes. Using the array later as the value to the `FlatList` component, you can easily render each note. In a functional component, you can define a default state variable as shown below.

```js
function ViewNotes({ navigation }) {
  const [notes, setNotes] = useState([]);

  // ...
}
```

React preserves the state between all the re-rendering that happens. The hook `useState` returns a pair of values. In the above snippet, the first one being the `notes` which holds the current value of an empty array (_by default_) and the second, `setNotes` is a function that lets you update the current value or in the out case, add items to the array.

To add items to the array, let us create a helper method called `addNotes`.

```js
const addNote = note => {
  note.id = notes.length + 1;
  setNotes([...notes, note]);
};
```

## Adding a FlatList component to render notes

When the array `notes` is empty, let us display a text message that indicates that there is no item in the list otherwise render a `FlatList` component. To do this, you have to import the component itself first.

The component `FlatList` is an efficient way to create scrolling data lists in a React Native app. It has a simple API to work with and is more efficient and preferment with a large amount of information to display in comparison to its alternate.

```js
import { StyleSheet, View, FlatList } from 'react-native';
import { Text, FAB, List } from 'react-native-paper';
```

Next, modify the JSX of the `ViewNotes` component. Do take note that when navigating to `AddNotes` screen, you have to pass it as a prop. This can be done by passing it as the second parameter to `navigation.navigate` function.

```js
return (
  <>
    <Header titleText="Simple Note Taker" />
    <View style={styles.container}>
      {notes.length === 0 ? (
        <View style={styles.titleContainer}>
          <Text style={styles.title}>You do not have any notes</Text>
        </View>
      ) : (
        <FlatList
          data={notes}
          renderItem={({ item }) => (
            <List.Item
              title={item.noteTitle}
              description={item.noteValue}
              descriptionNumberOfLines={1}
              titleStyle={styles.listTitle}
            />
          )}
          keyExtractor={item => item.id.toString()}
        />
      )}
      <FAB
        style={styles.fab}
        small
        icon="plus"
        label="Add new note"
        // add a second parameter object
        onPress={() =>
          navigation.navigate('AddNote', {
            addNote
          })
        }
      />
    </View>
  </>
);
```

From the above snippet, observe that there are three primary props that a FlatList component requires to display a list of data:

- `data`: an array of data that is used to create a list. Generally, this array is built of multiple objects.
- `renderItem`: is a function that takes an individual element from the data array and renders it on the UI.
- `keyExtractor`: it tells the list of data to use the unique identifiers or id for an individual element.

Also, add the `listTitle` inside the `StyleSheet` object.

```js
listTitle: {
  fontSize: 20;
}
```

## Using Navigation parameters to update the state

Since there are no notes, for now, let us modify the `AddNotes` screen to make it functional. This screen is responsible to add a note to the `ViewNotes` screen. Start by modifying the existing import statements.

```js
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { IconButton, TextInput, FAB } from 'react-native-paper';
```

Using the hook `useState` the component is going to hold the value of each note's title and its description as `noteTitle` and `noteValue`.

```js
function AddNote({ navigation }) {
  const [noteTitle, setNoteTitle] = useState('');
  const [noteValue, setNoteValue] = useState('');

  // ...
}
```

The `IconButton` component from `react-native-paper` is going to be used to close the modal. After that add two input fields using `TextInput` that are going to take the user value for the title of the note and its description.

Lastly, using a `FAB` component, the user can submit the form. This component is going to be temporarily disabled of there is no title provided for the note. It can be done by using the `disabled` prop.

On clicking this button the component using `navigation` props is going to perform to actions simultaneously. It is going to save the note's title and its description as well as perform an action to go back to the `ViewNotes` screen.

Here is the complete `AddNotes` code snippet along with corresponding styles.

```js
function AddNote({ navigation }) {
  const [noteTitle, setNoteTitle] = useState('');
  const [noteValue, setNoteValue] = useState('');

  function onSaveNote() {
    navigation.state.params.addNote({ noteTitle, noteValue });
    navigation.goBack();
  }
  return (
    <>
      <Header titleText="Add a new note" />
      <IconButton
        icon="close"
        size={25}
        color="white"
        onPress={() => navigation.goBack()}
        style={styles.iconButton}
      />
      <View style={styles.container}>
        <TextInput
          label="Add Title Here"
          value={noteTitle}
          mode="outlined"
          onChangeText={setNoteTitle}
          style={styles.title}
        />
        <TextInput
          label="Add Note Here"
          value={noteValue}
          onChangeText={setNoteValue}
          mode="flat"
          multiline={true}
          style={styles.text}
          scrollEnabled={true}
          returnKeyType="done"
          blurOnSubmit={true}
        />
        <FAB
          style={styles.fab}
          small
          icon="check"
          disabled={noteTitle == '' ? true : false}
          onPress={() => onSaveNote()}
        />
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingHorizontal: 20,
    paddingVertical: 20
  },
  iconButton: {
    backgroundColor: 'rgba(46, 113, 102, 0.8)',
    position: 'absolute',
    right: 0,
    top: 40,
    margin: 10
  },
  title: {
    fontSize: 24,
    marginBottom: 20
  },
  text: {
    height: 300,
    fontSize: 16
  },
  fab: {
    position: 'absolute',
    margin: 20,
    right: 0,
    bottom: 0
  }
});

export default AddNote;
```

Here is the output you are going to get when navigating to the `AddNotes` screen.

<img src='https://miro.medium.com/max/509/1*bwq4b8Y-YilTgZkWO2YCEA.png' />

## Running the app

The demo app is complete and ready to be tested. In the Expo client image below, and you can find a demo for adding a note and rendering the note.

<img src='https://miro.medium.com/max/378/1*hcV-c1jFreqaSOkHORxoMA.gif' />

## Conclusion

If you are getting started in React Native development, Expo as a toolkit can serve you well in your journey. Instead of dwelling much into iOS and Android development setup which can be overwhelming at the start, I'd recommend the least possible amount of tooling and incline more towards learning the core APIs and fundamentals of React Native.

The way the Expo is being maintained and adding support for Web and universal apps, it going to be an important part of the journey.

Originally published at [Heartbeat.fritz.ai](https://heartbeat.fritz.ai/getting-started-with-react-native-and-expo-using-hooks-in-2020-fb466c25b04c)

---

## Getting Started with React Native in 2019 - Build Your First App
Slug: getting-started-with-react-native-in-2019-build-your-first-app

![cover](https://i.imgur.com/p0FiCt8.jpg)

We live in the world of a variety of mobile devices majorly dominated by two platforms, iOS, and Android. It is a two-horse race and I am sure we can all agree on that. Building a mobile application is not an easy task though.

For iOS, you write code using Objective-C or Swift and for Android, you will find yourself using Java. Apart from different programming languages used to create a mobile that can run on each of the two platforms, the toolchains are entirely different too for both of these mobile platforms.

Many modern-day developers use a specific set of technology that is used to build web applications: HTML, CSS, and JavaScript. There are different frameworks that fall under the category commonly known as Hybrid applications. You can use almost one set of source code for developing the application for both iOS and Android platforms.

In recent years, hybrid frameworks have evolved coming from web view to use native APIs. This cross-platform approach of developing a mobile application comes with its own pros and cons. Pros such as being less-time consuming and cost-effective and cons include performance issues.

One great option that falls under the umbrella of cross-platform development is React Native. Developed and used by Facebook as well others such as Tesla, Walmart, Uber Eats, Instagram, Discord, Wix and so on. React Native is based on Facebookâ€™s web library ReactJS.

### What are you going toÂ learn?

In this tutorial, you will learn the following things:

- What is React Native?
- Setting up the Development Environment
- Use React Native CLI
- Run a React Native App
- What is App.js?
- Hot Reloading
- `AppRegistry`
- Build your first React Native App
- Learn about different UI components
- `View` Component
- `StyleSheet` Object
- `Text` Component
- Create a list with `FlatList`
- Learning Path for React Native

### What is ReactÂ Native?

In a nutshell, React Native allows you to build mobile applications that look, feel and perform much more like native applications. It uses the same fundamental UI building blocks as regular iOS and Android apps. You just put those building blocks together using JavaScript and React. Good thing for developers is that they can use almost the same concepts that are being used for building web applications.

If you are familiar with Reactjs or come from front-end development background, React uses a virtual DOM which acts as a shadow to real DOM available. When an element changes, that change is reflected on the real DOM by Virtual DOM using a node that corresponds to each element.

However, in React Native, there is no DOM rather than Native Components which are provided by platforms such as iOS and Android. There are no web views here. React Native has an instance of [**JavaScriptCore**](https://facebook.github.io/react-native/docs/javascript-environment.html) to execute JS code when an application starts. React Native uses RCTBridgeModule to make a connection between native code and JavaScript code.

In simple words, React Native brings the React to mobile app development. Its goal isnâ€™t to write the code once and run it on any platform. The main goal here is to learn once and write-anywhere. An important distinction to make. React Native is still relatively new, as at the time of writing this post, it is in its version `0.57`.

<img src='https://cdn-images-1.medium.com/max/800/1*Ea-6Srtp9ykLmHNp5y-4fQ.png' />

### Pre-requisites: Setting Up Development Environment

To dive deeply in React Nativeâ€™s ecosystem, we need to install a few things first to get started. Let us go through one of them.

#### Nodejs &Â Watchman

React Native uses Node.js, a JavaScript runtime, to build your JavaScript code. If you do not already have Node.js installed, itâ€™s time to get it from its official website [**here**](https://nodejs.org/en/). I recommend installing LTS (_long-term support_) `10.x.x` version which is also I am using personally.

Watchman is a tool developed by Facebook for watching file changes. It is highly recommended you install it for better performance. For Mac users, You will need the`homebrew` macOS package to install `watchman`: `brew install watchman`.

For Windows users, there is no `watchman` so you can skip this step but you need to have Nodejs as well as `python2` as React Native's recent version requires it.

Lastly, everyone (irrespective of the OS you are using) need to install theJava SE Development Kit (JDK) that can be found [**here**](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html). Make sure the version you install is at least or more than `>= 8`.

#### Native SDKs

For macOS developers, you can install Xcode which is free to develop iOS applications.

If you want to develop for Android, setting up its development environment can be a bit tedious if you are new to this. You will be installing [**Android Studio**](https://developer.android.com/studio/index.html) which is a completely free tool to develop Android apps in its native language. You will be installing a list of utilities for this process and then setting path variables for the first time, so I am recommending to go through the exact link [**here**](https://facebook.github.io/react-native/docs/getting-started) which are official setup instructions provided by Facebook.

### React NativeÂ CLI

Once you are done with the development environment setup process and necessary tools, you can take a deep breath right now. We are going to start building our first REACT NATIVE APP. In order to start, we need one more tool. Using `npm` (a package manager, _which you installed using Node.js_) you are now going to install `react-native-cli`. Open your terminal and run the following command.

```shell
npm install -g react-native-cli
```

This CLI tool is used to scaffold a starter project containing everything you need to build and run a React Native app. `npm` installs this CLI tool as a [**global module**](https://flaviocopes.com/npm-packages-local-global/).

```shell
react-native --version

## output
react-native-cli: 2.0.1
```

To verify that the installation process was a success, you can run the command below and it will output you the current version of the CLI tool.

### Running a React NativeÂ App

To get started we need to create a project directory using the CLI tool just installed. Open up your terminal and run the following.

```shell
react-native init EmojiDictRN
```

You can name it whatever you want. Once the process is done, traverse inside the project directory. You will be welcomed by a set of files like below.

<img src='https://cdn-images-1.medium.com/max/800/1*Q0M1ohq6xC1H7VXDTBpEiA.png' />

From above let us now take a brief look at the files or directories that are essential for us to understand:

- **App.js** the first file in any React Native app that is the entry point of the app development process. Whatever you write inside this file, it will get displayed on the mobile device.
- **node_modules/** is a folder which contains all the dependencies (_or packages_) that are used to develop and run this application.
- **index.js** is the entry point to trigger the app on a device or simulator
- **ios** is the folder containing an Xcode project and the code required to bootstrap this app for iOS devices
- **android** is the folder containing android related code to bootstrap this app for Android devices
- **package.json** where every dependency installed gets listed

You can ignore the other files as of now.

### Running the Application

The `react-native-cli` tool comes with some default snippets of code. To see it in action, you will have to run the application using a terminal. I am going to use an iOS simulator and an Android emulator for this purpose. Windows developers can ignore the iOS part.

```shell
npm start
```

Do note that, we have not made any changes in the source code of the application. To run the app, we need to trigger the below command first.

This will start the metro bundler to watch for any file changes in aÂ `.js` file in your project. Make sure this command is running in a separate terminal window or a tab when you are building your project for `iOS` or `Android`.

#### Running onÂ iOS

To run the app with whatever current content it has on an iOS simulator, you can run the following command below in the second terminal window.

```shell
react-native run-ios
```

This command builds your app and starts it on iOS simulator. This process consumes some good amount of time when building the necessary iOS files for the first time for any React Native app. It will also open up a simulator device for you like below when the process is done.

<img src='https://cdn-images-1.medium.com/max/800/1*DAShIjBe_a2yNNawkC6cNw.png' />

This iOS simulator is the default one with current Xcode version you have. However, you can run any sim device by adding a flag. By running the command:`xcrun simctl list devices` you can check out which devices you have available as simulators.

<img src='https://cdn-images-1.medium.com/max/800/1*VeZj8AI0mA_LMyEqGw9lUg.png' />

The last `Booted` or `Shutdown` against each listed device in above image tells you which devices are currently running. To build and run for another device, you can run the following command.

```shell
react-native run-ios --simulator="iPhone 8 Plus"
```

where `"iPhone 8 Plus"` is the value that you can look up through the last command I mentioned.

#### Running onÂ Android

You will need an Android device to run your React Native Android app. This can be either a physical Android device or more commonly, you can use an Android Virtual Device which allows you to emulate an Android device on your computer.

If you wish to run it on a real device, you can follow the complete set of instructions [**here**](https://facebook.github.io/react-native/docs/running-on-device)**.** For running on an Android emulator, open the Android Studio, and choose the option to â€˜open an existing project/folderâ€™. Once the project gets opened and is indexed, you will see an icon looking exactly like below image in the right corner.

<img src='https://cdn-images-1.medium.com/max/800/1*-qXxDE18Dz9uQp5J76vnUg.png' />

This is an option for enabling an Android Virtual Device (_AVD_). If you have just installed Android Studio, you will likely need to create a new AVD. After the virtual device is running, you can run the command `react-native run-android` from your terminal window to open up the application.

<img src='https://cdn-images-1.medium.com/max/800/1*0LUZsqEWNoQVwZVvQjtzbg.png' />

### How to ModifyÂ App.js?

To see the app in action on both the devices, let us modify `App.js` with the code below.

```js
import React, { Component } from 'react';
import { Platform, StyleSheet, Text, View } from 'react-native';

export default class App extends Component {
  render() {
    return (
      <View style={styles.container}>
        <Text style={styles.instructions}>Hello World!</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF'
  },
  instructions: {
    textAlign: 'center',
    color: '#333333',
    marginBottom: 5
  }
});
```

The result of the following modification can be seen if you press `Cmd + R` on iOS and double `R` on Android.

<img src='https://cdn-images-1.medium.com/max/1200/1*r0z57xfMMVAnhVboDFyghw.png' />

### Enable Hot Reloading

Hot Reloading feature in react native application helps to display any updates occur in UI, whenever you save anything in react native app-code. On enabling this feature, you do not have to press `Cmd + R` on iOS and double `R` on Android again for seeing the changes on the UI you just made.

<img src='https://cdn-images-1.medium.com/max/800/1*uZXfYtm9pPH8FX1ZFRzvyQ.png' />

To enable this feature, all you have to do is press `Ctrl + M/Cmd + M` depending on your OS, and select **Enable Hot Reloading** from the popup menu that appears as shown above.

### What is AppRegistry?

The file that renders this App component is `index.js` in the root directory which has the following code.

```js
/** @format */

import { AppRegistry } from 'react-native';
import App from './App';
import { name as appName } from './app.json';

AppRegistry.registerComponent(appName, () => App);
```

`AppRegistry` is the entry point to run a React Native application. App component or any other root component in the app should register by using `AppRegistry.registerComponent` such that the native system can load the bundle of the app and run the app by starting `AppRegistry.runApplication`.

You can read more about `AppRegistry` in-detail [**here**](https://facebook.github.io/react-native/docs/appregistry.html).

### Baby Steps: First React NativeÂ App

In this section, you are going to build your first React Native app. To get started, we have already generated a React Native project using the cli tool. The only thing now you have to understand is _what are components?_

**Components** are the visual elements that you see on the screen in a React Native app. There are several components made available for you to use by the React Native core. To understand this better, we can categorize these components in six broad categories:

- Basic or Core components such as `View`, `Text`, `Image`, `ScrollView`, `TextInput`, `StyleSheet`
- List components such as `FlatList` and `SectionList`
- User Interface or Form Control components such as `Picker`, `Slider`, `Button`, `Switch`
- iOS Specific components such as `ActionSheetIOS`, `SegmentedControlIOS`, `AlertIOS`, `PushNotificationsIOS`
- Android Specific components such as `DatePickerAndroid`, `TimePickerAndroid`, `ViewPagerAndroid`, `ToastAndroid`, `PermissionsAndroid`
- Other/Miscellaneous components such as `Alert`, `Animated`, `CameraRoll`, `Dimensions`, `Clipboard`, `StatusBar`, `Linking`, `Keyboard`, `ActivityIndicator`, `WebView`, and `Modal`

Getting in detail about each of them is out of the scope of this article and will be a tedious way to learn things initially. Instead, we are going to use a project-based approach to learn your way through them. There are many more components and APIs available in React Native core that you can look at the [**official documentation**](http://facebook.github.io/react-native/docs/components-and-apis#user-interface) and from time to time you will need to.

### What are we building?

You are going to build a small application to just familiarize yourself with basic components. The app is shown in the image below is going to be the end result.

<img src='https://cdn-images-1.medium.com/max/800/1*dKe0pfmB74jfoGTVp9nNmg.png' />

The above is nothing but a list of text coming directly from the componentâ€™s state. Create a new `src/components` directory in the root of the project and inside `components/` create a new file called `EmojiDict.js` with the following snippet of code.

```js
import React, { Component } from 'react';
import { View, Text, StyleSheet } from 'react-native';

class EmojiDict extends Component {
  state = {
    'ðŸ˜ƒ': 'ðŸ˜ƒ Smiley',
    'ðŸš€': 'ðŸš€ Rocket',
    'âš›ï¸': 'âš›ï¸ Atom Symbol'
  };

  render() {
    return (
      <View style={styles.container}>
        <Text>{this.state['ðŸ˜ƒ']}</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  }
});

export default EmojiDict;
```

Accordingly, we have to modify `App.js` file in order to display the result of this component.

```js
import React, { Component } from 'react';

import EmojiDict from './src/components/EmojiDict';

export default class App extends Component {
  render() {
    return <EmojiDict />;
  }
}
```

Now if you take a look at the simulator screen you will see the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*p8x7i3e3jIUvn-KpntKwng.png' />

_What is going on?_ Take a look at the `EmojiDict` file first. We are importing basic components from React Native. We start by declaring a `View` component, which is the basic building block in React Native file. It maps to fundamental native iOS (`UIView`) and Android (`View`) components, hence the name. You can think this component as mere `div` element from HTML where all other elements are placed inside. Hence, a `View` component can contain nested components.

`View` component puts a container element that supports layout styling with `flexbox` and other styles through CSS. We are providing styles to View via `StyleSheet`. Hence, you can say that `View` components are primarily used for styling and layout of children elements.

`StyleSheet` in React Native provides an API to create styles inside the component file. It takes a JavaScript object as it does above, and returns a new `Stylesheet` object from it. There are no _classes_ or _ids_ in React Native like in web development. To create a new style object you use `StyleSheet.create()` method.

The way we have defined styles by creating an object is the preferred way. Not only it helps you organize styles and keep them separate, but these styles when defined in this manner are also sent through the native render bridge only once.

The `Text` component is in many ways just like the `View` component, except that it is specifically available to display text. Also, like the `View` component, it supports styling. Right now we are using `flexbox` to style and center the anything inside the `View` component. `Flexbox` is an algorithm to specify the layout for a component for its children to follow the same pattern. Suppose if we modify it as below:

```js

render() {
		return (
			<View style={styles.container}>
				<Text>{this.state['ðŸ˜ƒ']}</Text>
				<Text>{this.state['ðŸš€']}</Text>
			</View>
		);
}
```

You will get the following result on refreshing the simulator.

<img src='https://cdn-images-1.medium.com/max/800/1*DqJex2fRcRlI9FSuouaD8g.png' />

The way we are creating a list of emojis isnâ€™t a pragmatic approach to handle data whether it comes from a third party API or manage by the componentâ€™s state and render it as a list as we do above. Let us convert our simple view into `FlatList`.

```js
<FlatList
  contentContainerStyle={styles.container}
  data={[
    { key: 'ðŸ˜ƒ', value: 'ðŸ˜ƒ Smiley' },
    { key: 'ðŸš€', value: 'ðŸš€ Rocket' },
    { key: 'âš›ï¸', value: 'âš›ï¸ Atom Symbol' }
  ]}
  renderItem={({ item }) => <Text>{item.value}</Text>}
/>
```

`FlatList` is cross-platform, by default vertical way to display a list of data items. It requires two props: `data` and `renderItem`. `data` is the source of information for the list. `renderItem` takes one item from the source and returns a formatted component to render. Styles that can be applied to a `FlatList` component is done by the prop `contentContainerStyle` that accepts the value of `Stylesheet` object. What we have above is the simplest version of flatlist. Moreover, FlatList in React Native has support to pull to refresh interaction and horizontal display mode.

<img src='https://cdn-images-1.medium.com/max/800/1*dKe0pfmB74jfoGTVp9nNmg.png' />

This completes our first React Native App. I am sure, you might have learned a thing or two. It is a just a basic component that renders a list of items.

### More on Learning ReactÂ Native

With lack of up to date resources or not many resources you will find on React Native concretely, I urge to stick with you learn by doing process and get as much as hands on experience in this field as you can. I did struggle when I started learning React Native, coming from a Web Development background.

Here is what I think you can do to advance with React Native development.

### Start withÂ basics

This article just provides you with an overview of what inside the React Native app development process and how things work behind the scenes, briefly. I often come across (especially through [_#100DaysOfCode_](https://x.com/_100DaysOfCOde) campaign) developers who struggle to learn a new framework with little no background in specific the programming language. My advice, before you leap to make gigantic projects, start with the basics. Learn the concepts as each specific component to the curve, make sure to apply them as much as you can and build small things.

For example, today learned about using `FlatList` component in this article. Try creating a list with your own dataset or find a mock/fake data set on the internet and try to build a small app out of it. Always remember the feeling you got from creating your first _Hello World_ program. Do you remember that sense of accomplishment?

Take small steps, build small things at first before dip your toes deep in the complexity of state management libraries such as Redux and Mobx, or persisting data, using third party APIs, using TypeScript or Flow, and so on. These are just tools, you do not need to know them on day one (_but I am not saying you have to never learn about them. The keyword here is that they are TOOLS_). If you are new to JavaScript, make sure you are clear with the basic ES6 features such as classes, arrow functions etc. Then, you must go through the basic ReactJS concepts such as props, state, and stateless components in general.

In summary, take a look at:

- ES6 Features
- ReactJS Components API
- Setting up a development environment for React Native
- Flexbox

### Advance yourÂ way

Once you have basic concepts clear in your mind and have played around a bit to get some amount of hands-on experience, it is time to advance further. Start building bigger apps that work or behave like a real application and interact with real-time data. Here is a list of things you can learn to advance in your journey.

- Offline data storage with `AsyncStorage`
- Working with third-party APIs
- Maps
- Splash Screens
- Navigation
- Redux (for state management)
- Redux Saga and Persist
- Tests and TDD
- Push notifications
- UI Animations
- Build and publish your app
- Continuous Delivery or CI

Do note that, these are just broad topics to get you started. There are many other things you will learn along the way. Donâ€™t get overwhelmed by that.

### Personal Challenges: What do you want out ofÂ it?

Maybe you to become professional a React Native developer and work in an organization that uses this tech framework or maybe you want to build apps for your clients/customers. Setting your own personal challenges in the way is a great way to learn. Make a commitment to yourself and work on it. Find apps on your phone or on stores that you want to clone or add an extra feature as a functionality, or learn about the user interface.

Do not get overwhelmed by the number of mistakes you do or the errors you get. Getting frustrated and ranting/complaining about it over the internet all day is easy but understand this is that, it will not solve your problems or make you a better developer. All of this is a part of your journey. Keep reminding yourself that.

[Originally published at Level up coding](https://levelup.gitconnected.com/getting-started-with-react-native-in-2019-build-your-first-app-a41ebc0617e2)

---

## Getting Started with Sequelize for Nodejs Applications
Slug: getting-started-with-sequelize-for-nodejs

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/getting-started-with-sequelize-for-nodejs-applications-2854c58ffb8c)

### Introduction toÂ ORM

ORM or Object Relation Mapping is a process of mapping between objects and relation database systems. An ORM acts like an interface between two system. ORM provide advantages for developers from basic ones like saving time and effort and rather focusing on business logic. The code is robust instead of redundant. ORM helps in managing queries for multiple tables in an effective manner. Lastly, an ORM (like [sequelize](http://docs.sequelizejs.com/en/v3/)) is capable to connect with different databases (which comes in handy when switching from one database to another).

### Getting Started with Sequelize

[Sequelize](https://github.com/sequelize/sequelize) is a promise-based ORM for Node.js. Sequelize is easy to learn and has dozens of cool features like synchronization, association, validation, etc. It also has support for PostgreSQL, MySQL, MariaDB, SQLite, and MSSQL. I am assuming you have some form of SQL database service started on your machine. I am currently using MySQL.

### Installation

Sequelize is available via npm.

```shell
$ npm install --save sequelize

# And one of the following:
$ npm install --save pg pg-hstore
$ npm install --save mysql // For both mysql and mariadb dialects
$ npm install --save sqlite3
$ npm install --save tedious // MSSQL
```

### Setting up a Connection

Sequelize does setup a connection between the rest api/application and your SQL database. To setup basic connection between the two:

```js
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  //choose anyone between them
  dialect: 'mysql' | 'mariadb' | 'sqlite' | 'postgres' | 'mssql',

  // To create a pool of connections
  pool: {
    max: 5,
    min: 0,
    idle: 10000
  },

  // For SQLite only
  storage: 'path/to/database.sqlite'
});
```

### How do I setup my Sequelize Connection?

For the sake brevity, I like to divide code into modules. After all, the Unix philosophy of [_one program/module should do one thing_](https://amandeepmittal.github.io/blog/2017/04/05/The-Node-Way-Philosophy-of-a-Platform/) is major part of the philosophy behind writing code in JavaScript (and using Node.js as a server side platform) these days.

I start with `config.json`/`config.js` file in the root of my application/api folder in which I define the general constraints needed to setup the connection with database:

```json
{
  "development": {
    "username": "root",
    "password": "root",
    "database": "articles",
    "host": "localhost",
    "dialect": "mysql"
  },
  "test": {
    "username": "root",
    "password": "root",
    "database": "articles",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "production": {
    "username": "root",
    "password": "root",
    "database": "articles",
    "host": "127.0.0.1",
    "dialect": "mysql"
  }
}
```

You can do this in yourÂ `.env` file if you like to follow that pattern. For more info on this see `[dotenv](https://www.npmjs.com/package/dotenv)`.

After defining the configuration variables, in my `models/` folder or where I define schema of tables in the database at application level, I create the connection in an `index.js` file:

```js
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const basename = path.basename(module.filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/config.json')[env];
const db = {};

if (config.use_env_variable) {
  const sequelize = new Sequelize(process.env[config.use_env_variable]);
} else {
  const sequelize = new Sequelize(
    config.database,
    config.username,
    config.password,
    config
  );
}

fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 && file !== basename && file.slice(-3) === '.js'
    );
  })
  .forEach(file => {
    const model = sequelize['import'](path.join(__dirname, file));
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

sequelize
  .authenticate()
  .then(() => {
    console.log('Connection has been established successfully.');
  })
  .catch(err => {
    console.log('Unable to connect to the database:', err);
  });

db.sequelize = sequelize;
db.Sequelize = Sequelize;

// Import Models such that I can use them in the api just by importing 'db'
db.user = require('./user')(sequelize, Sequelize);
db.admin = require('./admin')(sequelize, Sequelize);
db.articles = require('./articles')(sequelize, Sequelize);

module.exports = db;
```

Itâ€™s important to notice that I am exposing `db` object which contains every model/table schema definition. From now, I just have to import the `db` object to apply operations on specific database tables using it.

This setup can be auto-generated with the help of [Sequelize CLI](https://github.com/sequelize/cli) tool that helps in bootstrapping a new project in an effective manner (like the above) and handle database migrations directly from the terminal.

### Conclusion

Sequelize is feature rich ORM for Node.js. It has a documentation that at times may not provide direct solutions to your problems but there always Github issues for that. What I like about is its Promise based control flow. Coming from NoSQL background (and using MongoDB), understanding Sequelize really took less time. Most of the query based models are quite similar to that in MongoDB (especially the CRUD operations). I am looking for a brighter, more improved documentation and ease of support from Sequelize.

---

## Create a React Native Image Recognition App with Google Vision API
Slug: google-vision-api-firebase-react-native

![cover](https://i.imgur.com/UIZsVjh.jpg)

> [Originally published at Jscrambler](https://jscrambler.com/blog/create-a-react-native-image-recognition-app-with-google-vision-api)

Google Cloud Vision API is a machine learning tool that can classify details from an image provided as an input into thousands of different categories with pre-trained API models. It offers these pre-trained models through an API and the categories are detected as individual objects within the image. In this tutorial, you are going to learn how to integrate Google Cloud Vision API in a React Native application and make use of real time APIs.

## Installing Expo

If you are not familiar with Expo, this tutorial can be a good start. Basically, Expo provides a set of tools to create and publish React Native applications with minimal effort. Earlier, React Native had something called `create-react-native-app` which is now merged with Expo-Cli and is an official way to build a React Native app. To create your React Native app, you need to install Expo as a global npm module.

```shell
npm install -g expo-cli
```

Once the command line interface for Expo is installed in your local development environment, you must run the following command in order to generate a project.

```shell
expo-cli init google-vision-rn-demo
```

It will ask you for which template to use; choose the option **blank template** rather than tabs template. We only need a single screen in our application for the demonstration purposes. In the last step, you will be prompted to write the name of the project &mdash; simply type it and hit enter. Then, it will start installing dependencies. Once the project is created, traverse into the project directory. If you need any help with this setup, refer to the [Expo documentation](https://docs.expo.io/versions/v32.0.0/workflow/configuration/).

## Setting Up Firebase

In this section, we are going to set up a new Firebase project. It will provide us the database and backend service and we do not have to write our own backend for this tutorial, hence saving time and focusing on what we need to learn. For simplicity, I am going to make the Firebase project data public for demonstration purposes.

Visit [Firebase](https://console.firebase.google.com/) and sign-in with your Google ID. Once signed-in, click on a new project and enter a name. Lastly, hit the **Create Project** button.

![ss1](https://i.imgur.com/aQYciDd.png)

The next step is to make sure we set up Firebase database rules to allow us to upload image files through the app. From the left-hand side menu in the Firebase console, open `Database` tab and then choose `Rules` and modify them as follows.

```js
service cloud.firestore {
 match /databases/{database}/documents {
   match /{document=**} {
     allow read, write;
   }
 }
}
```

We need to install the Firebase SDK in our React Native app. Run the following command from your terminal.

```shell
npm install -S firebase
```

Now, create a folder called `config` and inside it, create a new file called `environment.js`. This file will contain all keys needed to bootstrap and hook Firebase with our application.

```js
//environment.js
var environments = {
  staging: {
    FIREBASE_API_KEY: 'XXXX',
    FIREBASE_AUTH_DOMAIN: 'XXXX',
    FIREBASE_DATABASE_URL: 'XXXX',
    FIREBASE_PROJECT_ID: 'XXXX',
    FIREBASE_STORAGE_BUCKET: 'XXXX',
    FIREBASE_MESSAGING_SENDER_ID: 'XXXX',
    GOOGLE_CLOUD_VISION_API_KEY: 'XXXX'
  },
  production: {
    // Warning: This file still gets included in
    // your native binary and is not a secure way to
    // store secrets if you build for the app stores.
    // Details: https://github.com/expo/expo/issues/83
  }
};

function getReleaseChannel() {
  let releaseChannel = Expo.Constants.manifest.releaseChannel;
  if (releaseChannel === undefined) {
    return 'staging';
  } else if (releaseChannel === 'staging') {
    return 'staging';
  } else {
    return 'staging';
  }
}
function getEnvironment(env) {
  console.log('Release Channel: ', getReleaseChannel());
  return environments[env];
}
var Environment = getEnvironment(getReleaseChannel());
export default Environment;
```

The `X`s are values of each key you have to fill in. Ignore the value for Key `GOOGLE_CLOUD_VISION_API_KEY` right now as we will get back to it in the next section. Other values for their corresponding keys can be attained at the Firebase console. You can get these values by visiting Firebase console and then click the gear icon next to `Project Overview` in the left-hand side menu bar and lastly go to `Project settings` section. There are ways in Expo where you do not have to publish your secret keys when deploying the app or uploading the codebase on a site like Github. The initial step I would recommend is to add this file inside `.gitignore`.

Then create another file called `firebase.js` inside the `config` directory. We will be using this file in the main application to send requests to upload an image to the Firebase storage. Also note that we are importing `environment.js` in it to access Firebase keys.

```js
// firebase.js
import * as firebase from 'firebase';

firebase.initializeApp({
  apiKey: Environment['FIREBASE_API_KEY'],
  authDomain: Environment['FIREBASE_AUTH_DOMAIN'],
  databaseURL: Environment['FIREBASE_DATABASE_URL'],
  projectId: Environment['FIREBASE_PROJECT_ID'],
  storageBucket: Environment['FIREBASE_STORAGE_BUCKET'],
  messagingSenderId: Environment['FIREBASE_MESSAGING_SENDER_ID']
});

export default firebase;
```

## Getting Google Cloud Vision API Key

To use a Google Cloud Platform service, you need a Gmail account. Once you are signed-in from your Gmail ID, you can visit the [Google Cloud Console](https://console.cloud.google.com/). The next step is to create a new project.

![ss6](https://i.imgur.com/29hfyJ7.png)

Click `select a project` from the drop-down menu and then `click new project`. Enter the name of your project and then click `Create`. Once youâ€™ve created the project, we are placed back into the main console page again and then need to select our newly created project.

The next step in this process is to get your API key. This you can get by clicking on the console and moving over to `Dashboard` section and under that choose `Enable APIs and Services`.

![ss7](https://i.imgur.com/hlCljun.png)

Then type **vision** in the search on the page as shown below.

![ss8](https://i.imgur.com/LuLN3o0g.png)

And then click `Vision API`.

![ss9](https://i.imgur.com/8folZ3J.png)

Lastly, click `Enable` like below

![ss10](https://i.imgur.com/087P0go.png)

In order to complete this process of enabling Vision API services, you are required to add billing information (if you haven't done already) to your Google Cloud Platform account.

Your URL in the dashboard will look like this: `https://console.cloud.google.com/apis/dashboard?project=FIREBASE-PROJECT-ID&folder&organizationId`. Once you are at the below screen, click on the `Credentials` section from the left-hand side menu and create a new API key if there isn't any by clicking on the button `Create Credentials` and then `API Key`.

![ss2](https://i.imgur.com/y36eTeJ.png)

Once you have created your API key, it is time to add it in the file `environment.js` for the key `GOOGLE_CLOUD_VISION_API_KEY`.

That's it. Setting up the APIs is complete. We can now move on to work on the app itself.

## Building The App

To get started, we need to install an npm package called `uuid` to create a unique blob for the image that is going to upload on the Firebase storage service. Run the command `npm install --save uuid`. Next, open `App.js` and paste the following code.

```js
import React from 'react';
import {
  ActivityIndicator,
  Button,
  Clipboard,
  FlatList,
  Image,
  Share,
  StyleSheet,
  Text,
  ScrollView,
  View
} from 'react-native';
import { ImagePicker, Permissions } from 'expo';
import uuid from 'uuid';
import Environment from './config/environment';
import firebase from './config/firebase';

export default class App extends React.Component {
  state = {
    image: null,
    uploading: false,
    googleResponse: null
  };

  async componentDidMount() {
    await Permissions.askAsync(Permissions.CAMERA_ROLL);
    await Permissions.askAsync(Permissions.CAMERA);
  }

  render() {
    let { image } = this.state;

    return (
      <View style={styles.container}>
        <ScrollView
          style={styles.container}
          contentContainerStyle={styles.contentContainer}
        >
          <View style={styles.getStartedContainer}>
            {image ? null : (
              <Text style={styles.getStartedText}>Google Cloud Vision</Text>
            )}
          </View>

          <View style={styles.helpContainer}>
            <Button
              onPress={this._pickImage}
              title="Pick an image from camera roll"
            />

            <Button onPress={this._takePhoto} title="Take a photo" />
            {this.state.googleResponse && (
              <FlatList
                data={this.state.googleResponse.responses[0].labelAnnotations}
                extraData={this.state}
                keyExtractor={this._keyExtractor}
                renderItem={({ item }) => <Text>Item: {item.description}</Text>}
              />
            )}
            {this._maybeRenderImage()}
            {this._maybeRenderUploadingOverlay()}
          </View>
        </ScrollView>
      </View>
    );
  }

  organize = array => {
    return array.map(function (item, i) {
      return (
        <View key={i}>
          <Text>{item}</Text>
        </View>
      );
    });
  };

  _maybeRenderUploadingOverlay = () => {
    if (this.state.uploading) {
      return (
        <View
          style={[
            StyleSheet.absoluteFill,
            {
              backgroundColor: 'rgba(0,0,0,0.4)',
              alignItems: 'center',
              justifyContent: 'center'
            }
          ]}
        >
          <ActivityIndicator color="#fff" animating size="large" />
        </View>
      );
    }
  };

  _maybeRenderImage = () => {
    let { image, googleResponse } = this.state;
    if (!image) {
      return;
    }

    return (
      <View
        style={{
          marginTop: 20,
          width: 250,
          borderRadius: 3,
          elevation: 2
        }}
      >
        <Button
          style={{ marginBottom: 10 }}
          onPress={() => this.submitToGoogle()}
          title="Analyze!"
        />

        <View
          style={{
            borderTopRightRadius: 3,
            borderTopLeftRadius: 3,
            shadowColor: 'rgba(0,0,0,1)',
            shadowOpacity: 0.2,
            shadowOffset: { width: 4, height: 4 },
            shadowRadius: 5,
            overflow: 'hidden'
          }}
        >
          <Image source={{ uri: image }} style={{ width: 250, height: 250 }} />
        </View>
        <Text
          onPress={this._copyToClipboard}
          onLongPress={this._share}
          style={{ paddingVertical: 10, paddingHorizontal: 10 }}
        />

        <Text>Raw JSON:</Text>

        {googleResponse && (
          <Text
            onPress={this._copyToClipboard}
            onLongPress={this._share}
            style={{ paddingVertical: 10, paddingHorizontal: 10 }}
          >
            JSON.stringify(googleResponse.responses)}
          </Text>
        )}
      </View>
    );
  };

  _keyExtractor = (item, index) => item.id;

  _renderItem = item => {
    <Text>response: {JSON.stringify(item)}</Text>;
  };

  _share = () => {
    Share.share({
      message: JSON.stringify(this.state.googleResponse.responses),
      title: 'Check it out',
      url: this.state.image
    });
  };

  _copyToClipboard = () => {
    Clipboard.setString(this.state.image);
    alert('Copied to clipboard');
  };

  _takePhoto = async () => {
    let pickerResult = await ImagePicker.launchCameraAsync({
      allowsEditing: true,
      aspect: [4, 3]
    });

    this._handleImagePicked(pickerResult);
  };

  _pickImage = async () => {
    let pickerResult = await ImagePicker.launchImageLibraryAsync({
      allowsEditing: true,
      aspect: [4, 3]
    });

    this._handleImagePicked(pickerResult);
  };

  _handleImagePicked = async pickerResult => {
    try {
      this.setState({ uploading: true });

      if (!pickerResult.cancelled) {
        uploadUrl = await uploadImageAsync(pickerResult.uri);
        this.setState({ image: uploadUrl });
      }
    } catch (e) {
      console.log(e);
      alert('Upload failed, sorry :(');
    } finally {
      this.setState({ uploading: false });
    }
  };

  submitToGoogle = async () => {
    try {
      this.setState({ uploading: true });
      let { image } = this.state;
      let body = JSON.stringify({
        requests: [
          {
            features: [
              { type: 'LABEL_DETECTION', maxResults: 10 },
              { type: 'LANDMARK_DETECTION', maxResults: 5 },
              { type: 'FACE_DETECTION', maxResults: 5 },
              { type: 'LOGO_DETECTION', maxResults: 5 },
              { type: 'TEXT_DETECTION', maxResults: 5 },
              { type: 'DOCUMENT_TEXT_DETECTION', maxResults: 5 },
              { type: 'SAFE_SEARCH_DETECTION', maxResults: 5 },
              { type: 'IMAGE_PROPERTIES', maxResults: 5 },
              { type: 'CROP_HINTS', maxResults: 5 },
              { type: 'WEB_DETECTION', maxResults: 5 }
            ],
            image: {
              source: {
                imageUri: image
              }
            }
          }
        ]
      });
      let response = await fetch(
        'https://vision.googleapis.com/v1/images:annotate?key=' +
          Environment['GOOGLE_CLOUD_VISION_API_KEY'],
        {
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
          },
          method: 'POST',
          body: body
        }
      );
      let responseJson = await response.json();
      console.log(responseJson);
      this.setState({
        googleResponse: responseJson,
        uploading: false
      });
    } catch (error) {
      console.log(error);
    }
  };
}

async function uploadImageAsync(uri) {
  const blob = await new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      resolve(xhr.response);
    };
    xhr.onerror = function (e) {
      console.log(e);
      reject(new TypeError('Network request failed'));
    };
    xhr.responseType = 'blob';
    xhr.open('GET', uri, true);
    xhr.send(null);
  });

  const ref = firebase.storage().ref().child(uuid.v4());
  const snapshot = await ref.put(blob);

  blob.close();

  return await snapshot.ref.getDownloadURL();
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    paddingBottom: 10
  },
  developmentModeText: {
    marginBottom: 20,
    color: 'rgba(0,0,0,0.4)',
    fontSize: 14,
    lineHeight: 19,
    textAlign: 'center'
  },
  contentContainer: {
    paddingTop: 30
  },

  getStartedContainer: {
    alignItems: 'center',
    marginHorizontal: 50
  },

  getStartedText: {
    fontSize: 17,
    color: 'rgba(96,100,109, 1)',
    lineHeight: 24,
    textAlign: 'center'
  },

  helpContainer: {
    marginTop: 15,
    alignItems: 'center'
  }
});
```

Note that, most of the source code for accessing and uploading to Firebase is taken from an example of using Expo with Firebase [here](https://github.com/expo/firebase-storage-upload-example). I am going to explain below the bits that are essential to connect and run Firebase. First, let us start by understanding what `uploadImageAsync` is doing.

```js
async function uploadImageAsync(uri) {
  const blob = await new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      resolve(xhr.response);
    };
    xhr.onerror = function (e) {
      console.log(e);
      reject(new TypeError('Network request failed'));
    };
    xhr.responseType = 'blob';
    xhr.open('GET', uri, true);
    xhr.send(null);
  });

  const ref = firebase.storage().ref().child(uuid.v4());
  const snapshot = await ref.put(blob);

  blob.close();

  return await snapshot.ref.getDownloadURL();
}
```

As shown in the above snippet, the `uploadImageAsync` function uploads the image by creating a unique image ID or blob with the help of `uuid`. It also uses `xhr` to send a request to the Firebase storage to upload the image. We are also defining a default state in the `App` component and asking for User Permissions for both using the camera roll or gallery or take a photo from the device's camera as shown in the code snippet below.

```js
state = {
    image: null,
    uploading: false,
    googleResponse: null
  };

  async componentDidMount() {
    await Permissions.askAsync(Permissions.CAMERA_ROLL);
    await Permissions.askAsync(Permissions.CAMERA);
 }
```

The `Button` in our `App component` publishes the image to Google's Cloud Vision API.

```js
<Button
  style={{ marginBottom: 10 }}
  onPress={() => this.submitToGoogle()}
  title="Analyze!"
/>
```

The `submitToGoogle` method is what sends requests and communicates with the API to fetch the result when the button `Analyze` is pressed by the user.

```js
submitToGoogle = async () => {
   try {
     this.setState({ uploading: true });
     let { image } = this.state;
     let body = JSON.stringify({
       requests: [
         {
           features: [
             { type: "LABEL_DETECTION", maxResults: 10 },
             { type: "LANDMARK_DETECTION", maxResults: 5 },
             { type: "FACE_DETECTION", maxResults: 5 },
             { type: "LOGO_DETECTION", maxResults: 5 },
             { type: "TEXT_DETECTION", maxResults: 5 },
             { type: "DOCUMENT_TEXT_DETECTION", maxResults: 5 },
             { type: "SAFE_SEARCH_DETECTION", maxResults: 5 },
             { type: "IMAGE_PROPERTIES", maxResults: 5 },
             { type: "CROP_HINTS", maxResults: 5 },
             { type: "WEB_DETECTION", maxResults: 5 }
           ],
           image: {
             source: {
               imageUri: image
             }
           }
         }
       ]
     });
     let response = await fetch(
       "https://vision.googleapis.com/v1/images:annotate?key=" +
         Environment["GOOGLE_CLOUD_VISION_API_KEY"],
       {
         headers: {
           Accept: "application/json",
           "Content-Type": "application/json"
         },
         method: "POST",
         body: body
       }
     );
     let responseJson = await response.json();
     console.log(responseJson);
     this.setState({
       googleResponse: responseJson,
       uploading: false
     });
   } catch (error) {
     console.log(error);
   }
 };
}
```

The Vision API uses HTTP Post request as a REST API endpoint to perform data analysis on images you send in the request. This is done via the URL `https://vision.googleapis.com/v1/images:annotate`. To authenticate each request, we need the API key. The body of this POST request is in JSON format. For example:

```json
{
  "requests": [
    {
      "image": {
        "content": "/9j/7QBEUGhvdG9...image contents...eYxxxzj/Coa6Bax//Z"
      },
      "features": [
        {
          "type": "LABEL_DETECTION",
          "maxResults": 1
        }
      ]
    }
  ]
}
```

You can change the value of `maxResults` for every category. The response from the Vision API is also in JSON format.

```json
"labelAnnotations": Array [
 Object {
   "description": "water",
   "mid": "/m/0838f",
   "score": 0.97380537,
   "topicality": 0.97380537,
 },
 Object {
   "description": "waterfall",
   "mid": "/m/0j2kx",
   "score": 0.97099465,
   "topicality": 0.97099465,
 },
 Object {
   "description": "nature",
   "mid": "/m/05h0n",
   "score": 0.9594912,
   "topicality": 0.9594912,
 }
]
```

The above result can be viewed in the terminal from Expo logs. You can see how the application works with a short demo done on iOS simulator below.

![demo](https://i.imgur.com/z0i8Tpi.gif)

If you visit the storage section in Firebase, you can notice that each image is stored with a name of base64 binary string.

![ss5](https://i.imgur.com/lPrHrQUg.png)

If you have a real device, just download the Expo client, scan the QR code and then you can try the `Take a photo` feature inside the application.

## Conclusion

In this tutorial, weâ€™ve shown you how to integrate Firebase storage services and use a machine learning API such as Google's Vision API with a React Native and Expo application.

You can find the complete code inside [this Github repo](https://github.com/amandeepmittal/google-vision-rn-demo).

---

## How to handle Deep Linking in a React Native app
Slug: handle-deep-linking-react-native

![cover](https://i.imgur.com/cHaZZW8.jpg)

> Originally published at [Jscrambler](https://jscrambler.com/blog/how-to-handle-deep-linking-in-a-react-native-app)

Deep Linking is a technique in which a given URL or resource is used to open a specific page or screen on mobile. So, instead of just launching the app on mobile, a deep link can lead a user to a specific screen within the app, providing a better user experience. This particular screen may reside under a series of hierarchical pages, hence the term "deep" in deep linking.

It is useful for marketing campaigns, app-user retention, etc. As an application user, you probably have experienced deep linking when opening a link, for example, for a product in an ecommerce store from the web browser. If you have the app of that shop installed, it may use a deep link to open the app navigate you directly to that productâ€™s screen.

In this tutorial, let's learn how to handle deep linking in a React Native app by creating an example app. We will create a simple app that will handle deep linking and go through configuring deep linking using [React Navigation](https://reactnavigation.org/docs/getting-started/) library.

Source code of the example app is available at this [GitHub Repo](https://github.com/amandeepmittal/react-native-examples/tree/main/rnDeepLinking).

## Configuring navigation in a React Native app

Let's start by creating a new React Native application. First, open up a terminal and run the following command:

```shell
npx react-native init rnDeepLinking

# after the project is generated by the above command
# navigate to the rnDeepLinking directory
cd rnDeepLinking
```

The example app you will build in this tutorial will contain two screens. The first screen will be the Home screen with a list of items. The second screen will be the Details screen which shows an item's details.

Let's configure [React Navigation version 6](https://reactnavigation.org/docs/hello-react-navigation) and install the required dependencies. This will allow configuring deep linking via navigation and navigating between two screens.

```shell
yarn add @react-navigation/native @react-navigation/native-stack react-native-screens react-native-safe-area-context
```

The next step is to link all the libraries you just installed. This example app uses the `0.67.x` React Native version.

On iOS devices, you have to run the following set of commands.

```shell
npx pod-install ios
```

For Android, open the file `android/app/src/main/java/<Your React Native Project Name>/MainActivity.java` and add the following code snippet:

```java
package com.rndeeplinking;

import android.os.Bundle;
import com.facebook.react.ReactActivity;

public class MainActivity extends ReactActivity {

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  @Override
  protected String getMainComponentName() {
    return "rnDeepLinking";
  }
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(null);
  }
}
```

That's all you need to configure React Navigation library in a bare React Native app.

_Note_: The process to configure React Navigation library in a bare React Native project may change in the future. It is recommended to follow instructions from their [official documentation](https://reactnavigation.org/docs/getting-started).

## Creating Home and Details screens

Create a new directory called `src/screens`. This will contain all the screen components of the app. Inside it, create two new files: `HomeScreen.js` and `DetailsScreen.js`.

The `HomeScreen.js` file displays a list of persons from an array of mock data from a [Json placeholder API](https://jsonplaceholder.typicode.com/users). The list is rendered using a `FlatList` component from React Native.

Each list person is wrapped by the `Pressable` component so that when an app user presses a user's name from the list, they will navigate to the Details screen.

```js
// src/screens/HomeScreen.js

import React, { useState, useEffect } from 'react';
import {
  ActivityIndicator,
  View,
  Text,
  FlatList,
  Pressable
} from 'react-native';

import Separator from '../components/Separator';

const HomeScreen = ({ navigation }) => {
  const [data, setData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(res => res.json())
      .then(res => {
        setData(res);
        setIsLoading(false);
      })
      .catch(error => {
        console.log(error);
      });
  }, []);

  const renderList = ({ item }) => {
    return (
      <Pressable
        onPress={() => alert('Navigate to Details screen')}
        style={{ paddingHorizontal: 10 }}
      >
        <Text style={{ fontSize: 24, color: '#000' }}>{item.name}</Text>
      </Pressable>
    );
  };

  return (
    <View style={{ flex: 1 }}>
      {isLoading ? (
        <ActivityIndicator color="blue" size="large" />
      ) : (
        <>
          <FlatList
            data={data}
            contentContainerStyle={{
              paddingVertical: 20
            }}
            keyExtractor={item => item.id}
            ItemSeparatorComponent={Separator}
            renderItem={renderList}
          />
        </>
      )}
    </View>
  );
};

export default HomeScreen;
```

Let's also create a new file inside the `src/components` directory and call it `Separator.js`. This file contains a `<Separator />` component is used to divide a list item in the `HomeScreen`. The `<Separator />` component is a simple `View` with some additional styles.

It is used as a value for the prop `ItemSeparatorComponent` in the `FlatList` component. The `ItemSeparatorComponent` prop defines a custom separator and is rendered between each item in the list.

```js
// src/components/Separator.js

import React from 'react';
import { View } from 'react-native';

const Separator = () => (
  <View
    style={{
      borderBottomColor: '#d3d3d3',
      borderBottomWidth: 1,
      marginTop: 10,
      marginBottom: 10
    }}
  />
);

export default Separator;
```

For the details screen, for now, let us just display a text string in the screen component file `DetailsScreen.js`:

```js
import React from 'react';
import { View, Text } from 'react-native';

const DetailsScreen = ({ navigation }) => {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>Details Screen</Text>
    </View>
  );
};

export default DetailsScreen;
```

## Setting up Stack Navigator

To set up a Stack Navigator in the app, create a new file called `src/navigation/RootNavigator.js` and add the following code snippet:

```js
// src/navigation/RootNavigator.js

import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import HomeScreen from '../screens/HomeScreen';
import DetailsScreen from '../screens/DetailsScreen';

const RootStack = createNativeStackNavigator();

const RootNavigator = () => {
  return (
    <NavigationContainer>
      <RootStack.Navigator>
        <RootStack.Screen name="Home" component={HomeScreen} />
        <RootStack.Screen name="Details" component={DetailsScreen} />
      </RootStack.Navigator>
    </NavigationContainer>
  );
};

export default RootNavigator;
```

Then, import `RootNavigator` in the `App.js` file:

```js
// App.js

import React from 'react';

import RootNavigator from './src/navigation/RootNavigator';

const App = () => {
  return <RootNavigator />;
};

export default App;
```

To build and run the app, open two instances of the terminal window. In the first instance, run `npx react-native start`. This will start the React Native packager.

To build the app for iOS or Android, run the appropriate command from the second instance of the terminal window. This will build the app for the platform you specify.

```shell
# for iOS
npx react-native run-ios

# for android
npx react-native run-android
```

Once the app is built, the above command will install it on the specified platform. Here is an example of the app running on an iOS simulator and a real Android device:

![js1](https://i.imgur.com/nSev8DI.png)

## Configuring Deep Linking in React Navigation

There are two ways to handle [Deep Linking](https://reactnative.dev/docs/linking) in a React Native app:

- Without navigation: by invoking React Native's core library via JavaScript and directly calling `Linking`. You can learn more about this in [React Native's official documentation](https://reactnative.dev/docs/linking#handling-deep-links)
- With navigation: by configuring React Navigation library

Most production-grade applications have multiple screens and nested navigators. So let's see how to implement it with React Navigation in our example app.

To allow React Navigation library to handle deep links through its routing logic, you need to define a configuration object. In this object, define a `prefixes` property that contains a URI scheme. The app is open based on this URI scheme.

This configuration object is then passed to a prop called `linking` on the `NavigationContainer`. Also, add a `fallback` prop on the container. It will render and display a loading indicator until the deep link is resolved.

```js
// src/navigation/RootNavigator.js

// rest of the import statement remains same
import { ActivityIndicator } from 'react-native';

const linking = {
  prefixes: ['peoplesapp://']
};

const RootNavigator = () => {
  return (
    <NavigationContainer
      linking={linking}
      fallback={<ActivityIndicator color="blue" size="large" />}
    >
      <RootStack.Navigator>
        <RootStack.Screen name="Home" component={HomeScreen} />
        <RootStack.Screen name="Details" component={DetailsScreen} />
      </RootStack.Navigator>
    </NavigationContainer>
  );
};
```

## Using uri-scheme package to configure URI schemes

Instead of manually setting up URI schemes for iOS and Android, you can use the [uri-scheme](https://www.npmjs.com/package/uri-scheme) npm package. It allows configuring and testing native URI schemes on iOS and Android devices. Thanks to the [Expo team](https://expo.dev/) for creating this package and making it available to make our developer life easier.

_Note:_ If you want to dive deep and set up URI schemes manually for both iOS and Android, check out the next two sections.

To set up the scheme, run the following command for the appropriate platform:

```shell
# for iOS
npx uri-scheme add peoplesapp --ios

# for Android
npx uri-scheme add peoplesapp --android
```

After this step, make sure to build the app again for the specific platform using either `npx react-native run-ios` or `npx react-native run-android`.

## Configuring scheme for iOS

To manually set up the scheme for iOS devices, open the `ios/your-project-name/AppDelegate.m` file and add the following code snippet:

```c
// Add the header at the top of the file:
#import <React/RCTLinkingManager.h>

// Add this above `@end`:
- (BOOL)application:(UIApplication *)application
   openURL:(NSURL *)url
   options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options
{
  return [RCTLinkingManager application:application openURL:url options:options];
}
```

Now, let's add the URI scheme to the iOS project configuration. Open, `Your-app-name/ios/app-name.xcworkspace` in Xcode.

Then, select the project name in the left sidebar and navigate to the **Info** tab:

![js2](https://i.imgur.com/2QOjwXa.png)

Next, go to the URL Types, click the **+ (plus) button**, and under the Identifier and URL schemes, add `peoplesapp`.

![js3](https://i.imgur.com/in5NQHl.png)

The **URL Types** are similar to what `http` represents in a web URL. It is what is used by iOS to open the app.

After this configuration step, rebuild your iOS app using `npx react-native run-ios`.

## Configuring scheme for Android

To manually set up a scheme for Android devices, you have to configure the scheme. `Open /android/app/src/main/AndroidManifest.xml` and set the value of `launchMode` to `singleTask`. To add the scheme, add a new `intent-filter` tag as shown below:

```xml
<!-- Set the launchMode to singleTask in <activity> -->
<activity
  android:name=".MainActivity"
  android:label="@string/app_name"
  android:configChanges="keyboard|keyboardHidden|orientation|screenSize|uiMode"
  android:launchMode="singleTask"
  android:windowSoftInputMode="adjustResize">
  <intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
  <!-- Add this new intent-filter tag -->
  <!-- Make sure to set the value of android:scheme to your own scheme -->
  <intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="peoplesapp" />
  </intent-filter>
</activity>
```

After this configuration step, rebuild your Android app using `npx react-native run-android`.

## Testing the iOS app

To test out the configuration you have set up so far, run the iOS app, and open up the iOS simulator. If the example app is already running, close it before testing.

Then, from a terminal window, run the following command:

```shell
# replace peoplesapp:// with your own URL
xcrun simctl openurl booted peoplesapp://

# OR use uri-scheme package to test
npx uri-scheme open peoplesapp:// --ios
```

This will open the example app:

![js4](https://i.imgur.com/dbs8gzj.gif)

You can also test it by opening up a web browser in your simulator device and running the URL `peoplesapp://`. It is going to ask you to whether open the external URI or not, as shown below:

![js5](https://i.imgur.com/PrPP5RB.gif)

## Testing the Android app

To test out the configuration set up so far, I am using a real Android device. You can also use an Android emulator. Make sure to close the example app if it is already running before testing.

From a terminal window, run the following command:

```shell
# replace peoplesapp:// with your own URL
adb shell am start -W -a android.intent.action.VIEW -d "peoplesapp://"

# OR use uri-scheme package to test
npx uri-scheme open peoplesapp:// --android
```

Here is the output after running the above command:

![js6](https://i.imgur.com/wWsOWqe.gif)

## Nested screen configuration

You can extend the `linking` config object to define a specific path for each screen. This is useful, especially when you have multiple screens and link to each specific screen.

In the example app, let's define linking paths for both the Home and Details screen. Modify the `linking` config object in the `src/navigation/RootNavigator.js` file as shown below:

```js
const linking = {
  prefixes: ['peoplesapp://'],
  config: {
    initialRouteName: 'Home',
    screens: {
      Home: {
        path: 'home'
      },
      Details: {
        path: 'details'
      }
    }
  }
};
```

The `initialRouteName` is the name of the initial screen. The back button is not shown by default when linking to a nested screen. Using the property, you can define a screen name to go back, within the app.

The `screens` property maps screen names to screen paths. The screen `path` is the path that is used to link to the screen.

Now, let's test it out. Make sure to quit the app before testing.

![js7](https://i.imgur.com/k5Y4YrL.gif)

The screen path configuration works as expected.

## Accessing dynamic parameters in a route

To display information of each person when visiting the Details screen with the URL scheme, you have to configure the `path` for the Details screen and add a dynamic parameter that represents the person's id from the list.

```js
const linking = {
  prefixes: ['peoplesapp://'],
  config: {
    initialRouteName: 'Home',
    screens: {
      Home: {
        path: 'home'
      },
      Details: {
        path: 'details/:personId'
      }
    }
  }
};
```

The `personId` is now available to the Details screen as a [route parameter](https://reactnavigation.org/docs/params/). Route parameters are accessible to a screen using `route.params` from React Navigation library.

Based on the `personId` value, the Details screen will fetch the data from the API and display the person's information.

Let's also handle the case where an app user navigates to the Details screen from the Home screen, that is, without using linking. In this case, open `HomeScreen.js` and replace the value `onPress` prop on the `Pressable` component as shown below:

```js
// src/screens/HomeScreen.js

<Pressable
  onPress={() => navigation.navigate('Details', { personDetailsId: item.id })}
  style={{ paddingHorizontal: 10 }}
>
  <Text style={{ fontSize: 24, color: '#000' }}>{item.name}</Text>
</Pressable>
```

Notice that the `personDetailsId` is a route parameter passed to the Details screen in the above snippet. This will only fetch a person's details when the user navigates to the Details screen from the Home screen.

In the Details screen, let's get both `personDetailsId` (the id coming from the Home screen) and `personId` (the id used from the URL scheme) from the `route.params` object.

Then using a `useEffect` hook, fetch data from Json Placeholder API and render the details:

```js
import React, { useState, useEffect } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

const DetailsScreen = ({ route }) => {
  const params = route.params || {};
  const { personDetailsId, personId } = params;

  const [data, setData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (personId) {
      fetch(`https://jsonplaceholder.typicode.com/users/${personId}`)
        .then(res => res.json())
        .then(res => {
          const fetchedDetails = [];

          Object.keys(res).forEach(key => {
            fetchedDetails.push({ key, value: `${res[key]}` });
          });
          setData(fetchedDetails);
          setIsLoading(false);
        })
        .catch(error => {
          console.log(error);
        });
    } else {
      fetch(`https://jsonplaceholder.typicode.com/users/${personDetailsId}`)
        .then(res => res.json())
        .then(res => {
          const fetchedDetails = [];

          Object.keys(res).forEach(key => {
            fetchedDetails.push({ key, value: `${res[key]}` });
          });

          setData(fetchedDetails);
          setIsLoading(false);
        })
        .catch(error => {
          console.log(error);
        });
    }
  }, []);

  return (
    <View style={{ flex: 1 }}>
      {isLoading ? (
        <ActivityIndicator color="blue" size="large" />
      ) : (
        <View style={{ paddingTop: 10, paddingHorizontal: 10 }}>
          {data.map(person => (
            <Text
              style={{ fontSize: 24, paddingBottom: 2 }}
              key={person.key}
            >{`${person.key}: ${person.value}`}</Text>
          ))}
        </View>
      )}
    </View>
  );
};

export default DetailsScreen;
```

Here is the output when you navigate from the Home to Details screen by pressing on a person's name from the list:

![js8](https://i.imgur.com/yA8Yi66.gif)

Here is the output when using the URL scheme:

![js9](https://i.imgur.com/vinhEG4.gif)

## Conclusion

You have now finished a complete demo of a React Native app that handles deep linking using React Navigation library.

Deep linking can bring significant improvements to the user experience of your mobile apps and enable search engines to provide [context-sensitive searches and results](https://techbeacon.com/app-dev-testing/state-mobile-development-deep-linking-containerization-iot). Hopefully, this guide will help you achieve great results in your own app.

---

## Handle different field types in React Native forms with formik and yup
Slug: handle-different-field-types-in-react-native-forms

In the [previous post](https://amanhimself.dev/build-validate-forms-with-react-native-formik-yup), you did a lot of things. From creating Login and Signup forms from scratch and using powerful libraries like Formik and yup to validate those forms.

In this tutorial, let us extend our knowledge of building and validating forms by handling different input field types other than strings. You are also going to take a look at my share of the solution on how to gracefully create a Confirm Password field and validate it using the reference of already setup `password` field.

Lastly, there is a small bonus section that will allow you to complete the UI of the form. You are going to add a toggle icon to show or hide the password for the user to re-check.

This tutorial is going to use an already setup source code from [**this Github repo**](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.2.0) release.

After installing the source code, please navigate inside the project directory and install dependencies by running the following command:

```shell
npm install

# or

yarn install
```

## Table of Contents

- Requirements
- Adding Confirm Password Field to Signup Screen
- Handling a CheckBox with Formik and Yup
- Bonus: Hide/Show Password fields
- Conclusion

## Requirements

To follow this tutorial, please make sure you following installed on your local development environment and access to the services mentioned below.

- Nodejs (>= `10.x.x`) with npm/yarn installed
- expo-cli (>= `3.x.x`), (previously known as create-react-native-app)

## Adding Confirm Password Field to Signup Screen

In the [**last post**](LINK HERE), I left you with a challenge to figure out how to add validation for confirm password field in the signup screen using `yup`. If you succeeded, please skip this section and move on the next one. If you are still curious about it, open `Signup.js` file and a new input field for the confirm password as well as a new property with the same name in the `initialValues` object of `Formik` element.

```js
<Formik
  initialValues={{
    name: '',
    email: '',
    password: '',
    // add this
    confirmPassword: ''
  }}
  onSubmit={values => {
    this.handleSubmit(values);
  }}
  validationSchema={validationSchema}
>
  {({
    handleChange,
    values,
    handleSubmit,
    errors,
    isValid,
    touched,
    handleBlur,
    isSubmitting
  }) => (
    <Fragment>
      {/* Rest of the code remains same */}
      <FormInput
        name="password"
        value={values.confirmPassword}
        onChangeText={handleChange('confirmPassword')}
        placeholder="Confirm password"
        secureTextEntry
        iconName="ios-lock"
        iconColor="#2C384A"
        onBlur={handleBlur('confirmPassword')}
      />
      <ErrorMessage
        errorValue={touched.confirmPassword && errors.confirmPassword}
      />
      <View style={styles.buttonContainer}>
        <FormButton
          buttonType="outline"
          onPress={handleSubmit}
          title="SIGNUP"
          buttonColor="#F57C00"
          disabled={!isValid || isSubmitting}
          loading={isSubmitting}
        />
      </View>
    </Fragment>
  )}
</Formik>
```

In the `validationSchema` object add a new property called `confirmPassword` that is going to be a string. Next, use `oneOf` method from Yup's API. Inside its array parameter, it accepts a `Yup.ref()` which creates a reference to another sibling from the `initialValues` object.

```js
const validationSchema = Yup.object().shape({
  name: Yup.string()
    .label('Name')
    .required()
    .min(2, 'Must have at least 2 characters'),
  email: Yup.string()
    .label('Email')
    .email('Enter a valid email')
    .required('Please enter a registered email'),
  password: Yup.string()
    .label('Password')
    .required()
    .min(4, 'Password must have more than 4 characters '),

  // add this
  confirmPassword: Yup.string()
    .oneOf([Yup.ref('password')], 'Confirm Password must matched Password')
    .required('Confirm Password is required')
});
```

The `Yup.ref('password')` here refers to the actual `password` field. Let us try to add a different password to both of these fields and see what happens.

I am going to add `pass` to the `password` field (_since it accepts four minimum characters_) and `passo` to the `confirmPassword` field.

![1](https://i.imgur.com/p9CEa5H.gif)

See the error message being displayed when both input fields do not match.

## Handling a CheckBox with Formik and Yup

You can create and validate other field types using Formik and Yup. In this section, you are going to achieve that by creating a checkbox field that is quite common when signing up into new applications where they make you agree to all of their terms and app policies.

Open `Signup.js` file and the following [checkbox element](https://react-native-training.github.io/react-native-elements/docs/checkbox.html#docsNav) from `react-native-elements` library. It is going to contain a boolean value. In the `initialValues` object, please add that.

```js
// import checkbox element
import { Button, CheckBox } from 'react-native-elements'

initialValues={{
  name: '',
  email: '',
  password: '',
  confirmPassword: '',
  // add "check" to initial values
  check: false
}}
```

At the checkbox, there is a prop called `checked` that is required. It holds the current value of the element whether it checked or not. After you have defined the `confirmPassword` input field, please state the following.

```js
<CheckBox
  containerStyle={styles.checkBoxContainer}
  checkedIcon="check-box"
  iconType="material"
  uncheckedIcon="check-box-outline-blank"
  title="Agree to terms and conditions"
  checkedTitle="You agreed to our terms and conditions"
  checked={values.check}
  onPress={() => setFieldValue('check', !values.check)}
/>
```

The required prop `checked` that changes the icon to check or uncheck. By default, it will be marked uncheck. The `uncheckedIcon` prop takes the value of an icon. The `title` prop's value of the checkbox when marked check, changes to the value of `checkedTitle`. These are fair advantages of using a component library like `react-native-elements`.

Using `setFieldValue` from Formik props, you can set the value of the `check` to true or false. It accepts the reference of the key `check` itself as the first parameter. `!values.check` states the opposite of the current value of the key `check`.

Lastly, edit the `validationSchema` by adding the key `check`. It is going to use boolean schema type.

```js
check: Yup.boolean().oneOf([true], 'Please check the agreement');
```

See the below demonstration on how it works.

![2](https://i.imgur.com/pj1wjhS.gif)

## Bonus: Hide/Show Password fields

In this section, you are going to add the ability to hide or show the password on the corresponding field. By the end of this section, the password input field is going to look like this.

<img src='https://cdn-images-1.medium.com/max/800/1*1-32GyAIseC81jkInsRxSg.png' />

To start, open `Login.js` file and import `TouchableOpacity` from `react-native` and `Ionicons` from expo's vector icons library which comes with Expo SDK.

```js
import { StyleSheet, SafeAreaView, View, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
```

Next step is to define an initial state inside the `Login` component. This will help track of the current icon being shown and the visibility of the password.

```js
state = {
  passwordVisibility: true,
  rightIcon: 'ios-eye'
};
```

The define a handler method that will trigger on the `onPress` prop of `TouchableOpacity`. It checks the previous state of the icon and the password's visibility field.

```js
handlePasswordVisibility = () => {
  this.setState(prevState => ({
    rightIcon: prevState.rightIcon === 'ios-eye' ? 'ios-eye-off' : 'ios-eye',
    passwordVisibility: !prevState.passwordVisibility
  }));
};
```

Then go to the password input field and add the prop `rightIcon` from `react-native-elements`, you are going to pass the `TouchableOpacty` for the icon to be touchable and trigger some function (_in this case, handlePasswordVisibility_).

Also, tame the prop `secureEntryText`. It accepts a boolean as its value, and that is what `passwordVisibility` is. If its value is true, which is the initial state, it will secure the password field entry. When clicked on the icon, the visibility is going to change to false, and then the password will be shown.

```js
secureTextEntry={passwordVisibility}
rightIcon={
  <TouchableOpacity onPress={this.handlePasswordVisibility}>
    <Ionicons name={rightIcon} size={28} color='grey' />
  </TouchableOpacity>
}
```

This is the output you are going to get.

<img src='https://cdn-images-1.medium.com/max/800/1*m5e8YiiykjcR2h9-PuqwqA.gif' />

## Conclusion

That's it. This post and the [previous one](https://amanhimself.dev/build-validate-forms-with-react-native-formik-yup) covers enough to get you started and create forms in advance forms in React Native apps using formik and yup.

You can go ahead and add the toggle password visibility to the `Signup` form screen as well. You will find the source code from [**this Github repo**](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.5.0) release.

[Originally published at Heartbeat](https://heartbeat.fritz.ai/handling-different-field-types-in-react-native-forms-with-formik-and-yup-fa9ea89d867e)

---

## How to handle navigation in WebViews in a React Native app
Slug: handle-navigation-in-webviews-react-native

As a React Native developer, you are going to come across use cases that will require you to embed or redirect a web application or a web page inside a React Native app. [WebViews](https://facebook.github.io/react-native/docs/webview.html) are often used for such use cases.

A community-maintained module, WebViews in React Native are the only way to let the user visit external links within an iOS or Android application. The WebView component in React Native core first became available in React Native version `0.57.x`.

In this tutorial, you are going to learn how to create a simple WebView component using `react-native-webview` npm module, and stretch it further to add custom navigation to handle URL history (just like in a web browser) using props provided y this module.

You can find the complete code for this tutorial at this [Github repo](https://github.com/amandeepmittal/react-native-examples/tree/master/rnWebViewCustomNav).

## Table of Contents

- Requirements
- Installing WebView package
- Implement a simple WebView
- Add a loading spinner
- Handle navigation when using WebViews
- Conclusion

## Requirements

- Nodejs version `<= 10.x.x` installed
- watchman installed
- Have access to one package manager such as npm or yarn
- use react native version `0.60.x` or above

## Installing WebView package

To generate a new React Native project you can use the react-native cli tool. open a terminal window and enter the following command.

```shell
npx react-native init [Project Name]
```

You can name your project anything you want. Make sure to navigate inside the project directory after it has been created. Then, install the `react-native-webview` dependency using a package manager.

```shell
yarn add react-native-webview
```

After the dependency has installed, you are going to config it to work on iOS and Android devices. For iOS devices make sure you install pods by navigating inside the `ios/` directory and execute the command `pod install`.

For Android users, if you are using the latest `react-native-webview` version (_which you are_) open the file `android/gradle.properties` and make sure the following two lines exist. If not, add them.

```groovy
android.useAndroidX=true
android.enableJetifier=true
```

Once the dependency installation is done, let us run the application. We are going to use an iOS simulator for this tutorial. If you are on Windows or Linux based operating systems, you can use Android Studio.

Run the command as stated below to open the boilerplate application that comes with `react-native-cli`.

```shell
# for Mac users
react-native run-ios

# for Windows/Linux users
react-native run-android
```

If the app opens without any error, that means the configuration we have done so far is good to go.

<img src='https://miro.medium.com/max/350/1*eYqHih1QsrZsxfiHsYnfPQ.png' />

## Implementing a simple WebView

In this section, let us create a simple webview component and understand how it works. Start by importing the `WebView` component from `react-native-webview` to render web content in a native view. Open the `App.js` file.

```js
import React from 'react';
import { SafeAreaView, StyleSheet, StatusBar } from 'react-native';
import WebView from 'react-native-webview';
```

The `WebView` component requires a `source` prop. This prop loads the static HTML or a URI (which is the current case if you look closely at the above snippet). A URI is a remote location for a web page to exist.

Inside the `App` function component let us render this simple webview component.

```js
const App = () => {
  return (
    <>
      <StatusBar barStyle="dark-content" />
      <SafeAreaView style={styles.flexContainer}>
        <WebView source={{ uri: 'https://heartbeat.fritz.ai/' }} />
      </SafeAreaView>
    </>
  );
};

const styles = StyleSheet.create({
  flexContainer: {
    flex: 1
  }
});

export default App;
```

To view this in action, make sure you build the React Native app for the first time using either of the command specified below from a terminal window. For Android users, if you are using a real device or a simulator, make sure it is running first. You are going to see a similar output as below:

<img src='https://miro.medium.com/max/350/1*l6ZpJ0_d8j58uJRMC-XLSQ.png' />

## Add a loading spinner

Did you notice that when the screen or the component loads for the first time, it just shows a blank white screen for a few seconds? This indicates that the web page is loading from the remote source. However, in a real-time application, you have to provide some type of loading indicator to the user to imply that the web page is being currently loaded.

This can be done by adding an `ActivityIndicator` component from the `react-native` core. It is going to display a spinner on the device's screen when the web page is in the loading state.

In the `App.js` file, among other imported components from `react-native`, import `ActivityIndicator`.

```js
// ... rest of the import statements
import {
  SafeAreaView,
  StyleSheet,
  StatusBar,
  ActivityIndicator
} from 'react-native';
```

To add a loading indicator that starts when the web page starts loading. Also, the indicator should stop when the web page has done loading.

The first requirement is that the prop `startInLoadingState` from `react-native-webview` module must be set to a value of true. Another prop, `renderLoading` is responsible for triggering the activity indicator. It always accepts a function as its value. The value of the function is going to be the `ActivityIndicator` component.

Add both of these props to `WebView` in `App.js`:

```js
<WebView
  source={{ uri: 'https://heartbeat.fritz.ai/' }}
  startInLoadingState={true}
  renderLoading={() => (
    <ActivityIndicator
      color="black"
      size="large"
      style={styles.flexContainer}
    />
  )}
/>
```

Take a look at how it works on the below screen.

<img src='https://miro.medium.com/max/377/1*m3pKSlirL8gqEXUHmlZc-A.gif' />

## Handle navigation when using WebViews

The [`WebView`](https://facebook.github.io/react-native/docs/webview) has a vast API and out of the box provides the most common functionalities that you can add to support different features in the app.

The `WebView` API provides some methods like `goBack` and `goForward` to handle navigation state and transitions. Such as the `goBack` method allows the user to go back one page at a time in the web view's history. Similarly, using the method `goForward`, you can move forward.

This navigation between web pages is done when there is a way to store or listen to the URL change. Using the prop called `onNavigationStateChange` that represents the navigation state of the component, you just need to pass the current URL and keep track of the previous and forward buttons.

The current is passed by creating a `ref` object which is the approach you are going to use in this demo app. It holds a mutable `.current` property that can be used to uniquely identify the URL.

I am going to use the latest Hooks syntax. If you are using the counterpart of the functional components, please make sure to check how to use `ref` property on the `WebView` instance inside the class component.

For those who have been following along this tutorial so far, please make sure that you import hooks such as `useRef`, and `useState` from React.

Also, import some more components from the react-native core that is going to help us add a footer to the app screen. This footer is going to have two buttons: one to go to the previous URL and one to go to the forward URL (if exists).

```js
import React, { useState, useRef } from 'react';
import {
  SafeAreaView,
  StyleSheet,
  StatusBar,
  ActivityIndicator,
  View,
  TouchableOpacity,
  Text
} from 'react-native';
import WebView from 'react-native-webview';
```

Inside the functional component `App`, let us create three state variables for the following purposes:

- `canGoBack`: to go the previous web page from the navigational state. Its initial value is going to be a boolean false.
- `canGoForward`: to go to the next web page in the navigational state. Its initial value is going to be a boolean false.
- `currentUrl` to keep a reference of the current URL. Its initial value is going to be an empty string.

Let us create these state variables inside the `App` component.

```js
const App = () => {
  const [canGoBack, setCanGoBack] = useState(false);
  const [canGoForward, setCanGoForward] = useState(false);
  const [currentUrl, setCurrentUrl] = useState('');

  //...
};
```

Use the `useRef` hook to create a `webviewRef` and define it after the state variables.

```js
const webviewRef = useRef(null);
```

Now, create two handler methods that are going to handle the navigational state transition of the current URL in real-time using the mutable property `current` on a button press.

```js
backButtonHandler = () => {
  if (webviewRef.current) webviewRef.current.goBack();
};

frontButtonHandler = () => {
  if (webviewRef.current) webviewRef.current.goForward();
};
```

Add the props `ref` and `onNavigationStateChange` to the `WebView` component. The `navState` is going to track the state changes and update it as well as fetch and set the current URL as shown below in the code snippet.

```js
<WebView
  source={{ uri: 'https://heartbeat.fritz.ai/' }}
  startInLoadingState={true}
  renderLoading={() => (
    <ActivityIndicator
      color="black"
      size="large"
      style={styles.flexContainer}
    />
  )}
  ref={webviewRef}
  onNavigationStateChange={navState => {
    setCanGoBack(navState.canGoBack);
    setCanGoForward(navState.canGoForward);
    setCurrentUrl(navState.url);
  }}
/>
```

After the `WebView` component, create a `View` component that holds two buttons. Each of the buttons is defined from `TouchableOpacity` that has an `onPress` prop. This prop is going to make use of the handler methods you defined earlier.

```jsx
<View style={styles.tabBarContainer}>
  <TouchableOpacity onPress={backButtonHandler}>
    <Text style={styles.button}>Back</Text>
  </TouchableOpacity>
  <TouchableOpacity onPress={frontButtonHandler}>
    <Text style={styles.button}>Forward</Text>
  </TouchableOpacity>
</View>
```

Here are the corresponding styles used in the above code snippet:

```js
const styles = StyleSheet.create({
  flexContainer: {
    flex: 1
  },
  tabBarContainer: {
    padding: 20,
    flexDirection: 'row',
    justifyContent: 'space-around',
    backgroundColor: '#b43757'
  },
  button: {
    color: 'white',
    fontSize: 24
  }
});
```

To see it in action, go back to the simulator/device of your choice and the first thing you are going to notice is the bottom tab bar on the screen.

<img src='https://miro.medium.com/max/350/1*5g5rXbyg4k1_J02DKL3QIA.png' />

Here is the complete demo in action with back and forward buttons working.

<img src='https://miro.medium.com/max/377/1*r2li3qWatN2JM_Pl9nhGBA.gif' />

## Conclusion

_Congratulations! You have completed this tutorial._

WebViews might not be the prominent way to create mobile apps but it does add an important feature to handle specific use cases where there is a requirement to connect web interfaces and native code.

The `WebView` component has a great API that you can refer [here](https://facebook.github.io/react-native/docs/webview).

You can find the complete code for this tutorial at this [Github repo](https://github.com/amandeepmittal/react-native-examples/tree/master/rnWebViewCustomNav).

Originally published at [Heartbeat.fritz.ai](https://heartbeat.fritz.ai/how-to-handle-navigation-with-webviews-in-a-react-native-app-1ed51ab3342f)

---

## How to use HarperDB instance with React Hooks
Slug: harperdb-with-react-hooks

![cover](https://i.imgur.com/jN0o3ij.png)

[HarperDB Cloud](https://harperdb.io/developers/get-started/?utm_source=amanmittal) is a database service that supports both SQL and NoSQL queries for CRUD operations. It needs minimal configuration to get started and its realm is not only limited to build REST APIs with a server-side technology such as Node.js.

HarperDB offers a way to access the database cloud instance directly in your client-side application. It has a built-in HTTP API that allows us to query data directly.

In this post, let's take a look at how we configure a HarperDB Cloud database instance and fetch the data by querying the database within a Reactjs app. HarperDB provides a React Hook, known as [useHarperDB](https://github.com/HarperDB/harperdb-sdk-react) to make our jobs easier.

## HarperDB instance glossary

This post is going to use a similar instance of the HarperDB database that we built using the REST API approach with Node.js in our [previous post](https://amanhimself.dev/blog/build-rest-api-with-nodejs-harperdb). Please take a look at the post on how to set up the cloud instance [here](https://amanhimself.dev/blog/build-rest-api-with-nodejs-harperdb#setting-up-an-instance-of-harperdb-cloud). This way you will have a populated table of data fields.

The schema in the above database instance is called `dev`. A schema in HarperDB is necessary. It is equivalent to a collection of tables. Without an existing schema you cannot create a new table and without a table, you cannot add or update data in the HarperDB instance.

Below the schema, there is an option to add one or more tables. In the above instance, there is a table already created and is called `outlets`. This table has a unique identifier `id` for each row of data.

On the right-hand side, you will find the data inside the table. Do notice the two timestamp fields. They are auto inserted by HarperDB whenever a new row adds to the table and is auto-maintained.

- **createdtime**: to record the timestamp when data is inserted.
- **updatedtime**: to record the timestamp when any data field is updated for the last time.

![ss0](https://i.imgur.com/iqb3tFI.png)

Once you have set up the cloud instance, make sure to use a React project with the library's version `16.8.0+`.

## Getting started

Start by creating a new React app. We are going to use this React app for building the example app in this post. Open up a terminal window and execute the following command:

```shell
npx create-react-app harperdb-integration-react

# after the project directory has been created
cd harperdb-integration-react

# install the following dependency
yarn add use-harperdb@0.1.2
```

Now you can start the development server to see the React app in action. Go to the terminal window and execute the command `yarn start`. You are going to get the following output in a browser window at URL: `http://localhost:3000/`.

![ss1](https://i.imgur.com/VTDySVc.png)

## Creating a user with custom roles

By default, the user created in the HarperDB Cloud instance is a superuser. It has admin rights to query and add data and rights to create and drop the table from the existing schema as well as create and drop new schemas. In a client-side application, we do not want to have a superuser. Since most client apps are public, this is never a good approach to use the default user.

The approach to resolve this is to create a new user that has the rights to only perform CRUD operations inside a data table. HarperDB provides a way to define custom user roles as well as create a new user using that role.

Start by opening your cloud instance and go to the tab `roles` [from the menu bar](https://harperdbhelp.zendesk.com/hc/en-us/articles/360051486534-Managing-Role-Permissions).

![ss2](https://i.imgur.com/tnoRgYP.png)

Here you can define a new **standard role** to create a custom one. Let's this new role, `client_user`.

![ss3](https://i.imgur.com/VFtacjy.png)

Once the new role is created, the instance prompts with the permissions we can assign to any user with this role. You are now allowed to configure the access to tables and schemas for this specific role. There is only one schema right now and inside it, there is only one data table. For this example, let's keep the default configuration and proceed by pressing the button **Update Role Permissions**.

![ss4](https://i.imgur.com/L5XyeIP.png)

Once the permissions are updated, go to the tab `users` next to the `roles` in the menu bar. This is used to add a new user with the custom role just created. From the drop-down menu, select the role `client_user`.

![ss5](https://i.imgur.com/D3sXeLD.png)

Click the **Add user** button to add the new user.

![ss6](https://i.imgur.com/nvVVhq6.png)

Now, we can use this custom user in the client React app to query the data from the table `outlets`.

## Integrating HarperDB in a React

The `use-harperdb` hook comes with a `HarperDBProvider` that is used to wrap the instance of the React app or the `App` component in general inside the `index.js` file. This is mandatory to execute a CRUD operation on the database instance.

Add the following import statement inside `src/index.js` file:

```js
// ... other import statements
import { HarperDBProvider } from 'use-harperdb';
```

To execute any CRUD operation on the database instance, the provider requires the db instance URL, the username, and the password associated with that user. We are going to make use of environmental variables to add these values.

Create a new file called `.env` at the root of the React project with the following variables. The values of these variables are mentioned as a description in `[]` but you must replace the square brackets and your own values.

```shell
REACT_APP_DB_URL=[Your Cloud Instance Provider URL]
REACT_APP_USER=[The name of the custom user with client_user role]
REACT_APP_PASSWORD=[The password associated with the custom user]
```

Create React App reads any environmental variables that are prefixed with `REACT_APP`. Instead of using a third-party library, we can directly use these environmental variables to provide necessary attributes to `HarperDBProvider`.

```js
ReactDOM.render(
  <React.StrictMode>
    <HarperDBProvider
      url={process.env.REACT_APP_DB_URL}
      user={process.env.REACT_APP_USER}
      password={process.env.REACT_APP_PASSWORD}
    >
      <App />
    </HarperDBProvider>
  </React.StrictMode>,
  document.getElementById('root')
);
```

That's it. We have successfully configured the React app to use the HarperDB database instance.

## Querying the data from HarperDB

To query the data from the database instance in the React app, the `useHarperDB` hook provides elements to do so.

Open the `App.js` file and import the hook from `use-harperdb`. Let's also set up a basic UI to display data when fetched.

```js
import React from 'react';
import './App.css';
import { useHarperDB } from 'use-harperdb';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <h2>Starbucks Outlets</h2>
        <table>
          <thead style={{ marginBottom: '20px' }}>
            <tr>
              <td style={{ textTransform: 'uppercase' }}>City</td>
              <td style={{ textTransform: 'uppercase' }}>Name</td>
              <td style={{ textTransform: 'uppercase' }}>Latitude</td>
              <td style={{ textTransform: 'uppercase' }}>Longitude</td>
            </tr>
          </thead>
          <tbody>
            <tr>{/* TODO: display data from query */}</tr>
          </tbody>
        </table>
      </header>
    </div>
  );
}

export default App;
```

The rule for using any hook is that they can only be consumed inside a functional component. The `useHarperDB` hook gives an array with elements to query the `data` which is returned as an array. It also provides:

- `loading` where you can let the user know if the query is running the data is not yet loaded
- `error` determines if there is an error when querying the data
- `refresh` it is a function that allows fetching the data

To query the data from the database instance, pass the object inside the hook.

Add the following snippet query in the `App.js` file to fetch all the data from the database.

```js
function App() {
  const [data, loading, error, refresh] = useHarperDB({
    query: { operation: 'sql', sql: 'select * from dev.outlets' }
    // interval: 5000
  });

  //...
}
```

In the above snippet, the second property of `interval` passed is optional to use when you don't want to explicitly use the `refresh` function. It accepts a value in milliseconds.

Let's add some JSX for `loading` and `error` by using `if/else` syntax inside the `App` component.

```js
function App() {
  // ...

  if (loading) {
    return <div>Loading ...</div>;
  }

  if (error && data.length === 0) {
    return <div>Error, no data found</div>;
  }

  return (
    <div className="App">
      <header className="App-header">
        <h2>Starbucks Outlets</h2>
        <table>
          <thead style={{ marginBottom: '20px' }}>
            <tr>
              <td style={{ textTransform: 'uppercase' }}>City</td>
              <td style={{ textTransform: 'uppercase' }}>Name</td>
              <td style={{ textTransform: 'uppercase' }}>Latitude</td>
              <td style={{ textTransform: 'uppercase' }}>Longitude</td>
            </tr>
          </thead>
          <tbody>
            <tr>{/* TODO: display data from query */}</tr>
          </tbody>
        </table>
      </header>
    </div>
  );
}
```

For a very brief moment, you may see the loading message being displayed.

![ss7](https://i.imgur.com/D5YDC1J.gif)

Also, if you are passing `interval` as the second property, you may notice that after every 5 seconds, the React app automatically refreshes the web page. To stop this behavior, you can remove the `interval` property.

Now using the JavaScript's `map` function, let's map over the array of `data` and display the contents. If data is fetched that means it exists and we can easily map over the array. Add the following code snippet in place of the comment.

```js
<tbody>
  {data &&
    data.map((item, index) => (
      <tr key={index}>
        <td>{item.title}</td>
        <td>{item.author}</td>
      </tr>
    ))}
</tbody>
```

Go back to the browser window and you will get the following result:

![ss8](https://i.imgur.com/jJFQ9k3.png)

The query can also be made using the `useHarperdb` hook with only the `data` array. Add the following query to fetch the total number of outlets or records from the database.

```js
const [data2] = useHarperDB({
  query: {
    operation: 'sql',
    sql: 'select count(*) as totalOutlets from dev.outlets'
  }
});
```

To display the total count, add the modify the JSX rendered from `App` component:

```js
// ...
<h2>Starbucks Outlets</h2>
<p>Total Outlets: {data2 && data2[0].totalOutlets}</p>
// ...
```

Here is the output after this step:

![ss9](https://i.imgur.com/jUY8J3T.png)

## Conclusion

Hooks are a great addition in the React world and they certainly help us write less code. The objective of this post was to introduce you to the `useHarperDB` hook and how to integrate it into a React app to fetch the data from a database hosted in the cloud.

**Resources & Further Reading:**

- [HarperDB documentation](https://harperdb.io/developers/documentation/overview/?utm_source=amanmittal)
- [HarperDB Developer examples](https://harperdb.io/developers/developer-examples/?utm_source=amanmittal) includes tutorials on React, Websocket, Python, etc.

---

## How to permanently hide folders from graph view in Obsidian
Slug: hide-folders-from-graph-view-obsidian

I've been using Obsidian for more than a year, and it has become more than a commonplace note-taking app. I use one vault to store all of my notes. They are related to work, projects, bookmarks, and sometimes my journal.

## Graph view: a useful tool

One of the fascinating tools I've found that Obsidian provides is the Graph view. The Graph view is an opportunity to view all of your notes in one place and see the connections between different notes. It's not only visual but also interactive. Clicking a node in the graph opens the note.

<img src="/images/obsidian/graphv-1.png" alt="Graph view in Obsidian" class="sm:w-2/3 mx-auto"/>

As you can see in the above graph, the nodes are colored in three ways: _black, green, and gray_. The _green_ ones are the tags that I'm using in some of my notes.

<img src="/images/obsidian/graphv-2.png" alt="Green nodes in Graph view" class="sm:w-2/3 mx-auto"/>

I often use it as a visual tool to see all my all tagged notes. This helps me identify the existing tags I am using and understand their connections. Clicking the magic wand icon, also isolates the tags and displays them in the Graph view.

After clicking a node in the graph, the view opens the Obsidian search panel. It displays all the notes using that tag. It also allows showing a view for a specific tag using **Filters**.

<img src="/images/obsidian/graphv-4.png" alt="Filters in Graph view" class="sm:w-2/4 mx-auto"/>

## Excluding notes from Graph view

Sometimes, I want to keep some of my notes hidden from this Graph view. There can be many reasons why would one want to do that. For example, you may have notes inside an Archive folder. You want to keep them for a while but don't want to remember them all the time. I have quite a few folders in my personal vault where I keep archiving notes. I also have an Attachment folder to keep all the screenshots used in different notes, inside one folder. It doesn't make sense to me to have them appear in the Graph view. It's just clutter.

Excluding files and folders from the graph view, search, and so on, by defining their paths.

- ClickÂ **Settings**Â in the Obsidian desktop app, and in the menu, clickÂ **Files & links**.
- UnderÂ **Excluded files**, clickÂ **Manage**Â to define the paths to the folders where these notes live. A path can include a top-level folder or a nested folder path.

<img src="/images/obsidian/graphv-3.png" alt="Excluding notes from Graph view setting in Obsidian" class="sm mx-auto"/>

---

## Hide and unhide files or directories visibility with chflags on macOS
Slug: hide-unhide-files-or-directories-with-chflags

The `chflags` command in macOS is a command for quickly hiding or unhiding files and directories. It is particularly useful for managing the visibility of files by altering their flags.

## Unhiding files or Directories

You might need to access files located in the `Library` directory. On a new Mac setup, this directory is hidden by default, making it less accessible for everyday users.

To make a hidden file or directory visible, use the `nohidden` flag with the `chflags` command. For example, to unhide the `Library` directory:

```shell
chflags nohidden ~/Library
```

This command removes the `hidden` attribute and makes the `Library` directory visible in the Finder.

## Hiding files or directories

If you want to hide a file or directory, use the `hidden` flag. This is useful for decluttering your view or protecting sensitive files from accidental access. For example, to hide the `Library` directory again:

```shell
chflags hidden ~/Library
```

By using the `hidden` flag, the `Library` directory will no longer be visible in the Finder.

## Conclusion

The `chflags` command is powerful for managing file visibility on macOS.

---

## How I Configure VS Code for Everything
Slug: how-i-configure-vscode-for-everything

![cover](https://i.imgur.com/hJ7W51N.jpg)

> [I made updates to this post here](https://amanhimself.dev/blog/setup-macbook-m1/) with additions to setup a new Macbook Pro based on M1 chip in 2021!

Recently, I was at the Boryspil Airport in Ukraine, working on a blog article, when suddenly my VS Code stopped working. It crashed! Not once, but twice in less than 30 minutes. Some of the content was autosaved, but some of it was gone forever.

I was frustrated at first as to why it had to crash at that moment. After re-opening the editor, I was angry with myself because I had to write some of the stuff that didnâ€™t get saved again.

Before this experience, it did at times feel that I had too many extensions that I wasnâ€™t using, as I stopped working with some of the frameworks in recent months (Angular, for example).

What did I do? The emotions werenâ€™t helping; I had to find a better way. So, I re-installed [VS Code](https://code.visualstudio.com/).

VS Code uses [Electron](https://electronjs.org/) as its base which enables it to be cross-platform and work on macOS, Windows, and Linux. It is built using [Node.js](https://nodejs.org/) and has complete support for any JavaScript developer.

Now, thatâ€™s what I call win-win. Itâ€™s fast compared to the previous editors ([Atom](https://atom.io/)) and IDEs ([Webstorm](https://www.jetbrains.com/webstorm/)) I have used.

## Themes

The first thing I did was install themes that I saw all day. I like my editor to be charming and appealing. Thus, I used the following themes for different purposes.

- fairyFloss (most of the time, because I love purple backgrounds).
- Dracula Official (I used this with my [iTerm](https://www.iterm2.com/) setup and switched between it and fairyFloss).
- Night Owl (just to try something new).
- Material-Icon-Theme (for file icons).

<img src='https://cdn-images-1.medium.com/max/800/1*7utI1vJayaK97t7lYhrv_A.jpeg' />

## Configuring VSÂ Code

Next, I changed a few things that I remembered from my previous settings.

- Set the `Tab` size to two spaces.
- Enabled [Emmet](https://emmet.io/) for HTML and JavaScript.
- Enabled `autoSave` with a delay of 5 seconds.
- Used OSâ€™s terminal setup and shell ([Zsh](https://ohmyz.sh/)).
- Enabled formatting of files by saving and pasting snippets from elsewhere.
- Disabled Minimap as I like to save space and we write modular functions modules these days.
- Also, enabled `wordwrap`.

### Extensions

The next step for me is to make this editor work like a charm with the help of some well-maintained and free extensions.

- [emojisense](https://marketplace.visualstudio.com/items?itemName=bierner.emojisense):
- [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer)
- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker) (I write a lot of blog posts in VS Code.)
- [Code::Stats](https://codestats.net/) (a small stats tool, for fun.)
- [ESLint](https://eslint.org/)
- [Indent 4-to-2](https://marketplace.visualstudio.com/items?itemName=Compulim.indent4to2) (converts tab indentation from four spaces to two.)
- [Express.js](https://expressjs.com/) (a snippets package written by me.)
- [markdownlint](https://github.com/markdownlint/markdownlint) (I sometimes write more Markdown in a day than JavaScript code.)
- [GitHub pull requests](https://help.github.com/en/articles/about-pull-requests).
- [GraphQL](https://graphql.org/) (published by Prisma.)
- [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost)
- [npm Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense)
- [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense)
- [Pug](https://marketplace.visualstudio.com/items?itemName=amandeepmittal.pug) (another snippet by me for Jade and Pug template languages, for some old projects.)
- [IntelliSense for CSS class names](https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion)
- [React Native Tools](https://marketplace.visualstudio.com/items?itemName=msjsdiag.vscode-react-native)
- [Todo Tree](https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree)
- [Version Lens](https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens)
- [Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync) (one of the most important extensions I have mentioned here)
- [Word Count](https://marketplace.visualstudio.com/items?itemName=ms-vscode.wordcount)
- [Prettier](https://prettier.io/) (Code formatter I canâ€™t live without.)

With Prettier, I like to use my own set of configurations, as described below.

```json
{
  "prettier.jsxSingleQuote": true,
  "prettier.printWidth": 100,
  "prettier.semi": false,
  "prettier.useTabs": true,
  "prettier.tabWidth": 2
}
```

## Conclusion

Thatâ€™s the setup I now use for my JavaScript, Node.js, [React](https://reactjs.org/) and React Native work. What type of VS Code configuration do you use? What does it look like? I hope you enjoyed reading this post.

Happy Coding!

[Originally published at Better Programming](https://medium.com/better-programming/how-i-configure-vscode-for-everything-7df65a316a52)

---

## How process.nextTick() works in Node.js?
Slug: how-process-nexttick-works-in-node-js

The [process](https://nodejs.org/api/process.html) object is a one of the few global objects provided by the Node.js core API. It can be access from anywhere, thus its methods can also be accessed. Such is a method called `process.nextTick()` which is used by developers in realtime applications everyday to defer the execution of a function until the next [Event Loop Iteration](https://medium.com/@amanhimself/the-node-js-system-51090c35dddc).

Browser JavaScript introduced us functions like `setTimeout()` to defer tasks in the near future. The `setTimeout()` function takes a callback function and a number value representing the time after which the callback function will be executed, in milliseconds.

```js
setTimeout(callback, 0);
```

In Node.js, each iteration of an Event Loop is called a tick. To schedule a callback function to be invoked in the next iteration of the Event Loop, we use process.nextTick(). It just takes a callback with no time bound, since it will be executing in the next iteration of the Event Loop.

```js
process.nextTick(callback);
```

The difference between setTimeout() and process.nextTick() is that the process.nextTick() function is specific to the Node.js Event Loop. setTimeout() uses JavaScript runtime to schedule its own queue of events. When using process.nextTick(), callback function associated with [it runs immediately after events in the Event Queue are processed by the Event Loop in a single iteration. In comparison to setTimeout(), it is faster since queue associated with setTimeout() or the JavaScript runtime](https://gist.github.com/mmalecki/1257394).

```js
function cb() {
  console.log('Processed in next iteration');
}
process.nextTick(cb);
console.log('Processed in the first iteration');
```

The above snippet is an example of how `process.nextTick()` works. You can save the snippet in a file.js and run using \$node file.js from your terminal. You will definitely notice that the second console.log printed before the console.log associated with function `cb()`.

```js
Processed in the first iteration
Processed in next iteration
```

### Further Reading:

- [process.nextTick vs setTimeout(fn, 0)](https://gist.github.com/mmalecki/1257394)
- [Nodejs Official Docs](https://nodejs.org/docs/latest/api/process.html#process_process_nexttick_callback_args)
- [Understanding process.nextTick()](https://howtonode.org/understanding-process-next-tick)

---

## How to add Splash Screen and an App Icon in React Native
Slug: how-to-add-a-splash-screen-and-app-icon-in-react-native-with-react-native-bootsplash

Every mobile application has a splash screen and an app icon, and together they provide the first impression. An app icon is displayed in various places, such as on an app store, on the device's app drawer, and so on., whereas a splash screen is shown during the app startup. Adding a splash screen or an app icon to a React Native app can be an agile process.

In this tutorial, let's learn how to use an awesome package called [react-native-bootsplash](https://github.com/zoontek/react-native-bootsplash) to display a splash screen when an app starts and then learn the process of adding app icons in a React Native app.

## Prerequisites

To follow this tutorial, please make sure you have the following tools and utilities installed on your local development environment and have access to the services mentioned below:

- [Node.js](https://nodejs.org/en/) version `12.x.x` or above installed
- Have access to one package manager such as npm or yarn or npx
- [react-native-cli](https://www.npmjs.com/package/react-native-cli) installed, or use npx

Note, the example app is created using React Native version `0.65.x`.

[**Complete source code for this example is at this GitHub repo**](https://github.com/amandeepmittal/react-native-examples/tree/master/rnSplashAndIconExample)

## Setup a React Native app

As an example for this tutorial, we will use a React Native project with two screens and React Navigation integrated.

To create a new React Native project and install the react-navigation dependencies, run the following command from the terminal window:

```shell
npx react-native init myAwesomeApp

# after the project directory is created
# navigate inside the directory
# and install the following dependencies

yarn add @react-navigation/native @react-navigation/native-stack react-native-safe-area-context react-native-screens
```

Inside `src/` directory, create a new directory called `navigation/` with a new file named `RootNavigator.js`. Add the following code to use the stack navigation pattern inside this file:

```js
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import HomeScreen from '../screens/HomeScreen';
import DetailScreen from '../screens/DetailScreen';

const Stack = createNativeStackNavigator();

const RootNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Details" component={DetailScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default RootNavigator;
```

Modify the `App.js` file:

```js
import React from 'react';

import RootNavigator from './src/navigation/RootNavigator';

const App = () => {
  return <RootNavigator />;
};

export default App;
```

Now, letâ€™s create two new screens. Start by creating a new directory called `src/screens/` and inside it, add the first file with the name `HomeScreen.js` and with the following code snippet:

```js
import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';

const HomeScreen = ({ navigation }) => {
  return (
    <View style={styles.screenContainer}>
      <Text style={styles.title}>Home Screen</Text>
      <Pressable
        style={styles.buttonStyle}
        onPress={() => navigation.navigate('Details')}
      >
        <Text style={styles.buttonTextStyle}>Go To Detail Screen</Text>
      </Pressable>
    </View>
  );
};

const styles = StyleSheet.create({
  screenContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff'
  },
  title: {
    fontSize: 32
  },
  buttonStyle: {
    height: 54,
    width: '80%',
    marginTop: 32,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2EE59D',
    shadowRadius: 5,
    shadowOpacity: 0.7,
    shadowColor: 'rgba(46, 229, 157, 0.5)',
    shadowOffset: {
      width: 0,
      height: 3
    }
  },
  buttonTextStyle: {
    color: '#fdfdfd',
    fontWeight: '700'
  }
});

export default HomeScreen;
```

Now, add the second screen component file, `DetailScreen.js`, and the following code snippet:

```js
import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';

const DetailScreen = ({ navigation }) => {
  return (
    <View style={styles.screenContainer}>
      <Text style={styles.title}>Detail Screen</Text>
      <Pressable
        style={styles.buttonStyle}
        onPress={() => navigation.navigate('Home')}
      >
        <Text style={styles.buttonTextStyle}>Go To Home Screen</Text>
      </Pressable>
    </View>
  );
};

const styles = StyleSheet.create({
  screenContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff'
  },
  title: {
    fontSize: 32
  },
  buttonStyle: {
    height: 54,
    width: '80%',
    marginTop: 32,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2EE59D',
    shadowRadius: 5,
    shadowOpacity: 0.7,
    shadowColor: 'rgba(46, 229, 157, 0.5)',
    shadowOffset: {
      width: 0,
      height: 3
    }
  },
  buttonTextStyle: {
    color: '#fdfdfd',
    fontWeight: '700'
  }
});

export default DetailScreen;
```

With the boilerplate setup done, now letâ€™s build the apps for iOS and Android.

For iOS, run the following command:

```shell
npx react-native run-ios
```

For Android, run the following command:

```shell
npx react-native run-android
```

Here is what the example app looks like in its current form. Notice that the splash screen and the app icon are defaults that come with React Native.

![js1](https://i.imgur.com/dh7TYQF.gif)

We are picking an icon from [Flaticon.com](https://www.flaticon.com/premium-icon/atom_3326760?term=react&related_id=3326850&origin=search) for the example app.

After creating the original app icon, save it inside the directory `src/assets/` and name the file `original_icon`. (_Note: you can name the original icon file as per your requirement_).

![js2](https://i.imgur.com/WJakXfC.png)

_Tip_: Make sure your initial app logo is `1024x1024px`.

## Installing react-native-bootsplash

The initial step is to install the react-native-bootsplash package and then generate assets using it.

Open the terminal window and execute the following command to install the package:

```shell
yarn add react-native-bootsplash

# or if using npm
npm install react-native-bootsplash
```

Next, for iOS, execute the command to install pods.

```shell
npx pod-install ios
```

Tip: If you use a React Native version lower than `0.60`, please follow the instructions [here](https://github.com/zoontek/react-native-bootsplash#-manual-linking) to link the package manually.

Next, add the following script in the `package.json` file under the `"scripts"` section:

```json
"scripts": {
  "generate": "npx react-native generate-bootsplash ./src/assets/original_icon.png --background-color=2EE59D   --logo-width=100 --assets-path=./src/assets --flavor=main"
}
```

Here is each option described:

- `generate-bootsplash` is the command to generate the assets.
- `./src/assets/original_icon.png` is the path to the original icon file. The path may vary depending on where you save the file in your React Native project.
- `--background-color=hexadecimal_value` is a color value in hexadecimal format. The color here is used as the background color of the splash screen.
- `--logo-width=100` is the width of the logo. This is a default value provided by the package
- `assets-path` is the path to the assets directory.
- `flavor` is an Android only option. Let's pass the value `main` here to target the default version of the Android app. You can learn more about [Build Variants on Android here](https://developer.android.com/studio/build/build-variants).

This will generate assets in the path specified for the option `assets-path`, a storyboard called `BootSplash.storyboard` file inside the `ios/app-name` directory, as well as generate assets for the Android app inside different sub-directories of the `android/app/src/main/res` folder.

![js3](https://i.imgur.com/xmqvhmG.png)

Android requires five different sizes for different screen pixel densities. Icons for lower resolution are created automatically from the baseline (_mdpi_). Refer to the table below for more information on pixel densities:

|   Resolution    | Density | Pixel units |
| :-------------: | :-----: | :---------: |
| mdpi (Baseline) | 160 dpi |     1Ã—      |
|      hdpi       | 240 dpi |    1.5Ã—     |
|      xhdpi      | 320 dpi |     2Ã—      |
|     xxhdpi      | 480 dpi |     3Ã—      |
|     xxxhdpi     | 640 dpi |     4Ã—      |

## Adding splash screen on iOS

Start by opening the file `ios/app-name.xcodeproj` in Xcode.

![js4](https://i.imgur.com/kjxEF8z.png)

Then, drag the file `BootSplash.storyboard` under the Project directory in the Xcode file manager on the left side of the Xcode from the path `ios/app-name/` directory.

![js5](https://i.imgur.com/Doa8D2k.png)

After dragging it, Xcode will prompt the following to create a folder reference. First, make sure that under the `Add to targets` option, the `app-name` is selected. Then click the **Finish** button.

![js6](https://i.imgur.com/RHMsIQL.png)

The `BootSplash.storyboard` file will now be represented in the file manager as shown below:

![js7](https://i.imgur.com/cJwlRGv.png)

Click on the `BootSplash.storyboard` file to verify that the background color was added when generating assets.

![js8](https://i.imgur.com/hSjkXLi.png)

Select the Xcode project from the file manager and select `BootSplash` from the dropdown menu next to `Launch Screen File`.

![js9](https://i.imgur.com/kdNCGCL.png)

Now, open the `ios/app-name/AppDelegate.m` file and add the import to the following header reference:

```c
#import "AppDelegate.h"

#import <React/RCTBridge.h>
#import <React/RCTBundleURLProvider.h>
#import <React/RCTRootView.h>

#import "RNBootSplash.h" // <- add this
```

In the same file, add the following line to initialize the BootSplash.

```c
@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  // ... other statements
   [RNBootSplash initWithStoryboard:@"BootSplash" rootView:rootView];
  return YES;
}
```

## Adding splash screen on Android

Start by modifying the `android/app/src/main/java/com/app-name/MainActivity.java` file.

```java
package com.rnsplashandiconexample;

import com.facebook.react.ReactActivity;

// ----- Add the following imports --------
import android.os.Bundle;
import com.zoontek.rnbootsplash.RNBootSplash;

public class MainActivity extends ReactActivity {

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  @Override
  protected String getMainComponentName() {
    return "rnSplashAndIconExample";
  }

  // ----- Add the following --------
  @Override
    protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    RNBootSplash.init(R.drawable.bootsplash, MainActivity.this);
  }
}
```

Then, modify the `android/app/src/main/res/values/styles.xml` file:

```xml
<resources>

    <style name="AppTheme" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="android:textColor">#000000</item>
    </style>

    <!-- Add the following lines (BootTheme should inherit from AppTheme) -->
    <style name="BootTheme" parent="AppTheme">
      <!-- set the generated bootsplash.xml drawable as activity background -->
      <item name="android:background">@drawable/bootsplash</item>
    </style>

</resources>
```

Next, modify the `android/app/src/main/AndroidManifest.xml` file by removing the original `<intent-filter>` tag and its contents. Replace it by adding `android:exported="true"` and create a new `activity` element to use the theme created in the previous step.

```xml
<activity
        android:name=".MainActivity"
        android:label="@string/app_name"
        android:configChanges="keyboard|keyboardHidden|orientation|screenSize|uiMode"
        android:launchMode="singleTask"
        android:windowSoftInputMode="adjustResize"
        android:exported="true">  <!--- Add this -->
</activity>

<!-- Then, add the following lines -->
<activity
      android:name="com.zoontek.rnbootsplash.RNBootSplashActivity"
      android:theme="@style/BootTheme"
      android:launchMode="singleTask">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
</activity>
```

## Control how to display a splash screen when the navigator is mounted

You can control the behavior of the splash screen to display until all the children of the React Navigation's `NavigationContainer` are mounted for the first time. This can be done by using a prop on the `NavigationContainer` called [`onReady`](https://reactnavigation.org/docs/navigation-container/#onready).

Modify the `RootNavigator.js` file by importing the `react-native-bootsplash` and adding the prop `onReady`.

```js
// after other import statements
import RNBootSplash from 'react-native-bootsplash';

const RootNavigator = () => {
  return (
    <NavigationContainer onReady={() => RNBootSplash.hide()}>
      {/* Rest remains same */}
    </NavigationContainer>
  );
};
```

## Testing the splash screen configuration

The last step to see the splash screen in action is to run the build command for both iOS and Android.

Open the terminal window and run the command to build the app for iOS and Android:

```shell
# for iOS
npx react-native run-ios

# for Android
npx react-native run-android
```

Here is the output after this step:

![js10](https://i.imgur.com/QYtfVuP.gif)

## Adding app icon to iOS app

To generate assets for different iOS devices, I am using a free app icon generator called [appicon.co](https://appicon.co/).

![js11](https://i.imgur.com/odLO1I4.png)

After generating all the image assets, you will be able to download them in a zip file.

Uploading an app icon for iOS follows the same process as using native iOS development. Open the file `ios/app-name.xcodeproj` in Xcode. Select the `Image.xcassets` from the file manager. Then select the **AppIcon**.

![js12](https://i.imgur.com/N0iQPnH.png)

Drag and drop all the required image assets after downloading and unzipping them from appicon.co. Place the images as per the necessary pixel densities. After you are done, here is how the Xcode might look like:

![js13](https://i.imgur.com/Ub2KLe9.png)

Open a terminal window and run the command to build an app for iOS:

```shell
npx react-native run-ios
```

After the rebuild, the app icon will display.

![js14](https://i.imgur.com/ojOLDxb.png)

## Adding app icon to Android app

The leverage react-native-bootsplash package generates all the app icons for Android and stores them in the multiple sub-directories under the `android/app/src/main/res` directory.

![js15](https://i.imgur.com/4araXHx.png)

The simple way here is to replace the default values for the properties `android:icon` and `android:roundIcon` in the `android/app/src/main/AndroidManifest.xml` file to point to the `bootsplash_logo` file name.

```xml
<application
  android:name=".MainApplication"
  android:label="@string/app_name"
  // modify the two lines below
  android:icon="@mipmap/bootsplash_logo"
  android:roundIcon="@mipmap/bootsplash_logo"
  // ----------------------------
  android:allowBackup="false"
  android:theme="@style/AppTheme">
```

After this modification, rebuild the Android app using the following command from a terminal window:

```shell
npx react-native run-android
```

After the rebuild, the app icon will display.

![js16](https://i.imgur.com/giZq4u9.png)

## Conclusion

Once you get the hang of this process, it doesn't take much time. Those are all the necessary steps to add a splash screen and an app icon to a React Native app.

For more advanced usage of `react-native-bootsplash` please check its [official documentation here on GitHub](https://github.com/zoontek/react-native-bootsplash). There are some advanced strategies explained there, including animating the splash screen.

[**Complete source code for this example is at this GitHub repo**](https://github.com/amandeepmittal/react-native-examples/tree/master/rnSplashAndIconExample)

---

## How To Build a News Reader App with React Native and NewsAPI
Slug: how-to-build-a-news-reader-app-with-react-native-and-newsapi

React Native is a great platform to build cross-platform mobile applications for iOs and Android. While there are few other framework options available in the mobile app development space to build cross-platform applications, coming from JavaScript or web development background makes learning and using React Native as a framework easier.

In this tutorial, I am going to walk you through the process of building a React Native application from scratch. Along with that, we are going to cover many topics such as installing and using a third party library for fetching real-time data, using a `Flatlist` component (_something you are going to use a lot in React Native_), using a third party UI library for React Native and implement a feature like _pull down to refresh content_.

The content in this article is as followed:

- Getting Started with Requirements
- Getting NEWS API Key
- Fetching data from News API
- The Article Component
- Learn about [react-native-elements](https://react-native-training.github.io/react-native-elements/) in detail
- Writing the News Component
- FlatList Component in Detail
- Conclusion

> [**Also, try out the Crowdbotics App Builder to instantly scaffold and deploy a React Native application.**](https://app.crowdbotics.com/dashboard/?utm_campaign=cb-medium&utm_source=blog-post&utm_medium=Medium&utm_content=react-native)

### Getting Started with Requirements

To continue reading this tutorial, you need a basic understanding of JavaScript as a programming language. If you have some experience working your way with Reactjs, you will have no problem following this tutorial. If you are a newbie to JavaScript or React ecosystem, I want to halt right here and go through [this awesome resource](http://www.react.express/) that can help you with understanding the basic concepts in this tutorial. (_Donâ€™t spend too much time if youâ€™re not interested in building web applications using Reactjs; just go through the main concepts._)

Please note that React Native is not a hybrid mobile app framework like others available. It uses a bridge between Javascript and native APIs of a specific platform. Do take a look at [React Native Official Docs](https://facebook.github.io/react-native/docs/getting-started.html) to read more about this.

Other requirements required in order to follow this tutorial:

- Nodejs above `8.x.x` installed on your local machine
- Know, how to run simple `npm` commands
- JavaScript/ES6 basics
- `watchman` the file watcher installed
- `react-native-cli` installed through npm

For a complete walkthrough on how you can set up a development environment for React Native, you can go through [official documentation here](https://facebook.github.io/react-native/docs/getting-started).

Once you installed `react-native-cli` you can begin by generating a React Native project. Run the below command to initialize a new React Native project. Also, note that you can name your React Native app anything. For demonstration purposes, I am going to call it `newsApiDemo`.

```shell
react-native init newsApiDemo
```

Once the project directory is generated, you can traverse inside it. Then, in two separate terminal windows or tabs, run two different commands to start your project.

```shell
cd newsApiDemo

# first terminal window
npm start

#second terminal window
react-native run-ios
```

_Note_ that I am going to use iOS simulator for demonstrating this tutorial. You are on a Windows or a Linux machine, go ahead and replace `run-ios` in react native command with `run-android`. Android developers, also make sure that the Android Virtual Device has bootstrapped before running the previous command.

Thatâ€™s all. Let us get going with the development process.

### Getting News APIÂ Key

[NewsAPI.org](https://newsapi.org/) is simple and easy to use data API that returns JSON metadata for headlines and articles from the internet. It uses over 30,000 sources to fetch data from the web.

You are going to use NewsApi for this tutorial. So it is better to get the API key in the start before you start developing your application. To get the API key, proceed to [**newsapi.org**](https://newsapi.org/) and sign in with your email id. After logging in, you will receive an API key when you click the button `Get API key`.

<img src='https://cdn-images-1.medium.com/max/1200/1*KPz9LFthqxokfaoNeZpBxQ.png' />

To save this API key, create a new folder called `src` and inside create another new directory called `config`. Inside `config` create a new file called `env.js` and save the API key as below.

```js
export const API_KEY = 'XXXXXXXXX';
```

This `API_KEY` is going to help us authenticate as a user of NewsAPI and use the free plan.

### Fetching data from NewsÂ API

To fetch data from the news API using our recently you are going to use JavaScriptâ€™s `fetch` API. Let us write a function that will handle this process. Create a new file inside `src/utils/fetchNews.js` and then add the following snippet.

```js
import { API_KEY } from '../config/env';

const url = `https://newsapi.org/v2/top-headlines?
country=us&apiKey=${API_KEY}`;

export async function getUSANews() {
  let result = await fetch(url).then((response = response.json()));

  return result.articles;
}
```

In the above file, we start by importing the `API_KEY`. Then we take the URL as a constant with the same name. It contains all the data we need. To verify that the URL is correct, visit the URL itself and replace of `${API_KEY}` with your own API key. You will get similar results in form of articles.

<img src='https://cdn-images-1.medium.com/max/800/1*FIkn5xklfPK7D-G6pbVbAw.png' />

This is a data representation of what we are getting from hitting the API URL.

<img src='https://cdn-images-1.medium.com/max/1200/1*NLk6XCk71Px7dpBhhEGx2g.png' />

The function `getUSANews()` is returning only the array `articles` from above. We will consume this array by traversing it and displaying each article along with the headline, its image URL.

_To get more information on the different data sources you can visit_ [**newsapi documentation**](https://newsapi.org/docs)**.**

### Adding a Third Party UIÂ Kit

Before we begin developing our UI components and display news articles, we are going to install a third party UI library that will provide us a lot of styling and pre-defined components, that with very little tweaks, we can make use of these components. You can think of this as a CSS framework (_such as Bootstrap or Semantics or any other_) in terms of Front-End Web Development.

Move ahead, stop the `npm run` command if it is still running the and in the same run the following set of commands to install `[react-native-elements](https://react-native-training.github.io/react-native-elements/docs/getting_started.html)` and `react-native-vector-icons`.

```shell
npm i -S react-native-elements

# then
npm i --save react-native-vector-icons

# then, last command: link it
react-native link react-native-vector-icons
```

To verify that dependencies have installed and their installed version of each dependency, you can always visit `package.json` file.

```json
"dependencies": {
    "react": "16.6.3",
    "react-native": "0.58.4",
    "react-native-elements": "^1.0.0",
    "react-native-vector-icons": "^6.2.0"
	},
```

**What about the** `**react-native link**` **command?** Why did we have to run it and what does it do? Read the next short section if you do not know what is linking of libraries in React Native means. You can skip it if you already know about it and move onto the next section.

**Side-note**: You are also going to _momentJS_ library to display each articleâ€™s published date and time. To install just run `npm i -S moment`, no linking required for this.

### Link Libraries ReactÂ Native

All third-party libraries in React Native have some native dependencies that use specific platform capabilities of iOS and Android. Linking these native dependencies with react-native link command indicates that a librariesâ€™ native dependencies are linked successfully to your iOS/Android project.

Whenever you link a library, you will always get a prompt message informing you whether the library has been successfully linked or not like below.

<img src='https://cdn-images-1.medium.com/max/800/1*SPv563AHWRByVg_aQqCmeA.png' />

### The Article Component

To display the data we need a React Native component. Create a new file inside `src/components/Article.js`. You start by requiring dependencies in order to build this component. Then, also save one article data object from the news API URL we visited earlier. For now, we are going to show hard-coded data. Also, the `Article` component is going to represent one single article, so it will satisfy our need for now. Here is the code for the complete component as of now.

```js
import React, { Component } from 'react';
import { View, TouchableHighlight } from 'react-native';
import { Text, Card, Divider } from 'react-native-elements';
import moment from 'moment';

const defaultJSONData = {
  source: {
    id: 'fox-news',
    name: 'Fox News'
  },
  author: null,
  title:
    "Jeff Bezos' investigator believes 'government
    entity' may have obtained texts: WashPo
    reporter - Fox News",
  description:
    'A security consultant for Amazon founder and
    Washington Post owner Jeff Bezos believes the
    CEOâ€™s lurid intimate photos may have been
    acquired by a "government entity," a reporter
    at the paper said Thursday.',
  url:
    'https://www.foxnews.com/tech/
    jeff-bezos-investigator-believes-government-enti
    ty-obtained-texts-wapo-reporter',
  urlToImage:
    'https://media2.foxnews.com/BrightCove/
    694940094001/2019/02/08/
    694940094001_5999770984001_5999767526001-vs.jpg',
  publishedAt: '2019-02-08T07:52:57Z',
  content:
    'A security consultant for Amazon founder and
    Washington Post owner Jeff Bezos believes the
    CEOâ€™s lurid intimate photos may have been
    acquired by a "government entity," a reporter
    at the paper said Thursday. Manuel
    Roig-Franzia, the reporter, told MSNBC that wâ€¦ [+1410 chars]'
};

class Article extends Component {
  render() {
    const time = moment(defaultJSONData.publishedAt || moment.now()).fromNow();

    return (
      <TouchableHighlight>
        <Card
          featuredTitle={defaultJSONData.title}
          featuredTitleStyle={{
            marginHorizontal: 5,
            textShadowColor: '#00000f',
            textShadowOffset: { width: 3, height: 3 },
            textShadowRadius: 3
          }}
          image={{
            uri:
              'https://media2.foxnews.com/
              BrightCove/694940094001/2019/02/08/
              694940094001_5999770984001_59997675260
              01-vs.jpg'
          }}
        >
          <Text style={{ marginBottom: 10 }}>
            {defaultJSONData.description || 'Read more...'}
          </Text>
          <Divider style={{ backgroundColor: '#dfe6e9' }} />
          <View
            style={{ flexDirection: 'row', justifyContent: 'space-between' }}
          >
            <Text
              style={{
                margin: 5,
                fontStyle: 'italic',
                color: '#b2bec3',
                fontSize: 10
              }}
            >
              {defaultJSONData.source.name.toUpperCase()}
            </Text>
            <Text
              style={{
                margin: 5,
                fontStyle: 'italic',
                color: '#b2bec3',
                fontSize: 10
              }}
            >
              {time}
            </Text>
          </View>
        </Card>
      </TouchableHighlight>
    );
  }
}

export default Article;
```

The `defaultJSONData` is going to be the source of the data until we successfully display one article in the form of a card element on the device's screen. Later on, we are going to fetch all the articles inside another component that will be using the `Article` component to display each article. The data to the `Article` component then, will be provided through props.

Inside the `render` method, we are using a combination of elements from both `react-native` and third party UI kit library, `react-native-elements`.

The `TouchableHighlight` component from react native is going to be useful to us. It is a wrapper that makes a normal view in React Native respond to touches properly on a mobile device.

These are the three UI elements from **react-native-elements**. A `Card` is helping us to display news article information. It contains content in the form of

- a news articleâ€™s headline: `defaultJSONData.title`
- the description: `defaultJSONData.description`
- the name source or the news provider: `defaultJSONData.source.name`
- the time article was published from the current time: `defaultJSONData.publishedAt`
- and the image of the article from the source: `defaultJSONData.urlToImage`

The `Card` has some special props. Like when you want to use to display the content on the image (_like we are doing_), you can use a combination of props such as `featuredTitle` and `image`. The `featuredTitleStyle` is just used to provide some extra weight to the text on the image.

I am sure, you are not getting much of this. So let us first find a way to display this card and then talk about it in detail. Open up `App.js` and add the following.

```js
import React, { Component } from 'react';
import { View, StyleSheet } from 'react-native';

import Article from './src/components/Article';

export default class App extends Component {
  render() {
    return (
      <View style={styles.container}>
        <Article />
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff'
  }
});
```

We are importing the `Article` class component from its file inside `/components/`. If you refresh the iOS/android simulator, you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*ZxFndMVOWSZsgJ-uYAe_eQ.png' />

Now, you get it. Take a look at the whole `Card`. It adds the outer most border on its own. Inside the card, notice how the `featuredTitle` is working its charm over the `image` prop. If you had used the simple `title`, you won't be getting similar result like above.

Also notice closely, the `Divider` between the description of the news article, and the source and the published time of the article. Below the `Divider`Â , we have a `View` that contains the source name and the time the article was published. We are using the divider element from `react-native-elements` and providing our own background color as the style. The news source provider has its own name converted to uppercase letters using JavaScript utility function `toUpperCase()`.

```js
<Text style={{ marginBottom: 10 }}>
  {defaultJSONData.description || 'Read more...'}
</Text>
```

In the description part, as in the above snippet, you will notice a default text `Read more...`. This is a placeholder text that will appear only in the scenario when the source in the API fails to provide a description for a news article.

### News Component

In this section, we are going to learn how to use display multiple articles from the API as a list. Do note that, this list is going to be a scrollable list. Create a new file inside `components/News.js` with the following code.

```js
import React, { Component } from 'react';
import { FlatList } from 'react-native';

import { getUSANews } from '../utils/fetchNews';
import Article from './Article';

class News extends Component {
  state = {
    articles: [],
    refreshing: true
  };

  componentDidMount = () => {
    this.fetchNews();
  };

  fetchNews = () => {
    getUSANews()
      .then(articles => {
        this.setState({ articles, refreshing: false });
      })
      .catch(() => this.setState({ refreshing: false }));
  };

  handleRefresh = () => {
    this.setState({ refreshing: true }, () => this.fetchNews());
  };

  render() {
    return (
      <FlatList
        data={this.state.articles}
        renderItem={({ item }) => <Article article={item} />}
        keyExtractor={item => item.url}
        refreshing={this.state.refreshing}
        onRefresh={this.handleRefresh}
      />
    );
  }
}

export default News;
```

We start by importing the usual React boilerplate code. From React Native, we are only going to use `FlatList` to render a list of news articles. We define an initial state object which has an array `articles` that will store all the articles after they are fetched from the API. The second property of the state is `refreshing`. This will be used with `FlatList` as props and accepts boolean value. This value when `true` triggers a refresh (_spinner_) animation. This animation is also visible at the starting of the application since the default value for `refreshing` is `true`.

You will notice the use of a lifecycle method called `componentDidMount()`. This gets invoked immediately after the `News` component is mounted. It further triggers the calling of another function called `fetchNews`.

The `fetchNews` calls the API function from the `utils` directory we created earlier in this tutorial. It returns a promise which further takes `articles` as an argument. If the data is fetched, we update the state object accordingly.

The last method is `handleRefresh`. It starts the spinner animation and invokes the `fetchNews()` method immediately after we update the component's state.

### FlatList

To render a list of items in React Native such that the user can scroll through them on their devices can be done through either using a FlatList, ScrollView or SectionList component. In this tutorial, we made use of `FlatList` component.

```js
<FlatList
  data={this.state.articles}
  renderItem={({ item }) => <Article article={item} />}
  keyExtractor={item => item.url}
  refreshing={this.state.refreshing}
  onRefresh={this.handleRefresh}
/>
```

A FlatList component takes two primary props whenever you want to make scrollable list our of data available to you. They are `data` and `renderItem`. `data` is the array that is used to create a list of item and `renderItem` is the function that takes an individual element of data from the array and renders it.

In the code above, notice how we implement `FlatList` in the `News.js`.

The `data` is coming from the initial state object and an object of each item is getting passed through `renderItem` which is further send as props to `Article` component. Apart from `data` and `renderItem`, we are using three other props.

`keyExtractor` is another important and required prop when using FlatList. It should always contain the value that is unique to each object in the data array. For example, from the news API source, we are using the URL of each news article since it is always going to be unique as each article is going to have a unique URL on the Web.

The `onRefresh` prop provides the functionality of _"Pull to Refresh"_. It also requires the prop `refreshing` as we did in the `News.js` and always accepts a boolean value.

### Rendering ArticlesÂ List

To display its content on the screen, you have to modify `App.js` accordingly.

```js
import React, { Component } from 'react';

import News from './src/components/News';

export default class App extends Component {
  render() {
    return <News />;
  }
}
```

In the `App.js` file, all we have to do is import `News` component to render its content. Check out the image below of how the data renders on the screen.

<img src='https://cdn-images-1.medium.com/max/800/1*mmO4jSlXr3WUOwK8fWJ5xg.png' />

If you pull the list down, the spinner animation will appear and if there is new data, it will update the list on the mobile screen.

<img src='https://cdn-images-1.medium.com/max/800/1*LJIVaD-W1YFfHw4zhpfRQQ.gif' />

### Conclusion

I hope you enjoyed reading this tutorial and hopefully, you learned something new out of it such as using third party API, using a UI toolkit and core React Native concepts such as `react-native link`, rendering a list using `FlatList` and implementing _Pull To Refresh_ functionality with it.

If you have any questions, you can reach out to me on [**Twitter**](https://www.twitter.com/amanhimself) and you can find the complete code for this tutorial in the **Github Repository** ðŸ‘‡.

[**amandeepmittal/newsApiDemo**](https://github.com/amandeepmittal/newsApiDemo)

[Originally published at Crowdbotics](https://medium.com/crowdbotics/29-useful-open-source-libraries-for-nodejs-4cefe08f7205)

---

## How to Build a Real Time Logo Detection App with React Native & Google Vision API
Slug: how-to-build-a-real-time-logo-detection-app-with-react-native-google-vision-api-and-crowdbotics

Google Vision API is a great way to add image recognition capabilities to your app. It does a great job detecting a variety of categories such as labels, popular logos, faces, landmarks, and text. You can think of Google Vision API as a Google Image Search offered as an API interface that you can incorporate into your applications.

**In this tutorial, you are going to build a React Native application that can identify a picture provided and detect the logo using Googleâ€™s Vision API in real time.**

You are going to learn how to connect Google Vision API with React Native and Expo. React Native and Expo will be quickly set up using a predefined scaffold from Crowdbotics. We setup Google Vision API from scratch, and use Firebase cloud storage to store an image that a user uploads. That image is then analyzed before the output is generated.

### Tldr

- Setting up Crowdbotics Project
- Installing dependencies
- Setting up Firebase
- Set up Google Cloud Vision API Key
- Logo Detection App
- Uploading Image to Firebase
- Image picker from Expo
- Analyzing the Logo
- Conclusion

### Setting up Crowdbotics Project

In this section, you will be setting up a Crowdbotics project that has React Native plus Expo pre-defined template with stable and latest dependencies for you to leverage. Setting up a new project using Crowdbotics app builder service is easy. Visit [app.crowdbotics.com](https://app.crowdbotics.com/vue-dashboard) dashboard. Once you are logged in, choose `Create a new application`.

<img src='https://cdn-images-1.medium.com/max/800/1*DK_PfPhWHLI4FQVQMzPGbQ.png' />

On the `Create Application` page, choose `React Native Expo` template under `Mobile App`.

<img src='https://cdn-images-1.medium.com/max/800/1*109DBQGNLHmC8lel8OOYmg.png' />

Lastly, choose the name of your template at the bottom of this page and then click the button `Create by app!`. After a few moments, you will get a similar window like below.

<img src='https://cdn-images-1.medium.com/max/800/1*RSZ9UeCX-ZHM6etmnY5Yuw.png' />

This will take you to the app dashboard, where you can see a link to GitHub, Heroku, and Slack. Once your project is created, you will get an invitation from Crowdbotics to download your project or clone the repository from [**Github**](https://github.com/crowdbotics-apps/rngooglevisionapi-1400) either on them email you logged in or as a notification if you chose Github authentication.

### Installing dependencies

Once you have cloned or downloaded the repository from Github, traverse inside it using command `cd` or similar from your terminal and install dependencies.

```shell
cd rngooglevisionapi-1400

cd frontend

# Install depenedencies

npm install
```

Installing dependencies might take a few minutes. Once the step is doneâ€Šâ€”â€Šdepending on the operating system you haveâ€Šâ€”â€Šyou can run the React Native application and verify if everything is working properly using either an iOS simulator or an Android emulator.

```shell
# for iOS
npm run ios

# for android
npm run android
```

Android users, note that you must have an Android virtual device already running in order to run the above command successfully.

### Setting upÂ Firebase

Using the Firebase project has a lot of advantages over a traditional server API model. It provides the database and the backend service and such that we do not have to write our own backend and host it. Visit [Firebase.com](http://www.console.firebase.com) and sign-in with your Google ID. Once logged in, click on a new project and enter a project name. Lastly, hit the **Create Project** button.

<img src='https://cdn-images-1.medium.com/max/800/1*BDhg-K1-ekeYg4D2AAir3A.jpeg' />

Make sure you set up Firebase real-time database rules to allow the app user to upload image files into the database. To change this setting a newly generated Firebase project, from the sidebar menu in the Firebase console, open Database tab and then choose Rules and modify them as below.

```js
service cloud.firestore {
 match /databases/{database}/documents {
   match /{document=**} {
     allow read, write;
   }
 }
}
```

Next step is to install the Firebase SDK in the project.

```shell
npm install --save firebase
```

To make sure that the required dependency is installed correctly, open `package.json` file. In the `dependencies` object you will find many other dependencies related to react, react native navigation, native-base UI kit, redux and so on. These libraries are helpful if you are working on a React Native project that requires feature like a custom and expandable UI kit, state management, navigation.

```json
"dependencies": {
    "@expo/vector-icons": "^9.0.0",
    "expo": "^32.0.0",
    "expokit": "^32.0.3",
    "firebase": "^5.9.0",
    "lodash": "^4.17.11",
    "native-base": "^2.10.0",
    "prop-types": "^15.6.2",
    "react": "16.5.0",
    "react-native": "https://github.com/expo/react-native/archive/sdk-32.0.0.tar.gz",
    "react-navigation": "^3.0.9",
    "react-navigation-redux-helpers": "^2.0.9",
    "react-redux": "^6.0.0",
    "react-style-proptype": "^3.2.2",
    "redux": "^4.0.1",
    "redux-thunk": "^2.3.0"
  }
```

You are not going to use the majority of them in this tutorial, but the advantage of [Crowdbotics App Builder](https://crowbotics.com/app-builder) is that it provides a pre-configured and hosted, optimum framework for React Native projects. The unwanted packages can be removed if you do not wish to use them.

After installing the Firebase SDK, create a folder called `config` and inside `frontend/src`, and then create a new file called `environment.js`. This file will contain all the keys required to bootstrap and hook Firebase SDK within our application.

```js
var environments = {
  staging: {
    FIREBASE_API_KEY: 'XXXX',
    FIREBASE_AUTH_DOMAIN: 'XXXX',
    FIREBASE_DATABASE_URL: 'XXXX',
    FIREBASE_PROJECT_ID: 'XXXX',
    FIREBASE_STORAGE_BUCKET: 'XXXX',
    FIREBASE_MESSAGING_SENDER_ID: 'XXXX',
    GOOGLE_CLOUD_VISION_API_KEY: 'XXXX'
  },
  production: {
    // Warning: This file still gets included in
    // your native binary and is not a secure way
    // to store secrets if you build for the app stores.
    // Details: https://github.com/expo/expo/issues/83
  }
};

function getReleaseChannel() {
  let releaseChannel = Expo.Constants.manifest.releaseChannel;
  if (releaseChannel === undefined) {
    return 'staging';
  } else if (releaseChannel === 'staging') {
    return 'staging';
  } else {
    return 'staging';
  }
}
function getEnvironment(env) {
  console.log('Release Channel: ', getReleaseChannel());
  return environments[env];
}
var Environment = getEnvironment(getReleaseChannel());
export default Environment;
```

The `Xs` are the values of each key you have to fill in. Ignore the value for Key `GOOGLE_CLOUD_VISION_API_KEY` for now. Other values for their corresponding keys can be attained from the Firebase console. Visit the Firebase console and then click the gear icon next to Project Overview in the sidebar menu and lastly go to `Project settings` section.

Then create another file called `firebase.js` inside the config directory. You are going to use this file in the main application later to send requests to upload an image to the Firebase cloud storage. Import `environment.js`in it to access Firebase keys. That's it for this section.

### Set up Google Cloud Vision APIÂ Key

You need a Gmail account to access the API key for any cloud service provided by Google. Go to [cloud.google.com](https://cloud.google.com/vision/). After you are signed in visit [Google Cloud Console](https://console.cloud.google.com/) and create a new project.

<img src='https://cdn-images-1.medium.com/max/800/1*564hjsW_Z7yQ1QPV5IaJDw.png' />

From the dropdown menu center, select a project. You can click the button `New Project` in the screen below but since we have already generated a Firebase project, select that from the list available.

<img src='https://cdn-images-1.medium.com/max/800/1*BVoAY6JXgqfbBRj0JSpJpg.png' />

Once the project is created or selected, it will appear at the dropdown menu. Next step is to get the Vision API key. Right now you are at the screen called `Dashboard` inside the console. From the top left, click on the menu button and a sidebar menu will pop up. Select `APIs & Services` > `Dashboard`.

<img src='https://cdn-images-1.medium.com/max/800/1*wqh5sg1lkr8mqVZqVbPEUQ.png' />

At the Dashboard, select the button Enable APIs and Services.

<img src='https://cdn-images-1.medium.com/max/800/1*3SaO3iHEzg8sstWl4lL4og.jpeg' />

Then type `vision` in the search bar as shown below and then click Vision API.

<img src='https://cdn-images-1.medium.com/max/800/1*0Wq-izllTVH_jO17AmSQqg.jpeg' />

Then, click the button `Enable` to enable the API. _Note that_ in order to complete this step of getting the API key, you are required to add billing information to your Google Cloud Platform account.

The URL, in your case, on the dashboard will be similar to `https://console.cloud.google.com/apis/dashboard?project=FIREBASE-PROJECT-ID&folder&organizationId`. Click on the `Credentials` section from the left sidebar to create a new API key.

<img src='https://cdn-images-1.medium.com/max/800/1*2WuMEpijqOASZQqUW_mkIQ.jpeg' />

Click the button `Create Credentials`. Once you have created the API key, it is time to add it in the file `environment.js` in place of the key `GOOGLE_CLOUD_VISION_API_KEY`.

The setup is complete. Let us move to the next section and start building the application.

### Logo Detection App

In order to continue building the app, there is another npm module it requires. Run the below command to install it.

```shell
npm install --save uuid
```

This package will help you create a blob for every image that is going to be used for analyzing in the app. A _blob_ is a binary large object stored as a single entity in a database. It is common to use blob for multimedia objects such as an image or a video.

Let us start by importing the necessary libraries that we are going to use in our App component. Open `App.js` file and import the following.

```js
import React, { Component } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Button,
  FlatList,
  Clipboard
} from 'react-native';
import { ImagePicker, Permissions } from 'expo';
import uuid from 'uuid';

import Environment from './src/config/environment';
import firebase from './src/config/firebase';
```

Next, inside the class component, define an initial state with three properties.

```js
class App extends Component {

	state = {
		image: null,
		uploading: false,
		googleResponse: null
  };
```

Each property defined above in the state object has an important role in the app. For instance, `image` is initialized with a value of `null` since when the app starts, there isn't any image URI available by default. The image will be later uploaded to the cloud service. The `uploading` is used when an image is being uploaded to the cloud service along with `ActivityIndicator` from React Native core. The last property, `googleResponse` is going to handle the response object coming back from the Google Vision API when analyzing the data.

It is important to ask for user permissions. Any app functionality that implements features around sensitive information such as location, sending push notifications, taking a picture from the deviceâ€™s camera, it needs to ask for permissions. Luckily, when using Expo, it is easier to implement this functionality. After you have initialized the state, use a lifecycle method `componentDidMount()` to ask for permission's to use a device's camera and camera roll (or _gallery_ in case of Android).

```js
async componentDidMount() {
		await Permissions.askAsync(Permissions.CAMERA_ROLL);
		await Permissions.askAsync(Permissions.CAMERA);
  }
```

For more information on Permissions with Expo, you should take a look at the [official docs](https://docs.expo.io/versions/latest/sdk/permissions/#__next).

On iOS, asking permissions alert will look like below.

<img src='https://cdn-images-1.medium.com/max/800/1*1IWny3GcKb4iZLQd9MyW0g.png' />

On Android:

<img src='https://cdn-images-1.medium.com/max/600/1*u9r_6MpkNUovKzGnRxbh1w.jpeg' />

<img src='https://cdn-images-1.medium.com/max/600/1*OZYu6KqBNfmAn5soM0JqYA.jpeg' />

### Uploading Images toÂ Firebase

To upload file on Firebase cloud storage, you have to create a function outside the class called `uploadImageAsync`. This function will handle sending and receiving AJAX requests to the Cloud Storage server. This function is going to be asynchronous.

```js
async function uploadImageAsync(uri) {
  const blob = await new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      resolve(xhr.response);
    };
    xhr.onerror = function (e) {
      console.log(e);
      reject(new TypeError('Network request failed'));
    };
    xhr.responseType = 'blob';
    xhr.open('GET', uri, true);
    xhr.send(null);
  });

  const ref = firebase.storage().ref().child(uuid.v4());
  const snapshot = await ref.put(blob);

  blob.close();

  return await snapshot.ref.getDownloadURL();
}
```

This asynchronous function `uploadImageAsync` uploads the image by creating a unique image ID or blob with the help of `uuid` module. It also uses `xhr` to send a request to the Firebase Cloud storage to upload the image. It also takes the URI of the image that is going to be uploaded. In the next section, you will learn more about uploading the image.

### Image picker fromÂ Expo

To access a deviceâ€™s UI for selecting an image either from the mobileâ€™s gallery or take a new picture with the camera, we need an interface for that. Some ready-made, configurable API that allows us to add it as functionality in the app. For this scenario, `ImagePicker` is available by Expo.

To use this API, `Permissions.CAMERA_ROLL` is required. Take a look below, how you are going to use it in `App.js` file.

```js
_takePhoto = async () => {
  let pickerResult = await ImagePicker.launchCameraAsync({
    allowsEditing: true,
    aspect: [4, 3]
  });

  this._handleImagePicked(pickerResult);
};

_pickImage = async () => {
  let pickerResult = await ImagePicker.launchImageLibraryAsync({
    allowsEditing: true,
    aspect: [4, 3]
  });

  this._handleImagePicked(pickerResult);
};

_handleImagePicked = async pickerResult => {
  try {
    this.setState({ uploading: true });

    if (!pickerResult.cancelled) {
      uploadUrl = await uploadImageAsync(pickerResult.uri);
      this.setState({ image: uploadUrl });
    }
  } catch (e) {
    console.log(e);
    alert('Upload failed, sorry :(');
  } finally {
    this.setState({ uploading: false });
  }
};
```

From the above snippet, notice that there are two separate functions to either pick the image from the deviceâ€™s file system: `_pickImage` and for taking a photo from the camera: `_takePhoto`. Whichever function runs, `_handleImagePicked` is invoked to upload the file to cloud storage by further calling the asynchronous `uploadImageAsync` function with the URI of the image as the only argument to that function.

Inside the `render` function you will add the two buttons calling their own separate methods when pressed.

```js
<View style={{ margin: 20 }}>
	<Button
		onPress={this._pickImage}
		title="Pick an image from camera roll"
		color="#3b5998"
	/>
</View>
<Button
onPress={this._takePhoto}
title="Click a photo"
color="#1985bc"
/>
```

### Analyzing theÂ Logo

After the image has either been selected from the file system or clicked from the camera, it needs to be shared with Googleâ€™s Vision API SDK in order to fetch the result. This is done with the help of a `Button` component from React Native core in the `render()` method inside `App.js`.

```js
<Button
  style={{ marginBottom: 10 }}
  onPress={() => this.submitToGoogle()}
  title="Analyze!"
/>
```

This `Button` publishes the image to Google's Cloud Vision API. On pressing this button, it calls a separate function `submitToGoogle()` where most of the business logic happens in sending a request and fetching the desired response from the Vision API.

```js
submitToGoogle = async () => {
  try {
    this.setState({ uploading: true });
    let { image } = this.state;
    let body = JSON.stringify({
      requests: [
        {
          features: [
            { type: 'LABEL_DETECTION', maxResults: 10 },
            { type: 'LANDMARK_DETECTION', maxResults: 5 },
            { type: 'FACE_DETECTION', maxResults: 5 },
            { type: 'LOGO_DETECTION', maxResults: 5 },
            { type: 'TEXT_DETECTION', maxResults: 5 },
            { type: 'DOCUMENT_TEXT_DETECTION', maxResults: 5 },
            { type: 'SAFE_SEARCH_DETECTION', maxResults: 5 },
            { type: 'IMAGE_PROPERTIES', maxResults: 5 },
            { type: 'CROP_HINTS', maxResults: 5 },
            { type: 'WEB_DETECTION', maxResults: 5 }
          ],
          image: {
            source: {
              imageUri: image
            }
          }
        }
      ]
    });
    let response = await fetch(
      'https://vision.googleapis.com/v1/images:annotate?key=' +
        Environment['GOOGLE_CLOUD_VISION_API_KEY'],
      {
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: body
      }
    );
    let responseJson = await response.json();
    console.log(responseJson);
    this.setState({
      googleResponse: responseJson,
      uploading: false
    });
  } catch (error) {
    console.log(error);
  }
};
```

The Vision API uses an HTTP Post request as a REST API endpoint. It performs data analysis on the image URI send with the request. This is done via the URL `https://vision.googleapis.com/v1/images:annotate?key=[API_KEY]`. To authenticate each request, we need the API key. The body of this POST request is in JSON format. This JSON request tells the Google Vision API which image to parse and which of its detection features to enable.

An example a POST body response in JSON format from the API is going to be similar like below.

```json
"logoAnnotations": Array [
         Object {
           "boundingPoly": Object {
             "vertices": Array [
               Object {
                 "x": 993,
                 "y": 639,
               },
               Object {
                 "x": 1737,
                 "y": 639,
               },
               Object {
                 "x": 1737,
                 "y": 1362,
               },
               Object {
                 "x": 993,
                 "y": 1362,
               },
             ],
           },
           "description": "spotify",
           "mid": "/m/04yhd6c",
           "score": 0.9259,
         },
      ],
```

Notice that it gives us back the complete object with a description of the logoâ€™s name searched for. This can be viewed in the terminal window from the logs generated while the Expo CLI command is active.

<img src='https://cdn-images-1.medium.com/max/800/1*EJ5MRzjxoBFElHT_1EHbXA.png' />

See the application in working below. A real android device was used to demonstrate this. If you want to test yourself one a real device, just download the Expo client for your mobile OS, scan the QR code generated after starting expo CLI command and then click the button Take a photo while the application is running.

If you visit the storage section in Firebase, you can notice that each image is stored with a name of base64 binary string.

<img src='https://cdn-images-1.medium.com/max/800/1*jWeopMWFwK7KAoaNPL3dDw.jpeg' />

### Conclusion

The possibilities of using Googleâ€™s Vision API are endless. As you can see above in the `features` array, it works with a variety of categories such as logos, landmarks, labels, documents, human faces and so on.

I hope you enjoyed this tutorial. Let me know if you have any questions.

You can find the complete code in the **Github repository** below.

[**crowdbotics-apps/rngooglevisionapi-1400**](https://github.com/crowdbotics-apps/rngooglevisionapi-1400)

[Originally published at Crowdbotics](https://medium.com/crowdbotics/how-to-build-a-real-time-logo-detection-app-with-react-native-google-vision-api-and-crowdbotics-9ed65fbcd15)

---

## How To Build a REST API With Nodejs and PostgreSQL
Slug: how-to-build-a-rest-api-with-nodejs-and-postgresql

![cover](https://i.imgur.com/0ARGlWV.png)

> [Originally published at Crowdbotics](https://medium.com/crowdbotics/how-to-build-a-rest-api-with-nodejs-and-postgresql-828c7ec1e8b1)

One of the most important aspects of being a Web Developer is to know how to work with APIs.

Whether building your own application as a front-end or back-end engineer, you are going to come across them. APIs are the core communication system behind the different software systems including the server, the database and the client-side of an application.

In this tutorial, **we are going to create a REST API using** [**Node.js**](https://www.crowdbotics.com/build/node-js/?utm_campaign=v1&utm_source=blog-post&utm_medium=Medium&utm_content=node) **as the back-end server with help from ExpressJS framework, and connect it with** [**PostgreSQL**](https://www.postgresql.org/) **database.**

## Prerequisites

To get started with this tutorial, knowledge of the following will be beneficial.

- Knowledge of some of the ES6 JavaScript features
- Node.js and npm installed on your local dev machine
- PostgreSQL installed

If you do not have PostgreSQL installed on your local development machine, you can continue reading the next step where I will walk you through step by step installing it. If you already have it, please skip the next step.

> [**Building with Node? Try out the Crowdbotics application builder to instantly scaffold and deploy a Node applications.**](https://app.crowdbotics.com/accounts/login/?utm_campaign=v1&utm_source=blog-post&utm_medium=Medium&utm_content=app-builder)

## Installing PostgreSQL

PostgreSQL is a powerful and an open source object-relational database. If you are on a Windows machine, PostgreSQL offers an [**installer**](https://www.postgresql.org/download/windows/)**.**

On macOS, I am going to use `Homebrew` to install it. Open a terminal window and type the following command.

```shell
brew install postgresql
```

Once the installation is complete, to start the PostgreSQL database you will need to run the below command.

```shell
brew services start postgresql
```

After starting this service, you will get a success message like below.

<img src='https://cdn-images-1.medium.com/max/800/1*oAV6fVIGxkjj5VD4nRCM1g.png' />

**Note**: Later on, when you need to stop the `postresql` service, you can run the command `brew services stop postgresql`.

## Getting Started

Create an empty directory and run the following set of commands to initialize an Express server.

```shell
# create a new directory
mkdir rest-api-nodejs-postgresql

# traverse inside it
cd rest-api-nodejs-postgresql

# initialize npm
npm int --yes

# install express
npm install -S express
```

Create a `server.js` file which is going to be the entry point for our server. At the top, we are going to require the `express` module and add some configuration middleware functions to handle `req.body` data. To run the server, type the command `node index.js` and go to URL `http://localhost:4000/` in a browser window and you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*hkctm5kI-r_XA_Ksg6fQAw.png' />

With that working, we need a way to restart the server every time we change something in our code. I am going to use `nodemon` which will automatically watch for changes in anyÂ `.js` file we make in our demo app. To install run `npm i -D nodemon` and add the following to your `package.json` file.

```json
"scripts": {
  "start": "nodemon server.js"
}
```

To now run the project we need to use `npm run start` command from now on.

## Setting up Sequelize

Since you have installed PostgreSQL database, and the service is up and running, we can move on to the next step that is to make a connection between the ExpressJS server and PostgreSQL. In order to do that, you will need an ORM (_Object Relational Mapper_) to provide us an interface for both the connection and the API. For our demo, we are going to use [**Sequelize**](http://docs.sequelizejs.com/). Let us begin by installing it.

```shell
npm install -S sequelize-cli
```

The next step is to create aÂ `.sequelizerc` file in the root of our project. This is going to be the configuration file that contains the specific paths required by Sequelize module. It will help us generate folders and files necessary for sequelize to work.

```js
path = require('path');

module.exports = {
  config: path.resolve('./config', 'config.json'),
  'models-path': path.resolve('./models'),
  'seeders-path': path.resolve('./seeders'),
  'migration-path': path.resolve('./migrations')
};
```

Notice that we are making use of `path` module from Node's core API in this process. The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path. If no path segments are passed, path.resolve() will return the absolute path of the current working directory and in our case, the current working directory is going to be the root of our project.

Now, letâ€™s run the initializing command in order to generate the boilerplate code and necessary folders.

```shell
sequelize init
```

When you run the above command successfully, you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*Nx7Ck_TlesGm552IzEVF5Q.png' />

You will also find changes made to your project directory like below. New files and folders created from theÂ `.sequelizerc` file.

<img src='https://cdn-images-1.medium.com/max/800/1*OiyN1jTzSb9wPQed6YHd6w.png' />

## Making Database Connection

The next step is to install the required dependencies in order to create a database connection with a PostgreSQL database and have access to the database for CRUD operations. Fire up your terminal with the following command.

```shell
npm install -S pg pg-hstore
```

The package `pg` is responsible for creating the database connection with our Express server and `pg-hstore` is for serializing and deserializing JSON data into the PostgreSQL's hstore format. `hstore` data format stores information in key/value pairs within a single PostgreSQL value. To read more about what exactly `hstore` is or how it works, you can pause here and give the [**official documentation**](https://www.postgresql.org/docs/9.3/hstore.html) a glimpse.

The two files that are being used in order to create the database connection in our project are `config/config.js` and `models/index.js`. The first thing you need to do here is to create a local database instance. From the command line run the below command.

```shell
createdb todos
```

The above `createdb` command is made available to us when we install the PostgreSQL database. Now, let us make some modifications to the`config.js` file. We have to manually define the database instance we create. You can even set up the password to protect the database on your local machine. For our demo, I am going to leave this configuration field to `null`. Also, you will have to change the database dialect to `postgres`.

```json
{
  "development": {
    "username": "root",
    "password": null,
    "database": "todos",
    "host": "127.0.0.1",
    "dialect": "postgres"
  },
  "test": {
    "username": "root",
    "password": null,
    "database": "todos",
    "host": "127.0.0.1",
    "dialect": "postgres"
  },
  "production": {
    "username": "root",
    "password": null,
    "database": "todos",
    "host": "127.0.0.1",
    "dialect": "postgres"
  }
}
```

You can change the aforementioned values for all three: `development`, `test`, and `production` but do make a notice, for now, we are going to use `development`. This is done in `models/index.js`.

```js
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(
    config.database,
    config.username,
    config.password,
    config
  );
}

fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 && file !== basename && file.slice(-3) === '.js'
    );
  })
  .forEach(file => {
    const model = sequelize['import'](path.join(__dirname, file));
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
```

When you deploy your application and use an online hosted database instance, you will need to change `const env = process.env.NODE_ENV || 'development';` with the database URL you get. With this, our setup is complete.

## Creating the DatabaseÂ Model

In this section, you are going to create two models: `Todo` and `TodoItem`. The `Todo` is going to be the list of one or many `TodoItem`. In terms of traditional SQL database, you can say that `Todo` will have a relationship with `TodoItem` of one-to-many. We are going to sequelize command line interface to generate the boilerplate code for our models.

```shell
sequelize model:create --name Todo --attributes title:string
```

The above command will generate a new file inside `models/todo.js`. You can verify that the above command runs successfully with below image.

<img src='https://cdn-images-1.medium.com/max/800/1*Du48q0ycr2EH7UTMQnkjBA.png' />

As you can see, another file is created in `migrations/` directory. Our concern at this time is the model file itself which looks like this.

```js
'use strict';
module.exports = (sequelize, DataTypes) => {
  const Todo = sequelize.define(
    'Todo',
    {
      title: DataTypes.STRING
    },
    {}
  );
  Todo.associate = function (models) {
    // associations can be defined here
  };
  return Todo;
};
```

This file is exporting a model called `Todo` which has a single attribute `title` as type `string`. Let us now create our next model for `TodoItem`.

```shell
sequelize model:create --name TodoItem --attributes content:string,complete:boolean
```

This is how our second model inside `todoitem.js` looks like. It has two attributes, `content` of datatype `string` and complete of datatype `boolean`.

```js
'use strict';
module.exports = (sequelize, DataTypes) => {
  const TodoItem = sequelize.define(
    'TodoItem',
    {
      content: DataTypes.STRING,
      complete: DataTypes.BOOLEAN
    },
    {}
  );
  TodoItem.associate = function (models) {
    // associations can be defined here
  };
  return TodoItem;
};
```

## Creating the Database Relationship

`Todo` and `TodoItem` are going to have one-to-many-relationship. This done by associating both the models and define a custom class method. Let us modify both the model files to add this and some modification in each attribute for things to work our way. Open `todo.js` file.

```js
'use strict';
module.exports = (sequelize, DataTypes) => {
  const Todo = sequelize.define(
    'Todo',
    {
      title: {
        type: DataTypes.STRING
      }
    },
    {}
  );
  Todo.associate = function (models) {
    // associations can be defined here
    Todo.hasMany(models.TodoItem, {
      foreignKey: 'todoId',
      as: 'todoItems'
    });
  };
  return Todo;
};
```

The first modification you will make is to add `type` to make the attribute easier to read. Next, inside `Todo.associate` class method we are defining a relationship between both our models using `hasMany` method. Notice how it intakes `models` parameter. The `foreignKey,` in this case, the `id` of each `TodoItem`. The `as` attribute next to `foreignKey` means that on each query for a todo, it will include the todo items for the above id.

Now, open `todoitem.js`.

```js
'use strict';
module.exports = (sequelize, DataTypes) => {
  const TodoItem = sequelize.define(
    'TodoItem',
    {
      content: { type: DataTypes.STRING },
      complete: { type: DataTypes.BOOLEAN, defaultValue: false }
    },
    {}
  );
  TodoItem.associate = function (models) {
    // associations can be defined here

    TodoItem.belongsTo(models.Todo, {
      foreignKey: 'todoId',
      onDelete: 'CASCADE'
    });
  };
  return TodoItem;
};
```

First, you are going to edit both attributes `content` and `complete`. With `complete` a default value is now has been added. Having a default value will allow the database to provide a value for the particular field. The `onDelete` tells the database to delete the whole todo item when from the associated todo it belongs too.

## Running the Migrations

Migrations provide a clearer picture of what our database models going to look like inside. Since you are making changes in the generated attributes and adding fields like in our case, `defaultValue`, you have to edit the migration files for each specific model wherever necessary.

Running migrations take care of creating the database table and associated column inside the table for us. This is the functionality of each `up` function in both migrations files. There is also a `down` function that is only to run when you need to undo the changes inside the database table for some reason. Open inside `migrations/<date-time>-create-todo.js` file.

```js
'use strict';
module.exports = {
  up: (queryInterface, Sequelize) => {
    return queryInterface.createTable('Todos', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  down: (queryInterface, Sequelize) => {
    return queryInterface.dropTable('Todos');
  }
};
```

Similar changes are made inside `migrations/<date-time>-crrate-todo-item.js`.

```js
'use strict';
module.exports = {
  up: (queryInterface, Sequelize) => {
    return queryInterface.createTable('TodoItems', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      content: {
        type: Sequelize.STRING
      },
      complete: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      todoId: {
        type: Sequelize.INTEGER,
        onDelete: 'CASCADE',
        references: {
          model: 'Todos',
          key: 'id',
          as: 'todoId'
        }
      }
    });
  },
  down: (queryInterface, Sequelize) => {
    return queryInterface.dropTable('TodoItems');
  }
};
```

In the above file, you are also defining the relationship between both the models. The `todoId` field is not going to be generated by Sequelize automatically until we define it above inside `migrations/<date-time>-crrate-todo-item.js`. Let us run the migration command and generate these models in our database. Open your terminal and execute the below command.

```shell
sequelize db:migrate
```

You will get a result like below indicating the success of the above command.

<img src='https://cdn-images-1.medium.com/max/800/1*XT_pFJozGEeytKP22F8Awg.png' />

**Please Note** if the above command throws an error such as `ERROR: role "root" does not exist`. This means you do not have a username created already for `postgres`. You will have to run the following command and can follow the official documentation [**here**](https://www.postgresql.org/docs/10/app-createuser.html) for information.

```shell
createuser <username>
```

## Building theÂ API

Creating models might seem overwhelming if you are doing it the first time but if you have followed closely so far, you will have no problem going through the whole process next time. In this section, we are going to start building our API. You are going to create your first controller for `todos` inside a new directory and file `controllers/todos.js`. We start by requiring the `todos` model.

```js
const Todo = require('../models').Todo;

module.exports = {
  create(req, res) {
    return Todo.create({
      title: req.body.title
    })
      .then(todo => res.status(201).send(todo))
      .catch(error => res.status(400).send(error));
  }
};
```

Then, we are exporting the controller function inside which `create` function exists. This function will handle the business logic behind the route handler that we are going to define soon for creating a new todo in our database. It accepts two parameters, `req` for incoming requests and `res` to send the response back to an individual incoming request. On success,Â `.then()` function will trigger and send back the todo item with an HTTP status of `201`. If an error is encountered,Â `.catch` will return the error with an HTTP status of `400`.

You can think of each todo we create here as the name of a list of items. Right now we only are defining the business logic of creating the name for each list. Letâ€™s complete this process and test with a REST client to see if everything works. Now we are going to connect this controller to the desired route. Create a new folder called `routes` and inside it a file called `index.js`.

```js
const todosController = require('../controllers/todos.js');

module.exports = app => {
  app.get('/api', (req, res) =>
    res.status(200).send({
      message: 'Create Your Own Todo Lists API'
    })
  );

  app.post('/api/todos', todosController.create);
};
```

In the above file, there are two routes being defined. One is `/api` which displays the welcome message and using `app.post('/api/todos`) where the request for creating a new to-do list can be send. Last step before the testing of this two new routes begin is to hook the routes inside `server.js` file.

```js
const express = require('express');

const app = express();
const PORT = 4000;

app.use(express.json());
app.use(
  express.urlencoded({
    extended: true
  })
);

// app.get('/', (req, res) => {
// 	res.json({ message: 'REST API with Node.js, and Postgres API' });
// });

require('./routes/index')(app);

app.listen(PORT, () => {
  console.log(`Server running at port ${PORT}.`);
});

module.exports = app;
```

To see if everything is working, letâ€™s run the server by running `npm run start` and open your favorite REST API client like Postman [Abhinav Asthana](https://medium.com/u/94144f041644) or [Insomnia REST Client](https://medium.com/u/f5d2e9d5d710) to test the new routes. When you run the URL `http://localhost:4000/api` you will get the success message like below.

<img src='https://cdn-images-1.medium.com/max/1200/1*mw85LS3bjGLqyy4-nG1oHg.png' />

Next step is to create a new todo item. Run the URL `http://localhost:4000/api/todos`.

<img src='https://cdn-images-1.medium.com/max/1200/1*eEigERbZHWQLKXEeKEcsxw.png' />

So far so good. Let us create a new controller and a route that will list all the to-do lists in our database. Open `controllers/todos.js`. Add the below after `create()` function.

```js
// after create()
list(req, res) {
		return Todo.all()
			.then(todos => res.status(201).send(todos))
			.catch(error => res.status(400).send(error));
  }
```

Now open `routes/index.js` and create the new route for this logic to run.

```js
app.get('/api/todos', todosController.list);
```

Open the REST client and visit the URL `http://localhost:4000/api/todos](http://localhost:4000/api/todos`.

<img src='https://cdn-images-1.medium.com/max/1200/1*70TGcibYiHPQ_jMGbHfEPw.png' />

## API for TodoÂ Items

Since the API is responding to the logic we have written behind it, you can continue to build it. In this section, you are going to create an individual item and add it to a specific list. Start by creating a file `todoitem.js` inside `controllers/`.

```js
const TodoItem = require('../models').TodoItem;

module.exports = {
  create(req, res) {
    return TodoItem.create({
      content: req.body.content,
      todoId: req.params.todoId
    })
      .then(todoItem => res.status(201).send(todoItem))
      .catch(error => res.status(400).send(error));
  }
};
```

Next step is to add the route for it inside `routes/index.js`.

```js
const todosController = require('../controllers/todos.js');
const todoItemsController = require('../controllers/todoitem.js');

module.exports = app => {
  app.get('/api', (req, res) =>
    res.status(200).send({
      message: 'Create Your Own Todo Lists API'
    })
  );

  app.post('/api/todos', todosController.create);
  app.get('/api/todos', todosController.list);

  app.post('/api/todos/:todoId/items', todoItemsController.create);
};
```

The last step is to test this API endpoint. Run the URL `http://localhost:4000/api/todos/2/items`. Do note that the `2` in this URL is the `id` of the list that will associate this todo item to a todo list. From earlier images, you can note that I had three lists with `IDs`: `2`, `9` and `10`. If everything is going right for you, this may differ. You will have `IDs` starting from `1`.

<img src='https://cdn-images-1.medium.com/max/1200/1*6ni8M5l4R3BN7Kz7xUZQtQ.png' />

Now let us modify the `list` function in `controllers/todos.js` such that it returns the todo item along with the list name.

```js
const Todo = require('../models').Todo;
const TodoItem = require('../models').TodoItem;

module.exports = {
  create(req, res) {
    return Todo.create({
      title: req.body.title
    })
      .then(todo => res.status(201).send(todo))
      .catch(error => res.status(400).send(error));
  },
  list(req, res) {
    return Todo.findAll({
      include: [
        {
          model: TodoItem,
          as: 'todoItems'
        }
      ]
    })
      .then(todos => res.status(201).send(todos))
      .catch(error => res.status(400).send(error));
  }
};
```

To test this, run the URL `http://localhost:4000/api/todos` and you will get similar result like below.

<img src='https://cdn-images-1.medium.com/max/1200/1*06TUB4RzVdfsCoAoTJyHrg.png' />

Notice how the below snippet is added. This is done through the association methods we defined earlier when creating both of our models.

```json
"todoItems": [
  {
    "id": 3,
    "content": "buy milk",
    "complete": false,
    "createdAt": "2018-12-02T18:06:25.059Z",
    "updatedAt": "2018-12-02T18:06:25.059Z",
    "todoId": 2
  }
]
```

## Deleting TodoÂ Lists

The last API endpoint we require is to delete a todo list which will further delete all items inside it as `todoItems`. Open `controllers/todos.js`.

```js
destroy(req, res) {
		return Todo.findById(req.params.todoId)
			.then(todo => {
				if (!todo) {
					return res.status(400).send({
						message: 'Todo List not found'
					});
				}
				return todo
					.destroy()
					res.status(200).send({ message: 'Todo List deleted Successfully' })
					.catch(error => res.status(400).send(error));
			})
			.catch(error => res.status(400).send(error));
  }
```

Add the corresponding route inside `routes/index.js`.

```js
app.delete('/api/todos/:todoId', todosController.destroy);
```

When you run the URL `http://localhost:4000/api/todos/2` with HTTP `DELETE` request it will respond back like below.

<img src='https://cdn-images-1.medium.com/max/1200/1*6xehAdlL-W2HpJMb3ytdCg.png' />

This can also be verified by running `http://localhost:4000/api/todos`. In response, you will not see the same todo list we just deleted.

<img src='https://cdn-images-1.medium.com/max/1200/1*x5U82BBpx__Cq8FCQZ9PRw.png' />

## Conclusion

Thatâ€™s it! In this article, you learned about using PostgreSQL as a database and using ORM tools like Sequelize, and how to migrate data models into database properly. We learned how to connect PostgreSQL database and what the correct configuration to do so. Also, we created a REST API using Express as the back-end server framework. Our REST API can be improved with better error handling and form validation. The possibilities from here are endless. The popularity of the PostgreSQL database among developers is at its peak.

**The complete code for the tutorial at [this Github repository](https://github.com/amandeepmittal/rest-api-node-postgresql)**

---

## How to Build a Serverless Backend with AWS Lambda and Nodejs
Slug: how-to-build-a-serverless-backend-with-aws-lambda-and-nodejs

Serverless architecture is a cloud computing execution model where a cloud provider like AWS, Azure or Google Cloud is used to deploy backend or server-side code. In comparison to traditionally deployed web applications, in serverless architecture, the developer does not has to maintain the servers or the infrastructure. They only have to pay a subscription to the third party vendor whereas the vendor is responsible to handle the operation of the backend logic of a server along with scalability, reliability, and security.

There are two ways a serverless architecture can be implemented in order to deploy your server-side code. First one is Backend as a Service or **_BaaS_**. A good example of this is Firebase which you can often see in conjunction between a web or a mobile application to a database or providing user authentication.

What we are going to focus in this article is called Function as a Service or **_FaaS_**. With FaaS, the server code is run inside containers that are usually triggered by common events such as HTTP requests from the client, database operations, file uploads, scheduled events and so on. The code on the cloud provider that is deployed and getting executed is in the form of a function.

In FaaS, these functions are deployed in modular form. One function corresponds to each operation, thus eliminating the rest of the code and time spent on writing boilerplate code for setting up a server and data models. These modular functions can further be scaled automatically and independently. This way, more time can be spent on writing the logic of the application that a potential user is going to interact with. You do not have to scale for the entire application and pay for it. Common use cases of FaaS so far have been implemented are scheduled tasks (or cron jobs), automation, [web applications](https://www.crowdbotics.com/build/build-software-faster), and [chatbots](https://www.crowdbotics.com/build/chatbot-software).

Common FaaS service platform providers are:

- AWS Lambda
- [Google Cloud](https://medium.com/u/4f3f4ee0f977) Functions
- Microsoft Azure Functions
- [Apache OpenWhisk](https://medium.com/u/3d89752f34da)

In the following tutorial, we are going to create a demo to deploy on a serverless infrastructure provider such as AWS Lambda.

### What is AWSÂ Lambda?

In order to build and deploy a backend function to handle a certain operation, I am going to start with setting up the service provider you are going to use to follow this article. AWS Lambda supports different runtimes such as [Node.js](https://www.crowdbotics.com/build/node-js), Java, Python,Â .NET Core and Go for you to execute a function.

The function runs inside a container with a 64-bit Amazon Linux AMI. You might be thinking, â€˜why I am telling you all of this?â€™ Well, using serverless for the first time can be a bit overwhelming and if you know what you are getting in return, thatâ€™s always good! More geeky stuff is listed below.

- Memory: 128MBâ€Šâ€”â€Š3008MB
- Ephemeral disk space: 512MB
- Max execution duration: 300 seconds
- Compressed package size: 50MB
- Uncompressed package size: 250MB

The execution duration here means that your Lambda function can only run a maximum of 5 minutes. This does mean that it is not meant for running longer processes. The disk space is the form of a temporary storage. The package size refers to the code necessary to trigger the server function. In case of Node.js, this does mean that any dependencies that are being imported into our server (for example, `node_modules/` directory).

A typical lambda function in a Node.js server will look like below.

<img src='https://cdn-images-1.medium.com/max/1200/1*a8oVpnOEISTzsuLEH9UaqA.png' />

In the above syntax, `handlerFunction` is the name of our Lambda function. The `event` object contains information about the event that triggers the lambda function on execution. The `context` object contains information about the runtime. Rest of the code is written inside the Lambda function and at last a `callback` is invoked with an error object and result object. We will learn more about these objects later when are going to implement them.

### Setting up AWSÂ Lambda

In order to setup a Lambda function on AWS, we need to first register an account for the access keys. Use your credentials to login or signup a new account on [console.amazon.com](https://portal.aws.amazon.com/billing/signup#/start) and once you are through the verification process you will be welcomed by the following screen.

<img src='https://cdn-images-1.medium.com/max/1200/1*Z_nBXZzDdIuiuM6JdFGqGA.png' />

To get the keys and permissions in order to deploy a function, we have to switch to Identity and Access Management (IAM). Then go to `Users` tab from the left hand sidebar and click on the button `Add user`. Fill in the details in the below form and do enable `Access Type > Programmatic Access`.

<img src='https://cdn-images-1.medium.com/max/1200/1*PHUnYi1euJNBo1DCgIP2Sw.png' />

Then on the next page, select `Attach Existing Policies Directly` and then select a policy name `AdministratorAccess`.

<img src='https://cdn-images-1.medium.com/max/1200/1*ZwcXfwj7ZtSW6PzZxGJDNQ.png' />

Click `Next: Review` button and then click `Create User` button when displayed. Proceeding to the next step you will see the user was created. Now, and only now, will you have access to the users Access Key ID and Secret Access Key. This information is unique for every user you create.

### Creating a Serverless Function

We are going to use install an npm dependency first to proceed and scaffold a new project. Open up your terminal and install the following.

```shell
npm install -g serverless
```

Once installed, we can run the serverless framework in the terminal by running the command:

```shell
serverless
```

Or use the shorthand `sls` for `serverless`. This command will display all the available commands that come with the serverless framework.

<img src='https://cdn-images-1.medium.com/max/1200/1*J5dUlRdUkpTqNY2POPK7ag.png' />

After installing the `serverless` dependency as a global package, you are ready to create your first function. To start, you will need to configure your AWS registered user credentials. AWS gives you a link to download access keys when creating a user.

<img src='https://cdn-images-1.medium.com/max/800/1*b8xegxAg6xjsMC4CHFsYzA.png' />

You can also visit your username and visit _Security Credentials_ like below.

<img src='https://cdn-images-1.medium.com/max/1200/1*9M0Nb4QTI9gFxoG1wVh1jA.png' />

Now let us configure AWS with the serverless package.

```shell
sls config credentials --provider aws --key ACCESS_KEY --secret SECRET_KEY
```

If the above command runs successfully you will get a success message like below

<img src='https://cdn-images-1.medium.com/max/800/1*uqlYKZAAgpDAWmXhN8mB0A.png' />

The good thing about using `serverless` npm package is that it comes with pre-defined templates that you can create in your project using a command and also creates a basic configuration for us that is required to deploy our Lambda function. To get started, I am going to use `aws-nodejs` template inside a new directory.

```shell
sls create -t aws-nodejs -p aws-serverless-demo && cd aws-serverless-demo
```

The `-p` flag will create a new directory with name `aws-serverless-demo`. The `-t` flag uses the pre-defined boilerplate. The result of this will create three new files in your project directory.

- UsualÂ `.gitignore`
- `handler.js` where we will write our handle function
- `serverless.yml` contains the configuration

The default handler file looks like below.

```js
'use strict';

module.exports.hello = async (event, context) => {
  return {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Go Serverless v1.0! Your function executed successfully!',
      input: event
    })
  };

  // Use this code if you don't use the http event with the LAMBDA-PROXY integration
  // return { message: 'Go Serverless v1.0! Your function executed successfully!', event };
};
```

In the above file, `hello` is the function that has two parameters: `event`, and `context`. `module.exports` is basic Nodes syntax as well as the rest of the code. You can clearly see it also supports ES6 features. An `event` is an object that contains all the necessary request data. The `context` object contains AWS-specific values. We have already discussed it before. Let us modify this function to our needs and add a third parameter called the`callback`. Open `handler.js` file and edit the `hello` function.

```js
'use strict';

module.exports.hello = (event, context, callback) => {
  console.log('Hello World');
  callback(null, 'Hello World');
};
```

The `callback` function must be invoked with an `error` response as the first argument, in our case it is `null` right now or a valid response as the second argument which is currently sending a simple `Hello World` message. We can now deploy this handler function using the command below from your terminal window.

```shell
sls deploy
```

It will take a few minutes to finish the process. Our serverless function gets packed into aÂ `.zip` file. Take a notice at the **Service Information** below. It contains all the information what endpoints are available, what is our function, where it is deployed and so on.

<img src='https://cdn-images-1.medium.com/max/800/1*m2FL-IdSqaFhKMuSmKnT_Q.png' />

You can try the `invoke` attribute like following to run the function and see the result.

```shell
sls invoke --function hello
```

The output will look like below.

<img src='https://cdn-images-1.medium.com/max/800/1*W_iWmZ_bVhyjp7mfbmBN6Q.png' />

Take a look at the configuration in `serverless.yml`.

```yml
# Welcome to Serverless!
#
# This file is the main config file for your service.
# It's very minimal at this point and uses default values.
# You can always add more config options for more control.
# We've included some commented out config examples here.
# Just uncomment any of them to get that config option.
#
# For full config options, check the docs:
#    docs.serverless.com
#
# Happy Coding!

service: aws-nodejs # NOTE: update this with your service name

# You can pin your service to only deploy with a specific Serverless version
# Check out our docs for more details
# frameworkVersion: "=X.X.X"

provider:
  name: aws
  runtime: nodejs8.10

# you can overwrite defaults here
#  stage: dev
#  region: us-east-1

# you can add statements to the Lambda function's IAM Role here
#  iamRoleStatements:
#    - Effect: "Allow"
#      Action:
#        - "s3:ListBucket"
#      Resource: { "Fn::Join" : ["", ["arn:aws:s3:::", { "Ref" : "ServerlessDeploymentBucket" } ] ]  }
#    - Effect: "Allow"
#      Action:
#        - "s3:PutObject"
#      Resource:
#        Fn::Join:
#          - ""
#          - - "arn:aws:s3:::"
#            - "Ref" : "ServerlessDeploymentBucket"
#            - "/*"

# you can define service wide environment variables here
#  environment:
#    variable1: value1

# you can add packaging information here
#package:
#  include:
#    - include-me.js
#    - include-me-dir/**
#  exclude:
#    - exclude-me.js
#    - exclude-me-dir/**

functions:
  hello:
    handler: handler.hello
#    The following are a few example events you can configure
#    NOTE: Please make sure to change your handler code to
#     work with those  events
#    Check the event documentation for details
#    events:
#      - http:
#          path: users/create
#          method: get
#      - s3: ${env:BUCKET}
#      - schedule: rate(10 minutes)
#      - sns: greeter-topic
#      - stream: arn:aws:dynamodb:region:XXXXXX:table/foo/stream/1970-01-01T00:00:00.000
#      - alexaSkill: amzn1.ask.skill.xx-xx-xx-xx
#      - alexaSmartHome: amzn1.ask.skill.xx-xx-xx-xx
#      - iot:
#          sql: "SELECT * FROM 'some_topic'"
#      - cloudwatchEvent:
#          event:
#            source:
#              - "aws.ec2"
#            detail-type:
#              - "EC2 Instance State-change Notification"
#            detail:
#              state:
#                - pending
#      - cloudwatchLog: '/aws/lambda/hello'
#      - cognitoUserPool:
#          pool: MyUserPool
#          trigger: PreSignUp

#    Define function environment variables here
#    environment:
#      variable2: value2

# you can add CloudFormation resource templates here
#resources:
#  Resources:
#    NewResource:
#      Type: AWS::S3::Bucket
#      Properties:
#        BucketName: my-new-bucket
#  Outputs:
#     NewOutput:
#       Description: "Description for the output"
#       Value: "Some output value"
```

### REST API with Serverless Stack

In this part of the tutorial, I will show you **how to hook up a MongoDB database as a service to a Serverless REST API.** We are going to need three things that will complete our tech stack. They are:

- AWS Lambda
- Node.js
- MongoDB Atlas

We already have the first two, all we need is to setup a [MongoDB](https://medium.com/u/db5cd12199bd) cloud database called Atlas. MongoDB Atlas is a database as a service developed by the team behind the MongoDB itself. Along with providing a free/paid tier for storing your data on the cloud, MongoDB Atlas provides a lot of analytics that is essential to manage and monitor your application. MongoDB Atlas does provide a free tier that we will be using with our serverless stack.

### Creating a database on MongoDBÂ Atlas

We will start by creating a database on the MongoDB Atlas. Login to the site and create an account if you do not have it already. We just need a sandbox environment to get hands-on experience so we must opt for free tier. Once you have your account set up, open up your account page and add a new organization.

<img src='https://cdn-images-1.medium.com/max/800/1*7W3seaSdt-J2JfQYHidnhQ.png' />

Now, after entering the name, proceed further and click on _Create Organization_.

<img src='https://cdn-images-1.medium.com/max/800/1*PfITUpnG3MXuQz23mskXNQ.png' />

You will be then prompted to the main screen where you can create a new project. Type in the name of your project and proceed further.

<img src='https://cdn-images-1.medium.com/max/800/1*d9BZjyAy5FPLB7TEXq3Ccw.png' />

MongoDB Atlas is secured by default. You need to set permissions before we leverage its usage in our app. You can name the database at the pointed field below.

<img src='https://cdn-images-1.medium.com/max/800/1*h1fSIz3G3svG6wzTCATiAA.png' />

Now, we can add our free sandbox to this project. It is called a cluster.

<img src='https://cdn-images-1.medium.com/max/800/1*1PO22dNYhGRkSzuwEilmFg.png' />

After all that, just add an admin user for the cluster and give him a really strong password. As you can see the price for this cluster will be `$0.00` forever. Your cluster will take a few minutes to deploy. While that is underway, let us finally start writing some code.

### Building theÂ API

Next, we install all the necessary dependencies in order to create the API.

```shell
init -y
npm i --save mongoose dotenv
```

After that, we configure the `serverless.yml` and add the other handler functions that we need to deploy.

```yml
# Welcome to Serverless!
#
# This file is the main config file for your service.
# It's very minimal at this point and uses default values.
# You can always add more config options for more control.
# We've included some commented out config examples here.
# Just uncomment any of them to get that config option.
#
# For full config options, check the docs:
#    docs.serverless.com
#
# Happy Coding!

service: aws-nodejs # NOTE: update this with your service name

# You can pin your service to only deploy with a specific Serverless version
# Check out our docs for more details
# frameworkVersion: "=X.X.X"

provider:
  name: aws
  runtime: nodejs8.10

functions:
  hello:
    handler: handler.hello
  create:
    handler: handler.create # point to exported create function in handler.js
    events:
      - http:
          path: notes # path will be domain.name.com/dev/notes
          method: post
          cors: true
  getOne:
    handler: handler.getOne
    events:
      - http:
          path: notes/{id} # path will be domain.name.com/dev/notes/1
          method: get
          cors: true
  getAll:
    handler: handler.getAll # path will be domain.name.com/dev/notes
    events:
      - http:
          path: notes
          method: get
          cors: true
  update:
    handler: handler.update # path will be domain.name.com/dev/notes/1
    events:
      - http:
          path: notes/{id}
          method: put
          cors: true
  delete:
    handler: handler.delete
    events:
      - http:
          path: notes/{id} # path will be domain.name.com/dev/notes/1
          method: delete
          cors: true
```

The CRUD operations that will handle the functionalities of the REST API are going to be in the file `handler.js`. Each event contains the event information of the current event that will be invoked from the `handler.js`. In the above configuration file, we have defined each CRUD operation along with an event and the name. Also notice, when defining the `events` in above file, we are associating an HTTP request with a `path` that is going to be the endpoint of the CRUD operation in the API, the HTTP method and lastly, `cors` option.

I am going to demonstrate a simple Note taking app through our REST API. These CRUD operations are going to be the core of it. Since our API is going to be hosted remotely, we have to enable Cross-Origin Resource Sharing. No need to install another dependency on that. Serverless configuration file has support for it. Just specify in the `events` section like `cors: true`. By default, it is false.

### Defining the Handler Functions

If you are familiar with Node.js and Express framework you will notice there is little difference in creating a controller function that leads to the business logic of a route. The similar approach we are going to use to define in each handler function.

```js
'use strict';

module.exports.hello = (event, context, callback) => {
  console.log('Hello World');
  callback(null, 'Hello World');
};

module.exports.create = (event, context, callback) => {
  context.callbackWaitsForEmptyEventLoop = false;

  connectToDatabase().then(() => {
    Note.create(JSON.parse(event.body))
      .then(note =>
        callback(null, {
          statusCode: 200,
          body: JSON.stringify(note)
        })
      )
      .catch(err =>
        callback(null, {
          statusCode: err.statusCode || 500,
          headers: { 'Content-Type': 'text/plain' },
          body: 'Could not create the note.'
        })
      );
  });
};

module.exports.getOne = (event, context, callback) => {
  context.callbackWaitsForEmptyEventLoop = false;

  connectToDatabase().then(() => {
    Note.findById(event.pathParameters.id)
      .then(note =>
        callback(null, {
          statusCode: 200,
          body: JSON.stringify(note)
        })
      )
      .catch(err =>
        callback(null, {
          statusCode: err.statusCode || 500,
          headers: { 'Content-Type': 'text/plain' },
          body: 'Could not fetch the note.'
        })
      );
  });
};

module.exports.getAll = (event, context, callback) => {
  context.callbackWaitsForEmptyEventLoop = false;

  connectToDatabase().then(() => {
    Note.find()
      .then(notes =>
        callback(null, {
          statusCode: 200,
          body: JSON.stringify(notes)
        })
      )
      .catch(err =>
        callback(null, {
          statusCode: err.statusCode || 500,
          headers: { 'Content-Type': 'text/plain' },
          body: 'Could not fetch the notes.'
        })
      );
  });
};

module.exports.update = (event, context, callback) => {
  context.callbackWaitsForEmptyEventLoop = false;

  connectToDatabase().then(() => {
    Note.findByIdAndUpdate(event.pathParameters.id, JSON.parse(event.body), {
      new: true
    })
      .then(note =>
        callback(null, {
          statusCode: 200,
          body: JSON.stringify(note)
        })
      )
      .catch(err =>
        callback(null, {
          statusCode: err.statusCode || 500,
          headers: { 'Content-Type': 'text/plain' },
          body: 'Could not fetch the notes.'
        })
      );
  });
};

module.exports.delete = (event, context, callback) => {
  context.callbackWaitsForEmptyEventLoop = false;

  connectToDatabase().then(() => {
    Note.findByIdAndRemove(event.pathParameters.id)
      .then(note =>
        callback(null, {
          statusCode: 200,
          body: JSON.stringify({
            message: 'Removed note with id: ' + note._id,
            note: note
          })
        })
      )
      .catch(err =>
        callback(null, {
          statusCode: err.statusCode || 500,
          headers: { 'Content-Type': 'text/plain' },
          body: 'Could not fetch the notes.'
        })
      );
  });
};
```

The context contains all the information about the handler function. How long it has been running, how much memory it is consuming among other things. In above, every function has the same value of `context.callbackWaitsForEmptyEventLoop` set to false and starts with `connectToDatabase` function call. The context object property `callbackWaitsForEmptyEventLoop` value is by default set to true. This property is used to modify the behavior of a callback.

By default, the callback will wait until the event loop is empty before freezing the process and returning the results to the invoked function. By setting this propertyâ€™s value to false, it requests the AWS Lambda to freeze the process after the callback is called, even if there are events in the event loop. You can read more about this context property at the official [Lambda Documentation](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html).

### Connecting MongoDB

We need to create a connection between the database and our serverless functions in order to consume the CRUD operations in real-time. Create a new file called `db.js` in the root and append it with following.

```js
const mongoose = require('mongoose');
mongoose.Promise = global.Promise;
let isConnected;

module.exports = connectToDatabase = () => {
  if (isConnected) {
    console.log('=> using existing database connection');
    return Promise.resolve();
  }

  console.log('=> using new database connection');
  return mongoose.connect(process.env.DB).then(db => {
    isConnected = db.connections[0].readyState;
  });
};
```

The is common Mongoose connection that you might have seen in other Nodejs apps if using MongoDB as a database. The only difference here is that we are exporting `connectToDatabase` to import it inside `handler.js` for each CRUD operation. Modify `handler.js` file and import it at the top.

```js
'use strict';

const connectToDatabase = require('./db');
```

Next step is to define the data model we need in order for things to work. Mongoose provides this functionality too. Serverless stack is unopinionated about which ODM or ORM you use in your application. Create a new file called `notes.model.js` and add the following.

```js
const mongoose = require('mongoose');
const NoteSchema = new mongoose.Schema({
  title: String,
  description: String
});
module.exports = mongoose.model('Note', NoteSchema);
```

Now import this model inside `handler.js` for our callbacks at the top of the file.

```js
const Note = require('./notes.model.js');
```

### Using Dotenv and Environment Variables

Protecting our keys and other essentials is the first step to a secured backend application. Create a new file called variables.env. In this file, we will add our MONGODB connection URL that we have already used in `db.js` as a `process.env.DB`. The good thing about environment variables is that they are global to the scope of the application.

To find out our MongoDB URL, we need to go back to the mongodb atlas, to out previously created cluster. Click the button `Connect` and then you will be prompted a page where you can choose how to access the application. Click `Allow Access From Anywhere`.

<img src='https://cdn-images-1.medium.com/max/800/1*tu5gwq1g-L_nWjpfUEz_ag.png' />

<img src='https://cdn-images-1.medium.com/max/800/1*sMkkGj1_unFYQveVf2Huew.png' />

Copy the mongodb URL from above and paste it in the `variables.env` file.

```shell
DB=mongodb://<user>:<password>@cluster0-shard-00-00-e9ai4.mongodb.net:27017,
cluster0-shard-00-01-e9ai4.mongodb.net:27017,cluster0-shard-00-02-e9ai4.mongodb.
net:27017/test?ssl=true&replicaSet=Cluster0-shard-0&authSource=admin
```

Replace the user and password field with your credentials. Now to make it work, all we have to add the following line in our `handler.js`.

```js
require('dotenv').config({ path: './variables.env' });
```

### Deployment

All you have to do is run the deploy command from the terminal.

```shell
sls deploy
```

Since we have connected our Lambda function, this command will prompt us with a different endpoints. Each handler function is deployed as a separate REST endpoint.

<img src='https://cdn-images-1.medium.com/max/800/1*vNUMO69rnmx5y-QF3Kr6-Q.png' />

You can test your API using CURL command from the terminal like below.

```shell
curl -X POST https://7w3e8tfao0.execute-api.us-east-1.amazonaws.com/dev/notes --data '{"title": "My First
Note", "description": "This is a note."}'
```

**The complete code for the tutorial at [this Github repository](https://github.com/amandeepmittal/aws-serverless-demo)**

[Originally published at Crowdbotics](https://medium.com/crowdbotics/how-to-build-a-serverless-backend-with-aws-lambda-and-nodejs-e0d1257086b4)

---

## How to build a xylophone app with Audio API, React Native, and Expo
Slug: how-to-build-xylophone-app-with-expo

React Native when used with Expo as a toolchain eases out the common pain to manage ios and android applications. After saying that, I realized that there is a delight to use this ever-growing open source mobile application framework. Expo has gained a lot of credibility as a framework to provide collective solutions to build React Native applications by lowering the time and effort of the developer using it. They are continuing to enhance it from time to time and keeping up with the latest changes in React Native community. That said, Expo SDK33 is a blast.

That being said, let us dive into one of the Expo's API. In this tutorial, you are going to build an application using Expo's Audio API. You are going to develop the following app (_a toy xylophone app_) step-by-step.

<img src='https://miro.medium.com/max/350/1*YE5sb3gX_ValSM48QGT1eQ.png' />

**Table of Contents**

## Requirements

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- [Nodejs](https://nodejs.org/en/) (>=`8.x.x`) with npm/yarn installed.
- [`expo-cli`](https://docs.expo.io/versions/latest/workflow/expo-cli/) (>= `2.19.4)`, previously known as create-react-native-app.
- [`watchman`](https://facebook.github.io/watchman/) is the file change watcher for React Native projects.

## Getting Started

To create a new Expo project, the only requirement is to have `expo-cli` installed. Then, execute the following command to create a new project directory.

```shell
expo init rn-xylophone-app

# navigate inside the app folder
cd rn-xylophone-app

# install the following dependency
yarn add expo-av
```

Once the project directory is generated, navigate inside it as shown in the above command. Then install the required dependency to add the functionality of playing an Audio file inside the React Native app. The dependency `expo-av` will help you use Audio API and its promise based asynchronous methods to play the audio files. You are going to implement this functionality later.

The last step needed is to have some sound files saved in your `assets` folder. You can, of course, use your audio files but if you want to use the same audio files used in this tutorial, you can download them at the link given below.

[add assets folder download link]

You might have got the idea of what the user interface is going to look while having a glimpse at the demo in the previous section. For each button, you are going to need a different color. Hence, create a new file called `contants/Colors.js` and add the following code.

```js
export const NoteOne = 'red';
export const NoteTwo = 'orange';
export const NoteThree = 'yellow';
export const NoteFour = 'green';
export const NoteFive = '#00FFFF    ';
export const NoteSix = '#000080';
export const NoteSeven = '#B266FF';
```

Require this file and all the Color codes inside `App.js` file after other imports.

```js
// ...after other imports

import {
  NoteOne,
  NoteTwo,
  NoteThree,
  NoteFour,
  NoteFive,
  NoteSix,
  NoteSeven
} from './constants/Colors';
```

The color names are specified to mark each audio file which is named and numbered similarly. To import all the sounds file needed to build the application from the `assets` folder. Add the below object before the `App` component as shown.

```js
const xyloSounds = {
  one: require('./assets/note1.wav'),
  two: require('./assets/note2.wav'),
  three: require('./assets/note3.wav'),
  four: require('./assets/note4.wav'),
  five: require('./assets/note5.wav'),
  six: require('./assets/note6.wav'),
  seven: require('./assets/note7.wav')
};
```

The above object `xyloSounds` consist of the path to each sound file. This will be helpful when you are writing business logic to play these audio files and have to detect which audio file to play for the specific note.

## Building the first UI button

In this section, you are going to create a button using `TouchableOpacity` that is going to play the sound for the note when pressed. To start, make sure in the file `App.js` you have imported the following APIs from the react-native core.

```js
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native';
```

Then, you have to modify the contents of the `render` function from the default, boilerplate text that any Expo application comes with. This is going to be done by creating a `View` container for each button, which will have a fixed height and margin of value `5` to add some spacing between the buttons.

```js
<View style={styles.container}>
  <View style={styles.buttonContainer}>
    <TouchableOpacity
      style={[styles.button, { backgroundColor: NoteOne }]}
      onPress={() => this.handlePlaySound('one')}
    >
      <Text style={styles.buttonText}>Note 1</Text>
    </TouchableOpacity>
  </View>
</View>
```

Notice that each button will have its background color specified in the file `constants/Colors.js`. This is done by inline styling method. To combine multiple styles in React Native, you can use an array notation like above. The button has one `onPress` method that is going to be responsible for playing the correct sound associated with the note. You will be creating the method `handlePlaySound` in the next section. However, do note that the value `one` being passed to this method is coming from the path you specified earlier for each audio file. Lastly, the button is going to have a text to display the correct audio file number.

The above snippet is followed by the styles that are created using `StyleSheet.create()` method.

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    marginTop: 50
  },
  buttonContainer: {
    height: 40,
    margin: 5
  },
  button: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  buttonText: {
    color: '#fff',
    fontSize: 18
  }
});
```

To see the current state of the application in action, go back to the terminal window and run the command `yarn start` or `expo start` if you do not have yarn installed. In the simulator screen, you are going to be welcomed, as shown in the below image.

<img src='https://miro.medium.com/max/350/1*jzwOoqsEJkTUSMMEKCwOPg.png' />

## Adding the Audio functionality

To play a sound in an Expo application, you are required to first the API for the `Audio` from `expo-av`. So at the top of the `App.js` file and after other imports, you can add the following line.

```js
import { Audio } from 'expo-av';
```

Next, you have to add the method `handlePlaySound` inside the `App` function and before the `render()` method. Inside this function, create a new sound object. Whenever you are required to play sound using `expo-av` library, you have to create a new object. This object is going to represent the instance of the class `Audio.sound`.

```js
handlePlaySound = async note => {
  const soundObject = new Audio.Sound();

  try {
    let source = require('./assets/note1.wav');
    await soundObject.loadAsync(source);
    await soundObject
      .playAsync()
      .then(async playbackStatus => {
        setTimeout(() => {
          soundObject.unloadAsync();
        }, playbackStatus.playableDurationMillis);
      })
      .catch(error => {
        console.log(error);
      });
  } catch (error) {
    console.log(error);
  }
};
```

In the above snippet, you can notice that the method `handlePlaySound` is going to accept one parameter. This parameter is going to be the note's number, hence the name of the parameter being passed in the above snippet is called `note`. Inside that, the first line creates the instance of the class `Audio.Sound()`.

Since JavaScript syntax of `async/await` is being used, it is better to create a `try/catch` block such that this Expo app does not give us any error when running the application. Inside this block, the first method `loadAsync` is used to create and load the sound from the source. Hence, the variable `source` defined explicitly is passed and contains the path of the first audio file from the `assets` folder.

To play the sound, `playAsync()` method is used. This method is, however, further extends using a promise that takes one object called `playbackStatus` object. This object uses `playableDurationMillis` to identify the position until the audio file should run from the memory. Once the audio file is played, the `soundObject` calls the method `unloadAsync()` which unloads the media file from memory. This allows the media file to be played again and again. The `setTimeout` function's value depends on the duration of the media file being played from memory.

Go back to the simulator or the device the current app is running and try to press the first button. You will hear the sound of the first note.

## Finishing the App

To complete building the application, you have to read the path of each file from the object `xyloSounds.` Edit the the value of `source` inside the method `handlePlaySound()`.
Also, add the button for each note and do not forget to pass the correct source value inside the `onPress()` method. For your reference, here is the complete code of the file `App.js`.

```js
import React from 'react';
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native';
import { Audio } from 'expo-av';

import {
  NoteOne,
  NoteTwo,
  NoteThree,
  NoteFour,
  NoteFive,
  NoteSix,
  NoteSeven
} from './constants/Colors';

const xyloSounds = {
  one: require('./assets/note1.wav'),
  two: require('./assets/note2.wav'),
  three: require('./assets/note3.wav'),
  four: require('./assets/note4.wav'),
  five: require('./assets/note5.wav'),
  six: require('./assets/note6.wav'),
  seven: require('./assets/note7.wav')
};

export default function App() {
  handlePlaySound = async note => {
    const soundObject = new Audio.Sound();

    try {
      let source = xyloSounds[note];
      // let source = require('./assets/note1.wav')
      await soundObject.loadAsync(source);
      await soundObject
        .playAsync()
        .then(async playbackStatus => {
          setTimeout(() => {
            soundObject.unloadAsync();
          }, playbackStatus.playableDurationMillis);
        })
        .catch(error => {
          console.log(error);
        });
    } catch (error) {
      console.log(error);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteOne }]}
          onPress={() => this.handlePlaySound('one')}
        >
          <Text style={styles.buttonText}>Note 1</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteTwo }]}
          onPress={() => this.handlePlaySound('two')}
        >
          <Text style={styles.buttonText}>Note 2</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteThree }]}
          onPress={() => this.handlePlaySound('three')}
        >
          <Text style={styles.buttonText}>Note 3</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteFour }]}
          onPress={() => this.handlePlaySound('four')}
        >
          <Text style={styles.buttonText}>Note 4</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteFive }]}
          onPress={() => this.handlePlaySound('five')}
        >
          <Text style={styles.buttonText}>Note 5</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteSix }]}
          onPress={() => this.handlePlaySound('six')}
        >
          <Text style={styles.buttonText}>Note 6</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: NoteSeven }]}
          onPress={() => this.handlePlaySound('seven')}
        >
          <Text style={styles.buttonText}>Note 7</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    marginTop: 50
  },
  buttonContainer: {
    height: 40,
    margin: 5
  },
  button: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  buttonText: {
    color: '#fff',
    fontSize: 18
  }
});
```

Now run the application in the simulator, and you will get the following screen.

<img src='https://miro.medium.com/max/350/1*YE5sb3gX_ValSM48QGT1eQ.png' />

## Conclusion

You have reached the end of this tutorial. I hope you have learned how to integrate the `expo-av` library to use `Audio` class to create functionality in your cross-platform applications and play audio media files. Important things to notice in this demo application is how to use available methods like `loadAsync()`, `unloadAsync()` and leverage the duration of the playing media using the object `playplaybackStatus`.

[Originally published at Heartbeat](https://heartbeat.fritz.ai/how-to-build-a-xylophone-app-with-audio-api-react-native-and-expo-7d6754a0603c)

---

## How To Build Your First VR App with ViroReact, React Native, and Crowdbotics
Slug: how-to-build-your-first-vr-app-with-viroreact-react-native-and-crowdbotics

Virtual Reality (VR) is an immersive technology that has intentions to improve the experience by providing a three-dimensional realistic environment rendered for the individual to feel real. The applications of this technology are boundless. You will find totally immersive and entertaining gaming applications as well as examples of healthcare simulations used to save lives.

For React Native developers, this technology is made accessible by a third party platform called [ViroReact](https://docs.viromedia.com/docs/viro-platform-overview). This platform allows React Native developers to rapidly build cross-platform AR/VR applications. ViroReact currently supports ARKit, ARCore, VR Cardboard, Gear VR and Daydream. [Viro Media](https://medium.com/u/25ec8f1004a4)

In this tutorial, we will be helping you go through the installation and setup process along with that create a small VR app and understand the basics behind it.

### Overview

- Getting Started: Setup and Installation
- What is ViroReact?
- Building the app
- Scenes and Text in a VR App
- Adding a 3D effect to the Text
- Adding a 360 PhotoSphere
- Conclusion

### Getting Started: Setup and Installation

To get started, we will be using a React Native project generated by [**Crowdbotics App Builder**](https://www.crowdbotics.com/app-builder). All you need to generate a project with Crowdbotics is login access either using your personal email or through your Github profile (_recommended_).

Once logged in, on the `Create Application` page, choose `React Native` template under `Mobile App`.

<img src='https://cdn-images-1.medium.com/max/800/1*AOJYgjJldsH0HPMvY5qb1w.png' />

Lastly, choose the name of your template at the bottom of this page and then click the button, Create my app!. After a few moments, your project will be generated. If you decided to access through Github, you will receive an invitation to the Github repository generated by the Crowdbotics service. Clone the repository at your dev machine for now.

To proceed further, you need to have the following already installed on your dev machine.

- Node.js
- watchman (OSX/Linux only)
- Python2, JDK (windows only)
- [ngrok package](https://www.npmjs.com/package/ngrok) installed as a global module
- react-native-cli
- react-viro-cli

To install both the command line tools, open up a terminal window and run the following command.

```shell
npm install -g react-native-cli react-viro-cli
```

After the installation, make sure you have the latest version of `react-viro-cli` which is `2.13.0` at the time of writing this tutorial. To check the version installed, run `react-viro-cli --version`.

Traverse inside the cloned Github repository. When inside, delete all the contents except, the following files.

- `.git` directory
- `.gitattributes`
- `.gitignore`

The reason behind this is that integrating an already existing React Native app with Viro React does not work quite as well as it is intended too. So, we are going to take a different approach. After deleting the files, use the react-viro cli to create a new project that has integration support by default.

```shell
react-viro init [PROJECT_NAME] --verbose
```

By default, `react-viro-cli` uses `yarn` to install project dependencies. After this step, you will have your project directory structure similar to the following.

<img src='https://cdn-images-1.medium.com/max/800/1*DbX1Fo44I0P0dDbmcyzdiQ.png' />

### What is ViroReact?

ViroReact is a platform that helps you build AR (_Augmented Reality_) and VR (_Virtual Reality_) application experiences. It uses ARKit and ARCore to implement the developer platform for specific mobile platforms such as iOS and Android. Other than React Native there is a development option for both native platforms provided by ViroCore.

ViroReact API comes with a number of custom React components to render different scenes and objects in a three-dimensional environment. A good thing about ViroReact is that it is open source so you do not have to worry about paying the licensing fees. However, do note that, due to the limitation of supported devices by ARKit and ARCore, you cannot use an extremely old OS version for either iOS or Android.

### Setting up Viro API and TestbedÂ App

Viro provides you a testbed application that can be installed on a real device and test the application you build along with the way. It also contains a few samples of testbed applications that are build using ViroReact core.

To install on the Viro Media App iOS devices, go the [app store here](https://itunes.apple.com/us/app/viro-media/id1163100576?mt=8) and for Android, there is an app on the [Play store here](https://play.google.com/store/apps/details?id=com.viromedia.viromedia). Note that it is a required step in order to proceed further.

To access Viro React core you need an API key. Login or create a new account at [viromedia.com](https://gist.github.com/amandeepmittal/www.viromedia.com) and you will get an API key on the registered email.

Once that is done, let us run the default sample testbed app that comes with every Viro project using its CLI tool. First, you are required to add the API key inside `App.js` file.

```js
var sharedProps = {
  apiKey: 'API_KEY_HERE'
};
```

After that, open up a terminal window and a run `npm start`.

<img src='https://cdn-images-1.medium.com/max/800/1*nqMq5cNU8OR-Flke9Vw3-g.png' />

When you run a Viro project, you will always notice in the terminal window that apart from getting `react-native-cli`interface that runs Metro bundler and loads the dependency graph, `react-viro-cli` uses ngrok packager service that provides an endpoint for you to run on the Viro Media app on a real device. You can see the endpoint reflected in the above screenshot.

When you open the application you are welcomed by the below screen.

<img src='https://cdn-images-1.medium.com/max/800/1*IpoaZjN-fS62-bF3bIXRng.jpeg' />

Next, click on the icon on the top left to access the menu bar.

<img src='https://cdn-images-1.medium.com/max/800/1*sgKQuwtK_c0T_A31FoALDw.jpeg' />

On the menu bar, click on `Enter Testbed`. Then, enter the ngrok endpoint generated in the terminal on running `npm start`.

<img src='https://cdn-images-1.medium.com/max/800/1*xJS5lJwedqRUSq7FLtEeEA.jpeg' />

Once that is done, click the button `Go` and you will be prompted to choose an environment like below. Click on `VR`.

<img src='https://cdn-images-1.medium.com/max/800/1*fHwBN1yhZLrOtSRzTMb7Vw.jpeg' />

You will see the pre-installed application like below in action on your device.

### Building theÂ app

As everything is in order, you can now move ahead and continue working on your VR app. You have already experienced a Hello World application that comes pre-built with ViroReact CLI tool. In this section, we are going to edit it and customize it in our way to accomplish the desired result.

First, we are going to eliminate the screen where it prompts about choosing a rendering environment for either an AR or a VR test application. Since we are only working on a VR app, let us update the `render()` function inside `App.js` file as below.

```js
render() {
		return this._getVRNavigator();
  }
```

The method `_getVRNavigator()` renders the scene navigator for the VR experience. The scene navigator is the entry point of any Viro application. For AR you will find, `ViroARSceneNavigator` and for VR you will find, `ViroVRSceneNavigator`. For any scene to render there are two required props by this component are the `apiKey` and an `initialScene`. In the file, `App.js` you will the currently rendered scene like below. The `sharedProps` part is the `apiKey`.

```js
<ViroVRSceneNavigator
  {...this.state.sharedProps}
  initialScene={{ scene: InitialVRScene }}
  onExitViro={this._exitViro}
/>
```

The `initialScene` props have a value of `InitialVRScene`. This value is actually a component that gets displayed initially by the scene navigator. In our case, it is the component `HelloWorldScene` for now.

```js
var InitialVRScene = require('./js/HelloWorldScene');
```

### Scenes and Text in a VRÂ App

Applications in Viro React consists of scenes that are represented by `ViroScene` component. Each scene is an equivalent of the `Views`. To create a basic scene all you have to do is modify the`<ViroScene>` component. Open `HelloWorldScene.js`. You will notice that `ViroScene` is being already imported.

```js
import { ViroScene, ViroText, Viro360Image } from 'react-viro';
```

Next, let us modify the `render` function. Create a text-based scene of our own.

```js
<ViroText>
  <ViroText
    fontSize={40}
    text='Hi, from Crowdbotics'
    width={2}
    height={2}
    position={[0, 0, -2]}
    textAlign='center'
    textAlignVertical='center'
    color='#ffffff'
  />
</ViroScene>
```

`ViroText` is a component that provides two-dimensional text functionality. It uses props such as the `text` itself, the `textAlign`, `fontSize`, `width`, `position`, and so on. The styling of the text can be done using a `fontFamily` but do note that not all platforms support all font families. You can also use styling objects created using `StyleSheet` from React Native core. The size of the text can be increased or decreased using `fontSize` property. See the result of the above snippet of code below.

<img src='https://cdn-images-1.medium.com/max/800/1*eeKdtwtZur54KOQMB3serQ.gif' />

To enable 3D text, there is a prop called `extrusionDepth` which is given a value greater than zero, enables 3D text. Let us add this property in `ViroText` component.

```js
<ViroText
  fontSize={40}
  text="Hi, from Crowdbotics"
  width={2}
  height={2}
  position={[0, 0, -2]}
  textAlign="center"
  textAlignVertical="center"
  color="#ffffff"
  extrusionDepth={8}
  materials={['frontMaterial', 'backMaterial', 'sideMaterial']}
/>
```

### Adding a 3D effect to theÂ Text

If the value of `extrusionDepth` is greater than zero, you can apply three materials to the text: `frontMaterial`, `backMaterial` and `sideMaterial`. Let us add different colors to these materials to see the effect. You will have to import `ViroMaterials` from `react-viro` in order to proceed.

```js
// import
import { ViroScene, ViroText, ViroMaterials } from 'react-viro';

// add props
<ViroText
					{/*...*/}
					extrusionDepth={8}
					materials={['frontMaterial', 'backMaterial', 'sideMaterial']}
				/>

// add materials
ViroMaterials.createMaterials({
	frontMaterial: {
		diffuseColor: '#FFFFFF'
	},
	backMaterial: {
		diffuseColor: '#FF0000'
	},
	sideMaterial: {
		diffuseColor: '#0000FF'
	}
});
```

`Materials` are the set of shading attributes that define the appearance of a geometryâ€™s surfaces when rendered. To see this in action, take a look below.

<img src='https://cdn-images-1.medium.com/max/800/1*D-9x9fS2r0zLiCexmjlktA.gif' />

### Adding a 360 PhotoSphere

You may have noticed in the testbed app that we tested earlier, it had a background image that acted like a 360 sphere. You often find these 360 images in VR applications. To add one in our application right now, download any asset from this [link](https://docs.viromedia.com/docs/assets) and paste the file inside the `projectname/js/res/` directory. These assets are free to use.

To add such an image, there is a component in Viro React API called `Viro360Image`. You can import it from `react-viro`.

```js
// import
import { ViroScene, ViroText, Viro360Image, ViroMaterials } from 'react-viro';
```

This component uses a deviceâ€™s gyroscope to display a 360 degrees view. Add the component inside `ViroScene` as below and before `ViroText`.

```js
<ViroScene>
  <Viro360Image source={require('./res/360_space.jpg')} />
  <ViroText {/*...*/} />
</ViroScene>
```

The initial load of the image might take a few seconds but it will appear in the path is correct. See the results below.

<img src='https://cdn-images-1.medium.com/max/1200/1*BI-MBJH-vqu5GmNyBgDH2Q.jpeg' />

### Conclusion

ViroReact provides a great set of API components that you can use to extend your VR application. Did you notice, we never had to re-start the ngrok bundler after making changes in the app component? This is where the advantage of ViroReact lies. I hope you enjoyed this tutorial.

The complete code for this tutorial is available in the Github repository below.

[**crowdbotics-apps/rnvrdemo-1546**](https://github.com/crowdbotics-apps/rnvrdemo-1546/tree/master/vrappdemo)

[Originally published at Crowdbotics](https://medium.com/crowdbotics/how-to-build-your-first-vr-app-with-viroreact-react-native-and-crowdboticsp-a376b49e1e1d)

---

## How To Build A Blog From Scratch With React, Markdown, GraphQL and Gatsbyjs
Slug: how-to-build-your-own-blog-from-scratch-with-gatsbyjs-graphql-react-and-markdown

There are lots of quick and easy, no-code ways to get blog up and runningâ€Šâ€”â€Šsuch as [Medium](https://blog.crowdbotics.com/should-you-use-medium-as-your-business-blog-platform-2019-update/) or Wordpressâ€Šâ€”â€Šbut, whether itâ€™s to customize, monetize, add security, or just learn, today, Iâ€™ll show you how to code your own blog from scratch.

When adding a blog to your existing website, or just starting out with a new blog, a static site generator can help you get started.

Static site generators such as GatsbyJS are primarily used to serve fixed content, but they can also be used for pretty much any web application, including blog and e-commerce web applications.

In this post, we are going to create a blog from scratch using GatsbyJS with ReactJS and GraphQL at its core.

### What is GatsbyJS?

[Gatsby](https://www.gatsbyjs.com/how-it-works/) is a simple, robust, and fast static site generator. It uses ReactJS to render static content on the web. The content in a Gatsby app is written in the same way as any other React app: through components. These components are rendered at build time to the DOM as static HTML, CSS, and JavaScript.

At a high level, Gatsby uses various source plugins to read data and make it available via a GraphQL interface. You write GraphQL queries to load this data and render React components. GraphQL can render content that is sourced from a large number of formats and sources such as Markdown, CSV, and CMS like Wordpress, Drupal, GraphCMS, and so on.

### Why useÂ Gatsby?

Gatsby takes care of a lot behind the scenes.

- Future proof [JAMstack](https://jamstack.org/) websites
- Gatsby has a rich plugin ecosystem that is easily extensible
- Pre-configured Webpack based build system (no need to break your head)
- Supports [PWA (_Progressive Web App_)](https://blog.crowdbotics.com/learn-to-build-a-simple-progressive-web-app-pwa-with-angular-and-lighthouse-hacker-news-clone/) by default
- Optimized for speed. Gatsby loads only critical parts so that your site loads as fast as possible. Once loaded, Gatsby prefetches resources for other pages so that clicking on the site feels incredibly fast

Gatsby also has an ever-growing data plugin ecosystem, especially for data transformation. Overall, I think the points above should be enough to lure you into trying it out.

### Pre-requisites

- Familiarity with HTML, JavaScript, ReactJS
- Nodejs with `npm` or `yarn` installed
- Gatsby CLI (which we are going to install in next section)

**Note:** At the time of writing this tutorial, Gatsby `v2` was officially launched.

### Getting Started withÂ Gatsby

To start, we need to install the command line utility provided by GatsbyJS to quickly scaffold projects. Open your terminal and type the following command.

```shell
npm install -g gatsby-cli
```

To verify that it has been installed, run the following command.

```shell
# Check the version
gatsby -v

# you will get a similar output
2.4.5
```

Once you successfully installed `gatsby-cli`, it is time to generate a new project.

```shell
gatsby new gatsby-blog-starter
```

This process will take a minute or two and, at the end of it, you will have a new directory. Traverse inside it. Gatsbyâ€™s default project structure looks like this:

<img src='https://cdn-images-1.medium.com/max/800/1*Y2MEtJVZ4BmnmALDO-D1lw.png' />

To see what we get by default, run `gatsby develop`. This will run the project without creating the official build directory on a development server through webpack (used by Gatsby internally). After the command runs successfully, you will be prompted by the following screen like below in your terminal.

<img src='https://cdn-images-1.medium.com/max/800/1*CC6dYalWGIY2d0DQ1Gg5yw.png' />

You can visit `http://localhost:8000` to see the default site in action.

<img src='https://cdn-images-1.medium.com/max/1200/1*1Ow9OKXVy8-T1x_bGiTjRg.png' />

### Running a GraphQLÂ Query

<img src='https://cdn-images-1.medium.com/max/800/1*L8BlmC_0Xx_B75e7Lv4osQ.png' />

Every Gatsby project contains at least these files. You might be familiar with some of these such as `node_modules`and `public` directory, which is served when deployed. It also contains `package.json`, which contains the metadata of any modern Javascript application.

Our main object of focus are in the directory `src` and files such as `gatsby-config.js` and `gatsby-node.js`.These contain the metadata and other essential information about our current application. Inside the `src/` there are two sub-directories: `components/` and `pages/`. The `components/` contain further two files: `layout.css` and `layout.js`. These serve as the starting point of our application.

You have already seen what the default page that comes with Gatsby looks like. We have a title in the navigation bar. Letâ€™s add a subtitle. Open `gatsby-config.js` and a new field `description` and change `title` like below.

```js
siteMetadata: {
    title: 'Gatsby Blog',
    description: 'This is my personal blog.'
  },
```

Gatsby allows us to query metadata fields described in this file as a GraphQL query. In order to take a look at what kind of stuff we can query from Gatsby, run `gatsby develop` from the terminal. You will not see any changes at `http://localhost:8000/` yet because we haven't modified the component responsible for that. However, we can verify by running a simple GraphQL query. Open `http://localhost:8000/___graphql` in the browser.

<img src='https://cdn-images-1.medium.com/max/1200/1*0F7_m7zpVpipIjc1qU9SMw.png' />

Weâ€™ve got the GraphQL browser open and over on the side here, we can see the documentation explorer, which lets us go through our schema and look at what kind of stuff we can query for. Click on the `query` type on the right hand side to see what query fields we can access.

<img src='https://cdn-images-1.medium.com/max/800/1*JsaxRxF-uWp4CCotFWBrMQ.png' />

This gives us a list of all of the query types that we can look for. Take a look at the `site` and the `siteMetadata`. You can start typing a `s`, and you will see an autocomplete for the query type `site`. This is really helpful. Run the below query.

<img src='https://cdn-images-1.medium.com/max/1200/1*zt1jv_nlaWMFNPgmZTSGYw.png' />

Great!

Now that you are familiar with the nitty-gritty of Gatsby and how it works, in the next section, we will start working on the blog.

### Writing our first Markdown blogÂ post

Gatsby makes use of various plugins for building static sites. In this section, we are going to install and configure in order to make use of `gatsby-source-filesystem` and `gatsby-transformer-remark` to work with locally stored Markdown files. Open your terminal and type.

I am using `yarn` because Gatsby uses it by default over `npm` as the package manager. Once both of these dependencies are installed, configure `gatsby-config.js` file like below.

```js
plugins: [
  'gatsby-transformer-remark',
  {
    resolve: `gatsby-source-filesystem`,
    options: {
      name: `pages`,
      path: `${__dirname}/src/pages/`
    }
  }
];
```

The rest of the plugins remain same. `gatsby-transformer-remark` is used parse Markdown files inÂ `.md` format into HTML. `gatsby-source-filesystem` helps us with reading those markdown files from the disk. Each post in our blog is going to be in markdown format.

To understand it better, let us add some posts. Traverse to `src/pages` directory and then add one or two posts in a year, month, and date format with a slug like below.

<img src='https://cdn-images-1.medium.com/max/800/1*kVIkKPBAX029E6DmXYUScQ.png' />

Each markdown file is supposed to have some frontmatter fields that are used to create and update our posts. Open the `2018-11-14-hello-world.md` and the following content.

Similarly you can add the content to the second post.

The content of these two Markdown files will be our first two blog posts. The block surrounded in dashes is referred to as _frontmatter_, and the contents of the block can be used to inject React components with the specified data, such as path, date, title, tags, and so on.

One important note is that path will be used when we dynamically create our pages to specify the URL to each blog to render the file. Weâ€™ll do this later.

### Creating the BlogÂ Template

If you take a look at your blog in a browser, you will see that Gatsby is not yet displaying any blog posts that you have created. This is because Gatsby still does not know where these blog posts are or that you even want them to be displayed in the browser. However, if you try to query it in the _GraphiQL_ browser tab, you can see that **frontmatter** data of blog post is available.

<img src='https://cdn-images-1.medium.com/max/1200/1*f2k6uRd0tZ31BIWJbXHRqg.png' />

Each Markdown file is parsed into a node of type `MarkdownRemark`. To query all markdown files in on query, we are using `allMarkdownRemark`. All **frontmatter** fields are converted into GraphQL fields.

To display each post let us create a new template that will be consistent in style and getting **frontmatter** from GraphQL query we have just seen. Inside the `src` directory, create a new folder called `templates` and inside it, create a new file called `blogPost.js`.

```js
import React from 'react';
import { graphql } from 'gatsby';

const Template = ({ data }) => {
  const title = data.markdownRemark.frontmatter.title;
  const date = data.markdownRemark.frontmatter.date;
  const html = data.markdownRemark.html;

  return (
    <div>
      <h1>{title}</h1>
      <div className="blogpost" dangerouslySetInnerHTML={{ __html: html }} />
    </div>
  );
};

export const postQuery = graphql`
  query ($pathSlug: String!) {
    markdownRemark(frontmatter: { path: { eq: $pathSlug } }) {
      html
      frontmatter {
        title
        date(formatString: "MMMM, DD, YYYY")
        path
        tags
        excerpt
      }
    }
  }
`;

export default Template;
```

In this component, notice the new query `postQuery` we are creating. This query will help us to display our blog posts into the template. This query puts all the _frontmatter_ we require in order to display blog post in the component `Template`'s `props`.

```js
const title = props.data.markdownRemark.frontmatter.title;
const html = props.data.markdownRemark.html;
```

In above, I am fetching the title for each post and the HTML content. While rendering the output we get from the query, I am using `dangerouslySetInnerHTML` which is a Reactâ€™s replacement for using `innerHTML` in the browser DOM. In general, setting HTML from code is risky because it exposes a user to a cross-site scripting (XSS) attack if used with sensitive data. Since we do not have any users (no login/signup system), I am just using it for content that is rendered as HTML from markdown.

We now have a template of how our blog post will look but we still havenâ€™t configured a way to render and convert a blog post into HTML. Thatâ€™s next. Open `gatsby-node.js` in the root of your project and add the following code.

```js
const path = require('path');

exports.createPages = ({ graphql, actions }) => {
  const { createPage } = actions;

  return new Promise((resolve, reject) => {
    const blogPostTemplate = path.resolve('src/templates/blogPost.js');
    // Query for markdown nodes to use in creating pages.
    resolve(
      graphql(`
        query {
          allMarkdownRemark(
            sort: { order: ASC, fields: [frontmatter___date] }
          ) {
            edges {
              node {
                frontmatter {
                  path
                  title
                  tags
                }
              }
            }
          }
        }
      `).then(result => {
        const posts = result.data.allMarkdownRemark.edges;

        posts.forEach(({ node }) => {
          const path = node.frontmatter.path;
          createPage({
            path,
            component: blogPostTemplate,
            context: {
              pathSlug: path
            }
          });
          resolve();
        });
      })
    );
  });
};
```

We start by requiring Nodeâ€™s `path` in order to fetch the blog post template. Notice the `actions` along with `graphql` as parameters when we are exporting `createPages`. Gatsby uses Redux internally to manage state. That's where `actions` come from. The object `actions` contain the functions and these can be individually extracted by using ES6 object de-structuring. It has pre-defined functions such as `createPage`, `createRedirect`, `setWebpackConfig` and so on. You can find all of them [**here**](https://www.gatsbyjs.org/docs/actions/).

We then make use `createPage` programmatically. There are [two other ways other](https://www.gatsbyjs.org/docs/creating-and-modifying-pages/) than the approach we are implementing. In our case, we need to read Markdown files.

Since our home page is still not done to display a list of blog posts you will have to visit each URL listed below in order to see the blog posts in action.

- For the first post, visit: `[http://localhost:8000/first-post](http://localhost:8000/first-post)`
- For the second post, visit: `[http://localhost:8000/second-post](http://localhost:8000/second-post)`

<img src='https://cdn-images-1.medium.com/max/800/1*FfBpJzPlwG8h5-3CvR8mJQ.png' />

Try to modify the `Template` component and other fields from the frontmatter. Open `src/blogPost.js`.

```js
const Template = ({ data }) => {
  const title = data.markdownRemark.frontmatter.title;
  const date = data.markdownRemark.frontmatter.date;
  const html = data.markdownRemark.html;
  return (
    <div>
      <h1>{title}</h1>
      <div>
        <em>{date}</em>
      </div>
      <br />
      <div className="blogpost" dangerouslySetInnerHTML={{ __html: html }} />
    </div>
  );
};
```

To represent the changes, I have added the date in italics just before the content of the blog post and after the title. Visit any postâ€™s URL and see it in action.

<img src='https://cdn-images-1.medium.com/max/800/1*cmFx6s6ZsVpGNHoI8wSMLQ.png' />

### Adding Previous and Next Blog PostÂ Links

For this feature to work with our blog, we are going to make use Gatsby `Link` component. It is a wrapper around `@reach/router`â€™s Link component that adds enhancements specific to Gatsby and you can even use props such as `activeStyle` or `activeClassName` to add styling attributes to the rendered element when it matches the current URL. Just like how a normal routing component in React behaves. Open `blogPost.js` file and add this.

```js
import React from 'react';
import { graphql, Link } from 'gatsby';

const Template = ({ data, pathContext }) => {
  const title = data.markdownRemark.frontmatter.title;
  const date = data.markdownRemark.frontmatter.date;
  const html = data.markdownRemark.html;
  const { next, prev } = pathContext;

  return (
    <div>
      <h1>{title}</h1>
      <div>
        <em>{date}</em>
      </div>
      <br />
      <div className="blogpost" dangerouslySetInnerHTML={{ __html: html }} />
      <p>
        {prev && (
          <Link to={prev.frontmatter.path}>
            {prev.frontmatter.title}{' '}
            <span role="img" aria-label="point-left">
              ðŸ‘ˆ{' '}
            </span>
            Previous
          </Link>
        )}
      </p>
      <p>
        {next && (
          <Link to={next.frontmatter.path}>
            Next{' '}
            <span role="img" aria-label="point-right">
              ðŸ‘‰
            </span>
            {next.frontmatter.title}
          </Link>
        )}
      </p>
    </div>
  );
};

// rest of the code remain sames
```

Notice how I am using `span` tags with attribute `role` to wrap emojis along with `aria-label` attribute. It is considered as good practice in Gatsby, React and you will definitely avoid any linting errors. Now to make the above code work, we need to modify the `context` in `gatsby-node.js`.

```js
posts.forEach(({ node }, index) => {
  const path = node.frontmatter.path;
  createPage({
    path,
    component: blogPostTemplate,
    context: {
      pathSlug: path,
      prev: index === 0 ? null : posts[index - 1].node,
      next: index === posts.length - 1 ? null : posts[index + 1].node
    }
  });
  resolve();
});
```

The context object now contains two keys called `prev` and `next`. We are also using `index` value of each post. If the `index === 0`, there is not going to be any previous post since it is the first one. You cannot go to a previous post here. We are then using these new context properties in `blogPost.js` using `pathContext`.

Visit the first post and you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*43qrMpLgEskYZzuZ2cFOQA.gif' />

### Display all posts onÂ Homepage

Since all of our markdown posts are getting rendered into HTML correctly, the next and previous post feature working too. So let us move ahead and display all the blog posts on the home page. Not the complete posts, but a link to each one.

```js
import React from 'react';
import { graphql, Link } from 'gatsby';

import Layout from '../components/layout';

const IndexPage = ({ data }) => {
  const { edges } = data.allMarkdownRemark;

  return (
    <Layout>
      <div>
        {edges.map(edge => {
          const { frontmatter } = edge.node;
          return (
            <div key={frontmatter.path}>
              <Link to={frontmatter.path}>{frontmatter.title}</Link>
              &nbsp;
              <small>
                {' '}
                <em>published on</em> {frontmatter.date}
              </small>
              <p>{frontmatter.excerpt}</p>
              <br />
            </div>
          );
        })}
      </div>
    </Layout>
  );
};

export const query = graphql`
  query HomePageQuery {
    allMarkdownRemark(sort: { order: DESC, fields: frontmatter___date }) {
      totalCount
      edges {
        node {
          id
          frontmatter {
            title
            date(formatString: "MMMM DD, YYYY")
            path
            tags
            excerpt
          }
        }
      }
    }
  }
`;

export default IndexPage;
```

On visiting the Home page URL: `http://localhost:8000/` you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*Ei7BmnjIcRvG0JmhGwVDZw.png' />

### Conclusion

We now have a functioning blog!

I challenge you to expand your own blog further by adding comments or tags functionalities. Gatsby has a lot to offer. You learn more about Gatsby at their [official documentation](https://www.gatsbyjs.org/).

**The complete code for the tutorial at [this Github repository](https://github.com/amandeepmittal/gatsby-blog-starter)**

[Originally published at Crowdbotics](https://medium.com/crowdbotics/how-to-build-your-own-blog-from-scratch-with-gatsbyjs-graphql-react-and-markdown-78352c367bd1)

---

## How to configure VS Code Bracket Pair Colors natively
Slug: how-to-configure-vscode-bracket-colors-natively

![cover image](https://res.cloudinary.com/practicaldev/image/fetch/s--lgaAXnJK--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r84rtekdnk3qd4r4v31e.png)

With an [update in August 2021](https://code.visualstudio.com/updates/v1_60#_high-performance-bracket-pair-colorization), VS Code started supporting Bracket pair colorization natively. It means there is no need to use the [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer) extension (_which I love_).

In their official announcement, the VS Code team states they chose to implement this feature natively to address performance issues.

I recently uninstalled the extension and thought, let's try to use the editor without any bracket color extension. I cannot. I've been using the extension [as long as I remember](https://amanhimself.dev/blog/how-i-configure-vscode-for-everything/) and I cannot go back to plain, colorless brackets.

![ss1](https://i.imgur.com/JBOVcnV.png)

To enable this setting, open the `settings.json` file for the VS Code editor and add the following:

```json
{
  // ...
  "editor.bracketPairColorization.enabled": true,
  "workbench.colorCustomizations": {
    "editorBracketHighlight.foreground1": "#ffb86c",
    "editorBracketHighlight.foreground2": "#8be9fd",
    "editorBracketHighlight.foreground3": "#bd93f9",
    "editorBracketHighlight.foreground4": "#50fa7b",
    "editorBracketHighlight.foreground5": "#f1fa8c",
    "editorBracketHighlight.foreground6": "#abb2c0",
    "editorBracketHighlight.unexpectedBracket.foreground": "#ff5555"
  }
}
```

And tweak the colors according to your style!

![ss2](https://i.imgur.com/tSgx02e.png)

By the way, the above colors are from [Dracula theme's ðŸ§›â€â™‚ï¸ color palette](https://draculatheme.com/contribute) to match the overall editor theme I am currently using.

---

## How to integrate Redux into your application with React Native and Expo
Slug: how-to-integrate-redux-into-your-application-with-react-native-and-expo

![cover](https://i.imgur.com/YqZC6zh.jpg)

Redux is an important part of the React Native ecosystem. If your world revolves around JavaScript, youâ€™ve probably heard about Redux. Before reading the rest of the tutorial and going further, just try to remember that you are only learning about Redux because it will make things easier for you, and not more difficult. Now let us learn why you need Redux in your application.

### Need forÂ Redux

Building a React or React Native application in the real world can become complex if there is not a proper way to handle data. If at any point the data is not managed, things will get out of hand. If you are familiar with React or React Native, you know the default way of handling data is to keep it in a component state and pass it to children components as props.

State and Props are the only two ways to control data in a component. Props is short for **properties.** It is a simple rule to follow in the React world that we should not mutate or change the value of props. In React, the flow of data is unidirectional or one way. That is, the data can always be passed from a parent to a child component. Take a look below at this simple example:

<img src='https://cdn-images-1.medium.com/max/800/1*PXT5wJ4ctcEANSAciWe6Iw.png' />

In the above example, we create two components (Parent and Child) in separate files. The Parent component consists of a view where the Child component is rendered. In the child component, the view renders a text message that is incoming from the props. The incoming message is available as the data in the state of the parent component.

This way, the child component can be reused with other parent components such that each parent component can have its own data to render. Do note that we are not modifying the value of `this.props` at any point.

The state is there to mutate data. This is the only reason that the state exists within each component. Whenever we want to change the state, we use `this.setState()` method within a component. This method re-renders the component and all of its child components to reflect the changes. This works both in React and React Native similarly, but the internals are different.

<img src='https://cdn-images-1.medium.com/max/800/1*YqjKCFCmuMikKf5n8kb_tw.png' />

Since we can manage state and props so efficiently within a React Native app, why is Redux necessary? Well, the above example represents the bare minimum and not a real-time scenario. Imagine an application like Instagram or Twitter. You have different screens, and each screen may depend on a component or two like the Parent and the reusable Child components from our example. It would be hard to keep track of the state of each component.

Redux is one the most widely adopted ways of handling data. It enables the state to be shared as a global attribute that an entire React Native application can use and receive in the form of props. This is known as creating a store in Redux. Redux simplifies the state by moving it into one place.

Redux uses an underlying React Mechanism called context. We are not going to dwell what context is, since it is out of the scope of this article. I just wanted you to know that nothing magical is happening behind the scenes.

Just remember the following terms, since we are going to see them in action in the tutorial below:

- Actions
- Reducers
- Store

The key to learning Redux is practice. I donâ€™t want to share too much information and overwhelm things right now. So let us begin by creating a demo application to learn Redux.

### Building a Pomodoro application

#### Getting Started with Expo-CLI

To build this application, I am going to use the latest tool introduced by the [Expo](https://medium.com/u/df61a4267d7a) team called [expo-cli](https://www.npmjs.com/package/expo-cli). Install it as a global dependency and then initialise a new React Native project using it.

<img src='https://cdn-images-1.medium.com/max/800/1*WVhMAOBzQNl-4RpL0CThLw.png' />

To see if everything is working correctly at this initial state, run the following command.

<img src='https://cdn-images-1.medium.com/max/800/1*qxzbx05hdPWwKy6zQGSS6g.png' />

You will be prompted with the following interface. Take some time to go through it. If you have build applications using Expo XDE or Create-React-Native-App before, you will see that not much has changed, except that now Expo-CLI makes use of the Chrome browser.

<img src='https://cdn-images-1.medium.com/max/800/1*PP7QE6q2zPf_Ge3OPAuYcg.png' />

Choose a simulator or device that can run Expo Client as marked in the above image. If you get the below screen, that means our React Native project has been initialised without any difficulties.

<img src='https://cdn-images-1.medium.com/max/800/1*BXZsSSnTpdxs38_dRcnb5w.png' />

With that, create the following files and folders inside the `components` directory. I will discuss why we are following this directory structure later. For now, our initial setup is complete and we can start building our application.

<img src='https://cdn-images-1.medium.com/max/800/1*xVtf1meIsa4A0frjAsFsIw.png' />

#### Timer Component â±

First, we will create a dumb Timer component and connect it with `App.js`. Add the following code to the `Timer/index.js`:

<img src='https://cdn-images-1.medium.com/max/800/1*wQk1JSY-NaEmU1FbZKz29g.png' />

Next, modify the `App.js` file:

<img src='https://cdn-images-1.medium.com/max/800/1*emdQmLUOWJ6yNmZ6ZYTI6w.png' />

<img src='https://cdn-images-1.medium.com/max/800/1*U1Cyur_BU0oqQYQ23oHNyg.png' />

We will now make a static Timer component to see how things fit in. Weâ€™ll start by modifying the `StatusBar`. Then we define two `Text` elements from the `react-native` library to specify where the actual timer will be displayed and where the buttons for starting and stopping the timer will be displayed. For now, both are text fields.

<img src='https://cdn-images-1.medium.com/max/800/1*dtR7uZ3PaUrpcksPrVFWHQ.png' />

<img src='https://cdn-images-1.medium.com/max/800/1*C4tNc0e_fqsuVfIu308BDQ.png' />

#### Adding ButtonsÂ ðŸ”˜

In this section, we are going to replace the section that displays `Start and Stop Buttons!` with actual buttons. We will be using `TouchableOpacity` to make this work. A `TouchableOpacity` component acts as a wrapper for making views respond properly to touches. The opacity of the wrapped view (or the button in our case) gets decreased whenever a user touches it.

We create a reusable component since we need two buttons: Start and Stop.

<img src='https://cdn-images-1.medium.com/max/800/1*tj3HIFtHmaRMJC_XgokHyQ.png' />

This is a stateless component, so it has no classâ€Šâ€”â€Šwe only need it to represent the Button in the UI of our app. We also import FontAwesome icons from `@expo/vector-icons`, which is a fork of react-native-vector-icons and comes directly with the expo SDK. No need to install it as a separate dependency. To display an icon, we need to define its `size`.

Lastly, in the above stateless component, we define `propTypes`. I will be discussing how and why we should use PropTypes in a React Native application in another article.

In a mobile app, events are triggered by touch. To handle those events, we are going to use `onPress`. We will have only two events here, Start and Stop. Both the buttons in our app are going to make use of `onPressOut` which differs from `onPress`Â . The `onPressOut` is called whenever the touch is released by the user (when the user stops pressing the button). It is called before `onPress` and is more accurate in a situation like ours where we need to start or stop the timer by pressing the button as soon as the user is done.

We will now require this `Button` component in our Timer component.

<img src='https://cdn-images-1.medium.com/max/800/1*jy7fxGEmZ6XhFbQVKBsmNw.png' />

<img src='https://cdn-images-1.medium.com/max/800/1*5YaPpg8mP6Nb95LIjifmdw.gif' />

### Integrating ReduxÂ ðŸ˜

So far, our Timer application does not do anything other than display a bare minimum UI. To make it work, we start by adding some necessary Redux dependencies.

<img src='https://cdn-images-1.medium.com/max/800/1*1wEzBipK4kL89Mt2d84sGQ.png' />

Now, let us start integrating Redux in our app.

#### Actions ðŸŽ¬

In Redux, the state of the whole application is represented by one JavaScript object. Think of this object as read-only, since we cannot make changes to this state (which is represented in the form of a tree) directly. We need `actions` to do so.

Actions are like events in Redux. They can be triggered in the form of mouse clicks, key presses, timers or network requests. The nature of each event mentioned is mutable. An action is a JavaScript object. To define an action, there is one requirement: each action much have its own type property. We define these types in a file called `types.js`:

<img src='https://cdn-images-1.medium.com/max/800/1*VKHREyQdGAXCvdmVFXfPBw.png' />

Our application needs only three actions so far. The type of any action is a string value and is defined as a constant.

In the file `actions.js`, we will require these types to define action creators. Action Creators are functions that create actions.

<img src='https://cdn-images-1.medium.com/max/800/1*8ZO2qO4_ivFDAcuVkcyw8g.png' />

#### Reducers ðŸšœ

The receiver of the action is known as a reducer. Whenever an action is triggered, the state of the application changes. The handling of the applicationâ€™s state is done by the reducers.

A reducer is a pure function that calculates the next state based on the initial or previous state. It always produces the same output if the state is unchanged. It takes two inputs, and state and action must return the default state.

<img src='https://cdn-images-1.medium.com/max/800/1*52J8tvpIPftFQvxGjljioQ.png' />

In our initial state, we define three attributes: `isPlaying`, `elapsedTime` and `timerDuration`. The timer currently has a default value of 6 (seconds) for testing purposes, but the actual value we are going to change later is `25` (or 1500 seconds).

Then there are three helper functions:

- `applyStartTimer` will start the timer
- `applyRestartTimer` will stop the timer function and set everything to default
- and lastly, `applyAddSecond` will check if the time passed is less than the total timer's duration. If so, itâ€™ll add one more second to increase its value. If the not, it will return the default state and stop the timer function from running.

After that, we define our reducer function and export the same function. Observe how the reducer function is organised. This is a pattern followed by most community members I have seen on the internet.

[This](https://egghead.io/courses/getting-started-with-redux) is a good resource to get started with Redux in general by [Dan Abramov](https://medium.com/u/a3a8af6addc1) and it is FREE!

#### Creating Redux StoreÂ ðŸ¬

With the help of the reducer and the initial state, we can create the store object.

<img src='https://cdn-images-1.medium.com/max/800/1*FcpwQgHpKTaMvM_jjLlhKQ.png' />

A store is an object that brings and actions and reducers together. It provides and holds state at the application level instead of individual components. Redux is not an opinionated library in terms of which framework or library should use it or not.

To bind a React or React Native application with Redux, you do it with `react-redux` module. This is done by using the high ordered component `Provider`. It basically passes the store down to the rest of the application.

We need to bind action creators with our Timer function in order to make it fully functional (so that it responds to the touchable events or the start or restart of the timer). We will do this in the `Timer/index.js` function.

First, we import the required dependencies to bind action creators.

<img src='https://cdn-images-1.medium.com/max/800/1*1amB7kU23eYwjF-a8aGUiQ.png' />

`bindActionCreators` maps action functions to an object using the names of the action functions. These functions automatically dispatch the action to the store when the function is called. To change the data, we need to dispatch an action. To enable this, we need two things: `mapStateToProps` and `mapDispatchToProps`, and we need to connect both of them with our component. This is the boilerplate code that you will be re-writing.

We define these two functions and modify our `export default` statement after we define the styles for our React Native views.

<img src='https://cdn-images-1.medium.com/max/800/1*RobgSa1MMNKK-J4RstCN9w.png' />

`mapStateToProps` is an object that lives in the store whose keys are passed down to the component as props. The below is the complete code for the Timer component.

### Completing The App

<img src='https://cdn-images-1.medium.com/max/800/1*LqWiY370yr3gXMPtiJC9wg.png' />)

I have created a custom function called `formatTime` to display the time in the correct format, but you can make use of any timer library. Next, to increment the value of time, I use the React lifecycle method `componentWillReceiveProps`. I know it is going to deprecated soon, but for now it works. See our mini-app in action below:

<img src='https://cdn-images-1.medium.com/max/800/1*kMPizExeDMG-6MrYNbw8ew.gif' />

For the sake of brevity and this demo, I am using only seconds to display the timer. You can increase the value of the timer by editing the value of constant `TIMER_DURATION` in `reducers.js`.

We have reached the end of the article. Hopefully, you have had as much fun reading it as I did writing it. You can find the complete code for this article at this Github repo:

[**amandeepmittal/rn-pomodoro-example**]https://github.com/amandeepmittal/rn-pomodoro-example)

_Do you remember me telling you about a particular file structure I followed in implementing Redux architecture? Well it is called_ **_re-ducks_** _pattern and you can find more details in this informative article by_ [_Alex Moldovan_](https://medium.com/u/93d08ec35da2)_:_

[**Scaling your Redux App with ducks**](https://medium.freecodecamp.org/scaling-your-redux-app-with-ducks-6115955638be)

[Originally published at freeCodeCamp.org](https://medium.com/free-code-camp/how-to-integrate-redux-into-your-application-with-react-native-and-expo-ec37c9ca6033)

---

## How to Mock Data for Node.js Applications using faker.js
Slug: how-to-mock-data-for-nodejs-applications-using-fakerjs

> [Originally Published at Hackernoon.com](https://hackernoon.com/how-to-mock-data-for-node-js-applications-using-faker-js-b1f4c0e78102)

When we start to build an application, we generally do not want to worry much about data. To create a database and fill it with sample data seems much of a hassle to me personally. I instead focus more on creating RESTful API and the front end of the application when I am prototyping.

However, this doesnâ€™t mean I donâ€™t pay attention to data organization in the database. Itâ€™s important to have schemas of collections and documents or any other way you want to organize your data. With this aspect complete, it clarifies _what_ and _how_ questions when creating APIs.

In a recent scenario, building a prototype of an E-Commerce web application for a client, I found myself in a similar situation. I had a deadline to deliver the prototype with a maximum number of functionalities checked required by the client. After settling on how to architecture databaseâ€™s schemas, I went on searchingâ€‹ and finding a gem to solve this issue: **faker.js.**

### Enter faker.js

Itâ€™s a wonderful node module to create fake/mock data when you face a similar situation. fakerjs has its own API, and itâ€™s huge. All credit goes to [**Marak**](https://x.com/marak), who built it. It has a vast API for almost every use case with an excellent [_documentation_ that can help you get familiar in minutes on Github.](https://github.com/marak/Faker.js/)

Letâ€™s consider a test case where I want some _a user_ to have the following amount of fields:

- name
- email
- website
- address
- bio
- image/avatar

```js
const faker = require('faker');

const User = {
  name: faker.name.findName(),
  email: faker.internet.email(),
  website: faker.internet.url(),
  address:
    faker.address.streetAddress() +
    faker.address.city() +
    faker.address.country(),
  bio: faker.lorem.sentences(),
  image: faker.image.avatar()
};

module.exports = User;
```

<img src='https://cdn-images-1.medium.com/max/1200/1*t8BjRlFjuUnbf0iXl-FZCQ.png' />

Thatâ€™s it. This is how you mock data using faker.js. Itâ€™s quick, simple to setup and no hassle at all. You just have to add it to your `npm` dependencies:

```shell
npm install faker --save
```

#### faker.js Data

List of data that can generate faker.js:

- address
- commerce
- company
- date
- finance
- hacker
- helpers
- image
- internet
- lorem
- name
- phone
- random
- system

Each element has many sub-items that you can check [here](https://github.com/Marak/faker.js) in the documentation.

Another good thing about Faker I like is that itâ€™s not only restricted to server-side JavaScript only. You can mock data for browser JavaScript too. A little snippet from the documentation shows how to do this:

```html
<script src="faker.js" type="text/javascript"></script>
<script>
  var randomName = faker.name.findName(); // Caitlyn Kerluke
  var randomEmail = faker.internet.email(); // Rusty@arne.info
  var randomCard = faker.helpers.createCard(); // random contact card containing many properties
</script>
```

This API will help you to prototype your JavaScript/Node.js applications at a faster rate. Not only that, you can easily mock your TDD/BDD tests when creating a RESTful API utilizing this library.

For full source code at [this Github Repository](https://github.com/amandeepmittal/fakerjs)

---

## Open any folder from the Terminal app in a Finder on macOS
Slug: how-to-open-any-folder-from-terminal-in-finder-on-mac

Often, I struggle or want to open the current directory I am working from the Terminal app to the Finder window on macOS.

I have been a macOS user for almost eight years now, and it never occurred to me that I couldn't open the current location from the Terminal app. Until recently, a frustration point led me to find the solution. Again, though, I am surprised by its simplicity.

To open the current working directory in the Finder window, use the following command:

```shell
open .
```

The `open` command opens a file or a folder. It exists on the macOS.

You can do more with this command. The `/` argument opens the root directory.

```shell
open /
```

A specific directory is also allowed:

```shell
open ~/Desktop
```

Using the option `R`, you can locate a specific file or folder in the Finder:

```shell
open -R /blog
```

## Opening files

There are more things that the `open` command can do. It can open files. For example, to open a markdown file in the default editor or IDE:

```shell
open ./blog/mm-yy/your-file-name.md
```

The above command opens the markdown file in the Xcode. You can pass the `-t` option to open in the file in a text editor.

```shell
open -t ./blog/mm-yy/your-file-name.md
```

## Opening URLs

It can do more than open files and folders. It can also open a URL in the default web browser set up on your machine:

Use option `a` to override the default web browser and specify a different one.

```shell
open -a Safari https://www.google.com
```

---

## How to rename default branch in Git and GitHub
Slug: how-to-rename-default-branch-name-in-git-and-github

I'm currently [maintaining a GitHub repo](https://github.com/amandeepmittal/react-native-examples) that has grown over the last year. It primarily contains all the example code that I create when working on React Native and Expo articles and tutorials.

Recently, I switched the default branch to `main`. Here are the steps I took. All of these commands execute inside a terminal window.

Start by moving the default branch locally using the `-m` flag.

```shell
git branch -m master main
```

Above, `master` is the old branch name and `main` is the new branch name.

Set the new branch as the local default on the remote. By default, Git doesn't allow renaming a remote branch.

```shell
git push -u origin main

# output
* [new branch]      main -> main
Branch 'main' set up to track remote branch 'main' from 'origin'.
```

Set the current local HEAD branch to point to the new branch on GitHub.

```shell
git remote set-head origin main
```

Now, go to the GitHub repo. Open Settings > Branches. Under Default Branch, click the edit button to switch to the `main` branch.

![ss1](https://i.imgur.com/T9Mm8g5.png)

Now, go back to the terminal window and run the following command to delete the previous default branch name.

```shell
git push origin --delete master

# output
To https://github.com/account/repo.git
- [deleted]         master
```

That's it!

---

## How to use ES6 import syntax in Node.js
Slug: how-to-use-es6-import-in-nodejs

![cover_image](https://i.imgur.com/mztPVQI.png)

<blockquote>
Photo by <a href="https://unsplash.com/@weirick?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Jake Weirick</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
</blockquote>

<br />

A module is a JavaScript file that exports one or more values. The exported value can be a variable, an object, or a function.

An ES6 import syntax allows importing modules exported from a different JavaScript file. It is a common pattern to use modules across React and React Native applications. The syntax is composed of the following ES module standard:

```js
import XXX from 'xxx';
```

An ES module is the ECMAScript standard of working with modules. Node.js uses the CommonJS standard to import modules. The syntax for this type of standard can be described as:

```js
const XXX = require('xxx');
```

Node js doesnâ€™t support ES6 import directly. Try writing the `import` syntax in a JS file:

```js
// index.js

import { ApolloServer, gql } from 'apollo-server';
```

Run the Node.js server either by using `npm start` or `npm run dev` and you will encounter the following error:

![ss1](https://i.imgur.com/lbHW7pl.png)

The solution to this error is in the first line of the above error snippet and is now [a recommend way by Node.js](https://nodejs.org/api/esm.html#esm_enabling). Set the `"type": "module"` in `package.json` file.

```json
{
  "type": "module"
}
```

This solution works for the latest Node.js versions (which is `15.4.x` at the time of writing) and versions above `14.x.x`.

![ss2](https://i.imgur.com/Mm92hul.png)

## What about environments using Node version lower than 14

Another solution to this problem is to use [Babel](https://babeljs.io/). It's a JavaScript compiler and allows you to write JS using the latest syntax. Babel is not framework or platform opinionated. This means that it can be used in any project that is written in JavaScript and thus, in a Node.js project as well.

Start by installing the following dev dependencies from a terminal window:

```bash
npm i -D @babel/core @babel/preset-env @babel/node
```

Then create a file at the root of the Node.js project called `babel.config.json` and add the following:

```json
{
  "presets": ["@babel/preset-env"]
}
```

The package `@babel/node` is a CLI utility that compiles JS code in a Node.js project with Babel presets and plugins before running it. It means it will read and apply any configuration mention in `babel.config.json` before executing the Node project.

Replace the `node` with `babel-node` to execute the server in the `start` or `dev` scripts.

An example of running Node server using `npm run dev` script:

```json
{
  "scripts": {
    "dev": "nodemon --exec babel-node server.js"
  }
}
```

---

## How to use ESLint in Node.js Applications
Slug: how-to-use-eslint-in-node-js-applications

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/how-to-use-eslint-in-node-js-applications-cc4b2298ce55)

ESLint is an open source JavaScript linting utility that help you overcome developer errors as JavaScript is loosely-typed language. There are quite a few options such as JSHint and JSCS in Javascript community for code linting and this post doesnâ€™t suggest that you cannot use them.

ESLint is designed to have all rules completely pluggable. Thatâ€™s one of the primary reasons it came into existence. It allows developers to create their own linting rules. Every rule provided in the [ESLint official guide](http://eslint.org/docs/user-guide) is standalone rule and a developer at any point can decide whether to use a specific rule or not.

### Installing

_Note_: You must have Node.js installed in order to access ESLint via itâ€™s package manager `npm`.

For local installation to a project directory:

```shell
npm install eslint --save-dev
```

For a global installation in your working system:

```shell
npm install eslint -g
```

ESLint will now be available via `eslint` command in your terminal.

### Configuration

Easiest way to configure it to setup aÂ `.eslintrc` JSON file where are all the linting rules can be described.

An example ofÂ `.eslintrc`:

```json
{
  "env": {
    "node": 1,
    "browser": 1
  },
  "globals": {
    "exampleGlobalVariable": true
  },
  "rules": {
    "eqeqeq": 1
  },
  "plugins": []
}
```

If you installed eslint globally, you can also generate config file using:

```shell
eslint --init
```

Other case, if you have installed it locally to a project, you will need to type in your terminal:

```shell
./node_modules/.bin/eslint --init
```

In both cases, you will be prompted with set of basic questions to generateÂ `.eslintrc` file.

<img src='https://cdn-images-1.medium.com/max/800/0*RMPR1vjmB6jsHtHw.png' />

An example of file generated after above prompt:

```json
{
  "env": {
    "browser": true,
    "commonjs": true
  },
  "extends": "eslint:recommended",
  "rules": {
    "indent": ["error", "tab"],
    "linebreak-style": ["error", "unix"],
    "quotes": ["error", "single"],
    "semi": ["error", "never"]
  }
}
```

For detailed information on Configuration, [read here](http://eslint.org/docs/user-guide/configuring).

### Rules

Rules in ESLint are added individually. No rules are enforced by default. You have to specify rules explicitly, then only it will be enabled for the linting process.

You can find a complete list of rules in the [official documentation here](http://eslint.org/docs/rules/)

After deciding which rules to include, you have to set there error levels. Each error level can be defined as following:

- `0` - Turn the rule off
- `1` - Turn the rule on as a warning
- `2` - Turn the rule on as an error

The difference between an error and a warning is the exit code that eslint will have when it finishes. If any errors are found, eslint will exit with a `1` exit code, otherwise it will exit with a `0`. If you are linting within a build step this allows you to control which rules should "break your build" and which ones should be considered as warnings.

Learn how to [configure rules in detail here](http://eslint.org/docs/user-guide/configuring#configuring-rules).

### Environments

The code you are writing might be suitable for a particular environment such as, you might be writing a REST API in Node.js application using Express Framework (Sinatra) and the frontend of that application is going to be built in AngularJS. Two different projects, two different environments and both can have separate eslint configurations in one file even though the client and the server are under one project directory that is been considered as root of your project.

How is it done? By setting the environment id to true in the `"env"` section ofÂ `.eslintrc`.

### Linting

ESLint comes with a command line interface (CLI) to lint your files or directory.

```js
eslint file.js
eslint dir/
```

The output generated will be grouped by file, and will specify the `line:column` number, warning/error, reason for the error, and the name of the rule for each failure.

### Use ESLint with your preferred CodingÂ Style

ESLint personally does not promote any coding style. You can setupÂ `.eslintrc` file to enforce coding style using [style rules](http://eslint.org/docs/rules/#stylistic-issues) that you like.

You can also use ESLint with Style guides such as [JavaScript Standard Style](http://standardjs.com/). You have to use extra plugin for that. The full guide can be found here [https://github.com/feross/eslint-config-standard](https://github.com/feross/eslint-config-standard).

To add a plugin toÂ `.eslintrc`:

Some plugins for popular libraries: [Angular](https://www.npmjs.com/package/eslint-plugin-angular) | [React](https://www.npmjs.com/package/eslint-plugin-react)

Another plugin, I find very useful is [one variable per var](https://www.npmjs.com/package/eslint-plugin-one-variable-per-var) just to maintain code consistency over a large/open-source project.

---

## How to use Font Awesome in an Ionic Application
Slug: how-to-use-font-awesome-in-an-ionic-application

There is an element of confusion when it comes to use FontAwesome in an Ionic Application. To include this fonts library in Ionic needs a bit of configuration and this step by step guide will provide just that.

### Bootstrap an Ionic Application

Create a new Ionic application or you can follow these steps to include FontAwesome in your Ionic application. Nothing will break down.

```shell
$ ionic start ionic-use-fontawesome
```

Now, install the FontAwesome package from `npm` and save it in the app's dependencies:

```shell
$ npm install font-awesome --save
```

Type the above in the root folder of your app. This will add the `font-awesome` folder under `node_modules`. The `--save` option will include the package inside the dependencies section of `package.json` file.

### Include theÂ fonts

Now wander to the `src/index.html` file and add the following `link` tag just above `build/main.css`:

```html
<link rel="stylesheet" href="assets/css/font-awesome.min.css" />
<link href="build/main.css" rel="stylesheet" />
```

### Add a Custom CopyÂ Script

Ionic includes a copy script file that is called during the build process when the command `ionic serve` executes and it is responsible for moving specific and required resources from `node_modules` to the `www` folder such as ionicons.

The location of this script file is under `node_modules` folder:

<img src='https://cdn-images-1.medium.com/max/800/0*samQXT4FoWTgUXK1.png' />

Copy this file and paste in inside a new directory called `config` under the root directory of your Ionic application. Open the file and add fontawesome entries at the bottom of this file.

```js
copyFontawesomeFonts: {
    src: ['{{ROOT}}/node_modules/font-awesome/fonts/**/*'],
    dest: '{{WWW}}/assets/fonts'
  },
  copyFontawesomeCss: {
    src: ['{{ROOT}}/node_modules/font-awesome/css/font-awesome.min.css'],
    dest: '{{WWW}}/assets/css'
  }
```

### Include Custom Copy Script in package.json

We must include this custom script inside our `package.json` file to override the one where we copied the original file from. Open the `package.json` file and add this json code:

```json
"config": {
    "ionic_copy": "./config/copy.config.js"
  }
```

Thatâ€™s it in the configuration part.

### Use FontAwesome

To implement FontAwesome in this or any Ionic application after the above configuration, we try adding some fonts on our pre-generated home page.

```html
<ion-header>
  <ion-navbar color="secondary">
    <ion-title> FontAwesome Icons </ion-title>
  </ion-navbar>
</ion-header>

<ion-content padding>
  <ion-list>
    <ion-item>
      <i class="fa fa-battery-empty" style="color: red;"></i> Battery Level
      Empty
    </ion-item>
    <ion-item> <i class="fa fa-battery-1"></i> Battery Level 1 </ion-item>
    <ion-item> <i class="fa fa-battery-2"></i> Battery Level 2 </ion-item>
    <ion-item> <i class="fa fa-battery-3"></i> Battery Level 3 </ion-item>
    <ion-item>
      <i class="fa fa-battery-4" style="color: green;"></i> Battery Level 4
    </ion-item>
  </ion-list>
</ion-content>
```

<img src='https://cdn-images-1.medium.com/max/800/0*RnPachma2AAxR_SY.png' />

There are more than 675 icons available in FontAwesome and I think a combination of both Ionicons and FontAwesome will be enough for some the applications out there. You can even style them, change their `font-size` and color as per your needs.

[**_Full source code at this Github Repository_**](https://github.com/amandeepmittal/ionic-use-font-awesome)

[Originally Published at Hackernoon.com](https://medium.com/hackernoon/how-to-use-font-awesome-in-an-ionic-application-31638ed3f77d)

---

## How to use Import statements in Nodejs
Slug: how-to-use-import-statements-in-nodejs

> **UPDATE:** Up to date version of this post is at [How to use ES6 import syntax in Node.js](https://amanhimself.dev/blog/how-to-use-es6-import-syntax-in-node/).

I donâ€™t always like to try different versions of setting up a Nodejs application. Donâ€™t get me wrongâ€Šâ€”â€ŠI believe in experimenting with oneâ€™s set up, which can lead to learning new things. But there is a limit. Recently, I find myself more often going to set up a Nodejs server to develop a RESTful API. Furthermore, the server has to work with the client in a way that the client can consume the API easily. For the client-side development, I am using ReactJS.

With the context switching between the client and the server I often find myself making errors during the process. One of the most common is using `import` statements in Nodejs files. This leads to a syntax error called `Unexpected identifier`. Even after switching to Nodejs `v10` LTS on my local machine, I find the lack of using ES6 modules rather disappointing.

To overcome this problem, and reduce the number of errors I cause during development, I read a few tutorials but decided to mesh a setup of my own. These tutorials, though well written, use methods that are almost completely opposite to one another. I want consistency when working on full-stack applications for my day job.

As a result, I m going to show you a streamlined, less time-consuming version of using `import` statements in a Nodejs server-side application. To continue to read this article, please make sure you have following applications installed on your local machine:

- Nodejs
- npm

### Getting Started With a MockÂ Project

I call it a mock project because I am going to start from scratch to build this setup. At the end of this tutorial, I will leave a link to a Github repository that can serve as a starter kit to many of your Nodejs plus Express projects. You can skip to the link part and DIYâ€Šâ€”â€Šthereâ€™s no complexity here. If youâ€™re still curious, continue to read this short piece.

To start, create a new directory, traverse inside it and initialize it with `npm`.

```shell
mkdir node-babel-setup
npm init -y
```

You can check out the `package.json` file after initializing your project as an npm project. It will be filled with details that you have used to configure npm.

```json
{
  "name": "node-babel-setup",
  "version": "0.0.1",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "Aman Mittal <amandeepmittal@live.com> (www.amanhimself.me)",
  "license": "MIT"
}
```

Next, create a new file with the following command from your terminal:

```shell
touch index.js
```

<img src='https://cdn-images-1.medium.com/max/800/1*cToGazhSQLTx3oIwsJULPQ.png' />

Thatâ€™s all we need to set up a bare minimum project directory. In the next section, we take a look at what dependencies we have to install and why we need those dependencies.

### Creating the NodeÂ Server

To create a server I am going to use Express. To include Express in our project as a dependency, run the following command from your terminal:

```shell
npm install -S express
```

Next, append the `index.js` file with the following code:

```js
const express = require('express');

const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
  res.send('Hello from Nodejs!');
});

app.listen(PORT, () => {
  console.log(`ðŸš€ at port ${PORT}`);
});
```

You can run the server by running the command `node index.js`. Visit URL `http://localhost:3000/` and youâ€™ll see a message displayed in the browser window: `Hello from Nodejs!`.

This indicates that the code for the server is fine. Now modify the first line of `index.js` to:

```js
import express from 'express';
```

Run the same command `node index.js` and stay at the terminal window. This time the server does not start as there is an error in the process. Itâ€™s the same error I told you about at the start of this article. Nodejs cannot execute `import` statements by default.

<img src='https://cdn-images-1.medium.com/max/800/1*itCGCm0lnbBG94KS6D0bOg.png' />

### Using Babel

All we need is a transpiler, which allows us to write JavaScript using ES6 features such as `import` statements in our Nodejs project. _Whatâ€™s a transpiler?_

> Transpilers are also known as source-to-source compilers that read code from source written in one programming language and produce an equivalent code in another language.

In our case weâ€™re not switching programming languages, rather we need to use new language features that are not yet supported by the LTS version of Node. Iâ€™m going to set up Babel compiler and enable it in our project by going through the following configuration process:

First, you will have to install few dependencies. Do mind -D flag as we only need these dependencies for our development environment:

```shell
npm install -D babel-cli babel-preset-env babel-watch
```

Once you have installed them, add aÂ `.babelrc` file to the root of the project and add the following config:

```json
{
  "presets": ["env"]
}
```

The last step in the configuration process is to add a `dev` script in `package.json`. You can name this script whatever you like. This will take care of running the babel compiler on its own (automate) once there is a change. This done by `babel-watch` that also takes care of re-starting Nodejs web server.

```json
"scripts": {
  "dev": "babel-watch index.js",
}
```

To see it action make sure the following code to your `index.js` uses `import` statement like below.

```js
import express from 'express';

const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
  res.send('Hello!');
});

app.listen(PORT, () => {
  console.log(`ðŸš€ at port ${PORT}`);
});
```

From terminal write `nr dev`. If there are no errors, youâ€™ll get the following:

<img src='https://cdn-images-1.medium.com/max/800/1*Rz9TPPfk6B4p4NPTntXKvg.png' />

Where `nr` is shorthand for `npm run`. You can also visit `http://localhost3000/` in your browser to verify the result and see if the server is working or not.

### Conclusion

This article has shown you how to create a bare minimum Node server from scratch, and how you can introduce upcoming JavaScript features in your Node.js environment using Babel. Iâ€™m sure now you are not going to make the same silly errors like me in _Nodejs_ + _insert a frontend framework/library of your choice_ as I did.

_You can find the complete source code for the above article at_ [**_Github Repo_**](https://github.com/amandeepmittal/node-babel-setup)

---

## How to use iOS simulator in full-screen
Slug: how-to-use-ios-simulator-in-full-screen

When working on React Native or Expo applications, it is important to create focus to get in a flow. Sometimes, there are a lot of tasks to cover and very little time. To help focus on the task ahead, one way to speed up development is to use full-screen mode for iOS simulators. For example, a focused environment on my laptop screen includes zero visibility for the Dock and the menu bar.

Before Xcode version 12, the full-screen support was hidden behind a user flag. The below command can be run to solve the issue for older Xcode versions.

```shell
defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES
```

With the latest version of Xcode and each new macOS version trying to outperform its previous one, it has never been easy to enable full-screen mode for an iOS simulator.

![ss1](https://i.imgur.com/mvSX1u2.png)

In the above image, observe that [VS Code editor](setup-macbook-m1) is on the left and the iOS simulator is on the right.

To enter the full-screen mode, click on the resize window icon (green icon) on the application (iOS simulator and the editor/IDE of your choice).

![ss2](https://i.imgur.com/nhkQdNs.png)

Then, you can position one application on the left and another on the right.

![ss3](https://i.imgur.com/ZjU2UUi.gif)

It's already challenging to keep distractions at bay. But, sometimes, a little bit of focus can go a long way.

---

## How to use React Native Localize in React Native apps
Slug: how-to-use-react-native-localize

Not every app require global customers but if you have plans to have, you would need internationalization in your React Native app. Using [`react-native-localize`](https://github.com/react-native-community/react-native-localize) your app can detect the operating system or the device language and support the multi-languages.

In this tutorial, let us build a small demo that uses `react-native-localize` along with a popular internationalization library [`i18n-js`](https://github.com/fnando/i18n-js). The app will display some mock locales based on the device's language and region settings.

## Table of contents

- Requirements
- Installing react-native-localize
- Add locales
- Add i18n Functionality
- Completing the App component
- Run the app
- Conclusion

## Requirements

- Node.js >= `10.x.x` version installed
- watchman
- react-native-cli

Do note that Iâ€™m going to use an iOS simulator for this tutorial.

## Installing react-native-localize

To get started, open a terminal window and generate a new React Native app. Also, install the following dependencies after navigating inside the app directory.

```shell
react-native init rni18nDemo

cd rni18nDemo

yarn add react-native-localize i18n-js lodash.memoize

# for ios only
cd ios/
pod install
```

If you are using `react-native` version greater than `0.60.x` you won't have to link the library `react-native-localize` manually. If you are below the specified version, please refer to the module's official documentation [here](https://github.com/react-native-community/react-native-localize).

This library gives you access to localization constants related to a particular device. These constants are not included in `i18n-js` library.

The `lodash.memoize` package is going to be used since `i18n-js` does not have a concept of caching.

## Add locales

Create two new files `en.json` and `nl.json` inside the directory `src/translations/`. Both of these files are for separate languages: English, and Dutch. Inside these files are JSON objects that have key-value pairs. The key for both files or the languages is going to be the same. The value for each key is going to differ as it contains the actual translation.

Following are the contents of each file:

```json
// en.json
{
 "hello": "Hello!",
 "Good morning": "Good morning",
 "Currency": "USD"
}

// nl.json
{
 "hello": "Hallo!",
 "Good morning": "Goedemorgen",
 "Currency": "EUR"
}
```

## Add i18n Functionality

Open `App.js` file and import the following statements.

```js
import React from 'react';
import * as RNLocalize from 'react-native-localize';
import i18n from 'i18n-js';
import memoize from 'lodash.memoize';
import { SafeAreaView, StyleSheet, Text } from 'react-native';
```

Next, require the translation files from the directory created in the previous step, using an object `translationGetters`.

```js
const translationGetters = {
  en: () => require('./src/translations/en.json'),
  nl: () => require('./src/translations/nl.json')
};
```

Add the helper function `translate` that is going to translate the keywords on the language selection.

```js
const translate = memoize(
  (key, config) => i18n.t(key, config),
  (key, config) => (config ? key + JSON.stringify(config) : key)
);
```

Next, add another helper method that is going to detect the fallback language when there is no proper translation available for a particular word or phrase.

Also, using `RNLocalize.findBestAvailableLanguage()` method, you can let the app detect the possible language tag (_value for each tag is coming from the language getters object_) and if not tag is available, it is going to use the fallback language tag. This method can also be used with some languages to detect their reading direction (_such as RTL_).

```js
const setI18nConfig = () => {
  const fallback = { languageTag: 'en' };
  const { languageTag } =
    RNLocalize.findBestAvailableLanguage(Object.keys(translationGetters)) ||
    fallback;

  translate.cache.clear();

  i18n.translations = { [languageTag]: translationGetters[languageTag]() };
  i18n.locale = languageTag;
};
```

## Completing the App component

Lastly, let us create the `App` component. In the `App.js` file, start by adding a `constructor` method that is going to be used to set the i18n config helper method.

```js
class App extends React.Component {
  constructor(props) {
    super(props);
    setI18nConfig();
  }

  // ...
}

export default App;
```

Then, using the lifecycle methods `componentDidMount` and `componentWillUnmount`, you are going to add and remove event listeners to listen for any localization change.

```js
componentDidMount() {
 RNLocalize.addEventListener('change', this.handleLocalizationChange)
 }

 componentWillUnmount() {
 RNLocalize.removeEventListener('change', this.handleLocalizationChange)
 }

 handleLocalizationChange = () => {
 setI18nConfig()
 .then(() => this.forceUpdate())
 .catch(error => {
 console.error(error)
 })
 }
```

Here is the rest of the component file with the `render` method and the styles used in it. Apart from translation locales, `react-native-localize` provide ready to use helper methods such as `getCountry()`. This particular method returns a value in the form of a country code based on the device's locale.

```js
render() {
 return (
 <SafeAreaView style={styles.safeArea}>
 <Text style={styles.value}>{translate('hello')}</Text>
 <Text style={styles.value}>{translate('Good morning')}</Text>
 <Text style={styles.value}>Currency: {translate('Currency')}</Text>
 <Text style={styles.value}>Country: {RNLocalize.getCountry()}</Text>
 </SafeAreaView>
 )
}

// styles
const styles = StyleSheet.create({
 safeArea: {
 backgroundColor: 'white',
 flex: 1,
 alignItems: 'center',
 justifyContent: 'center'
 },
 value: {
 fontSize: 24
 }
})
```

## Run the app

Make sure you build the app before running it on the platform of your choice. Here are the commands you need to run depending on the device.

```shell
# ios
react-native run-ios

# android
react-native run-android
```

When the app's build process is complete, it is going to run the English locales by default.

<img src='https://miro.medium.com/max/350/1*3KLq-CScY5yMp1pPnf1qjg.png' />

On changing the locale, the correct result is reflected in the app.

<img src='https://miro.medium.com/max/377/1*cURVMx8splW7SgIaLd6y_g.gif' />

## Conclusion

This completes the tutorial on how to use `react-native-localize` to add and use language translations in a React Native app.

Here is the complete code for this demo in a **[Github repo](https://github.com/amandeepmittal/rni18nDemo)**.

Checkout [Jonathan Palma's](https://x.com/jonathanpalma__) who wrote [a small i18n library](https://github.com/jonathanpalma/react-native-simple-i18n#readme) after being inspired from this post. Check the library here on [GitHub](https://github.com/jonathanpalma/react-native-simple-i18n#readme).

Originally published at [Heartbeat.fritz.ai](https://heartbeat.fritz.ai/how-to-use-react-native-localize-in-react-native-apps-3bb3d510f801)

---

## How to use the Geolocation API in a React Native app
Slug: how-to-use-the-geolocation-api-in-a-react-native-app

Geolocation as an API has different methods that can be used in a web application. But itâ€™s also a powerful API for mobile development. Ride share mobile apps like Uber, map app like Google Maps, and location features implemented in apps like Instagram depend on using this API. React Native takes advantage of this API and its available methods by extending the [**Geolocation Web specification**](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation).

The Geolocation API returns different methods such as `getCurrentPosition` to get the current location and `watchPosition` to subscribe to location updates. They are available in React Native as polyfill.

Along with this, youâ€™re going to implement a real-time feature to ask **user permissions**. Permissions in `react-native-cli` can be a bit tricky, but after reading this article, it should be much easier.

### What are we building?

In this tutorial, weâ€™ll start by going to use basic methods from the Geolocation API and then build a complete app in React Native using a `react-native` command-line interface tool.

The outcome of following this tutorial is going to be a complete React Native weather application that consumes weather data from a third-party API and presents that data in a simple UI.

<img src='https://cdn-images-1.medium.com/max/800/1*PMstW38hq0Zza4T8mZr6qg.png' />

### Table ofÂ Contents

- Getting Started with `react-native-cli`
- Accessing Geolocation API
- Setting Permissions for iOS and Android
- Building the Weather App: First Steps
- The Loading Component
- Weather Screen
- Fetching the Data
- Adding Dynamic Weather Conditions
- Conclusion

### Prerequisites

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- [Node.js](https://nodejs.org/en/) (>=`8.x.x`) with npm/yarn installed.
- `react-native` CLI tool with a version equal to or above `2.0.1`. You can install the CLI tool with the following command.

```shell
npm install -g react-native-cli
```

> Please note that, throughout this tutorial, Iâ€™ll be using an iOS simulator to demonstrate the application.

### Getting Started

To get started, we need to initialize a new React Native project. Run the command below:

```shell
react-native init geoWeatherApp
```

Then traverse into the newly-created directory and run the following commands to see if everything is working fine.

```shell
cd geoWeatherApp
npm run start

## in second tab/window terminal
react-native run-ios
```

The second command will run the build process for the iOS platform. You can run `react-native run-android` if you wish to you use an Android emulator. Since our application is â€˜bare minimumâ€™ right now and doesnâ€™t contain much source code, except in the `App.js` file, youâ€™ll see the image below when the app runs for the first time in the simulator.

<img src='https://cdn-images-1.medium.com/max/800/1*T3QXVm1-unXEjKEZhmKo7A.png' />

If you take a look at the project structure, youâ€™ll notice that there are separate build folders such as `/android` and `/ios` for each platform to bootstrap the application.

### Accessing the Geolocation API

The Geolocation API exists as a global object called navigator object in React Native, just like the web. Itâ€™s accessible through `navigator.geolocation` in our source code, and thereâ€™s no need to import it.

For our demonstration purposes, weâ€™ll use the `getCurrentPosition` method from the Geolocation API. This method allows a mobile app to request a user's location and accepts three parameters: success callback, error callback, and a configuration object.

Weâ€™ll only modify the `App.js` file with the following code:

```js
// App.js

import React, { Component } from 'react';
import { Alert, StyleSheet, Text, View, TouchableOpacity } from 'react-native';

export default class App extends Component {
	state = {
		location: null
	};

	findCoordinates = () => {
		navigator.geolocation.getCurrentPosition(
			position => {
				const location = JSON.stringify(position);

				this.setState({ location });
			},
			error => Alert.alert(error.message),
			{ enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }
		);
	};

	render() {
		return (
			<View style={styles.container}>
				<TouchableOpacity onPress={this.findCoordinates}>
					<Text style={styles.welcome}>Find My Coords?</Text>
					<Text>Location: {this.state.location}</Text>
				</TouchableOpacity>
			</View>
		);
	}
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: 'center',
		alignItems: 'center',
		backgroundColor: '#F5FCFF'
	},
	welcome: {
		fontSize: 20,
		textAlign: 'center',
		margin: 10
	}
```

Observe the function `findCoordinates`. It holds the logic of fetching a device's current location. Weâ€™re also using the local state object to store and display the returned data object provided by `position`.

<img src='https://cdn-images-1.medium.com/max/800/1*LmcWwnrsZOXkGbmagtx7Mw.png' />

When you click the text `Find My Coords?` (itâ€™s touchable since weâ€™re using `TouchableOpacity`) it will first ask for permission, as shown below.

<img src='https://cdn-images-1.medium.com/max/800/1*72jjzVbVBLl-mTdk_vMA7w.png' />

Note that even in development mode and while running the app in a simulator, permission is only asked for once. To perform this again, youâ€™ll have to delete the app from your simulator and re-run the command to start the Expo app. When permission is granted, it will fetch the result, store it in the appâ€™s state, and display the returned object:

<img src='https://cdn-images-1.medium.com/max/800/1*K5bwsAxiRQm0Z2qImvniaA.png' />

### Setting Permissions for iOS andÂ Android

In iOS, geolocation is enabled by default when a project is created using the `react-native-cli`. To use it, we just need to include a key in `info.plist`, which is inside the `ios/geoWeatherApp` directory.

<img src='https://cdn-images-1.medium.com/max/800/1*2be8SbVAPPukbDgPUsl29g.png' />

That field is already there if you check the file. In order to enable geolocation in the background, you need to include the `NSLocationAlwaysUsageDescription` key in `info.plist` file and add location as a background mode in the `Capabilities` tab through Xcode. Also, if youâ€™re using CocoaPods for React Native, make sure to include the `RCTGeolocation` sub-podspec.

For Android, we need to add the following line in our `android/app/src/AndroidManifest.xml` file.

```xml
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
```

<img src='https://cdn-images-1.medium.com/max/800/1*lDejJzVSE6YGIRGT_Lgbjw.png' />

Now if you run your application in the Android Emulator, youâ€™ll see the same welcome screen as shown before in the iOS simulator. Click on the text `Find My Coords?` and youâ€™ll be prompted to ask whether to allow the application to request the userâ€™s location or not.

<img src='https://cdn-images-1.medium.com/max/800/1*gJVJOiCG4NO45iEnmwfdtA.png' />

If you press allow, youâ€™ll see the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*H9Pj8TlBfWqlrtZfmPWteQ.png' />

You can find the complete code for this part of the tutorial in the repository below.

### Building the Weather App: FirstÂ Steps

In this section, weâ€™re going to take what we learned in the last section and build a complete weather application using a third party weather API providerâ€”such as the [OpenWeatherMap API](https://openweathermap.org/api)â€”and our current Geolocation API knowledge.

First, we need to gather the API key from [OpenWeatherMap](https://openweathermap.org/api). Sign in or make a new account if you donâ€™t already have one (itâ€™s free, no worries). Using this API, weâ€™re going to build a simple mobile application that uses a mobile deviceâ€™s geolocation. The coordinates from a userâ€™s location will be passed to the OpenWeatherMap API which, in return, will give us a forecast for that location.

<img src='https://cdn-images-1.medium.com/max/800/1*8yiknE8jK7gnClfanEsSfw.png' />

Once youâ€™re logged in, visit [**https://home.openweathermap.org/api_keys**](https://home.openweathermap.org/api_keys) to fetch your API key. Thereâ€™s a default API key provided by OpenWeatherMap, so weâ€™re going to use that in our project.

Now, open up your `App.js` file and enter the following snippet of code to see if everything is working well:

```js
// App.js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class App extends React.Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>Minimalist Weather App</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

And youâ€™ll see the following output is rendered.

<img src='https://cdn-images-1.medium.com/max/800/1*mXaHYMh_TgpEeJjrKFz2ug.png' />

The next step is to install [**react-native-vector-icons**](https://oblador.github.io/react-native-vector-icons/). If youâ€™ve already installed react-native-vector-icons, then you can skip this step. Otherwise, enter the following command in your terminal window.

```shell
npm install -S react-native-vector-icons
```

The last step in this process is to link our newly-installed library.

```shell
react-native link react-native-vector-icons
```

**_Why do we have to perform this last command?_** All third-party libraries in React Native have some native dependencies that use platform-specific capabilities for iOS and/or Android. Linking these native dependencies with the `react-native link` command indicates that a libraryâ€™s native dependencies are linked successfully to your iOS/Android project.

Whenever you link a library, youâ€™ll always get a prompt message informing you whether the library has been successfully linked or not. Since weâ€™ve already added permissions to ask and access a userâ€™s location in this project, we can skip this and continue to the next step. If youâ€™re building this project from scratch, you can go back to the section [**Setting Permissions for iOS and Android**](#d8df) and add the necessary permissions.

### The Loading Component

In this step, weâ€™ll develop our first screenâ€”a loading screen. Inside the `App.js` file, start by defining a local state:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class App extends React.Component {
  state = {
    isLoading: true
  };

  render() {
    const { isLoading } = this.state;
    return (
      <View style={styles.container}>
        {isLoading ? null : (
          <View>
            <Text>Minimalist Weather App</Text>
          </View>
        )}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

The code above states that when the value of local state for `isLoading` is `false`, itâ€™s going show the name of the value of the `<Text>` component, which in this case is the name of the application. This is what weâ€™re going to render.

Later on, instead of displaying the name of the application, weâ€™ll show the weather info here, once our API has successfully fetched the data. For now, letâ€™s stick to this message so we can first work on the question: _What if our app is in the state of loading?_ Let's add the message text to indicate that the app is fetching the data. Change the content of `render()`:

```js
render() {
    const { isLoading } = this.state;
    return (
      <View style={styles.container}>
        {isLoading ? (
          <Text>Fetching The Weather</Text>
        ) : (
          <View>
            <Text>Minimalist Weather App</Text>
          </View>
        )}
      </View>
    );
}
```

Right now, if you change to value of `isLoading` to true, youâ€™ll notice the below screen appear.

<img src='https://cdn-images-1.medium.com/max/800/1*fo8IAFglmCCWcBkSTiigLQ.png' />

> Note: After testing for the above screen, make sure you set the default value of `isLoading` to false.

### Weather Screen

Weâ€™ll define a new weather component atÂ `./components/Weather.js`. The boilerplate code for every weather condition screen is going to be the same. It will be divided into two viewsâ€”a header and a body. The header will show the weather condition icon and temperature, and the body will display the text associated with the weather condition.

In `Weather.js`, we start by defining two containers inside the main container: `headerContainer` and `bodyContainer`. Do note that weâ€™re defining the `Weather` component not as a class but as a function in order to receive props and since it wonâ€™t be managing a state.

```js
// Weather.js
import React from 'react';
import { View, Text, Stylesheet } from 'react-native';

const Weather = () => {
  return (
    <View style={styles.container}>
      <View style={styles.headerContainer} />
      <View style={styles.bodyContainer} />
    </View>
  );
};

const styles = StyleSheet({
  container: {
    flex: 1
  },
  headerContainer: {},
  bodyContainer: {}
});

export default Weather;
```

Iâ€™m going to use `MaterialCommunityIcons` to display weather icons in the app.

```js
import React from 'react';
import { View, Text, Stylesheet } from 'react-native';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

const Weather = () => {
  return (
    <View style={styles.weatherContainer}>
      <View style={styles.headerContainer}>
        <Icon size={48} name="weather-sunny" color={'#fff'} />
        <Text style={styles.tempText}>TemperatureËš</Text>
      </View>
      <View style={styles.bodyContainer}>
        <Text style={styles.title}>So Sunny</Text>
        <Text style={styles.subtitle}>It hurts my eyes!</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  weatherContainer: {
    flex: 1,
    backgroundColor: '#f7b733'
  },
  headerContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  tempText: {
    fontSize: 48,
    color: '#fff'
  },
  bodyContainer: {
    flex: 2,
    alignItems: 'flex-start',
    justifyContent: 'flex-end',
    paddingLeft: 25,
    marginBottom: 40
  },
  title: {
    fontSize: 48,
    color: '#fff'
  },
  subtitle: {
    fontSize: 24,
    color: '#fff'
  }
});

export default Weather;
```

To see it in action, letâ€™s modify `App.js`. Import the `Weather` component and then make changes to the `render()` function accordingly:

```js
// App.js
import Weather from './components/Weather';


// ...
render() {
		const { isLoading } = this.state;
		return (
			<View style={styles.container}>
				{isLoading ? <Text>Fetching The Weather</Text> : <Weather />}
			</View>
		);
  }
```

<img src='https://cdn-images-1.medium.com/max/800/1*dOKWGbyK8rLkcJb57lE8YQ.png' />

### Fetching theÂ Data

To fetch real-time weather data, I found the OpenWeatherMap API to be highly useful and consistent. To communicate with the API, youâ€™ll need an API key (as discussed previously). To store the API key in our app, create a new file calledÂ `./utils/WeatherApiKey.js`.

```js
export const API_KEY = '849338767c0e95025b5559533d26b7c4';
```

The way the OpenWeatherMap API works is that we need to feed it longitude and latitude coordinates from the deviceâ€™s location. It then fetches the data from its server as a JSON object. From the server, we now need two things: the temperature, and the weather condition. We should have both stored in the local state in `App.js`.

```js
state = {
  isLoading: false,
  temperature: 0,
  weatherCondition: null,
  error: null
};
```

We start by importing the API key we just defined, then updating our state with `temperature`, `weatherCondition`, and `error`. We need a lifecycle method to re-render the component once the data is fetched from the API. For this purpose, `componentDidMount()` works best. Add the below snippet before the `render()` function in `App.js`:

```js
componentDidMount() {
		navigator.geolocation.getCurrentPosition(
			position => {
				this.fetchWeather(position.coords.latitude, position.coords.longitude);
			},
			error => {
				this.setState({
					error: 'Error Getting Weather Conditions'
				});
			}
		);
	}

	fetchWeather(lat = 25, lon = 25) {
		fetch(
      `http://api.openweathermap.org/data/2.5/
      weather?lat=${lat}&lon=${lon}&APPID=${API_KEY}
      &units=metric`
		)
			.then(res => res.json())
			.then(json => {
				this.setState({
					temperature: json.main.temp,
					weatherCondition: json.weather[0].main,
					isLoading: false
				});
			});
  }
```

Weâ€™re also using JavaScriptâ€™s `navigator` API to get the current location. (_This is where a JavaScript API will communicate with a native one using a bridge._) We pass on the values of latitude and longitude to our custom function `fetchWeather`, where the OpenWeatherMap API is called.

The result we get is in JSON format, and if you console log it, youâ€™ll be able to see the result as a JSON object in the Expo terminal, where there are a lot of values. We need only the temperature value and weather condition. We then update our local state with the new values obtained. `&units=metric` at the end of our API call converts the temperature from Kelvin to Celsius.

Now all we have to do is pass the two values of our local state as props to the `Weather` component and then update it so that it can receive those props:

```js
<Weather
  weather={this.state.weatherCondition}
  temperature={this.state.temperature}
/>
```

Then, update `Weather.js` accordingly to use props:

```js
const Weather = ({ weather, temperature }) => {
  return (
    <View style={styles.weatherContainer}>
      <View style={styles.headerContainer}>
        <MaterialCommunityIcons size={48} name="weather-sunny" color={'#fff'} />
        <Text style={styles.tempText}>{temperature}Ëš</Text>
      </View>
      <View style={styles.bodyContainer}>
        <Text style={styles.title}>{weather}</Text>
        <Text style={styles.subtitle}>It hurts my eyes!</Text>
      </View>
    </View>
  );
};
```

The result will be as follows:

<img src='https://cdn-images-1.medium.com/max/800/1*pIZuRJJlYJwrNkm2we-8PA.png' />

### Adding Dynamic Weather Conditions

Since weâ€™ve done the hard part of fetching the real-time data, we need to make the `Weather` component behave [dynamically based on the values](https://openweathermap.org/weather-conditions) itâ€™s getting. This entire dynamic behavior will be associated with `weatherCondition`.

Using `weatherCondition`, we can define changes in our background, title, subtitle, and weather icon. Let's start by pre-defining weather conditions in a file,Â `./utils/WeatherConditions.js`:

```js
export const weatherConditions = {
  Rain: {
    color: '#005BEA',
    title: 'Raining',
    subtitle: 'Get a cup of coffee',
    icon: 'weather-rainy'
  },
  Clear: {
    color: '#f7b733',
    title: 'So Sunny',
    subtitle: 'It is hurting my eyes',
    icon: 'weather-sunny'
  },
  Thunderstorm: {
    color: '#616161',
    title: 'A Storm is coming',
    subtitle: 'Because Gods are angry',
    icon: 'weather-lightning'
  },
  Clouds: {
    color: '#1F1C2C',
    title: 'Clouds',
    subtitle: 'Everywhere',
    icon: 'weather-cloudy'
  },

  Snow: {
    color: '#00d2ff',
    title: 'Snow',
    subtitle: 'Get out and build a snowman for me',
    icon: 'weather-snowy'
  },
  Drizzle: {
    color: '#076585',
    title: 'Drizzle',
    subtitle: 'Partially raining...',
    icon: 'weather-hail'
  },
  Haze: {
    color: '#66A6FF',
    title: 'Haze',
    subtitle: 'Another name for Partial Raining',
    icon: 'weather-hail'
  },
  Mist: {
    color: '#3CD3AD',
    title: 'Mist',
    subtitle: "Don't roam in forests!",
    icon: 'weather-fog'
  }
};
```

These weather conditions are provided from the OpenWeatherMap API. Then, letâ€™s import them in `Weather.js`:

```js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

import { weatherConditions } from '../utils/WeatherConditions';

const Weather = ({ weather, temperature }) => {
  return (
    <View
      style={[
        styles.weatherContainer,
        { backgroundColor: weatherConditions[weather].color }
      ]}
    >
      <View style={styles.headerContainer}>
        <Icon size={72} name={weatherConditions[weather].icon} color={'#fff'} />
        <Text style={styles.tempText}>{temperature}Ëš</Text>
      </View>
      <View style={styles.bodyContainer}>
        <Text style={styles.title}>{weatherConditions[weather].title}</Text>
        <Text style={styles.subtitle}>
          {weatherConditions[weather].subtitle}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  weatherContainer: {
    flex: 1
  },
  headerContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  tempText: {
    fontSize: 48,
    color: '#fff'
  },
  bodyContainer: {
    flex: 2,
    alignItems: 'flex-start',
    justifyContent: 'flex-end',
    paddingLeft: 25,
    marginBottom: 40
  },
  title: {
    fontSize: 48,
    color: '#fff'
  },
  subtitle: {
    fontSize: 24,
    color: '#fff'
  }
});

export default Weather;
```

Weâ€™ve made some additions by using available props with weather conditions to dynamically change the background, icon, weather name, and the subtitle. You can play around with the styling to make it look more minimalistic or more exquisiteâ€Šâ€”â€Šitâ€™s up to you!

<img src='https://cdn-images-1.medium.com/max/800/1*Z6Nv_m3cBRuj9w5qwiJStw.png' />

### Conclusion

Youâ€™ve successfully used the knowledge of geolocation data and setting up permissions in a real-time scenario to build a weather forecast application using a third party API and React Native.

[Originally published at Heartbeat](https://heartbeat.fritz.ai/how-to-use-the-geolocation-api-in-a-react-native-app-b5e611b00a0c)

---

## Ignoring JSX components in Vale
Slug: ignoring-jsx-components-in-vale

When using [Vale](<[https://vale.sh/docs](https://vale.sh/docs)>) to prose lint documentation written in MDX, you may face a common challenge where Vale tries to lint the text within JSX components. This can lead to false positives and unnecessary warnings or errors depending on how your Vale rules are configured.

Vale is already "markup" aware, which means it is capable of both applying rules to and ignoring certain sections of your markdown files. In this post, let's explore how you can use custom block-level ignores in your Vale configuration using `BlockIgnores`. This is a pattern I am using while managing documentation at work.

## Understanding Vale's initialization process and challenge with JSX components

If you write documentation using MDX, you're likely familiar with how combining Markdown and JSX components creates a powerful authoring experience.

When Vale starts processing a file, initialization rules are first applied. These rules are defined inside a `.vale.ini` file in a project's root directory. These rules determine how Vale should handle different parts of your document, pay attention to which area and skip other areas. This file also configures the format of your documentation. For example, treating MDX files as Markdown files is defined by:

```ini
[formats]
mdx = md
```

Now, let's take a look at a typical MDX documentation file where a JSX component is used:

```jsx
<Terminal
  cmd={[
    '# Install Tailwind CSS',
    '$ npx expo add tailwindcss@3 postcss autoprefixer -- --dev',
    '',
    '# Create a Tailwind config file',
    '$ npx tailwindcss init -p',
  ]}
/>

# OR

<Alert type="warning">
 The following feature is experimental.
</Alert>
```

Vale processes this file in three main stages:

- Vale will look for markers indicating special syntax, where it can look for style rules, vocab rules, and so on
- Then, it applies patterns that can be ignored using [`BlockIgnores`](<[https://vale.sh/docs/keys/blockignores](https://vale.sh/docs/keys/blockignores)>) and [`TokenIgnores`](https://vale.sh/docs/keys/tokenignores)
- Finally, it applies your defined style rules to the text

Things get interesting when Vale lints the plain text used inside JSX components in MDX files. It may throw a warning or an error (depending on how your Vale styles rules are defined) by flagging the text inside the JSX component.

## Using Vale's BlockIgnores

Vale provides block-level configuration to ignore a specific pattern. When defined using `BlockIgnores`, Vale skips that pattern during the linting process.

`BlockIgnores` are defined inside the `.vale.ini` configuration:

```ini
BlockIgnores =
```

You can use regular expressions (regex) to tell Vale which JSX components to ignore. For example, to ignore the `<Terminal />` component entirely, you can update `BlockIgnores` to:

```ini
# Ignore self-closing Terminal components
BlockIgnores = (?s)<Terminal.*?/>,
```

This regex pattern will match and ignore any instances of the `<Terminal />` component used inside an MDX file as part of your docs source code. The `(?s)` allows the pattern to match across multiple lines, the `<Terminal.*?/>` matches the self-closing JSX tag, and `.*?` matches everything between the tag.

`BlockIgnores` also accepts multiple sections and you can use `,` to separate them. For example, to ignore `Alert` from the first example, you can extend `BlockIgnores` to:

```ini
# Now, ignore Alert components with Children
BlockIgnores = (?s)<Terminal.*?/>,(?s)<Alert>.*?</Alert>
```

The pattern `.*?` in the above example matches the child text inside the `Alert` tags.

After adding any configuration, as shown in the example above, test and verify that the patterns you ignore work correctly.

## Wrapping up

By understanding Vale's initialization rules and using custom regular expression patterns to exclude a specific block, you create a robust documentation linting setup that can gracefully handle JSX components within your markdown files.

---

## How to implement Forgot Password feature in React Native with Firebase
Slug: implement-forgot-password-firebase-react-native

> Originally published at [Heartbeat.Fritz.ai](https://heartbeat.fritz.ai/how-to-implement-forgot-password-feature-in-react-native-and-firebase-app-890b572d9759)

In some of the previous posts, you built a React Native app using Firebase as the backend service provider for Email authentication and storing user data upon successful sign-up.

Let's add another common yet useful and necessary feature in the current app structure: **Forgot Password**. This feature will require another screen in the current React Native app. To follow this tutorial, you can go through the previous posts if you are a beginner to the React Native world:

- [How authentication works using react-navigation 4.x.x](https://heartbeat.fritz.ai/how-authentication-flow-works-in-react-native-apps-using-react-navigation-4-x-a30bb4d9e5d6)
- [How to build and validate forms in React Native apps using Formik and Yup](https://heartbeat.fritz.ai/build-and-validate-forms-in-react-native-using-formik-and-yup-6489e2dff6a2)
- [Handle different field types in React Native forms](https://heartbeat.fritz.ai/handling-different-field-types-in-react-native-forms-with-formik-and-yup-fa9ea89d867e)
- [Use React Context API to build React Native, Expo and Firebase apps](https://amanhimself.dev/context-api-react-native-firebase)

**Or** you if you are comfortable in understanding React Native code, dive deep in source code or download it from the Github repo release [here](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.6.0).

After downloading the source code, please navigate inside the project directory and install dependencies by running the command `npm install` or `yarn install`.

## Table of Contents

- Requirements
- Add Forgot Password Screen
- Add a method to send a password reset email
- Create a Form
- Handle Password Reset

## Requirements

To follow this tutorial, please make sure you the following libraries are installed on your local development environment and access to the services mentioned below.

- Nodejs (`>= 12.x.x`) with npm/yarn installed
- Expo SDK (`>= 40.x.x`)
- Firebase account, free tier will do

## Add Forgot Password Screen

Letâ€™s start with a basic screen and hook it up with current navigation flow such that an app user will be able to navigate to this new screen from the `Login` screen.

Create a new file `screens/ForgotPassword.js` with some dummy text.

```js
import React, { Component } from 'react';
import { Text, View } from 'react-native';

class ForgotPassword extends Component {
  render() {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text>Forgot Password Screen</Text>
      </View>
    );
  }
}

export default ForgotPassword;
```

Open the `AuthNavigation.js` file and this new class component as below.

```js
import { createStackNavigator } from 'react-navigation-stack';
import Login from '../screens/Login';
import Signup from '../screens/Signup';
import ForgotPassword from '../screens/ForgotPassword';

const AuthNavigation = createStackNavigator(
  {
    Login: { screen: Login },
    Signup: { screen: Signup },
    ForgotPassword: { screen: ForgotPassword }
  },
  {
    initialRouteName: 'Login',
    headerMode: 'none'
  }
);

export default AuthNavigation;
```

Lastly, open `Login.js` file. Logically, this where a button to navigate to this new `ForgotPassword` component should exist. First, add the handler method `goToForgotPassword` inside the `Login` class component with other handler methods.

```js
goToForgotPassword = () => this.props.navigation.navigate('ForgotPassword');
```

Passing the name of the route as the first parameter to `navigation.navigate()` is how you navigate from one screen to the other screen using `react-navigation` library. In this case, the name of the route is going to be `ForgotPassword`.

Next, add the a `Button` component after the `Signup` button. The value of the `onPress` prop of this button is going to be the handler method.

```js
<Button
  title="Forgot Password?"
  onPress={this.goToForgotPassword}
  titleStyle={{
    color: '#039BE5'
  }}
  type="clear"
/>
```

Now, open a simulator or a real device with an Expo client installed and run the command `expo start` from a terminal window. You will be welcomed by the following screen.

![ss1](https://i.imgur.com/U7hRwYl.png)

Clicking on the button `Forgot Password ?` will lead you to the new screen.

![ss2](https://i.imgur.com/UrH4dJY.png)

## Add a method to send a password reset email

The Firebase authentication module provides a method that you can use in React Native apps to send a link to the user's registered email id with the app. Users can click the link to reset the password. Firebase does this on its own. You do not have to write the server code to add this functionality to your app.

To start, open `config/Firebase/firebase.js` file and add the following method. You will use this method inside the `ForgotPassword` component by providing the user's email as input.

```js
passwordReset: email => {
  return firebase.auth().sendPasswordResetEmail(email)
},
```

That's all you need to configure the Firebase app to make sure it sends the email on the registered email id.

To extend this further, you can try and customize the Email template that Firebase uses to send the reset password link [here](https://support.google.com/firebase/answer/7000714).

## Create a Form

Using the previously obtained knowledge of Formik ad yup let us add an input field and a button. The input field will take in the email and the button will be responsible to perform the action of submitting the form. In other words, it will trigger the network to reset the user's email in a handler method.

Open `ForgotPassword.js` file and add the following import statements.

```js
import React, { Component, Fragment } from 'react';
import { Text, SafeAreaView, View, StyleSheet } from 'react-native';
import { Formik } from 'formik';
import * as Yup from 'yup';
import FormInput from '../components/FormInput';
import FormButton from '../components/FormButton';
import ErrorMessage from '../components/ErrorMessage';
import { withFirebaseHOC } from '../config/Firebase';
```

After the import statements, add `validationSchema` object. This object is similar to that used in `Login` component and will help to determine whether the input provided already exists as the registered email or not.

```js
const validationSchema = Yup.object().shape({
  email: Yup.string()
    .label('Email')
    .email('Enter a valid email')
    .required('Please enter a registered email')
});
```

Go the `render` function, and replace its existing content to the form below.

```js
render() {
    return (
      <SafeAreaView style={styles.container}>
        <Text style={styles.text}>Forgot Password?</Text>
        <Formik
          initialValues={{ email: '' }}
          onSubmit={(values, actions) => {
            this.handlePasswordReset(values, actions)
          }}
          validationSchema={validationSchema}>
          {({
            handleChange,
            values,
            handleSubmit,
            errors,
            isValid,
            touched,
            handleBlur,
            isSubmitting
          }) => (
            <Fragment>
              <FormInput
                name='email'
                value={values.email}
                onChangeText={handleChange('email')}
                placeholder='Enter email'
                autoCapitalize='none'
                iconName='ios-mail'
                iconColor='#2C384A'
                onBlur={handleBlur('email')}
              />
              <ErrorMessage errorValue={touched.email && errors.email} />
              <View style={styles.buttonContainer}>
                <FormButton
                  buttonType='outline'
                  onPress={handleSubmit}
                  title='Send Email'
                  buttonColor='#039BE5'
                  disabled={!isValid || isSubmitting}
                />
              </View>
              <ErrorMessage errorValue={errors.general} />
            </Fragment>
          )}
        </Formik>
      </SafeAreaView>
    )
  }
```

In the above code snippet, the elements such as `FormInput`, `FormButton` and `ErrorMessage` are some re-usable custom presentational components that you can find inside `components/` directory. `this.handlePasswordReset(values, actions)` is the handler method that accepts two parameters. You will write the logic behind this method in the next section.

The corresponding styles to the component are:

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    marginTop: 150
  },
  text: {
    color: '#333',
    fontSize: 24,
    marginLeft: 25
  },
  buttonContainer: {
    margin: 25
  }
});
```

Lastly, do not forget to wrap the `ForgotPassword` with the Firebase High Order Component `withFirebaseHOC` to use `passwordReset` method as props.

```js
export default withFirebaseHOC(ForgotPassword);
```

Now go back to the simulator and you will get the following screen.

![ss3](https://i.imgur.com/2ry1EAn.png)

## Handle Password Reset

Inside the `ForgotPassword` component create a new handler method called `handlePasswordReset`. This is going to be an asynchronous function that will accept the user's email as the parameter from the Formik's values.

Also, pass the `actions` from Formik as the second parameter. Instead of just console logging the error values, to display the error on the screen, Formik provides `setFieldError`.

```js
handlePasswordReset = async (values, actions) => {
  const { email } = values;

  try {
    await this.props.firebase.passwordReset(email);
    console.log('Password reset email sent successfully');
    this.props.navigation.navigate('Login');
  } catch (error) {
    actions.setFieldError('general', error.message);
  }
};
```

The above snippet signifies that if the email provided as the input is valid, it will send the request to reset the password. On success, a message on Expo's console will be displayed as shown below.

![ss4](https://i.imgur.com/zDL0Pfg.png)

Also, on success, it will navigate the user back to the login screen. On errors, the code inside the `catch` block will be triggered.

To try it out, register a user with a valid email address such that you can receive an email. On registering a new user, right now, the app will log you in. Sign out from the app which will take you back to the login screen. Next, go the `Forgot Password` screen and enter the valid email.

![ss8](https://i.imgur.com/YwJ191G.png)

You will receive an email like the below. It uses the default Firebase template. To demonstrate, I am using my personal Gmail address.

![ss5](https://i.imgur.com/kmgey8U.png)

Click on the link and it will redirect you to a webpage like below.

![ss6](https://i.imgur.com/vhuApsk.png)

Upon successful password change, it will prompt with the following message to the user.

![ss7](https://i.imgur.com/rLPkUeE.png)

## Conclusion

That's it! It is that simple. With a new password, you can try to login to the app now and it will work. If you have come this far, I am hope enjoyed reading this post. These are some of the strategies I try to follow with any Firebase + React Native projects.

I hope any of the codebase used in this tutorial helps you. To find the complete code, you will have to visit this [Github repo release](https://github.com/amandeepmittal/expo-firebase/releases/tag/0.7.0).

## Further reading

- [Hiring a React Native Developer: What Should You Look For? by Jess Marranco](https://www.g2i.co/blog/hiring-a-react-native-developer)

---

## Implementing Infinite Scroll with React Query and FlatList in React Native
Slug: infinite-scroll-with-react-query-and-flatlist-in-react-native

> Originally published at [Jscrambler.com](https://jscrambler.com/blog/implementing-infinite-scroll-with-react-query-and-flatlist-in-react-native)

Infinite Scrolling is a way to implement pagination in mobile devices. It is common among mobile interfaces due to the limited amount of space. If you use social media applications like Instagram or Twitter, this implementation is commonly used across those apps.

In this tutorial, let's learn how to implement an infinite scroll using the FlatList component in React Native. To fetch data, we will use a real REST API service provided by [RAWG](https://rawg.io/apidocs). It is one of the largest video game databases, and they have a free tier when it comes to using their API for personal or hobby projects. React Query library will help us make the process of fetching data a lot smoother.

## Prerequisites

To follow this tutorial, please make sure you have the following tools and utilities installed on your local development environment and have access to the services mentioned below:

- [Node.js](https://nodejs.org/en/) version `12.x.x` or above installed
- Have access to one package manager such as npm or yarn or npx
- [RAWG API key](https://rawg.io/apidocs)

You can also check the [complete source code for this example is at this GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/main/infinite-scroll-with-react-query).

## Creating a new React Native app

To create a new React Native app, let's generate a project using [create-react-native-app](https://github.com/expo/create-react-native-app) command-line tool. This tool helps create universal React Native apps, supports React Native Web, and you can use native modules. It is currently being maintained by the awesome Expo team.

Open up a terminal window and execute the following command:

```shell
npx create-react-native-app

# when prompted following questions
What is your app named? infinite-scroll-with-react-query
How would you like to start â€º Default new app

# navigate inside the project directory after it has been created
cd infinite-scroll-with-react-query
```

Then, let's install all the dependencies that will be used to create the demo app. In the same terminal window:

```shell
yarn add native-base react-query && expo install react-native-safe-area-context react-native-svg
```

This command should download all the required dependencies. To run the app in its vanilla state, you can execute either of the following commands (depending on the mobile OS you're using). These commands will build the app.

```shell
# for iOS
yarn ios

# for android
yarn android
```

## Creating a Home Screen

Let's create a new directory called `/src`. This directory will contain all the code related to the demo app. Inside it, create a sub-directory called `/screens` that will contain the component file, `HomeScreen.js`.

In this file, let's add some JSX code to display the title of the app screen.

```js
import React from 'react';
import { Box, Text, Divider } from 'native-base';

export const HomeScreen = () => {
  return (
    <Box flex={1} safeAreaTop backgroundColor="white">
      <Box height={16} justifyContent={'center'} px={2}>
        <Text fontSize={28} fontWeight={'600'} color={'emerald.500'}>
          Explore Games
        </Text>
      </Box>
      <Divider />
    </Box>
  );
};
```

The `Box` component from NativeBase is a generic component. It comes with many props, a few of them are to apply SafeAreaView of the device. The prop `safeAreaTop` applies padding from the top of the device's screen. One advantage of using the NativeBase library is its built-in components provide props like handling safe area views.

Most NativeBase components also use utility props for most commonly used styled properties such as `justifyContent`, `backgroundColor`, andmore. Shorthands for these utility props such as `px` for padding horizontal.

## Setting up providers

Both NativeBase and React Query libraries require their corresponding providers to set up at the root of the app. Open the `App.js` file and add the following:

```js
import React from 'react';
import { StatusBar } from 'expo-status-bar';
import { NativeBaseProvider } from 'native-base';
import { QueryClient, QueryClientProvider } from 'react-query';

import { HomeScreen } from './src/screens/HomeScreen';

const queryClient = new QueryClient();

export default function App() {
  return (
    <>
      <StatusBar style="auto" />
      <NativeBaseProvider>
        <QueryClientProvider client={queryClient}>
          <HomeScreen />
        </QueryClientProvider>
      </NativeBaseProvider>
    </>
  );
}
```

All the providers must wrap the entry point or the first screen of the application. In the above snippet, there is only one screen, so all the providers are wrapping `HomeScreen`.

The `QueryClientProvider` component provides an instance in the form of `QueryClient` that can be further used to interact with the cache.

After modifying `App.js`, you will get the following output on a device:

![ss1](https://i.imgur.com/aFep48m.png)

## Add a Base URL to use RAWG REST API

If you want to continue reading this post and build along with the demo app, make sure you have access to the API key for your RAWG account. Once you've done that, create a new file called `index.js` inside the `/src/config` directory. This file will export the base url of the API and API key.

```js
const BASE_URL = 'https://api.rawg.io/api';
// Replace the Xs below with your own API key
const API_KEY = 'XXXXXX';

export { BASE_URL, API_KEY };
```

Replace the Xs in the above snippet with your own API key.

## Fetching data from the API

To fetch the data, we will use JavaScript `fetch` API method. Create a new file called `index.js` inside `/src/api`. It will import the base url and the API key from the `/config` directory and expose a function that fetches the data.

```js
import { BASE_URL, API_KEY } from '../config';

export const gamesApi = {
  // later convert this url to infinite scrolling
  fetchAllGames: () =>
    fetch(`${BASE_URL}/games?key=${API_KEY}`).then(res => {
      return res.json();
    })
};
```

Next, in the `HomeScreen.js` file, import React Query hook called `useQuery`. This hook accepts two arguments. The first argument is a unique key. This key is a unique identifier in the form of a string. It tracks the result of the query and caches it.

The second argument is a function that returns a promise. This promise is resolved when there is data or throws an error when there is something wrong when fetching the data. We've already created the promise function that fetches data asynchronously from the API's base Url in the form of `gamesApi.fetchAllGames()`. Let's import the `gamesApi` as well.

Inside the `HomeScreen`, let's call this hook to get the data.

```js
import React from 'react';
import { Box, Text, FlatList, Divider, Spinner } from 'native-base';
import { useQuery } from 'react-query';

import { gamesApi } from '../api';

export const HomeScreen = () => {
  const { isLoading, data } = useQuery('games', gamesApi.fetchAllGames);

  const gameItemExtractorKey = (item, index) => {
    return index.toString();
  };

  const renderData = item => {
    return (
      <Text fontSize="20" py="2">
        {item.item.name}
      </Text>
    );
  };

  return isLoading ? (
    <Box
      flex={1}
      backgroundColor="white"
      alignItems="center"
      justifyContent="center"
    >
      <Spinner color="emerald.500" size="lg" />
    </Box>
  ) : (
    <Box flex={1} safeAreaTop backgroundColor="white">
      <Box height={16} justifyContent={'center'} px={2}>
        <Text fontSize={28} fontWeight={'600'} color={'emerald.500'}>
          Explore Games
        </Text>
      </Box>
      <Divider />
      <Box px={2}>
        <FlatList
          data={data.results}
          keyExtractor={gameItemExtractorKey}
          renderItem={renderData}
        />
      </Box>
    </Box>
  );
};
```

In the above snippet, take a note that React Query comes with the implementation of request states such as `isLoading`. The `isLoading` state implies that there is no data and is currently in the "fetching" state. To improve the user experience, while the `isLoading` state is true, a loading indicator or a spinner component can be displayed (as did in the above snippet using the `Spinner` component from NativeBase).

Here is the output after this step:

![ss2](https://i.imgur.com/jSX1Aqu.gif)

## Adding pagination to the API request

The `useInfiniteQuery` hook provided by the React Query library is a modified version of the `useQuery` hook. In addition to the request states such as `isLoading` and `data`, it utilizes a function to get the next page number using `getNextPageParam`.

In the case of RAWG REST API, the data fetch on each request contains the following keys:

- `count`: the total count of games.
- `next`: the url to the next page.
- `previous`: the url of the previous page. Is `null` if the current page is first.
- `results`: the array of items on an individual page.

The key names `next`, and `previous` will depend on the response structure of the API request. Make sure to check your data response what are the key names and what are their values.

Currently, the API request made in the `/api/index.js` file does not consider the number of the current page. Modify as shown below to fetch the data based on the page number.

```js
export const gamesApi = {
  // later convert this url to infinite scrolling
  fetchAllGames: ({ pageParam = 1 }) =>
    fetch(`${BASE_URL}/games?key=${API_KEY}&page=${pageParam}`).then(res => {
      return res.json();
    })
};
```

The addition `&page=${pageParam}` in the above snippet is how the `getNextPageParam` function will traverse to the next page if the current page number is passed in the request endpoint. Initially, the value of `pageParam` is `1`.

## Using useInfiniteQuery hook

Let's import the `useInfiniteQuery` hook in the `HomeScreen.js` file.

```js
// rest of the import statements remain same
import { useInfiniteQuery } from 'react-query';
```

Next, inside the `HomeScreen` component, replace the `useQuery` hook with the `useInfiniteQuery` hook as shown below. Along with the two arguments, the new hook will also contain an object as the third argument. This object contains the logic to fetch the data from the next page using the `getNextPageParam` function.

The function retrieves the page number of the next page. It accepts a parameter called `lastPage` that contains the response of the last query. As per the response structure we discussed earlier in the previous section, check the value of `lastPage.next`. If it is not `null`, return the next page's number. If it is `null`, return the response from the last query.

```js
const { isLoading, data, hasNextPage, fetchNextPage } = useInfiniteQuery(
  'games',
  gamesApi.fetchAllGames,
  {
    getNextPageParam: lastPage => {
      if (lastPage.next !== null) {
        return lastPage.next;
      }

      return lastPage;
    }
  }
);
```

## Implementing infinite scroll on FlatList

In the previous snippet, the `hasNextPage` and `fetchNextPage` are essential. The `hasNextPage` contains a boolean. If it is `true`, it indicates that more data can be fetched. The `fetchNextPage` is the function provided by the `useInfiniteQuery` to fetch the data of the next page.

Add a handle method inside the `HomeScreen` component called `loadMore`. This function will be used on the FlatList prop called `onEndReached`. This prop is called when the scroll position reaches a threshold value.

```js
const loadMore = () => {
  if (hasNextPage) {
    fetchNextPage();
  }
};
```

Another difference between `useInfiniteQuery` and `useQuery` is that the former's response structure includes an array of fetched pages in the form of `data.pages`. Using JavaScript `map` function, get the `results` array of each page.

Modify the `FlatList` component as shown below:

```js
<FlatList
  data={data.pages.map(page => page.results).flat()}
  keyExtractor={gameItemExtractorKey}
  renderItem={renderData}
  onEndReached={loadMore}
/>
```

Here is the output after this step. Notice the scroll indicator on the right-hand side of the screen. As soon as it reaches a little below half of the list, it repositions itself. This repositioning indicates that the data from the next page is fetched by the `useInfiniteQuery` hook.

![ss3](https://i.imgur.com/IiJMVA7.gif)

The default value of the threshold is `0.5`. This means that the `loadMore` will get triggered at the half-visible length of the list. To modify this value, you can add another prop, `onEndReachedThreshold`. It accepts a value between 0 and 1, where 0 is the end of the list.

```js
<FlatList
  data={data.pages.map(page => page.results).flat()}
  keyExtractor={gameItemExtractorKey}
  renderItem={renderData}
  onEndReached={loadMore}
  onEndReachedThreshold={0.3}
/>
```

## Display a spinner when fetching next page data

Another way to enhance the user experience is when the end of the list is reached, and the data of the next page is still being fetched (let's say, the network is weak). While the app user waits for the data, it is good to display a loading indicator.

The `useInfiniteQuery` hook provides a state called `isFetchingNextPage`. Its value will be true when the data from the next page is fetched using `fetchNextPage`.

Modify the `HomeScreen` component as shown below. The loading spinner renders when the value of `isFetchingNextPage` is true. The `ListFooterComponent` on the FlatList component is used to display the loading indicator at the end of the list items.

```js
export const HomeScreen = () => {
  const { isLoading, data, hasNextPage, fetchNextPage, isFetchingNextPage } =
    useInfiniteQuery('games', gamesApi.fetchAllGames, {
      getNextPageParam: lastPage => {
        if (lastPage.next !== null) {
          return lastPage.next;
        }

        return lastPage;
      }
    });

  const loadMore = () => {
    if (hasNextPage) {
      fetchNextPage();
    }
  };

  const renderSpinner = () => {
    return <Spinner color="emerald.500" size="lg" />;
  };

  const gameItemExtractorKey = (item, index) => {
    return index.toString();
  };

  const renderData = item => {
    return (
      <Box px={2} mb={8}>
        <Text fontSize="20">{item.item.name}</Text>
      </Box>
    );
  };

  return isLoading ? (
    <Box
      flex={1}
      backgroundColor="white"
      alignItems="center"
      justifyContent="center"
    >
      <Spinner color="emerald.500" size="lg" />
    </Box>
  ) : (
    <Box flex={1} safeAreaTop backgroundColor="white">
      <Box height={16} justifyContent={'center'} px={2}>
        <Text fontSize={28} fontWeight={'600'} color={'emerald.500'}>
          Explore Games
        </Text>
      </Box>
      <Divider />
      <Box px={2}>
        <FlatList
          data={data.pages.map(page => page.results).flat()}
          keyExtractor={gameItemExtractorKey}
          renderItem={renderData}
          onEndReached={loadMore}
          onEndReachedThreshold={0.3}
          ListFooterComponent={isFetchingNextPage ? renderSpinner : null}
        />
      </Box>
    </Box>
  );
};
```

Here is the output:

![ss4](https://i.imgur.com/uLmbrjC.gif)

## Wrapping up

In this tutorial, you've successfully implemented infinite scroll using `useInfiniteQuery` from React Query. Using this library for fetching and managing data inside a React Native app takes away a lot of pain points. Make sure to check out the [Infinite Queries](https://react-query.tanstack.com/guides/infinite-queries) documentation here.

You can also check the [complete source code for this example is at this GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/main/infinite-scroll-with-react-query).

---

## Inline footnotes in Markdown
Slug: inline-footnotes-in-markdown

Using footnotes helps keep your main content clean and focused. A footnote can provide additional context without interrupting the reading flow for your audience and is excellent for properly citing sources, references, or side notes.

You can use inline footnotes by writing your text subject followed by a marker like `some-text[^1`] (where `1` is an arbitrary value). Then, you can reference the footnote at the bottom of your content with `[^1]: This is a footnote.`.

The example in the screenshot below shows a simple implementation of footnotes on this blog:

Notice the return symbol (â†©ï¸Ž), which allows a reader to jump back to the reference point in your post.

<img src="/images/inline-footnotes.png" width="480" />

Footnotes are common in academic writing and on many blogs where additional content enhances credibility. I have personally not used them on this blog, but I think I have a use case in mind.

---

## How to install Node.js using NVM on macOS M1
Slug: install-nodejs-using-nvm-on-macos-m1

Node.js can be installed in different ways. I recently started working on an organization repository that requires using different Node.js versions. Using [Node Version Manager (NVM)](https://github.com/nvm-sh/nvm) it is possible to switch between different Node.js versions on the fly. It also allows testing code with older Node.js versions.

NVM is a shell script used for installing and managing Node.js on a Unix based system. It allows switching between different versions of Node.js via the command line quickly. It also works with any [POSIX](https://en.wikipedia.org/wiki/POSIX) shell such as `zsh`.

## Prerequisites

Make sure you have installed the following before proceeding:

- [Command line tools](https://amanhimself.dev/blog/setup-macbook-m1/#xcode)
- [Homebrew](https://amanhimself.dev/blog/setup-macbook-m1/#homebrew)
- [Git](https://amanhimself.dev/blog/setup-macbook-m1/#git)
- [zsh](https://amanhimself.dev/blog/setup-macbook-m1/#zsh-and-oh-my-zsh)

## Remove existing installed Node.js version

> This step is optional. If you haven't installed Node.js previously using Homebrew, skip this.

If you have an existing Node.js version installed, please remove it before installing NVM. For example, my machine already has a node version installed via Homebrew.

Open the terminal window and run:

```shell
brew uninstall --ignore-dependencies node
brew uninstall --force node
```

## Install NVM via Homebrew

Install NVM using Homebrew:

```shell
brew install nvm
```

After the above command runs, create a directory for NVM at the home working directory:

```shell
mkdir ~/.nvm
```

When using the `zsh` shell, add the following config inside `~/.zshrc`:

```shell
export NVM_DIR="$HOME/.nvm"
[ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
[ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion
```

Now, either restart the terminal app or execute `source ~/.zshrc` to re-load the latest config for the `zsh` shell from the file.

Run the command `nvm --version` to verify. For example, if the config has loaded, this command would display a version.

## Install Node.js via NVM

Node.js is available in two different versions:

- Long Term Support (LTS)
- Current with latest features

Although I used to love using the Current version with the latest features on my personal machine, I use the LTS version for work. At the time of writing this post, the current LTS version is `16`.

Running the command `nvm install node` would install the current version with the latest features.

To install the current LTS Node.js version, execute:

```shell
nvm install --lts
```

Then, verify the version by running:

```shell
node --version

# Output: v16.13.2
```

## Multiple Node.js versions

To install different versions of Node.js, you can run:

```shell
# nvm install Version-Number
nvm install 14
```

## Use a specific Node.js version

After installing multiple versions, use the command below to set a specific version as the default version and use it:

```shell
nvm use 16
```

## Uninstall a Node.js version

Before uninstalling a Node.js version, make sure it is not the active version or currently used version on the machine. Switch to a different version and then run the command:

```shell
nvm uninstall 14
```

## List all installed Node.js versions

To check for all the installed Node.js versions via nvm, run:

```shell
nvm ls
```

## Set the latest Node.js version as the default

To always set the latest Node.js version as the default in the shell, run:

```shell
nvm alias default node
```

## Update to the latest version

To update to the latest version `nvm` provides the following command:

```shell
nvm install --lts
```

After installing the latest version, to re-install any global packages installed with the previous version, run:

```shell
nvm install node --reinstall-packages-from=node
```

Then, [uninstall the previous Node.js version](#uninstall-a-nodejs-version).

---

## Integrating Firebase with React Native
Slug: integrating-firebase-with-react-native

**This post has been updated in 2021. Please visit [this URL](https://jscrambler.com/blog/integrating-firebase-with-react-native) to view the new post.**

Firebase is a Backend as a Service (_BaaS_) that provides an advantage to mobile developers who use React Native for developing mobile applications. As a React Native developer, by using Firebase you can start building an MVP (minimum viable product), keeping the costs low and prototyping the application pretty fast. In this tutorial, we will be learning how to get started by integrating Firebase with a React Native application. We will also create a small application from scratch with the help of Firebase & React Native to see how they work together.

## Getting Started

[Firebase](https://console.firebase.google.com/?pli=1) is a platform that got acquired by Google and has a healthy and active community. Most users in this community are web and mobile developers as Firebase can help with mobile analytics, push notification, crash reporting and out of the box provides email as well as social authentication.

To get started, you will need a target mobile OS, whether you choose to go with iOS or Android or both. Please refer to [React Native official documentation](https://facebook.github.io/react-native/docs/getting-started) if you are setting up React Native development environment for the first time. You will need sdk tools and Android Studio especially to setup a developer environment for Android. For iOS, you only need Xcode installed on your macOS. You will also need to have installed:

- [Nodejs](http://nodejs.org) (`>= 8.x.x`) and npm/yarn installed
- [react-native-cli](https://www.npmjs.com/package/react-native-cli) (`>= 2.0.1`)

React Native is distributed as two npm packages, `react-native-cli`, and `react-native`. We are going to use the `react-native-cli` to generate an app. Begin by installing `react-native-cli`:

```shell
npm install -s react-native-cli
```

Now, letâ€™s create a new React Native project called â€œrnFirebaseDemoâ€:

```shell
react-native init rnFirebaseDemo
```

When the above command is done running, traverse into the project directory using `cd rnFirebaseDemo`. Now, letâ€™s check if everything is working correctly and our React Native application has been properly initialized by running one of the following commands:

```shell
# on macOS
react-native run-ios

# For Windows/Unix users
react-native run-android
```

This command will run the default screen as shown below in an iOS simulator or Android emulator but it will take a few moments since we are running it for the first time.

![ss1](https://i.imgur.com/mBobZpT.png)

## Adding Firebase

To add Firebase to our existing React Native application, we need to install the dependency.

```shell
yarn add firebase
```

When we open the project in a code editor, its structure looks like this:

![ss2](https://i.imgur.com/TdKzipp.png)

We need to make some modifications before we can really start building our app. Create an `src` directory inside the root folder. This is where our app components and screens will live. Further, within the `src` directory, we will create two folders: `screens` and `components`.

![ss3](https://i.imgur.com/N9m3Y83.png)

The `screen` directory will contain all the UI related components that we need to display to the end user, whereas the `components` folder will contain any other component that will be used or re-used to display the user interface.

Let us create our first screen, Home screen, inside `screens/` with a new file `Home.js`.

```js
import React, { Component } from 'react';
import { View, Text } from 'react-native';

export default class Home extends Component {
  render() {
    return (
      <View>
        <Text>Home Screen</Text>
      </View>
    );
  }
}
```

Our next screen is going to be `Add Item`. Create a new file called `AddItem.js`.

```js
import React, { Component } from 'react';
import { View, Text } from 'react-native';

export default class AddItem extends Component {
  render() {
    return (
      <View>
        <Text>Add Item</Text>
      </View>
    );
  }
}
```

Our last screen is going to be a List of items that we need to display. In the same directory, create a new file called `List.js`.

```js
import React, { Component } from 'react';
import { View, Text } from 'react-native';

export default class List extends Component {
  render() {
    return (
      <View>
        <Text>List</Text>
      </View>
    );
  }
}
```

## Adding react-navigation

To navigate between different screens, we need to add the `react-navigation` library. We are going to use the latest version that is `3.0.0`.

```shell
yarn add react-navigation
```

Next, we will install `react-native-gesture-handler`. If youâ€™re using Expo, you donâ€™t need to do anything here.

```shell
yarn add react-native-gesture-handler
```

The next step is clearly to run the command below and link the libraries we just installed:

```shell
react-native link
```

After adding this package, let us run the build process again:

```shell
# on macOS
react-native run-ios

# For Windows/Unix users
react-native run-android
```

Now, to see it in action, let us add the Home component as our first screen. Add the following code in `App.js`.

```js
import React, { Component } from 'react';
import { createStackNavigator, createAppContainer } from 'react-navigation';
import Home from './src/screens/Home';

// we will use these two screens later in our AppNavigator
import AddItem from './src/screens/AddItem';
import List from './src/screens/List';

const AppNavigator = createStackNavigator({
  Home: {
    screen: Home
  }
});

const AppContainer = createAppContainer(AppNavigator);

export default class App extends Component {
  render() {
    return <AppContainer />;
  }
}
```

At this stage, if we go to the simulator, we will see the following result:

![ss4](https://i.imgur.com/IMXVJ9n.png)

The Home Screen is showing up. We will add two other screens as routes to `AppNavigator` in order to navigate to them through the Home Screen.

```js
const AppNavigator = createStackNavigator(
  {
    Home,
    AddItem,
    List
  },
  {
    initialRouteName: 'Home'
  }
);
```

Now, our stack has three routes: a Home route, an AddItem route, and a ListItem route. The Home route corresponds to the `Home` screen component, the AddItem corresponds to the `AddItem` screen and the ListItem route corresponds to the `ListItem` component. The initial route for the stack is the `Home` route, this is defined if we have multiple screens and need to describe a starting point.

## Navigating between the screens

Previously, we defined a stack navigator with three routes but we didn't hook them up in order to navigate between them. Well, this is an easy task too. The `react-navigation` library provides us with a way to manage navigation from one screen to another and back. To make this work, we will modify the `Home.js`.

```js
import React, { Component } from 'react';
import { Button, View, Text } from 'react-native';

export default class Home extends Component {
  render() {
    return (
      <View>
        <Text>Home Screen</Text>
        <Button
          title="Add an Item"
          onPress={() => this.props.navigation.navigate('AddItem')}
        />
        <Button
          title="List of Items"
          color="green"
          onPress={() => this.props.navigation.navigate('List')}
        />
      </View>
    );
  }
}
```

In the code above, we are adding a `Button` component from the `react-native` API. `react-navigation` passes a navigation prop in the form of `this.props.navigation` to every screen in the stack navigator. We have to use the same screen name on the `onPress` function to navigate as we defined in `App.js` under `AppNavigator`.

You can also customize the back button manually with your own styling on both screens `AddItem` and `List` but, for our demonstration, we are going to use the default.

![ss5](https://i.imgur.com/oB1OSRS.gif)

## Creating a Database with Firebase

Go to the [Firebase](https://firebase.google.com/) Console, log in from your Google Account and a create a new project.

![ss6](https://i.imgur.com/kB6UcyI.png)

We will then add the database configuration in a new file inside `src/config.js`.

```js
import Firebase from 'firebase';
let config = {
  apiKey: 'AIzaXXXXXXXXXXXXXXXXXXXXXXX',
  authDomain: 'rnfirebXXX-XXXX.firebaseapp.com',
  databaseURL: 'rnfirebXXX-XXXX.firebaseapp.com',
  projectId: 'rnfirebase-XXXX',
  storageBucket: 'rnfirebase-XXXX.appspot.com',
  messagingSenderId: 'XXXXXXX'
};
let app = Firebase.initializeApp(config);
export const db = app.database();
```

The config object is where you fill in the details you get after creating a new project in Firebase and going to the section **Add Firebase to your web app**. Also in the Firebase console, from left sidebar, click on **Database** and then choose the first option: ((Realtime Database)). Then, go to â€œrulesâ€ and paste the following:

```json
{ "rules": { ".read": true, ".write": true } }
```

![ss7](https://i.imgur.com/JyNyFqS.png)

## Adding Data from the App to Firebase

In this section, we will edit `AddItem.js` which represents an input field and a button. The user can add a item to the list and it will get saved to Firebase data.

```js
import React, { Component } from 'react';
import {
  View,
  Text,
  TouchableHighlight,
  StyleSheet,
  TextInput,
  AlertIOS
} from 'react-native';

import { db } from '../config';

let addItem = item => {
  db.ref('/items').push({
    name: item
  });
};

export default class AddItem extends Component {
  state = {
    name: ''
  };

  handleChange = e => {
    this.setState({
      name: e.nativeEvent.text
    });
  };
  handleSubmit = () => {
    addItem(this.state.name);
    AlertIOS.alert('Item saved successfully');
  };

  render() {
    return (
      <View style={styles.main}>
        <Text style={styles.title}>Add Item</Text>
        <TextInput style={styles.itemInput} onChange={this.handleChange} />
        <TouchableHighlight
          style={styles.button}
          underlayColor="white"
          onPress={this.handleSubmit}
        >
          <Text style={styles.buttonText}>Add</Text>
        </TouchableHighlight>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  main: {
    flex: 1,
    padding: 30,
    flexDirection: 'column',
    justifyContent: 'center',
    backgroundColor: '#6565fc'
  },
  title: {
    marginBottom: 20,
    fontSize: 25,
    textAlign: 'center'
  },
  itemInput: {
    height: 50,
    padding: 4,
    marginRight: 5,
    fontSize: 23,
    borderWidth: 1,
    borderColor: 'white',
    borderRadius: 8,
    color: 'white'
  },
  buttonText: {
    fontSize: 18,
    color: '#111',
    alignSelf: 'center'
  },
  button: {
    height: 45,
    flexDirection: 'row',
    backgroundColor: 'white',
    borderColor: 'white',
    borderWidth: 1,
    borderRadius: 8,
    marginBottom: 10,
    marginTop: 10,
    alignSelf: 'stretch',
    justifyContent: 'center'
  }
});
```

In the code above, we are adding a Firebase database instance from `config.js` and `db` and then pushing any item that the user adds through `addItem` and `handleSubmit()`. You will get an alert message when you press the button **Add** to add the item from the input value as shown below.

![ss8](https://imgur.com/qi5UQec.gif)

To verify that the data is there in the database, go to your Firebase console.

[ss9](https://i.imgur.com/KZDYCIo.png)

## Fetching Items from the Database

To fetch data from the Firebase database, we are going to use the same reference to `db` in `List.js`.

```js
import React, { Component } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import ItemComponent from '../components/ItemComponent';

import { db } from '../config';

let itemsRef = db.ref('/items');

export default class List extends Component {
  state = {
    items: []
  };

  componentDidMount() {
    itemsRef.on('value', snapshot => {
      let data = snapshot.val();
      let items = Object.values(data);
      this.setState({ items });
    });
  }

  render() {
    return (
      <View style={styles.container}>
        {this.state.items.length > 0 ? (
          <ItemComponent items={this.state.items} />
        ) : (
          <Text>No items</Text>
        )}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    backgroundColor: '#ebebeb'
  }
});
```

For the `ItemComponent`, we create a new file inside `components/ItemComponent.js`. This is a non-screen component. Only the `List` will use it to `map` and display each item.

```js
import React, { Component } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import PropTypes from 'prop-types';

export default class ItemComponent extends Component {
  static propTypes = {
    items: PropTypes.array.isRequired
  };

  render() {
    return (
      <View style={styles.itemsList}>
        {this.props.items.map((item, index) => {
          return (
            <View key={index}>
              <Text style={styles.itemtext}>{item.name}</Text>
            </View>
          );
        })}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  itemsList: {
    flex: 1,
    flexDirection: 'column',
    justifyContent: 'space-around'
  },
  itemtext: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center'
  }
});
```

This step concludes the integration of a Firebase database with our React Native app. You can now add the new data items and fetch them from the database as shown below.

![ss9](https://i.imgur.com/0Nr4d4J.gif)

## Conclusion

In this tutorial, weâ€™ve shown you how to integrate Firebase with a React Native application. You donâ€™t a complete server that creates an API and further uses a database to prototype or build an MVP of your application.

You can find the complete code inside [this Github repo](https://github.com/amandeepmittal/rnFirebaseDemo).

[Originally published at Jscrambler](https://jscrambler.com/blog/integrating-firebase-with-react-native)

---

## Introduction to Hybrid Mobile Apps
Slug: introduction-to-hybrid-mobile-apps

### What is a Hybrid MobileÂ App?

> _Hybrid application is a type of mobile application that uses browser window to display its interface._

A hybrid mobile application is built with HTML, CSS and JavaScript and is contained in a native wrapper so that it can be installed on a mobile device. This can be done without having to learn the native programming languages (e.g. Swift, Java).

It does mean that there is one codebase for all different platforms such iOS, and android.

This comes under the classification of types of mobile applications that consists of three types:

- Native: developed using platform specific programming language such as Objective C or Java
- Mobile Websites: developed using web technologies such as HTML, CSS & JavaScript and are accessible only through mobile web browser. They are actually web applications.
- Hybrid: cross-platform and have access to native APIs (mostly through plugins)

For example, an architecture of Hybrid Mobile application developed using Ionic Framework consists of two concepts that one must be familiar with ASAP: WebView & Apache Cordova.

### What is aÂ WebView?

Think it of as a browser that runs inside the scope of a mobile application using a framework such as Ionic that mimics the native UI. This browser implements code written in HTML, CSS and JavaScript.

The application on a specific mobile operating system runs via tool like [Cordova](https://cordova.apache.org/). It provides APIs written in JavaScript to interact with Native features of mobile device such as access to camera or a microphone.

WebView communicates with Cordovaâ€™s APIs which then further communicates with mobile devices.

<img src='https://cdn-images-1.medium.com/max/800/1*hdwWntqxD-qOL8vf87DmAQ.png' />

WebViews are so common these days that you can build desktop applications using [Electron](http://electron.atom.io/).

### Why To GoÂ Hybrid?

Before answering this question mysellf, I think you should read [_Myths around Hybrid Mobile Applications?_](https://devdactic.com/myth-hybrid-development/) written by Simon of [Devdatic.com](https://devdactic.com/).

This will answer the question above and along with it, my POV is that if you already know web development and or have experience with frameworks like Angular, or React, opting for Hybrid mobile development is a good way to expand your skills and take leverage of your current coding skills. After all, I love creating stuff and for me this is a great start.

### Alternatives

There are few alternates/frameworks available in the world of Hybrid Development. One of them is [Ionic Framework](https://ionicframework.com/) and with its next release earlier this year, it provides better performance for the hybrid apps. It also has a huge and helpful community to help you out whenever you get stuck.

Other options which I havenâ€™t tried yet but think are worth mentioning include compile-to-native frameworks like [React Native](https://facebook.github.io/react-native/) and [NativeScript](https://www.nativescript.org/).

[Originally Published at Hackernoon.com](https://medium.com/hackernoon/introduction-to-hybrid-mobile-apps-c97720b30557)

---

## Ionic 2/3 CLI Reference
Slug: ionic-2-3-cli-reference

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/ionic-2-3-cli-reference-13f9fae3f964)

> _The Ionic CLI is your go-to tool for developing Ionic apps._

Ionic CLI is a great tool when it comes to avoid writing a lot of boilerplate code. It generates pages, services, can run or emulate your Ionic application with and generate needed resources for the mobile application such as splash screen.

This is a quick reference into Ionic CLI.

### Installing the CLIÂ Tool

You can install it with npm:

```shell
$ npm install -g ionic
```

To check if it has installed correctly, in your terminal window, type:

```shell
$ ionic info

global packages:

    @ionic/cli-utils : 1.3.0
    Ionic CLI        : 3.3.0

System:

    Node       : v6.11.0
    OS         : macOS Sierra
    Xcode      : Xcode 8.1 Build version 8B62
    ios-deploy : not installed
    ios-sim    : not installed
```

### Starting a newÂ App

To start with a new mobile application, Ionic framework provides different set of ready-to-use templates:

```shell
$ ionic start --list

tabs ............... ionic-angular A starting project with a simple tabbed interface
blank .............. ionic-angular A blank starter project
sidemenu ........... ionic-angular A starting project with
                    a side menu with navigation in the content area
super .............. ionic-angular A starting project
                    complete with pre-built pages,
                    providers and best practices
                    for Ionic development.
conference ......... ionic-angular A project that
                    demonstrates a realworld application
tutorial ........... ionic-angular A tutorial based
                      project that goes along with the
                      Ionic documentation
aws ................ ionic-angular AWS Mobile Hub Starter
```

For creating a new project:

```shell
$ ionic start my-new-app blank
```

_With update to Ionic 3, no more adding tags such as_ `_--v2_` _after the template name in the above command. By default, Ionic app generated will be of version 2/3. To generate an Ionic app of version 1 (with good ol' Angularjs):_

```shell
$ ionic start my-new-app blank --v1
```

### Serving

Once you `cd` into your projectâ€™s directory, serve your app on your local machine with `serve`:

```shell
$ ionic serve
```

To serve on a different port:

```shell
$ ionic serve --port 9100
```

Use `â€“-lab` tag to see your app side by side on multiple platforms (such as iOS, Android and Windows Mobile):

```shell
$ ionic serve --lab
```

To serve without live reload:

```shell
$ ionic serve --nolivereload
```

### Generating Providers andÂ Pages

To generate a new page:

```shell
$ ionic  g page Page2
```

To generate a provider/service:

```shell
$ ionic g provider DataService
```

Know them all- List the available generators:

```shell
$ ionic g --list
```

### Generating Resources

To generate the app icon and splash screen with resources:

```shell
$ ionic cordova resources
```

To generate just the app icon:

```shell
$ ionic cordova resources --icon
```

Or, just the splash screen:

```shell
$ ionic cordova resources --splash
```

Now, generate resources for a specific platform:

```shell
$ ionic cordova resources android
```

## Add Ionic Plugins

```shell
$ ionic cordova plugin [action] [plugin]

# Example
$ ionic cordova plugin add cordova-plugin-x-socialsharing
```

### Adding Platform

To add a target mobile platform for the app to use:

```shell
$ ionic cordova add android
```

### App on anÂ Emulator

To start an emulator:

```shell
$ ionic cordova emulate ios
```

Emulate with livereload:

```shell
$ ionic cordova emulate ios --livereload
```

### Running Ionic App on a Connected Device

Letâ€™s say, I have an iOS device connected, so to run the app on that device:

```shell
$ ionic cordova run ios --device
```

Production check:

```shell
$ ionic cordova run android --prod --release
```

### Git Initialisation

Another advantage of using Ionic CLI tool is that it initialises a git repository when creating an Ionic project using the `ionic start` command from the terminal with an `initial commit` already. You can verify that by running:

```shell
$ git log --oneline --graph --decorate --color

# Output
* 029f86e (HEAD -> master) Initial commit
```

---

## JavaScript Code Conventions
Slug: javascript-code-conventions

This article is about coding conventions. Everywhere I read articles about complex things in programming, links to other good/better/awesome articles, but nobody seems to talk about the basic things in programming.

Like the coding conventions used by programmers in their work, I am a JavaScript enthusiast, and never once did I came across a good article on basic conventions and guidelines to write code that is helpful for me and others to read my code.

Thus, this is my attempt, and this article contains some general coding conventions as well as some specific guidelines only applicable to JavaScript.

## So what are Code Conventions?

These are the guidelines about programming practices, file and directory structure, and commenting.

Now you may be wondering why do you need guidelines for files and directory structure? Well, to keep it simple, and when working in a team, you have to follow some rules for a specific file structure for that application. Otherwise, it will be a huge mess.

## Style Guidelines

They are the type of Code Convention that includes the layout of the code within a file.

## Indentation

The first thing to do when writing code in a file is how to handle indentation.

```js
if (num === 1) {
  for (i = 0; i < array.length; i++) {
    if (array[i] !== 0) {
      //some code
    } else if (array[i] === array.length) {
      // code
    }
  }
}
```

Observe in the previous example there is a flow. This is what indentation is all about. It makes the program readable. The else if statement is used for the if statement inside the for loop and not the outside if statement.

Two ways to achieve indentation:

- using tabs
- using spaces

**Using Tabs**
For each indentation level, use one tab character. Thus, the second level will have two tab characters and so on.

**Using Space**

Each indentation level is made up of multiple spaces. The levels contain spaces in pairs, like two spaces for the first level, four spaces for the second level, etc.

The advantage of using spaces over tabs is that all text editors are configured according to spaces and are treated exactly the same. The disadvantage here is to put spaces in each line. Thankfully, we are in an era where text editors are smart enough and they automatically do indentation.

## Avoid ASI Automatic Semicolon Insertion

Avoiding semicolons is possible, and if JavaScript has a mechanism called ASI, why the hell care about semicolons? If you are comfortable with ASI carry on. But the rules of ASI are complex, and using your time in writing code rather than worrying about ASI is better.

It causes errors, and sometimes things wonâ€™t work because the JavaScript parser may read things differently from the way they are written.

Also, semicolons improve the readability of the code for other programmers too. If you are working collaboratively, itâ€™s a great help.

## Avoid Horizontal Scrolling

The recommended length of code in a line is 80 characters. Even though the text editors have become smart, the length of 80 characters has is still used as a convention.

## Blank Lines are not harmful

Using blank lines to separate unrelated lines of code. It improves readability.

Without blank lines:

```js
if (num === 1) {
  for (i = 0; i < array.length; i++) {
    if (array[i] !== 0) {
      //some code
    } else if (array[i] === array.length) {
      // code
    }
  }
}
```

With blank lines:

```js
if (num === 1) {
  for (i = 0; i < array.length; i++) {
    if (array[i] !== 0) {
      //some code
    } else if (array[i] === array.length) {
      // code
    }
  }
}
```

## Naming Convention

ECMAScript uses camelCase convention. You should too when naming Variables and Functions. And try to use meaningful names for those variables and functions and keep them short.

## Function Naming

In JS, all we do is make functions in the form of callbacks and events. Author of Maintainable Javascript Nicholas Zakas introduces some common conventions for functions. I find this helpful:

- can Function that returns a boolean
- has Function that returns a boolean
- is a Function that returns a boolean
- get Function that returns a non boolean
- set Function that is used to save a value

## Constructors

Constructors are functions too and are used to create objects via a new operator. But avoid using camelCase and use PascalCase instead.

It is helpful since JavaScript uses the same for naming pre-defined constructors.

## Comments

For single-line comments, I observed this when using JSLint, after // use a space between them(the two slashes) and the comment.

```js
// Single-Line Comment
```

> Following all conventions can be hard and a stressful matter at times when you are focusing on the logic part of the code. Thus, there is an alternative that works for me most of the time, is the [Beautify](https://atom.io/packages/atom-beautify) package that I use in the text editor [Atom](http://www.atom.io/) and I am sure it is available for the majority of other text editors.

---

## Keep homebrew up to date
Slug: keep-homebrew-up-to-date

I've been using [homebrew](https://brew.sh/) for as long as I can remember using macOS. I recently learned about cleaning up old and outdated files using the `brew cleanup` command. I also run it sequentially with `update` and `upgrade` commands:

```shell
brew update && brew upgrade && brew cleanup
```

Sometimes, I periodically upgrade packages that are installed using brew. Thus, I thought, why not add an alias such as below in my `.zshrc` file:

```shell
alias hbc="brew update && brew upgrade && brew cleanup"
```

This helps me to update and upgrade outdated packages, and clean up old files. Now, whenever I have to run all three tasks, I simply run `hbc` in the terminal.

Upgrading outdated packages periodically saves me from a situation when installing a new package, homebrew will upgrade all outdated packages first.

---

## Large header title in Expo Router
Slug: large-header-title-in-expo-router

Creating native iOS experiences in React Native is about using platform conventions. One of these patterns that Apple offers is the large header title that smoothly collapses as you scroll through a list, something you must have seen in Apple's apps like Settings or Messages.

In this post, let's dive into how to use the large header title when using Expo Router library for iOS.

## Understanding large header titles

Before jumping into code, it is worth understanding what makes the large headers special. In SwiftUI, `navigationBarTitleDisplayMode` property is used to control the display mode of a title in the navigation bar. The concept starts when as an app user, you land on a screen and the large title gives you immediate context about the screen you are on. This screen also contains a scrollable list of items. As you scroll through the list, the title smoothly collapses to a smaller size (regular title), providing an efficient use of space when you're engaged with the content of the screen.

To see it live, open the **Settings** app on your iOS device and scroll through the list of settings options. As you start scrolling through the list of options, you will see that the large title smoothly transitions into a compact header that stays visible at the top of your screen. There is also a blur effect that automatically kicks in behind the regular title on iOS 26.

Here's an example of a large header title enabled for a screen on iOS 26 Simulator:

<img src="/images/large-header-titles/ss17.png" width="260" />

For list views, these large header titles can collapse into a regular headers when you scroll through the list:

<img src="/images/large-header-titles/ss18.gif" width="260" />

## Prerequisites

- An iOS Simulator/device that can run iOS 26
- An iOS Simulator/device that can run iOS 18
- Android Emulator/device (optional)

## Setting up the navigation

Without going into too much detail, let's go through the overview of the navigation structure of the example app you will be using in this post. Establishing the understanding is important to understand the navigation flow of the example app.

```text
example-app/
â”œâ”€â”€ app/
â”‚ â”œâ”€â”€ \_layout.tsx (Root Stack)
â”‚ â””â”€â”€ (tabs)/
â”‚ â”œâ”€â”€ \_layout.tsx (Native Tabs)
â”‚ â”œâ”€â”€ (home)/
â”‚ â”‚ â”œâ”€â”€ \_layout.tsx (Home Stack)
â”‚ â”‚ â””â”€â”€ index.tsx (Home Screen)
â”‚ â”œâ”€â”€ favorites/
â”‚ â”‚ â”œâ”€â”€ \_layout.tsx (Favorites Stack)
â”‚ â”‚ â””â”€â”€ index.tsx (Favorites Screen)
â”‚ â”œâ”€â”€ search/
â”‚ â”‚ â”œâ”€â”€ \_layout.tsx (Search Stack)
â”‚ â”‚ â””â”€â”€ index.tsx (Search Screen)
â”‚ â””â”€â”€ settings/
â”‚ â”œâ”€â”€ \_layout.tsx (Settings Stack)
â”‚ â””â”€â”€ index.tsx (Settings Screen)
â””â”€â”€ package.json
```

Nothing fancy, just a standard bottom tab-based app where each tab has its own stack navigator. The whole example follows the recommended navigation pattern from Expo Router's file-based routing system and there is nothing complex about it.

## Basic implementation

The focus is on the `HomeLayout` which lives inside the `app/(tabs)(home)/\_layout.tsx` file. The layout is responsible for displaying a title on the screen:

```tsx
import { Stack } from 'expo-router';

export default function HomeLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Home'
        }}
      />
    </Stack>
  );
}
```

The `index.tsx` file in the same directory is responsible for displaying a list of items:

```tsx
import { ScrollView, Text } from 'react-native';

export default function Index() {
  return (
    <ScrollView contentContainerStyle={{ padding: 16 }}>
      {Array.from({ length: 100 }).map((_, index) => (
        <Text key={index} style={{ paddingVertical: 4 }}>
          Item {index}
        </Text>
      ))}
    </ScrollView>
  );
}
```

## Enabling large header titles for home screen

To enable large header title for the home screen, you need to set the `headerLargeTitle` prop to `true` on the `Stack.Screen` component in `app/(home)/_layout.tsx` file:

```tsx
import { Stack } from 'expo-router';

export default function HomeLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Home',
          headerLargeTitle: true,
          headerTransparent: true
        }}
      />
    </Stack>
  );
}
```

In the above code example, the `headerTransparent` prop is also set to `true` to ensure that the header stays transparent for blur effect to work.

The next step is to add set `contentInsetAdjustmentBehavior` to `automatic` on the `ScrollView` component in `index.tsx` file:

```tsx
import { ScrollView, Text } from 'react-native';

export default function Index() {
  return (
    <ScrollView
      contentContainerStyle={{ padding: 16 }}
      contentInsetAdjustmentBehavior="automatic"
    >
      {Array.from({ length: 100 }).map((_, index) => (
        <Text key={index} style={{ paddingVertical: 4 }}>
          Item {index}
        </Text>
      ))}
    </ScrollView>
  );
}
```

The `contentInsetAdjustmentBehavior` prop is essential. It tells the ScrollView to automatically adjust its content insets to account for the navigation bar. If you are using a different list component, such as `FlatList`, you will use this prop on that component instead.

Result of this configuration so far is the expected result. On an iOS Simulator running 26 version, you will see the large header title enabled for the home screen and smoothly collapsing into a regular title:

<img src="/images/large-header-titles/ss18.gif" width="260" />

## The iOS 18 problem

Here's where things get interesting. If you test this on an iOS 18, you will notice that a blur effect is not applied behind the regular title. That is because pre-iOS 26 versions need an explicit blur configuration to work. You can achieve this by setting the `headerBlurEffect` prop to `regular`:

```tsx
import { Stack } from 'expo-router';

export default function HomeLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Home',
          headerLargeTitle: true,
          headerTransparent: true,
          headerBlurEffect: 'regular'
        }}
      />
    </Stack>
  );
}
```

On running the app on an iOS 18, you will see the blur effect applied behind the regular title:

<img src="/images/large-header-titles/ss19.gif" width="260" />

> Note: I've set the text string color to `red` in `/(home)/index.tsx` for an easier demonstration of the blur effect in the header.

## iOS version specific implementation

After applying the `headerBlurEffect` prop on the home screen, when you go back to the iOS 26 Simulator, you will notice that the large header title is disappearing behind the blur effect explicitly applied. Not exactly the behavior you want.

<img src="/images/large-header-titles/ss20.png" width="260" />

Since iOS 26 can handle applying blur effect automatically, you can use the following approach:

- Detect the iOS version using `Platform.Version`
- Conditionally apply `headerBlurEffect` prop for iOS 18

Update the code in `/(home)/_layout.tsx` file to include the following:

```tsx
import { Stack } from 'expo-router';
import { Platform } from 'react-native';

function getIOSVersion(): number {
  if (Platform.OS !== 'ios') return 0;

  return parseInt(Platform.Version as string, 10);
}

function isIOS26OrLater(): boolean {
  return getIOSVersion() >= 26;
}

export default function HomeLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Home',
          headerLargeTitle: true,
          headerTransparent: true,
          headerBlurEffect: isIOS26OrLater() ? undefined : 'regular'
        }}
      />
    </Stack>
  );
}
```

This change will satisfy both iOS versions:

<img src="/images/large-header-titles/ss21.gif" width="360" />

## Don't forget Android

One last detail. These large header titles are an iOS pattern and `headerTransparent` prop makes the header really transparent on Android. To fix this, you need to conditionally set `headerTransparent` prop's value to `true` only for iOS, as I've shared in an [earlier post](/blog/blur-effect-in-header-with-expo-router/#applying-blur-effect-only-on-ios):

```tsx
export default function HomeLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Home',
          headerLargeTitle: true,
          headerTransparent: Platform.OS === 'ios',
          headerBlurEffect: isIOS26OrLater() ? undefined : 'regular'
        }}
      />
    </Stack>
  );
}
```

Result on Android:

<img src="/images/large-header-titles/ss22.png" width="260" />

## Wrapping up

The version check might feel like a hack, but it's actually respecting how the platform evolved. iOS 26 improved the API by making blur automatic. We're just adapting to that improvement while maintaining backward compatibility.

---

## My 2025 Macbook setup
Slug: macbook-setup-2024

## A brief history of this guide

I documented my entire setup when I first switched to a MacBook Pro with Apple Silicon in 2020. Since then, I have upgraded to two different Macbooks and made some changes and adjustments to my personal setup by adopting new tools and leaving the old ones behind.

After recently revisiting [my old setup guide](/blog/setup-macbook-m1/) while reconfiguring a previous laptop, I noticed significant changes and decided an update was in order. This post reflects my current setup strategy.

## Initial setup

In this section, set up or configure the system and install essential tools required for development or configuring other tools.

### Updating macOS

After logging in, ensure the macOS is on the latest release version. If not, navigate to System Settings and update the macOS software.

### Disable annoying

Once the macOS version is up to date, I turn off some annoying settings. They might not annoy you, so feel free to skip this section.

- Go to System Settings > Battery > Options > Disable **Slightly dim the display on battery**.
- Go to Lock Screen and
  - Set Start the screen saver when in active for **1 hour**.
  - Set the turn display off on the battery when it is inactive for **3 hours**.
  - Set the display off on power adapter when inactive for **3 hours**.

> **Tip**: Verify that the user account on the MacBook has Admin privileges. To verify, go to Settings > Users & Groups and see if the user account has **Admin** role. All Mac users with an Admin role can use `sudo` to run command-line utilities with administrative (root) privileges.

### Secure data with FileVault

FileVault offers full-disk encryption to safeguard your data from unauthorized physical access. Activating it adds an essential layer of security. To enable it:

- Go to System Settings > Privacy & Security > Security > FileVault > Enable **Turn On**.

### Install Xcode and Command Line Tools

The following tools must be installed before proceeding with the rest of the guide:

- **Xcode**: Open App Store, install [Xcode](https://apps.apple.com/in/app/xcode/id497799835?mt=12). It's a large download and will take a while.
- **Terminal**: [iTerm2](https://iterm2.com/downloads.html) &mdash; primary terminal app

After the Xcode installation finishes, install **Command Line Tools**. Open the terminal app (iTerm) and run:

```shell
xcode-select --install && sudo xcodebuild -license
```

Let's verify that Command Line Tools have been installed properly and install iOS simulators (only required if you are into mobile app development):

- **Verify Command Line Tools** installation: Open Xcode from the menu bar, go to **Xcode > Preferences > Location**, and make sure that **Command Line Tools** point towards the current Xcode app.
- When opening Xcode for the first time, you'll be prompted to **select platforms for development**. Select iOS 18 and click **Download and install** to download iOS simulators. _This behavior changed with macOS Sonoma._

The initial setup is complete! You've now reached a point where you can proceed further.

## Other macOS system settings tweaks

Let's update some System Settings to navigate through the macOS with ease and familiar (habitual) settings.

> **Note**: These are some custom settings that I use on my MacBook. Feel free to skip this section or take time to apply yours.

Click **Apple Icon** from the menu bar and open **System Settings** to change or apply the settings below:

<!-- vale off -->

- **Siri:** Disable it (if not already)
- **Spotlight**:
  - Under Search results, disable search except for Applications, Calculator, Conversion, Definition, Developer, Events & Reminders, and System Settings
- **Desktop & Dock**:
  - Enable: Automatically hide and show the Dock
  - Disable: Show suggested and recent apps in Dock
  - Size: 30%
  - Magnification: 45%-50%
  - Click wallpaper to reveal Desktop: Only in Stage Manager
  - Widgets > Show Widgets: Disable
  - Mission Control: Disable Automatically rearrange Spaces
  - Hot Corners: Disable all
- **Trackpad**:
  - Point & Click
    - Enable secondary click with the bottom right corner
    - Enable Tap to click with one finger
    - Tracking speed: 90%
    - Click: Medium
    - Force click and haptic feedback: Disable
    - Look up & data detectors: Disable
  - Scroll & Zoom
    - Natural scrolling: Disable
  - More Gestures
    - Swipe between pages: Off
- **Keyboard**
  - Key repeat rate: Fast
  - Delay until repeat: Short
- **Finder settings**:
  - General > Enable Hard disks, disable CDs, DVDs, and iPods
    - Set New Finder windows show to Downloads
  - Tags: Switch off all
  - Advanced > Show filename extensions
  - Enable showing hidden files (hold Cmd + Shift dot(`.`) in a Finder window)
  - Enable: View > Show Path Bar, Show Status Bar
  - Enable: View > Show Tab Bar
- **Change Launchpad icon grid layout:**

```shell
# Specify the number of columns to be used.
defaults write com.apple.dock springboard-columns -int 12

# Specify the number of rows to be used.
defaults write com.apple.dock springboard-rows -int 10

# Restart the Dock to apply the changes.
killall Dock
```

### Modify other default re-writes

Preferences are stored in `~/Library/Preferences/`. The following are some of the default settings that I change:

```shell
# Disable .DS_Store files
defaults write com.apple.desktopservices DSDontWriteNetworkStores true

# Disable autocorrect
defaults write NSGlobalDomain NSAutomaticSpellingCorrectionEnabled -bool false

# Set key-repeat values
# Source: https://mac-key-repeat.zaymon.dev/
defaults write -g InitialKeyRepeat -int 12
defaults write -g KeyRepeat -int 2

# Show Library folder
chflags nohidden ~/Library

# Show hidden files
defaults write com.apple.finder AppleShowAllFiles YES
```

<!-- vale on -->

## Install Homebrew: macOS package manager

An important step in installing development-related tools is using Homebrew, a package manager I've trusted for nearly eight years.

To install Homebrew, open iTerm and run the command:

```shell
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

After installing, add the Homebrew to the `PATH`:

```shell
echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> /Users/amanhimself/.zshrc
eval "$(/opt/homebrew/bin/brew shellenv)"
```

> **Note**: If you don't have a `.zshrc`, create one at `/Users/user-name/`.

Then, add the following to `.zshrc`:

```shell
export PATH=/opt/homebrew/bin:$PATH
```

## Install apps from Homebrew bundle

I keep a list of must install apps in a Homebrew bundle inside my dotfiles repo. [Download the file](https://github.com/amandeepmittal/dotfiles/blob/master/brewfile.sh) from the repo and run the following command to install the apps:

```shell
brew bundle --file=brewfile.sh
```

> **Tip**: Git is already installed as part of Xcode Command Line Tools. However, I prefer to install the latest version from `brew` and avoid using the outdated version installed by Apple. After installing `git`, run `git --version` in a new terminal window. If you run this command in the same terminal window, it will show the Apple Git version.

### Git global configurations

After installing Git, apply the following global configurations:

- Set up the default branch for any new project to `main` (This was introduced in Git version `2.28`):

```shell
git config --global init.defaultBranch main
```

- Enable colors in command output:

```shell
git config --global color.uni auto
```

- Set up real name and email:

```shell
git config --global user.name "Real name"
git config --global user.email email@domain.com
```

To check or verify the global git config, run:

```shell
git config -l --global
```

## Install Oh My Zsh

To manage ZSH configuration and plugins, install [Oh My Zsh](https://ohmyz.sh/):

```shell
sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
```

After the installation, ensure the `.zshrc` file exports the path below at the top. To view, run `nano .zshrc` in the terminal.

```shell
# Path to your oh-my-zsh installation
export ZSH="$HOME/.oh-my-zsh"
```

The `$HOME` is `/Users/your-macOS-username`. To verify this, you can run:

```shell
echo $HOME
```

Install [`zsh-syntax-highlighting`](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md). It provides syntax highlighting for the ZSH shell. Run the following commands:

```shell
# Depending on the /plugins folder in your local setup
cd $HOME/.oh-my-zsh/plugins

# Then clone the git repository
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git

echo "source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" >> ${ZDOTDIR:-$HOME}/.zshrc
```

After installing the syntax highlight plugin on Iterm2, restart it or open a new instance for it to start recognizing the commands.

### Configure .zshrc

Copy and paste the `.zshrc` from [`dotfiles`](https://github.com/amandeepmittal/dotfiles) to `Users/user-name/.zshrc`. The file is organized in such a way that it should work without any additional configuration.

### Configure Starship prompt

I have been using Spaceship as my command line prompt for a long time, but it has been having some problems lately. I learned about Starship a few months ago and decided to try it out. It meets all my requirements, so I continued using it.

Since Starship is already installed in the brew bundle step, ensure the following is added to the end of `~/.zshrc`:

```shell
eval "$(starship init zsh)"
```

To use the pre-defined configuration, copy `starship.toml` from the [`dotfiles`](https://github.com/amandeepmittal/dotfiles) repo to `Users/user-name/config`. The file is organized in such a way that it should work without any additional configuration.

## Configure iTerm

- Open iTerm > Preferences > Profiles and Import `iterm-default.json` from [`dotfiles`](https://github.com/amandeepmittal/dotfiles) repo.
- Profiles > Colors > Import `Dracula.itermcolors` from `dotfiles` repo for Color Presets and apply it.
- Profiles > Terminal > Show mark indicators > **Disable**.
- Text > Font, select **JetBrainsMono Nerd Font**.
- Text > Non-ASCII Font, select **Hack Nerd Font Mono**.
- Appearance > General > Theme > set to **Minimal**.
- General > Selection > Clicking on command selects it to restrict Find and Filter > **Disable**.

## Setup a primary web browser

By now, you will need a primary web browser to set up and do some things further.

- Arc for personal and primary browser
  - Log in to the primary email
- Chrome for work
  - Log in to work email

### Shared extensions to install for both browsers

- Grammarly login and extension install
- Install [Detailed SEO extension](https://chrome.google.com/webstore/detail/detailed-seo-extension/pfjdepjjfjjahkjfpkcgfmfhmnakjfba?hl=en)
- Install [JSON Viewer](https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh)
- 1Password

### Shared configuration or steps required in both browsers

- Create a Google meet, and share and record the screen. This will get all required permissions to be working, and you don't have to restart the browser in an actual meeting.
- Log in to GitHub, Gmail, and Calendar.

## GitHub setup and configuration

To configure an account on GitHub.com and use an SSH key, follow the steps from GitHub documentation:

- [Generate a new SSH key](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key)

- [Add SSH key to ssh-agent](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#adding-your-ssh-key-to-the-ssh-agent)

- [Add new SSH key to GitHub account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account#adding-a-new-ssh-key-to-your-account)

> **Note:** After configuring SSH key with GitHub, download GitHub desktop app and clone `dotfiles` repository because you will need the configuration files from it in the next few steps.

## Install Node.js and npm

To install Node.js and npm, use Node Version Manager (NVM).Â [Read the entire blog post on how to install Node.js using NVM](https://amanhimself.dev/blog/install-nodejs-using-nvm-on-macos-m1/).

### After installing Node.js and npm

Node.js comes with the default package managerÂ **npm**. Set defaults for it:

```shell
npm config set init-author-name "your name"

npm config set init-author-url "example.com"

npm config set init-license MIT
```

Install the following global npm packages:

- [eas-cli](https://www.npmjs.com/package/eas-cli):Â For work and personal use.

```shell
npm i -g eas-cli
```

Also, I use the following command to update global packages:

```shell
npx npm-check -gu
```

## Install Java

To install Java17, run:

```shell
brew install --cask zulu@17
```

Add theÂ `JAVA_HOME`Â environment variable inÂ Â **~/.zshrc**:

```shell
export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
```

> **Note**: Already configured in `.zshrc` if copied dotfiles were setup correctly.

## VS Code

VS Code has supported ARM chips since March 13, 2021. Download the [installer for VS Code](https://code.visualstudio.com/download). I am using the following VS Code configuration:

```json
{
  "editor.tabSize": 2,
  "workbench.colorTheme": "Licht Theme",
  "workbench.editor.tabSizing": "shrink",
  "editor.cursorBlinking": "phase",
  "editor.fontLigatures": false,
  "editor.wordWrap": "on",
  "editor.cursorSmoothCaretAnimation": "on",
  "editor.tabCompletion": "on",
  "editor.formatOnPaste": true,
  "editor.formatOnSave": true,
  "git.openRepositoryInParentFolders": "always",
  "editor.semanticHighlighting.enabled": true,
  "editor.guides.bracketPairs": true,
  "editor.bracketPairColorization.enabled": true,
  "files.trimTrailingWhitespace": true,
  "readTime.enabled": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "cSpell.language": "en,en-US",
  "cSpell.enabledFileTypes": {
    "markdown": true,
    "mdx": true
  },
  "editor.inlineSuggest.enabled": true,
  "editor.minimap.enabled": true,
  "editor.fontSize": 13,
  "terminal.integrated.fontFamily": "JetBrainsMono Nerd Font",
  "workbench.iconTheme": "catppuccin-latte",
  "editor.fontFamily": "JetBrains Mono",
  "editor.fontWeight": "normal",
  // Markdown
  "[markdown]": {
    "editor.quickSuggestions": {
      "comments": "on",
      "strings": "on",
      "other": "on"
    }
  },
  // JSON
  "[json]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // JavaScript
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // JavaScript + React
  "[javascriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // TypeScript
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // TypeScript + React
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // JSON with Comments
  "[jsonc]": {
    "editor.defaultFormatter": "vscode.json-language-features"
  },
  // HTML
  "[html]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // ----------------------------------
  // ESLINT
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  // CODE::STATS EXTENSION
  "codestats.apikey": "your-api-key",
  "files.associations": {
    ".env*": "dotenv"
  },
  "vale.doNotShowWarningForFileToBeSavedBeforeLinting": true,
  "mdx.validate.validateFileLinks": "ignore",
  "workbench.editor.enablePreview": false,
  "explorer.confirmDelete": false,
  "editor.renderLineHighlight": "line",
  "githubPullRequests.pullBranch": "never",
  "editor.linkedEditing": true,
  "workbench.startupEditor": "none",
  "update.mode": "manual",
  "telemetry.telemetryLevel": "crash",
  "github.copilot.enable": {
    "*": true,
    "plaintext": false,
    "markdown": true,
    "scminput": false
  },
  "redhat.telemetry.enabled": false,
  "errorLens.enabledDiagnosticLevels": ["error", "warning"]
}
```

### Setup VS Code as the default editor

To set up VS Code as the default editor, use `code .` to open a directory directly from the command line to the editor, you need to install `code` command in the `PATH`.

- Open VS Code, and open the command palette.
- Type **Shell** and select **Shell Command: Install 'code' command in PATH**.

![Installing code command in Path in VS Code](/images/macbook-setup-shell.png)

### VS Code themes

I usually switch between the following themes:

- Quiet Light (built-in)
- [Licht theme](https://marketplace.visualstudio.com/items?itemName=cnakazawa.licht-theme)

### VS Code extensions

I have a list of must-have extensions in my [dotfiles repo](https://github.com/amandeepmittal/dotfiles/blob/master/vscode-extensions.vsix):

```shell
code --install-extension astro-build.astro-vscode
code --install-extension atishay-jain.all-autocomplete
code --install-extension bradlc.vscode-tailwindcss
code --install-extension catppuccin.catppuccin-vsc-icons
code --install-extension chrischinchilla.vale-vscode
code --install-extension christian-kohler.npm-intellisense
code --install-extension cnakazawa.licht-theme
code --install-extension dbaeumer.vscode-eslint
code --install-extension eamodio.gitlens
code --install-extension esbenp.prettier-vscode
code --install-extension expo.vscode-expo-tools
code --install-extension formulahendry.auto-close-tag
code --install-extension formulahendry.auto-complete-tag
code --install-extension formulahendry.auto-rename-tag
code --install-extension github.copilot
code --install-extension github.copilot-chat
code --install-extension github.vscode-pull-request-github
code --install-extension johnpapa.read-time
code --install-extension mathiasfrohlich.kotlin
code --install-extension naumovs.color-highlight
code --install-extension oderwat.indent-rainbow
code --install-extension orta.vscode-ios-common-files
code --install-extension redhat.vscode-yaml
code --install-extension riussi.code-stats-vscode
code --install-extension streetsidesoftware.code-spell-checker
code --install-extension streetsidesoftware.code-spell-checker-cspell-bundled-dictionaries
code --install-extension tamasfe.even-better-toml
code --install-extension unifiedjs.vscode-mdx
code --install-extension usernamehw.errorlens
code --install-extension vincaslt.highlight-matching-tag
code --install-extension wakatime.vscode-wakatime
```

This list of extensions can be generated by running `code --list-extensions` in the terminal.

## Conclusion

That's the setup I now use for my JavaScript, Node.js, React, React Native, Expo, and documentation work.

---

## How to manage state in React apps with useReducer and useContext hooks
Slug: manage-state-with-usecontext-usereducer-in-react-apps

![cover](https://i.imgur.com/Q0W4kzf.jpg)

Choosing a state management library to manage and handle a global state in a React app can be tricky and time-consuming. A lot depends on the scope of the React app and there are many options available.

With the adaption of React Hooks API, one such option is to use a combination of `useReducer` hook and the Context API. In this post, let's take a look at how to manage global state in a React app using both of them.

## Prerequisites

To take full advantage of this tutorial, or run along with the example, please make sure you following installed/access to in your local development environment.

- Node.js version >= `12.x.x `installed
- have access to one package manager such as `npm` or `yarn`
- `create-react-app` cli installed or use `npx`
- basics of React Hooks

If you are not familiar with React Hooks, I recommend you to go through the [in-depth post on React hooks here](https://amanhimself.dev/blog/react-app-with-localstorage-api-and-hooks).

## State management in React apps with useReducer

There are two types of states to deal with in React apps. The first type is the local state that is used only within a React component. The second type is the global state that can be shared among multiple components within a React application.

With the release of Context API as well as Hooks API, implementing a global state is possible without installing any additional state management library. The `useReducer` hook is a great way to manage complex state objects and state transitions. You may have seen or used `useState` to manage [simple or local state](https://amanhimself.dev/blog/react-app-with-localstorage-api-and-hooks) in React apps.

The `useReducer` hook is different from `useState`. The main advantage it has over `useState` is that covers the use case when there is a need of handling complex data structures or a state object that contains multiple values. It updates the state by accepting a reducer function and an initial state. Then, it returns the actual state and a dispatch function. This dispatch function is used to make changes to the state.

## Create a new React app & installing dependencies

To get started, create a new React project by executing the following command in a terminal window:

```shell
npx create-react-app react-expense-tracker

cd react-expense-tracker
```

To focus on the main topic of this tutorial as well as to give the demo app a nice look and feel, let's use pre-defined components from [Reactstrap](https://reactstrap.github.io/). It provides Bootstrap 4 components that are based on Flexbox and useful to handle the layout of a web app. To get started using Bootstrap in a React app, install the following dependencies:

```shell
yarn add bootstrap@4.5.0 reactstrap@8.5.1 uuid@8.2.0
```

After installing these dependencies, open the React project you created and open the file `index.js`. Add an import statement to include the Bootstrap CSS file.

```js
// after other imports
import 'bootstrap/dist/css/bootstrap.min.css';
```

That's it to set up Bootstrap in the current React app.

## Defining a global state

Start by creating a new file called `GlobalState.js` inside the `src/` directory.

Let's use React's context API to create a Context provider that can is going to share the state across multiple components. You can think of this example as mimicking Redux' philosophy. Import the required statements.

```js
import React, { useReducer, createContext } from 'react';
import { v4 as uuid } from 'uuid';
```

Next, create an empty context for Expense and define an initial state object. This initial state is going to have one expense item present. This also helps to define a schema or data model for all other expense items (_but do note that this for demonstration purpose in context to this post_).

```js
export const ExpenseContext = createContext();

const initialState = {
  expenses: [
    {
      id: uuid(),
      name: 'Buy Milk',
      amount: 10
    }
  ]
};
```

Then define a function called `reducer`. It is going to take two arguments, the current state and action. This reducer's job is to modify or update the state object whenever there is an action taken within the app by the user. One example of an action is a user adding an expense.

For the following example, this `reducer` function is going to have one action type, which is to add the expense. If there are no changes or modifications, this `reducer` function is going to return the current state (_which is the default case_).

```js
const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD_EXPENSE':
      return {
        expenses: [...state.expenses, action.payload]
      };
    default:
      return {
        state
      };
  }
};
```

Next, define an `ExpenseContextProvider` that is going to behave like a store (_as a store in [Redux](https://amanhimself.dev/blog/redux-with-react-native-hooks)_).

```js
export const ExpenseContextProvider = props => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <ExpenseContext.Provider value={[state, dispatch]}>
      {props.children}
    </ExpenseContext.Provider>
  );
};
```

The `useReducer` hook allows us to create a reducer using the `reducer` function defined previously. The `initialState` is passed as the second argument.

## Wrap the App with the provider

When the `ExpenseContextProvider` is wrapped around any component in the React app, that component and its children will be able to access the current state as well as modify the state object.

In this section, that's what we are going to do. Open, `App.js` file, and modify it as below.

```js
import React from 'react';
import { Container } from 'reactstrap';

import { ExpenseContextProvider } from './GlobalState';

import Header from './components/Header';
import Form from './components/Form';
import List from './components/List';

export default function App() {
  return (
    <ExpenseContextProvider>
      <Container className="text-center">
        <Header />
        <Form />
        <List />
      </Container>
    </ExpenseContextProvider>
  );
}
```

In the next sections, let us create other components that are children to this `App` component. Create a `components/` directory and then create three new component files:

- `Header.js`
- `Form.js`
- `List.js`

## Add the header of the app

In this section, let us define a presentational component called `Header`. It's going to be a simple jumbotron component from Bootstrap displaying the title of the app and the logo.

Open `Header.js` and add the following snippet:

```js
import React from 'react';
import { Jumbotron } from 'reactstrap';
import Logo from '../logo.svg';

export default function Headers() {
  return (
    <Jumbotron fluid>
      <h3 className="display-6">
        Expense Tracker React App
        <img src={Logo} style={{ width: 50, height: 50 }} alt="react-logo" />
      </h3>
    </Jumbotron>
  );
}
```

## Add a form component

Open `Form.js` file and import the following statements.

```js
import React, { useState, useContext } from 'react';
import {
  Form as BTForm,
  FormGroup,
  Input,
  Label,
  Col,
  Button
} from 'reactstrap';
import { v4 as uuid } from 'uuid';

import { ExpenseContext } from '../GlobalState';
```

The `uuid` module is going to generate a unique id for each expense item in the global state.

Define a `Form` component that is going to access values from `ExpenseContext` using `useContext` hook.

```js
export default function Form() {
  const [state, dispatch] = useContext(ExpenseContext);

  //...
}
```

Using the `useState` reducer, define two state variables that are going to be local to this component. These state variables are going to help us define controlled input fields. A controlled input field accepts its current value as a prop as well as a callback to change that value.

Add the following initial state for `name` and `amount` using `useState`. Both of them are going to have an empty string as their initial value.

```js
const [name, setName] = useState('');
const [amount, setAmount] = useState('');
```

To update their values when a user starts typing, add the following handler methods. Both of these functions are going to retrieve the value from the corresponding field. The console statements are for testing purposes.

```js
const handleName = event => {
  console.log('Name ', event.target.value);
  setName(event.target.value);
};

const handleAmount = event => {
  console.log('Amount ', event.target.value);
  setAmount(event.target.value);
};
```

Lastly, to submit the form, there is going to be another handler method called `handleSubmitForm`. This method when triggered is going to dispatch the action to add the expense (`ADD_EXPENSE`). This is how the `reducer` function in the global state updates the state.

```js
const handleSubmitForm = event => {
  event.preventDefault();
  if (name !== '' && amount > 0) {
    dispatch({
      type: 'ADD_EXPENSE',
      payload: { id: uuid(), name, amount }
    });

    // clean input fields
    setName('');
    setAmount('');
  } else {
    console.log('Invalid expense name or the amount');
  }
};
```

Lastly, add the following JSX to display the component.

```js
return (
  <BTForm style={{ margin: 10 }} onSubmit={handleSubmitForm}>
    <FormGroup className="row">
      <Label for="exampleEmail" sm={2}>
        Name of Expense
      </Label>
      <Col sm={4}>
        <Input
          type="text"
          name="name"
          id="expenseName"
          placeholder="Name of expense?"
          value={name}
          onChange={handleName}
        />
      </Col>
    </FormGroup>
    <FormGroup className="row">
      <Label for="exampleEmail" sm={2}>
        Amount
      </Label>
      <Col sm={4}>
        <Input
          type="number"
          name="amount"
          id="expenseAmount"
          placeholder="$ 0"
          value={amount}
          onChange={handleAmount}
        />
      </Col>
    </FormGroup>
    <Button type="submit" color="primary">
      Add
    </Button>
  </BTForm>
);
```

## Display a list of items

In this section, let's add the `List.js` component to display a list of items from the current state object provided by the `ExpenseContext`. Open the file and add the following import statements:

```js
import React, { useContext } from 'react';
import { ListGroup, ListGroupItem } from 'reactstrap';

import { ExpenseContext } from '../GlobalState';
```

Next, map the `state` value to display the name of the expense and the amount of the expense as a list item.

```js
export default function List() {
  const [state] = useContext(ExpenseContext);
  return (
    <ListGroup>
      {state.expenses.map(item => {
        return (
          <ListGroupItem key={item.id}>
            {item.name} - $ {item.amount}
          </ListGroupItem>
        );
      })}
    </ListGroup>
  );
}
```

## Running the app

All the components of the simple Expense Tracker app are complete. Now, let's run the app and see it as an action. On the initial render, the Rect app is going to look like below.

![ss1](https://i.imgur.com/KrlTYS6.png)

It is going to display one expense item that is defined as the object in the initial state. Try adding a new item in the list and see if the list updates and form gets cleared or not.

![ss2](https://i.imgur.com/92qztPT.gif)

## Conclusion

Using `useReducer` in conjunction with React's Context API is a great way to quickly get started with managing your state. However, some caveats come with React's Context API. Re-rendering of multiple components unnecessarily can become a huge problem and its something you should take care.

---

## Managing python environments on macOS using conda-forge
Slug: managing-python-environments-on-macos-using-conda

If you use your macOS for Python projects, especially for AI tools like Stable Diffusion WebUI or Open Web UI, you likely find it frustrating that macOS ships with a `python3` default version. Sometimes, this version can be outdated or locked down. One project may require Python 3.11, while another requires 3.9.

For example, at the time of writing the guide, the default Python version on my machine is:

```shell
python3 --version

# Output
Python 3.13.3
```

However, considering the Stable Diffusion Web UI's requirements, it is recommended to install Python 3.10 because `torch`, a framework for building deep learning models, isn't supported in newer versions.

<img src="/images/py/py1.png" />

<img src="/images/py/py2.png" />

This is where using `conda` to manage packages and environments in Python projects comes in handy. It helps to install, manage, and update packages from Anaconda and other repositories, removing that extra layer of complexity.

In this guide, I'll share installation steps to install `conda` using [Miniforge](https://github.com/conda-forge/miniforge), which is a lightweight, community driven `conda` installer. Whether you're setting up Stable Diffusion WebUI for the first time or spinning up Open WebUI for local AI chat, you'll have clean, reproducible environments that just work.

## Download the shell script

Miniforge recommends downloading `conda` using a shell script for Apple Silicon machines.

<img src="/images/py/py3.png" />

Visit https://conda-forge.org/download/.
Download the latest version by clicking the macOS tile for `arm64 (Apple Silicon)`.

Once you have downloaded it, in your terminal, run the script using `sh`:

```shell
sh /Users/username/Downloads/Miniforge3-MacOSX-arm64.sh
```

This will bring up the installation steps, such as reviewing the license and agreeing to it. Once you accept the license terms and accept the location to install it (I choose the default location so it installs under the `username` directory).

<img src="/images/py/py4.png" />

## Activate conda's base environment

To activate conda's base environment that will use the default Python version, you need to add the following in your shell's source script. Since I use zsh shell, I added the following at the end of my `.zshrc` file:

```shell
################ END OF FILE configs ################

# conda

eval "$(/Users/username/miniforge3/bin/conda shell.zsh hook)"
```

Then, either restart the terminal or run `source .zshrc`.

## Verify installation

To verify installation, I am using a new terminal window. I run the following commands:

```shell
conda â€”-version

# Output
conda 25.3.0

python â€”-version

# Output
Python 3.12.10
```

Â 
Python `3.12.10` is the default version conda is using on my machine. This Python version is installed separately from the one pre-installed on macOS or installed via homebrew before.

At any time, you can also run `which python` to check the location of the Python's executable file:

```shell
which python
/Users/username/miniforge3/bin/python
(base)
```

## New environment with conda

To create a new environment and use a specific Python version, run the command:

```shell
conda create â€”name py39
```

This command will create a new environment and will also output the environment location on your machine:

```shell
environment location: /Users/username/miniforge3/envs/py39
```

Any environment created goes inside the `miniforge3/envs/` directory.

To use this new environment, you need to activate it first by using the `activate` option:

```shell
conda activate py39
```

Once it is activated, run the command to install the Python version you want in your project's environment:

```shell
conda install python=3.9
```

Then, you can run the version verification command to check which version of Python is used in this environment:

```shell
python --version

# Output
Python 3.9.23
```

## Deactivate an environment

To deactivate an environment, you can run:

```shell
conda deactivate
```

After running this command, you will be back into the conda's base environment, which was created by default.

<img src="/images/py/py5.png" width="460" />

---

## Mapped types in TypeScript
Slug: mapped-types-in-typescript

As per [TypeScript's documentation](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html), mapped types can be used to avoid repeating the type information inside a new type. A mapped type might look complex at first glance, but they do save the repetition.

A mapped type allows to create a new type based on existing ones. This new type then can map over the property of the existing type without the needing to redefine those types.

To understand this, let's start with a JavaScript object. The following `pokemonColors` is a simple object that contains three pokemon properties:

```ts
const pokemonColors = {
  fire: 'red',
  water: 'blue',
  grass: 'green'
};
```

Each property has its own color value to resemble the type of the pokemon. Also notice that each color value is manually typed to its pokemon type. Writing this in TypeScript will become:

```ts
interface PokemonTypeColorMap {
  fire: string;
  water: string;
  grass: string;
}
```

This is fine. Each pokemon type defined is of type string. That is something not going to change through out the pokemon data set. Also, if you want to add more pokemon types, you will have to update this interface manually.

Using mapped types, you can avoid manually managing this interface. Instead of writing each property, you can define the list of types:

```ts
type PokemonType = 'fire' | 'water' | 'grass';
```

This type is a union of strings.This is important because a mapped type only works with a union of strings or numbers or symbols.

Now, you can create mapped type to create properties for each type:

```ts
type PokemonTypeColorMap = {
  [Type in PokemonType]: string;
};
```

The `Type in PokemonType` is actual pokemon type property and the `: string` means each property holds a string value. The maintenance of `PokemonType` also becomes a bit easier. When you add a new property type to the `PokemonType`, all you need to do is expand the union of strings.

Now, when defining the color values for a pokemon property type, you can use `PokemonColors` type:

```ts
export const Colors: PokemonTypeColorMap = {
  fire: '#F08030',
  water: '#6890F0',
  grass: '#78C850'
};
```

---

## How to integrate Material UI library in React apps
Slug: material-ui-integration-with-react

Material design was introduced by Google around 2014 as a design language and it still shares some popularity among web and mobile applications. One of the common ways to integrate and use this design system in React apps is through [MaterialUI](https://material-ui.com/getting-started/installation/) library.

![ss1](https://i.imgur.com/l4PZ8tB.png)

In this post, let us take a look at how to integrate a material library that is available as an npm module and consists of built React components that you can use to build apps. You are going to learn from scratch on how to install and configure this library as well as build a small demo app.

![ss8](https://i.imgur.com/QxtWlBz.png)

## Prerequisites

Before you begin this tutorial you are going to need the following:

- a Web browser such as Chrome, Firefox and so on
- Node.js version above `12.x.x` installed on your local machine
- JavaScript/ES6 basics
- React basics
- npm/yarn install
- either `create-react-app` globally installed or access via `npx`

## Create a new React app

To start, you are going to need to setup a React project. Let's use `npx` to do so. Execute the following command in a terminal window.

```shell
npx create-react-app reactmaterial
```

By using the `npx` command (a part of the Node Package Manager (npm)) you execute `create-react-app` without the need to download and install the package globally.

When the new project is done scaffolding with the default dependencies such as React library and React DOM library installed.

Change in the new directory and you are going to be welcomed by the following structure of files and folders.

![ss2](https://i.imgur.com/W9D0ToF.png)

To verify that the React app is working, (_you can totally skip the step at this time_), run `yarn start` from the terminal window and open the default React app running at `http://localhost:3000` in a browser window.

![ss3](https://i.imgur.com/OkkceuE.png)

## Install Material UI library

The next step is to install the Material-UI library and integrate it to work with the current React app. The first is to install the core dependency of this library.

```shell
yarn add @material-ui/core
```

Material-UI was designed with the Roboto font in mind. If you wish to use it, you can follow the instructions. Go back to the terminal window and install the typeface package of the font. Also note that, the following steps to install this font are optional.

```shell
yarn add typeface-roboto
```

Then go to the entry point of your React app (preferably, `./src/index.js` file) and import the font.

```js
// rest of the import statements
import 'typeface-roboto';
```

Alternatively, if you do not wish to install the above npm module for the font, you can also use the CDN version of the font and read about it [here](https://material-ui.com/components/typography/#roboto-font-cdn).

## Using AppBar to create a custom navigation bar

In this section let us build a navigation bar. Create a new file called `./src/components/Navbar.js` and start by importing the components `AppBar`, `ToolBar`, and `Typography` from the MaterialUI library.

The `AppBar` component is used to display branding, screen titles, and navigation of the web app. That is what you are going to use it for. The `ToolBar` component is wrapper where you can place your components horizontally. The `Typography` component applies the Material UI theme that is available by default.

```js
import React from 'react';
import { AppBar, Toolbar, Typography } from '@material-ui/core';
```

Next, export a function component called `Navbar` with the following JSX.

```js
export default function Navbar() {
  return (
    <AppBar>
      <Toolbar>
        <Typography variant="h6">React and Material-UI App</Typography>
      </Toolbar>
    </AppBar>
  );
}
```

In the code snippet above, notice the `variant` prop on the `Typography` component. It uses the variant mapping to properly associate a UI element with an HTML semantic element (_such as h6 in the code snippet_).

Now, to see it in action, import the `Navbar` component in the `App.js` file.

```js
import React from 'react';
import Navbar from './components/Navbar';

function App() {
  return (
    <div>
      <Navbar />
    </div>
  );
}

export default App;
```

You are going to get the following result after this step.

![ss4](https://i.imgur.com/HhDhiP3.png)

## Implementing a Paper component

Two components that are going to be used in this section in order to layout a view for the items of the list are called `Grid` and `Paper`.

Material Designâ€™s responsive UI is based on a 12-column grid layout. The `Grid` component helps you implement this layout system and then provide the values or the number of grids you want to display. A basic grid might look like below:

![ss5](https://i.imgur.com/UqiYt1i.png)

Material UI uses CSS's Flexbox to manage layout alignments and sizing of the grid columns.

The other component `Paper` actually displays the physical properties of a paper on the screen. It resembles a flat, texture of a sheet of paper, and using a prop called `elevation` you can manipulate its default display behavior. Do note that, this component does need an initial width and height.

Create a new component file called `./src/components/List.js` which is going to be used as a reusable component later. This presentational component is going to display a `Paper` component inside `Grid` with custom styles.

```js
import React from 'react';
import { Grid, Paper, makeStyles } from '@material-ui/core';

const useStyles = makeStyles(theme => ({
  root: {
    marginTop: 100,
    flexGrow: 1
  },
  paper: {
    height: 220,
    width: 340,
    backgroundColor: '#ebebeb'
  },
  avatarImage: {
    width: 200,
    height: 200,
    borderRadius: 100
  }
}));

export default function List() {
  const classes = useStyles();

  return (
    <Grid container spacing={2}>
      <Grid item className={classes.root} xs={12}>
        <Grid container justify="center" spacing={2}>
          <Grid key={1} item>
            <Paper className={classes.paper} elevation={2} />
          </Grid>
        </Grid>
      </Grid>
    </Grid>
  );
}
```

The `makeStyles` comes from the Material UI API. It links a style sheet with a function component and returns a hook that you use inside the component.

You can modify the `App.js` file to include the `List` component.

```js
// rest of the import statements
import List from './components/List';

function App() {
  return (
    <div>
      <Navbar />
      <List />
    </div>
  );
}
```

Here is the result you are going to get after this step.

![ss6](https://i.imgur.com/8PL5Xrs.png)

## Fetching random user data

To display data inside `List` component, let us use [https://randomuser.me/](https://randomuser.me/) API. In the `App` component the data is going to be fetched on the initial render using `useEffect` hook. The `useState` hook is used to store the fetched data by defining a state variable whose initial value is an empty array.

To start, first, import the hooks from the `react` library.

```js
import React, { useState, useEffect } from 'react';
```

After that create a state variable called `data` inside the `App` component. Along with the `data` variable, define two other state variables, `isLoading` to track the whether app is in loading mode (that is, the data is being fetched from the API) and `error` to track if there is an error while fetching the data. The loading state of the React app is going to be `true` by default.

```js
function App() {
  const [data, setData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');

  //rest of the code
}
```

The `useEffect` hook is going to have a callback that is going to fetch the data using JavaScript's `fetch` API.

```js
useEffect(() => {
  fetch('https://randomuser.me/api/?results=5')
    .then(res => res.json())
    .then(
      result => {
        setIsLoading(false);
        setData(result.results);
      },
      error => {
        setIsLoading(false);
        setError(error);
      }
    );
}, []);
```

You can conditionally render the JSX based on the state variables.

```js
if (isLoading) {
  return <div>Loading ...</div>;
} else if (error) {
  return <div>There is an error fetching data.</div>;
} else {
  return (
    <div>
      <Navbar />
      <List />
    </div>
  );
}
```

Now, when you refresh the React app, you are going to see the JSX being rendered that is related to the loading state of the app, for split seconds.

![ss7](https://i.imgur.com/hBWfaYc.gif)

## Display a list of users

You can now pass the user information you want to display in the form of the prop at the `List` component. Use JavaScript's `map` function to traverse the array `data`.

```js
{
  data.map(item => (
    <List
      key={item.id.value}
      userAvatar={item.picture.large}
      firstName={item.name.first}
      lastName={item.name.last}
    />
  ));
}
```

These props are then passed as arguments to the `List` component.

```js
xport default function List({ userAvatar, firstName, lastName }) {
  const classes = useStyles();

  return (
    <Grid container spacing={2}>
      <Grid item className={classes.root} xs={12}>
        <Grid container justify="center" spacing={2}>
          <Grid key={1} item>
            <Paper className={classes.paper} elevation={2}>
              <Grid container justify="center">
                <Avatar
                  alt="User"
                  className={classes.avatarImage}
                  src={userAvatar}
                />
                <Typography variant="p">
                  Name: {firstName} {lastName}
                </Typography>
              </Grid>
            </Paper>
          </Grid>
        </Grid>
      </Grid>
    </Grid>
  );
}
```

The above code snippet uses few more core components from Material UI (such as `Avatar`). You can find their reference in the official documentation of this library.

Here is the final result you are going to get when you back to the browser screen.

![ss8](https://i.imgur.com/QxtWlBz.png)

## Conclusion

I hope in this post, you get the idea of how you can leverage the core components of [Material UI library](https://material-ui.com/getting-started/installation/) in your React apps and save a ton of development time.

References:

- [Materia UI official docs](https://material-ui.com/getting-started/installation/)
- [AJAX calls in React](https://reactjs.org/docs/faq-ajax.html)
- [Random User API](https://randomuser.me/documentation#howto) to mock data in your React apps
- To learn more about React Hooks, check out my post on that [here](https://dev.to/amanhimself/build-a-expense-tracker-app-with-react-hooks-and-localstorage-api-4lfj)

---

## Migrating from Expressjs 4 to 5
Slug: migrating-from-expressjs-4-to-5

ExpressJS 5.0 is in alpha release stage but I believe weâ€™ll be adding it as a dependency in our `package.json` files in matter of no time. This article gives some tips regarding the way we are writing code using this framework and how we should adapt the new changes even if we are using ExpressJS _version 4.0_.

Iâ€™ll start with most common thing such as `response`.

Express 5 no longer supports the signature `res.send`, instead we should adapt using this method in this form:

`res.status(statusCode).send();`

We have to set the status code before sending the response object. This new version of `res.send` is basically a chain of two methods: `res.status` & `res.send`.

With that mind, ExpressJS 5 deprecates `res.send(statusCode)` method where `statusCode` is the number representing the HTTP response header status code. To send just the statusCode, that is, without sending the response object, we can use `res.sendStatus(statusCode)` method.

In similar manner, other methods that have been changed are:

```js
res.json()-- > res.status().json();
res.jsonp()-- > res.status.jsonp();
```

Another notable method that is going to be deprecated in next version of ExpressJS is `res.sendfile()`. Instead, we must adapt its new form, the camelCase one: `res.sendFile()` which is already been supported by the ExpressJS versions later than `4.8.x`. It comes with optional parameters that you can check them [**here**](http://expressjs.com/en/4x/api.html#res.sendFile)**.**

Whether you are planning to use the alpha release of Express 5.0 or still going on with the latest versions of Express 4.0, I would suggest to start adapting these methods immediately.

_The full list of changes or the official Express Migration Guide is to be found_ [here](http://expressjs.com/en/guide/migrating-5.html)**_._**

[Originally Published at Hackernoon.com](https://hackernoon.com/migrating-from-expressjs-4-to-5-156dcd80eb11)

---

## How to Offer Multi-language Support in a React Native App
Slug: multi-language-support-in-react-native-with-react-i18next

Internationalization is an important feature to overcome the language barrier among people who use a particular software application. Not every app requires us to consider a global customer base. But if you have plans to include support for international users in your app, youâ€™ll need internationalization in your React Native app.

[i18next](https://www.i18next.com/) is an internationalization framework written in JavaScript and provides methods for localizing the app and implementing the other standard i18n features.

In this tutorial, let's take a look at the steps to add multi-language support to a React Native app using i18n.

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6, basics of React and meet the following requirements in your local dev environment:

- Node.js version `12.x.x` or above installed.
- Have access to one package manager such as npm or yarn or npx.
- [react-native-cli](https://www.npmjs.com/package/react-native-cli) installed, or use npx.

## Setting up a React Native app

After initializing a React Native project, make sure to install the external libraries to follow along with this tutorial. Navigate inside the project directory, and then run the following command install the following libraries:

```shell
yarn add react-i18next i18next @react-navigation/native @react-navigation/bottom-tabs @react-native-async-storage/async-storage react-native-vector-icons react-native-screens react-native-safe-area-context react-native-reanimated react-native-localize react-native-gesture-handler

# after this step, for iOS, install pods
npx pod-install ios
```

React Native Vector Icons will be used for adding icons in the app. React Navigation is used to add and enable navigation between screens in the app. Make sure to initialize and configure navigation as described in [React Navigation library getting started doc](https://reactnavigation.org/docs/getting-started/).

The following libraries are going to be used for adding multi-language support to the app:

- `i18next`: internationalization library.
- `react-i18next`: provides binding for React and React Native projects using Hooks, High Order Components (HOCs), and so on. We will use the `useTranslation` hook to translate the text within React Native function components.
- `react-native-localize`: provides helper functions to figure based on the device's localized language preference.
- `@react-native-async-storage/async-storage`: is an unencrypted, asynchronous, persistent, key-value storage system that is global to the app. It is used to store the user's language preference such that it persists when the app restarts.

> ðŸ”¥ Tip: Always make sure to check out installation steps in the documentation of libraries installed in a React Native app. Some may differ and change over time. It's hard to keep a blog post up to date with all these changes.

## Building a React Native app

After installing libraries, let's setup the React Native app with mock screens and navigation.

Create a `src/` folder inside the project root directory and inside it, create the following files and folders:

- `/constants`
  - `/translations`
  - `IMLocalize.js`
- `/navigation`
  - `RootNavigator.js`
- `/screens`
  - `/HomeScreen.js`
  - `SettingsScreen.js`
- `/components`
  - `LanguageSelector.js`

Start by adding a `RootNavigator.js` file inside the `/navigation` folder. It will have both screens as tabs and some configuration to display an icon and a label for each tab.

```js
import * as React from 'react';
import { Text, View } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Ionicons from 'react-native-vector-icons/dist/Ionicons';

import HomeScreen from '../screens/HomeScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

export default function RootNavigator() {
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName;

            if (route.name === 'Home') {
              iconName = focused ? 'ios-home' : 'ios-home-outline';
            } else if (route.name === 'Settings') {
              iconName = focused ? 'ios-settings' : 'ios-settings-outline';
            }

            return <Ionicons name={iconName} size={size} color={color} />;
          },
          tabBarActiveTintColor: 'tomato',
          tabBarInactiveTintColor: 'gray',
          headerShown: false
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}
```

Next, let's add code snippets for screens. In `HomeScreen.js`, add the following code. For now, it only displays a `Text` component:

```js
import React from 'react';
import { Text, View } from 'react-native';

export default function HomeScreen() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>Home</Text>
    </View>
  );
}
```

Similarly, the `SettingsScreen.js` file will also display a `Text` component:

```js
import React from 'react';
import { Text, View } from 'react-native';

export default function SettingsScreen() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>Settings!</Text>
    </View>
  );
}
```

Now, modify the `App.js` file to add the following code snippet:

```js
import React from 'react';

import RootNavigator from './src/navigation/RootNavigator';

export default function App() {
  return <RootNavigator />;
}
```

At this point, if you run the `npx react-native run-ios` or `npx react-native run-android` command, you should see the following screen on a simulator/emulator or on a device:

![cb1](/images/cb/img1.png)

## Create translation files

Initially, we will like to translate tab names based on the language selected within the app. To do this, we need to create translation config files.

You can organize these translation files in the way you want, but here we are following a pattern. Inside `constants/translations/` directory, let's create subdirectories for each language to support in this demo app. The languages supported here are `en` for English and `fr` for French.

Inside each language directory, create separate files that will split the translations from commonly used text to translate specific texts such as for tab navigation labels. Under `i18n`, this separation leads to creating namespaces for each language. Later in the tutorial, you will see how to access the value of a key, for example, `home` from the namespace `navigation` to translate the tab bar label.

Here is how the directory structure would like under `translations/`:

![cb1](/images/cb/img2.png)

Inside `en/common.js` file, add the following snippet:

```js
export default {
  hello: 'Hello',
  languageSelector: 'Select Your Language'
};
```

Inside `en/navigate.js` file, add the following code snippet:

```js
export default {
  hello: 'Bonjour',
  languageSelector: 'SÃ©lecteur de langue'
};
```

Next, inside add translated tab labels for each language in their corresponding `navigate.js` files:

```js
// en/navigate.js
export default {
  home: 'Home!',
  settings: 'Settings'
};


// fr/navigate.js
export default {
  home: 'Ã‰cran principal',
  settings: 'Le rÃ©glage'
};
```

Lastly, export these translated texts:

```js
// en/index.js
import common from './common';
import navigate from './navigate';

export default {
  common,
  navigate
};

// fr/index.js
import common from './common';
import navigate from './navigate';

export default {
  common,
  navigate
};
```

## Adding multi-language support configuration

Now that you have translation files ready and dependencies installed, let's configure how to create a configuration using those libraries installed earlier.

All of this configuration will live inside `IMLocalize.js` file. Start by importing the following dependencies. Also, define a `LANGUAGES` object that requires each language file as an object and using JavaScript syntax of `Object.keys` convert the `LANGUAGES` object to an array.

```js
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as RNLocalize from 'react-native-localize';

import en from './translations/en';
import fr from './translations/fr';

const LANGUAGES = {
  en,
  fr
};

const LANG_CODES = Object.keys(LANGUAGES);
```

The `i18n` is configured in a certain way. The initial step it requires is to detect a language. Hence, define your own custom language detector. It will check the user's stored language preference when the app starts. If the user's language preference is not available, you will need to define a fallback language or find the best available language to fall back on.

Create a `LANGUAGE_DETECTOR` configuration object:

```js
const LANGUAGE_DETECTOR = {
  type: 'languageDetector',
  async: true,
  detect: callback => {
    AsyncStorage.getItem('user-language', (err, language) => {
      // if error fetching stored data or no language was stored
      // display errors when in DEV mode as console statements
      if (err || !language) {
        if (err) {
          console.log('Error fetching Languages from asyncstorage ', err);
        } else {
          console.log('No language is set, choosing English as fallback');
        }
        const findBestAvailableLanguage =
          RNLocalize.findBestAvailableLanguage(LANG_CODES);

        callback(findBestAvailableLanguage.languageTag || 'en');
        return;
      }
      callback(language);
    });
  },
  init: () => {},
  cacheUserLanguage: language => {
    AsyncStorage.setItem('user-language', language);
  }
};
```

Then, add the configuration initialize `i18n`. It will start by detecting the language, passing the i18n instance to `react-i18next`, and initializes using some options. This option makes `i18n` available for all React Native components.

```js
i18n
  // detect language
  .use(LANGUAGE_DETECTOR)
  // pass the i18n instance to react-i18next.
  .use(initReactI18next)
  // set options
  .init({
    resources: LANGUAGES,
    react: {
      useSuspense: false
    },
    interpolation: {
      escapeValue: false
    },
    defaultNS: 'common'
  });
```

These options may vary depending on your React Native project. We recommend you to go through [available configuration options for i18n](https://www.i18next.com/overview/configuration-options).

Next, import the `IMLocalize` file in `App.js` file:

```js
// after other import statements
import './src/constants/IMLocalize';
```

## Creating a Language Selector component

Since you have initialized the languages in the React Native app, the next step is to allow the user to select between different languages available inside the app.

Inside `LanguageSelector.js` file, start by importing the following libraries:

```js
import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import Ionicons from 'react-native-vector-icons/dist/Ionicons';
import { useTranslation } from 'react-i18next';
```

The `useTranslation` hook will allow accessing `i18n` instance inside this custom component which is used to change the language.

Next, define an array of `LANGUAGES`.

```js
const LANGUAGES = [
  { code: 'en', label: 'English' },
  { code: 'fr', label: 'FranÃ§ais' }
];
```

Then, define the function component `Selector`. It will allow the user to switch between different languages inside the app and also enlist the available languages.

It will get the currently selected language from the `i18n` instance. Using a handler method called `setLanguage`, you can allow the functionality to switch between different languages from the `LANGUAGES` array defined above this function component.

This function component uses `Pressable` from React Native to change the language.

```js
const LANGUAGES = [
  { code: 'en', label: 'English' },
  { code: 'fr', label: 'FranÃ§ais' }
];

const Selector = () => {
  const { i18n } = useTranslation();
  const selectedLanguageCode = i18n.language;

  const setLanguage = code => {
    return i18n.changeLanguage(code);
  };

  return (
    <View style={styles.container}>
      <View style={styles.row}>
        <Text style={styles.title}>Select a Language</Text>
        <Ionicons color="#444" size={28} name="ios-language-outline" />
      </View>
      {LANGUAGES.map(language => {
        const selectedLanguage = language.code === selectedLanguageCode;

        return (
          <Pressable
            key={language.code}
            style={styles.buttonContainer}
            disabled={selectedLanguage}
            onPress={() => setLanguage(language.code)}
          >
            <Text
              style={[selectedLanguage ? styles.selectedText : styles.text]}
            >
              {language.label}
            </Text>
          </Pressable>
        );
      })}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingTop: 60,
    paddingHorizontal: 16
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  title: {
    color: '#444',
    fontSize: 28,
    fontWeight: '600'
  },
  buttonContainer: {
    marginTop: 10
  },
  text: {
    fontSize: 18,
    color: '#000',
    paddingVertical: 4
  },
  selectedText: {
    fontSize: 18,
    fontWeight: '600',
    color: 'tomato',
    paddingVertical: 4
  }
});

export default Selector;
```

Import the `Selector` component inside the `SettingsScreen.js` file:

```js
import React from 'react';
import { View } from 'react-native';

import Selector from '../components/LanguageSelector';

export default function SettingsScreen() {
  return (
    <View style={{ flex: 1, backgroundColor: '#fff' }}>
      <Selector />
    </View>
  );
}
```

Here is the output in the simulator after this step:

![cb1](/images/cb/img3.png)

## Using the useTranslation hook

The `useTranslation` hook has two important functions that you can utilize inside your React Native app. You have already seen the first one (`i18n` instance) in the previous step. The next is called `t` (my personal guess is that it is short for translation) function. You can refer the namespaces defined in the translation files and pass them as arguments to this function.

Let's see that in action. Let's start with the `LanguageSelector` component itself. It has a title called `Select a Language`. While defining the translation files, we've already defined its translation in both English and French languages in their corresponding `common.js` files.

The initial step to getting the `t` function is to import the `useTranslation` hook. However, the `LanguageSelector.js` file already has it from the previous section.

Modify the following line to get the `t` function from the hook inside the `Selector` component:

```js
const { t, i18n } = useTranslation();
```

Next, modify the `Text` component contents used to define the title:

```js
<Text style={styles.title}>{t('common:languageSelector')}</Text>
```

Here is the output. The default or the initial language in our case is English. When the next language is selected, it translates the title on the Settings screen.

![cb1](/images/cb/img4.gif)

You can also modify the text strings according to the previously defined namespaces in the translation files.

For an example, the `RootNavigator` will be modified as follows:

```js
import * as React from 'react';
import { Text, View } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Ionicons from 'react-native-vector-icons/dist/Ionicons';
import { useTranslation } from 'react-i18next';

import HomeScreen from '../screens/HomeScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

export default function RootNavigator() {
  const { t } = useTranslation();
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName;

            if (route.name === 'Home') {
              iconName = focused ? 'ios-home' : 'ios-home-outline';
            } else if (route.name === 'Settings') {
              iconName = focused ? 'ios-settings' : 'ios-settings-outline';
            }

            return <Ionicons name={iconName} size={size} color={color} />;
          },
          tabBarActiveTintColor: 'tomato',
          tabBarInactiveTintColor: 'gray',
          headerShown: false
        })}
      >
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          options={{ tabBarLabel: t('navigate:home') }}
        />
        <Tab.Screen
          name="Settings"
          component={SettingsScreen}
          options={{ tabBarLabel: t('navigate:settings') }}
        />
      </Tab.Navigator>
    </NavigationContainer>
  );
}
```

Here is the final output:

![cb1](/images/cb/img5.gif)

## Conclusion

This completes our tutorial on how to add multi-language support in a React Native app. There are different strategies you can use inside your app to provide translation support. This tutorial is just one of the examples.

Please don't mind my translation for French text corresponding to English text. I am not good at it at all. ðŸ˜…

**Useful Links**

- [useTranslation Hook](https://react.i18next.com/latest/usetranslation-hook)
- [You can find the complete source code at GitHub](https://github.com/amandeepmittal/react-native-examples/tree/master/rnMultiLanguageExample)
- [Originally Published at Crowdbotics.com](https://amanhimself.dev/blog/how-to-offer-multi-language-support-in-a-react-native-app/)

---

## Multi Page Navigation in an Ionic App
Slug: multi-page-navigation-in-an-ionic-app

Ionic makes it easy to create multiple pages navigation using `NavController` as the genesis of navigation stack. In this little application, I will try to make the concept clear to you.

### Generate Application andÂ Pages

To start with, letâ€™s create a new Ionic app for this showcase. Follow along with me. To get started, we have to scaffold a new project, my favorite one-to-go Ionic CLI command:

```shell
ionic start -a 'Multi Page Navigation'
-i app.multipage.nav ionic-multi-page-nav blank
```

`cd` in to the new project created by the above Ionic CLI command and run `ionic serve` to see the blank template with just a homepage available. We will create two new pages in this application to showcase our motive.

To read about the basic Navigation in an Ionic app, see this.

Now, with the help of Ionic CLI, letâ€™s generate two new pages before diving into our code base.

```shell
$ ionic g page page1
$ ionic g page page2
```

I am naming the two new pages generic but you can name them anything you want. Just follow the convention when importing the modules. Inside the `app/pages` you can see, there are two new folders with the names we generated. Each have its ownÂ `.ts`,Â `.html` andÂ `.scss` file, thus, completing a web component on which every Ionic and Angular apps are based on.

To proceed, we need to add both the pages in our `app.module.ts`:

```ts
import { BrowserModule } from '@angular/platform-browser';
import { ErrorHandler, NgModule } from '@angular/core';
import { IonicApp, IonicErrorHandler, IonicModule } from 'ionic-angular';
import { SplashScreen } from '@ionic-native/splash-screen';
import { StatusBar } from '@ionic-native/status-bar';

import { MyApp } from './app.component';
import { HomePage } from '../pages/home/home';

// new pages to be added in declarations and entryComponents
import { Page1Page } from '../pages/page1/page1';
import { Page2Page } from '../pages/page2/page2';

@NgModule({
  declarations: [MyApp, HomePage, Page1Page, Page2Page],
  imports: [BrowserModule, IonicModule.forRoot(MyApp)],
  bootstrap: [IonicApp],
  entryComponents: [MyApp, HomePage, Page1Page, Page2Page],
  providers: [
    StatusBar,
    SplashScreen,
    { provide: ErrorHandler, useClass: IonicErrorHandler }
  ]
})
export class AppModule {}
```

### Setup Home Page for Basic Navigation

As the `app.module.ts` is updated with our changes, the scope of the whole application can now access these two new pages. To implement the navigation between them, we have to first update our `home.html` with buttons that will navigate to a specific page and business logic behind those events in `home.ts`.

```html
<ion-header>
  <ion-navbar>
    <ion-title>Ionic Multi Page App</ion-title>
  </ion-navbar>
</ion-header>

<ion-content padding>
  <ion-card>
    <ion-card-header> Home Page </ion-card-header>
    <ion-card-content>
      <button ion-button (click)="goTo('page1')">Page1</button>
      <button ion-button color="secondary" (click)="goTo('page2')">
        Page2
      </button>
      <button ion-button color="light" (click)="back()">Back</button>
    </ion-card-content>
  </ion-card>
</ion-content>
```

Letâ€™s update `home.ts` as well.

```ts
import { Component } from '@angular/core';
import { NavController } from 'ionic-angular';

import { Page1Page } from '../page1/page1';
import { Page2Page } from '../page2/page2';

@Component({
  selector: 'page-home',
  templateUrl: 'home.html'
})
export class HomePage {
  constructor(public navCtrl: NavController) {}

  goTo(page) {
    if (page === 'page1') {
      this.navCtrl.push(Page1Page);
    } else if (page === 'page2') {
      this.navCtrl.push(Page2Page);
    }
  }

  back() {
    if (this.navCtrl.length() >= 2) {
      this.navCtrl.pop();
    }
  }
}
```

The `goTo()` function will help us in navigating to the desired page and `back` button will bring us to the previous page in the navigation stack. This is important! I mentioned to the previous page, not the home page. If you are familiar with Ionic 1, this would how state will work.

### Updating Page1 andÂ Page2

To continue to develop our demo application, we need to update our `Page1` and `Page2` components.

```html
<!--Page1-->
<ion-header>
  <ion-navbar>
    <ion-title>Ionic Multi Page App</ion-title>
  </ion-navbar>
</ion-header>

<ion-content padding>
  <ion-card>
    <ion-card-header> Page 1 </ion-card-header>
    <ion-card-content>
      <button ion-button color="secondary" (click)="goTo('page2')">
        Page2
      </button>
      <button ion-button color="light" (click)="back()">Back</button>
    </ion-card-content>
  </ion-card>
</ion-content>
```

```ts
import { Component } from '@angular/core';
import { IonicPage, NavController, NavParams } from 'ionic-angular';
import { Page2Page } from '../page2/page2';

@IonicPage()
@Component({
  selector: 'page-page1',
  templateUrl: 'page1.html'
})
export class Page1Page {
  constructor(
    public navCtrl: NavController,
    public navParams: NavParams
  ) {}

  goTo(page) {
    if (page === 'page2') {
      this.navCtrl.push(Page2Page);
    }
  }

  back() {
    if (this.navCtrl.length() >= 2) {
      this.navCtrl.pop();
    }
  }

  ionViewDidLoad() {
    console.log('ionViewDidLoad Page1Page');
  }
}
```

Similar for the `Page2`:

```html
<ion-header>
  <ion-navbar>
    <ion-title>Ionic Multi Page App</ion-title>
  </ion-navbar>
</ion-header>

<ion-content padding>
  <ion-card>
    <ion-card-header> Page 2 </ion-card-header>
    <ion-card-content>
      <button ion-button (click)="goTo('page1')">Page1</button>
      <button ion-button color="light" (click)="back()">Back</button>
    </ion-card-content>
  </ion-card>
</ion-content>
```

```ts
import { Component } from '@angular/core';
import { IonicPage, NavController, NavParams } from 'ionic-angular';
import { Page1Page } from '../page1/page1';

@IonicPage()
@Component({
  selector: 'page-page2',
  templateUrl: 'page2.html'
})
export class Page2Page {
  constructor(
    public navCtrl: NavController,
    public navParams: NavParams
  ) {}

  goTo(page) {
    if (page === 'page1') {
      this.navCtrl.push(Page1Page);
    }
  }

  back() {
    if (this.navCtrl.length() >= 2) {
      this.navCtrl.pop();
    }
  }

  ionViewDidLoad() {
    console.log('ionViewDidLoad Page2Page');
  }
}
```

### Running theÂ App

If we save all the files and again from the terminal run:

```shell
$ ionic serve

# OR

$ ionic serve --lab
```

The output shown can be best described in these screenshots:

<img src='https://cdn-images-1.medium.com/max/800/0*sMnNW4P3ONmaUZCP.png' />

<img src='https://cdn-images-1.medium.com/max/800/0*iPNMEzroixe-Dmlj.png' />

<img src='https://cdn-images-1.medium.com/max/800/0*7oSIkMCTVC0JOaQ5.png' />

This is just a glimpse of how multi page navigation in Ionic might work that might help you to get started with development.

_To get the full code, you can visit_ [**this Github Repository**](https://github.com/amandeepmittal/ionic-multi-page-nav)

[Originally Published at Hackernoon.com](https://medium.com/hackernoon/multi-page-navigation-in-an-ionic-app-8b008f616cdb)

---

## My Top Tutorials in Web Development and React Native in 2018
Slug: my-top-tutorials-in-web-development-and-react-native-in-2018

When the year 2018 started I wasnâ€™t sure where am I headed to. I had recently started freelancing as a developer, paying bills for myself was my highest priority after leaving traditional 9 to 6(and the countless number of hours spent on commuting). One thing I had realised previously was that an expression of freedom was loving the work you do at your terms. There is no linear virgule to the path of success and financial independency.

Devoting rest of my time and energy to share my knowledge in form of articles through this blog was not on my mind at all then. I used to write long or short tutorials explaining one framework from point of view of a beginner or the trouble I had getting started with a new framework, just for the sake that fellow developers wonâ€™t have to spend endless hours Googling about a certain library or the topic that they need to use or learn, for a bigger picture they are working on. I still follow this pattern closely when writing a new article today. My motive is to add value rather than take readerâ€™s time with no end result for either of us.

Forward few months, when people started reading and appreciating my writing by expressing gratitude in any way possible, some of my content helped them, there was a new sense of responsibility and a new goal that I had to accomplish.

I have had previous experience in blogging and writing. Running a book blog for past five years, published in some poetry magazines, published by own ebook on Book Blogging and not consistently running a tech blog on Medium for more than a year at the time.

I can say, in these 365 days I have learned a lot about marketing one self shamelessly, promoting content in a manner that doesnâ€™t enforce, identifying the constructive criticism, making connections, gettinh paid to write and in the end some personal things about myself.

Achieving half a million views on the written content soon became a target goal for me and I can say, I did accomplish it blissfully.

Creating content with the thought glued in your consciousness that you have to provide value to the reader is a goal hard to accomplish but if done in tiniest bits, not impossible.

> It is good to have an end to journey toward; but it is the journey that matters, in the end.
> â€• Ursula K. LeÂ Guin

Thus, in below, I am summarising a list of articles that I think will help you achieve your goal or fill that gap in the year 2019 if your goal in the new is to become a developer ðŸŽ‰.

### Web Development

Javascript is often thought of a web programming language but Javascript, and javascript frameworks such as NodeJS, have many applications apart from just web apps including desktop applications, mobile applications, embedded systems, and back-end development.

If you are in web development (as I am), and you also want to explore new applications in machine learning, you may be wondering, â€˜do I have to wander spend time learning a whole new programming language to explore machine learning?â€™ No, in fact. Machine learning concepts can be explored with many different programming language and frameworks, including NodeJS.

[**Top NodeJS Libraries and Tools For Machine Learning**](https://medium.com/crowdbotics/top-nodejs-libraries-and-tools-for-machine-learning-ae0c106c9a69)

Get familiar with function-as-a-service (FaaS), deploy a demo on a AWS Lambda serverless computing platform, hook up a MongoDB database-as-a-service to a serverless REST API.

[**How to Build a Serverless Backend with AWS Lambda and Nodejs**](https://medium.com/crowdbotics/how-to-build-a-serverless-backend-with-aws-lambda-and-nodejs-e0d1257086b4)

Hello World! with GraphQLâ€Šâ€”â€ŠIn this tutorial, you will learn how to build a GraphQL server with Nodejs and Express using Apollo Server library 2.0.

[**Creating a GraphQL server with NodeJS**](https://medium.com/crowdbotics/creating-a-graphql-server-with-nodejs-ef9814a7e0e6)

In the article below, I will describe how to take an existing Web Application that is build using MongoDB, ExpressJS, [Node.js](http://crowdbotics.com/build/node-js?utm_source=medium&utm_campaign=nodeh&utm_medium=node&utm_content=mern), and [React](https://www.crowdbotics.com/build/react) (often called as MERN stack) on a deployment service like Heroku. If you have an existing application built using the same tech stack, you can definitely skip the process in which I show you to quickly build a web application and go straight on to the deployment part.

[**Deploy a MERN stack app on Heroku**](https://medium.com/crowdbotics/deploy-a-mern-stack-app-on-heroku-b0c255744a70)

Another MERN related in-detail article where you will learn to create a JWT powered login/signup system with glimpse into using Material UI library with ReactJS.

[**Building a MERN Stack App With Material UI**](https://medium.com/crowdbotics/building-a-mern-stack-app-with-material-ui-33ff8ca4da01)

### React Native

Building a React or React Native application in the real world can become complex if there is not a proper way to handle data. If at any point the data is not managed, things will get out of hand. Redux is an important part of the React Native ecosystem. If your world revolves around JavaScript, youâ€™ve probably heard about Redux. Before reading the rest of the tutorial and going further, just try to remember that you are only learning about Redux because it will make things easier for you, and not more difficult.

[**How to integrate Redux into your application with React Native and Expo**](https://medium.freecodecamp.org/how-to-integrate-redux-into-your-application-with-react-native-and-expo-ec37c9ca6033)

React Native is a great framework to develop cross-platform mobile applications for the platforms iOS and Android. In this, Iâ€™m going to take you through the process of building a â€œminimalistâ€ weather application using React Native by fetching real-time data

[**Building a Minimalist Weather App with React Native and Expo**](https://blog.expo.io/building-a-minimalist-weather-app-with-react-native-and-expo-fe7066e02c09)

My most acclaimed article so far in 2018 is the one below. It guides how to get started using React Native and tries to clear the misconceptions that I have found in somewhere about React Native using DOM and is a hybrid app development framework. It is not.

[**React Native: How to Setup Your First App**](https://hackernoon.com/react-native-how-to-setup-your-first-app-a36c450a8a2f)

In 2019, I look forward to add more value to the tech community and help fellow developers achieve their goals and may be reach another half million views.

[Originally published at Hackernoon](https://medium.com/hackernoon/my-top-tutorials-in-web-development-and-react-native-in-2018-627da9e0481f)

---

## How to use React Navigation in a React Native App
Slug: navigation-in-a-react-native-app

Navigation plays an important role in mobile applications. Without navigation, there will be little use of an application. In this tutorial, we are going to learn how to implement Navigation in a React Native application from scratch. If you are familiar with web, or Reactjs as library, overall concept of navigation is same. It is used to navigate to different pages or screens (in our case). However, the implementation of a navigation library here is different from the web.

### Getting Started

Before building a mobile application it is recommended that one spends an amount of time strategize how the application will handle navigation and routing. In this module, we will be covering different navigation techniques available to us. First, let us setup our project. We will use **react native CLI tool** for this. If you havenâ€™t installed it, type the first line otherwise if you already installed, you can skip the first command.

Next, we will navigate into the new project directory and will run the project to see if everything is working fine by running the following command.

<img src='https://cdn-images-1.medium.com/max/800/1*NlX0zu7oVyFJv_CKdLXMMg.png' />

After that, we will install the dependency we need to implement navigation in our application.

```shell
yarn add react-navigation
```

Now that we have created our bare minimum application and have the required dependencies installed, we can start by creating our components and look at different navigation techniques.

### Stack Navigation

Stack Navigation is exactly what the word _stack_ refers to. It is a pile of screens or app pages that can be removed from the top. It follows a simple mechanism, _last in, first out_. It stack navigator, it means, adding screens on top of each other. To implement this we will create three screens inside the directory `src/`. If the directory name is not available to you, do create one. These three screens areÂ `.js` files: `ScreenOne`, `ScreenTwo` and `ScreenThree`.

```shell
// ScreenOne.js
import React, { Component } from 'react';
import { View, StyleSheet, TouchableHighlight, Text } from 'react-native';

class ScreenOne extends Component {
	static navigationOptions = {
		title: 'Welcome'
	};
	render() {
		const { navigate } = this.props.navigation;
		return (
			<View style={styles.container}>
				<TouchableHighlight
					onPress={() => navigate('ScreenTwo', { screen: 'Screen Two' })}
					style={styles.button}
				>
					<Text style={styles.buttonText}>Screen One </Text>
				</TouchableHighlight>
			</View>
		);
	}
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: 'center',
		alignItems: 'center'
	},
	button: {
		alignSelf: 'stretch',
		marginLeft: 10,
		marginRight: 10,
		borderRadius: 5,
		height: 40,
		justifyContent: 'center'
	},
	buttonText: {
		color: 'teal',
		fontSize: 22,
		alignSelf: 'center'
	}
});
export default ScreenOne;

// ScreenTwo.js
import React, { Component } from 'react';
import { View, StyleSheet, TouchableHighlight, Text } from 'react-native';

class ScreenTwo extends Component {
	static navigationOptions = ({ navigation }) => {
		return {
			title: `Welcome ${navigation.state.params.screen}`
		};
	};

	render() {
		const { state, navigate } = this.props.navigation;
		return (
			<View style={styles.container}>
				<Text style={styles.titleText}>{state.params.screen}</Text>

				<View style={styles.buttonContainer}>
					<TouchableHighlight
						onPress={() => this.props.navigation.goBack()}
						style={[styles.button, { backgroundColor: '#3b3b3b' }]}
					>
						<Text style={styles.buttonText}>Go Back</Text>
					</TouchableHighlight>

					<TouchableHighlight
						onPress={() => navigate('ScreenThree', { screen: 'Screen Three' })}
						style={[styles.button, { backgroundColor: '#4b4bff' }]}
					>
						<Text style={styles.buttonText}>Next</Text>
					</TouchableHighlight>
				</View>
			</View>
		);
	}
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: 'center',
		alignItems: 'center'
	},
	button: {
		alignSelf: 'stretch',
		marginLeft: 10,
		marginRight: 10,
		borderRadius: 5,
		height: 40,
		justifyContent: 'center'
	},
	buttonText: {
		color: 'white',
		fontSize: 22,
		alignSelf: 'center'
	}
});
export default ScreenTwo;

// ScreenThree.js
import React, { Component } from 'react';
import { StyleSheet, View, Text, TouchableHighlight } from 'react-native';

class ScreenThree extends Component {
	static navigationOptions = ({ navigation }) => ({
		title: `Welcome ${navigation.state.params.screen}`
	});

	render() {
		const { params } = this.props.navigation.state;
		return (
			<View style={styles.container}>
				<Text style={styles.titleText}>{params.screen}</Text>
				<TouchableHighlight
					style={styles.button}
					onPress={() => this.props.navigation.goBack()}
				>
					<Text style={styles.buttonText}>Go Back</Text>
				</TouchableHighlight>
			</View>
		);
	}
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: 'center',
		alignItems: 'center'
	},
	titleText: {
		fontSize: 22
	},
	button: {
		alignSelf: 'stretch',
		marginRight: 25,
		marginLeft: 25,
		marginTop: 20,
		borderRadius: 20,
		backgroundColor: '#ff0044',
		height: 50,
		justifyContent: 'center'
	},
	buttonText: {
		color: 'white',
		fontSize: 18,
		alignSelf: 'center'
	}
});

export default ScreenThree;
```

Notice, in all three screens we have access `navigation.state` as props and `navigationOptions` as a static object. The navigationOptions takes header options for the screen title _Welcome_. In the application screen above, you will see the Welcome text in the toolbar. Other header options include `headerTitle`, `headerStyle` and many more. This is made available to us by `react-navigation` dependency.

`this.props.navigation` object also different properties that we can directly access in our component. The first, `navigate` is used to specify screen to navigate. Next, `goBack()` is the method that helps us navigate back to the previous screen, if available. Lastly, the `state` object help us keep track of the previous and the new state.

Using `onPress()` handler we can also access the screen directly as we are doing in `ScreenOne.js`. Just pass the component and the screen name as an argument.

```js
onPress={() => navigate('ScreenTwo', { screen: 'Screen Two' })}
```

All of these methods and objects are made available to our components because of below configuration. To make use of these three screens, and see how Stack Navigation works in action, we will modify our `App.js` as:

```js
import React from 'react';

import { StackNavigator } from 'react-navigation';
import ScreenOne from './src/stack/ScreenOne';
import ScreenTwo from './src/stack/ScreenTwo';
import ScreenThree from './src/stack/ScreenThree';

const App = StackNavigator({
  ScreenOne: { screen: ScreenOne },
  ScreenTwo: { screen: ScreenTwo },
  ScreenThree: { screen: ScreenThree }
});

export default App;
```

We are importing `StackNavigator` from `react-navigation` and all other screens we created inside the source directory.

<img src='https://cdn-images-1.medium.com/max/800/1*7ucBAxqZoAqvDGEbHfSniQ.png' />

_Screen One_

<img src='https://cdn-images-1.medium.com/max/800/1*mwaLBOP-jYybqXn4dN10Sg.png' />

_Screen Two_

<img src='https://cdn-images-1.medium.com/max/800/1*1i4GrVvkqB1qHoF5GjY5mQ.png' />

_Screen Three_

### Tab Navigation

The way Tab Navigation work is different from Stack Navigator. The different screens will be available to the UI at one point and there is no first or next screen. The user can access each tab from the Tab Menu. To create a Tab Navigation menu, we need to import `createBottomTabNavigator`. Let us see how it works. This time, we will edit the `App.js` code.

```js
// App.js
import React from 'react';
import { Text, View } from 'react-native';
import { createBottomTabNavigator } from 'react-navigation';

class HomeScreen extends React.Component {
  render() {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text>Home!</Text>
      </View>
    );
  }
}

class SettingsScreen extends React.Component {
  render() {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text>Settings!</Text>
      </View>
    );
  }
}

export default createBottomTabNavigator({
  Home: HomeScreen,
  Settings: SettingsScreen
});
```

<img src='https://cdn-images-1.medium.com/max/800/1*f8_SrGnqj7wR7m31-9bnVg.png' />

Of course, you can modularize it a bit by separating Home and Setting screen in different components of their own. For our demo application, the above example serves the purpose. You can add `tabBarOptions` to modify its look and feel.

```js
export default createBottomTabNavigator(
  {
    Home: HomeScreen,
    Settings: SettingsScreen
  },
  {
    tabBarOptions: {
      activeTintColor: 'red',
      inactiveTintColor: 'black'
    }
  }
);
```

<img src='https://cdn-images-1.medium.com/max/800/1*tATWRPRM39a6UkruTayrTw.png' />

### Conclusion

It might take a while to grasp them and use them for your application but once you get the whole of the basic concept, you can do wonders with it. You can even integrate Stack and Tab Navigators for complex scenarios. [react-navigation](https://reactnavigation.org/docs/en/getting-started.html) has a good documentation.

[Originally published at Hackernoon.com](https://medium.com/hackernoon/navigation-in-a-react-native-app-cf61ed85e80b)

---

## Nesting Tab and Stack navigators in React Native and Expo apps
Slug: nested-navigators-in-react-native

Using [`react-navigation`](https://reactnavigation.org/docs/en/getting-started.html) you can definitely nest different types of navigators. The term nesting navigators mean that rendering one navigator inside a screen of another navigator.

The possible scenarios of nesting navigators are:

- Stack navigator nested inside drawer navigator
- Tab navigator nested inside stack navigator
- Stack navigator nested inside a tab navigator

In this tutorial, let us examine one of the above scenarios by nesting Tab inside a stack navigator. Whether you are following from the previous tutorial on building a stack navigator using a component-based configuration with the latest version of the react-navigation library, or not, here is the source code of the Expo demo app that is going to be leveraged. This demo app, already has a stack navigator running. You can download the source code from the Github rep [here](https://github.com/amandeepmittal/react-native-examples/tree/master/reactnav5-stack-navigator).

## Table of contents

- Install dependencies
- Create a mock screen
- Create a tab navigator
- Adding icon and changing active tint color
- Passing `screenOptions` in a Tab Navigator
- Updating the header title for the nested child navigator
- Conclusion

## Requirements

Requirements for this tutorial is simple. Have the following installed on your local dev environment.

- Node.js version >= `10.x.x` installed
- Have access to one package manager such as npm or yarn
- Latest `expo-cli` version installed or use npx

Do note that, without dwelling much into the configuration of native binaries with the `react-navigation` library, I am going to use a project that is already generated using `expo-cli`. If you wish to start afresh, choose the blank template.

## Install dependencies

Install the following dependency to setup a Tab Navigator. Run the following command from a terminal window.

```shell
yarn add @react-navigation/bottom-tabs
```

This package is going to allow the app to have a simple tab bar appear at the bottom of the screen and switch between different routes. The demo app we are going to build is going to consist of two tabs. We are going to nest the stack navigator inside the first tab and create a mock screen for the second tab.

## Create a mock screen

Even though the current app structure has three different screen components (_open `src/screens` to view them_), let us create another screen component called `Profile` that will act as the second tab. Create a new file called `src/screens/Profile.js` with the following code snippet:

```js
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';

function Profile(props) {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Profile Tab</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  }
});

export default Profile;
```

## Create a tab navigator

In this section, let us set up a basic Tab navigator. Start by renaming the file `MainStackNavigator` to `AppNavigator.js` in the directory `src/navigation`.

After the renaming, the routes config file, after other import statements, import the `createBottomTabNavigator` from `@react-navigation/bottom-tabs` as well as the `Profile` screen component.

```js
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
// add this after other import statements
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

import Home from '../screens/Home';
import Detail from '../screens/Detail';
import Settings from '../screens/Settings';
// add this after other import statements
import Profile from '../screens/Profile';
```

Then create an instance of the `createBottomTabNavigator` called `Tab` as below:

```js
// after other instances
const Tab = createBottomTabNavigator();
```

Next, create a function called `MainTabNavigator()`. Using `Tab.Navigator` you can define the structure of the routes and use `Tab.Screen` you can define each of the routes.

Let us define tab routes for now: `Home` and `Profile`.

```js
function MainTabNavigator() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={Home} />
      <Tab.Screen name="Profile" component={Profile} />
    </Tab.Navigator>
  );
}
```

Now, in the `MainStackNavigator()` instead of passing the `Home` screen, let us pass the `MainTabNavigator`.

```js
<Stack.Screen name="Home" component={MainTabNavigator} />
```

Lastly, to make all of this work, open `App.js` file in the root of the project and modify the statement that imports the `MainStackNavigator` with the correct file name.

```js
import React from 'react';

// make sure this matches the file name of navigator config
import MainStackNavigator from './src/navigation/AppNavigator';

export default function App() {
  return <MainStackNavigator />;
}
```

Go back to the terminal window, execute `expo start` and open up an Expo client inside a simulator or a real device. You are going to get the following result.

<img src='https://miro.medium.com/max/369/1*_noQNKBA1wUf8EkgNyCsQA.gif' />

## Adding icon and changing active tint color

From the last image, you notice that the active tab is highlighted by a tint color of blue and the non-active tab is of gray. Let us change this tint color.

Open `AppNavigator.js` file at `Tab.Navigator` add a prop called `tabBarOptions`. This prop allows you to customize the tab bar shared between different routes.

Add the following:

```js
<Tab.Navigator
  tabBarOptions={{
    activeTintColor: '#101010'
  }}
>
  {/* rest remains same */}
</Tab.Navigator>
```

Go to the simulator device, you are going to notice that the active tab bar label has a color of black from the previous blue.

<img src='https://miro.medium.com/max/350/1*y3hy861GwUm_mj1HCvr3Ew.png' />

Let us add some icons to the tab bar. Start by importing the `Ionicons` from `@expo/vector-icons`.

```js
import { Ionicons } from '@expo/vector-icons';
```

Then, in each `Tab.Screen`, add an options prop that is going to have a property of `tabBarIcon`. This function returns the component `Ionicons`. Pass the arguments `color` and `size` you can maintain the active tint color.

```js
<Tab.Navigator
  tabBarOptions={{
    activeTintColor: '#101010'
  }}
>
  <Tab.Screen
    name="Home"
    component={Home}
    options={{
      tabBarIcon: ({ color, size }) => (
        <Ionicons name="ios-home" color={color} size={size} />
      )
    }}
  />
  <Tab.Screen
    name="Profile"
    component={Profile}
    options={{
      tabBarIcon: ({ color, size }) => (
        <Ionicons name="ios-person" size={size} color={color} />
      )
    }}
  />
</Tab.Navigator>
```

Here is the output:

<img src='https://miro.medium.com/max/350/1*3G4fINzTR9vNIGQzujkegQ.png' />

You can even change the background of the tab bar by adding a `style` property to `tabBarOptions`.

```js
<Tab.Navigator
  tabBarOptions={{
    activeTintColor: '#101010',
    style: {
      backgroundColor: '#ffd700'
    }
  }}
>
  {/* rest remains same */}
</Tab.Navigator>
```

Here is the output for the above snippet:

<img src='https://miro.medium.com/max/350/1*Gxk9p_0XQ2z-y-sYHH7Epw.png' />

## Passing screenOptions in a Tab Navigator

The previous section is one way to add icons to each route or screen in the tab bar. There is another way you can do it by passing `screenOptions` in the wrapper `Tab.Navigator`. This prop is used to modify or add common styles to a navigator.

```js
function MainTabNavigator() {
  return (
    <Tab.Navigator
      tabBarOptions={{
        activeTintColor: '#101010',
        style: {
          backgroundColor: '#ffd700'
        }
      }}
      screenOptions={({ route }) => ({
        tabBarIcon: ({ color, size }) => {
          let iconName;
          if (route.name == 'Home') {
            iconName = 'ios-home';
          } else if (route.name == 'Profile') {
            iconName = 'ios-person';
          }
          return <Ionicons name={iconName} color={color} size={size} />;
        }
      })}
    >
      <Tab.Screen name="Home" component={Home} />
      <Tab.Screen name="Profile" component={Profile} />
    </Tab.Navigator>
  );
}
```

There is no change in the functioning of the tab navigator from the previous section, as you can notice below:

<img src='https://miro.medium.com/max/369/1*X06mUqbYfHKYEDdPAVBJjA.gif' />

## Updating the header title for the nested child navigator

Right now the title for each tab screen is going to be the same. This is because the root navigator (which, here is the Stack Navigator) structure is going to look at its immediate children, which are Home, Detail and Settings screen. In the current scenario, if you are to set the title for the `Profile` screen passing the prop `options`, it is not going to work.

This is because the `Profile` screen is a child of the Tab Navigator and not Stack Navigator. The tab navigator is nested inside the Stack navigator and thus, Profile is not the immediate child to Stack Navigator.

For each tab to have its own title (since the tab navigator is nested inside the stack navigator), you have to determine the title for a specific tab screen based on the navigation state from the property `route.state`.

This can be done by defining a helper function called `getHeaderTitle` that has `route` as its parameter. Why pass `route`? Because it contains the `state` property which refers to the child's navigator state and the value of the currently active route name can be obtained from this state.

Add a function called `getHeaderTitle` in `AppNavigator.js` file.

```js
function getHeaderTitle(route) {
  const routeName = route.state
    ? route.state.routes[route.state.index].name
    : route.params?.screen || 'Home';

  switch (routeName) {
    case 'Home':
      return 'Home';
    case 'Profile':
      return 'Profile';
  }
}
```

Then, [as per the recommended way](https://reactnavigation.org/docs/en/screen-options-resolution.html#__docusaurus), add the options prop to the `Stack.Screen` route whose value is `Home`.

```js
<Stack.Screen
  name="Home"
  component={MainTabNavigator}
  options={({ route }) => ({
    headerTitle: getHeaderTitle(route)
  })}
/>
```

Now, when visiting the `Profile` tab, you are going to get the desired title in the header.

<img src='https://miro.medium.com/max/369/1*gCs24QDMEQ_D6DcDxjiALw.gif' />

## Conclusion

_Congratulations! Youâ€™ve completed this tutorial._

In this tutorial, we discuss only one scenario of nesting navigators. The main objective here is to get familiar with the component-based configuration of the Tab Navigator in the latest version of the `react-navigation` library.

Here is the link to the complete Tab Navigator API [here](https://reactnavigation.org/docs/en/bottom-tab-navigator.html) I'd recommend you to check.

You can find the complete code for this tutorial at this [GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/reactnav5-tab-navigator).

Originally published at [Heartbeat.fritz.ai](https://heartbeat.fritz.ai/nesting-tab-and-stack-navigators-in-react-native-and-expo-apps-cc118a141e70)

---

## New blog theme
Slug: new-blog-theme-and-colors

Finally, I've updated the blog theme style and colors to represent the code snippets in a way I like. The colors or I should say, the code theme used is `rose-pine-moon`. Using [Shiki](https://shiki.style/guide/) makes it easier to switch between any supported them for the code.

Currently, the Astro Paper template I am using for this blog, it's a matter of updating the theme name in `shikiConfig` inside the `astro.config.ts` file.

```ts
export default {
  markdown: {
    shikiConfig: {
      theme: 'rose-pine-moon'
    }
  }
};
```

This code snippet is a configuration object that customizes the appearance of code blocks in a documentation system or website. Specifically, it sets up Shiki, a syntax highlighter, to use the 'rose-pine-moon' color theme. Shiki is a popular tool that provides syntax highlighting for code snippets in markdown files and Astro includes it by default.

To change light and dark mode theme colors, I've updated the base styles applied from `base.css`:

```css
@layer base {
  :root,
  html[data-theme='light'] {
    --color-fill: 255, 252, 249;
    --color-text-base: 34, 34, 34;
    --color-accent: 0, 0, 0;
    --color-card: 243, 244, 246;
    --color-card-muted: 248, 248, 248;
    --color-border: 229, 229, 229;
  }
  html[data-theme='dark'] {
    --color-fill: 34, 34, 34;
    --color-text-base: 255, 252, 249;
    --color-accent: 255, 255, 255;
    --color-card: 51, 51, 51;
    --color-card-muted: 68, 68, 68;
    --color-border: 85, 85, 85;
  }
}
```

Within the base layer, a light and a dark mode theme are defined by `html[data-theme='light'])` and `html[data-theme='dark'])`. Each theme sets the values of CSS variables that are used throughout the site to define colors. For example, `--color-fill` is used to set the background color of the site, `--color-text-base` is used to set the text color, and so on.

---

## Writing a Node.js Twitter Bot Part 2
Slug: node-js-twitter-bot-tutorial-part-2

If you read the [first part of my tutorial](https://community.risingstack.com/node-js-twitter-bot-tutorial/), you already know how to make a Twitter Bot with Node.js that retweets and favorites tweets using the Twitter API.

In the second part of the Twitter Bot tutorial, we will continue to extend our Bot by adding functionality that will tweet back to any Twitter user who follows our bot.

Before starting this, make sure your directory structure includes:

- `package.json` (the configuration file for our Node.js application)
- `config.js` (the configuration file of our Twitter application that contains both consumer and access key & tokens)
- `bot.js` (our main application file)

The representation would be:

```shell
root/project-name
|- bot.js
|- config.js
|- package.json
```

You can take a look at the complete bot.js file from [the first part of this tutorial](https://community.risingstack.com/node-js-twitter-bot-tutorial/).

Also, make sure you have the [twit](https://www.npmjs.com/search?q=twit) npm module installed.

## How to make a Twitter bot that replies

After setting up the dependencies and loading/requiring the configuration related to our application, we are going to develop a functionality that is going to tweet back to a Twitter user who follows the Bot's Twitter Handler.

We are going to use [Twitter's Streaming API](https://dev.twitter.com/streaming/overview) to interact with our followers.

## Setting up the Streams API

First, we have to set up a stream. Fortunately, the third party npm dependency `twit` provides an API function `.stream()` to do this task.

```js
// Use Streams API for interacting with a USER
// set up a user stream

var stream = Twitter.stream('user');
```

`.stream()` keeps the connection alive, and returns an `EventEmitter`.

`twit` provides a list of stream events to listen on, such as 'follow', 'unfollow', 'favorite' and 'unfavorite'.

Right now we are only interested in the follow event, however the basic syntax is similar to every event.

```js
// when someone follows
stream.on('follow', followed);
```

When a user follows our Twitter Bot, the `follow` event will trigger the callback associated with it, in our case `followed`.

```js
// ...trigger the callback
function followed(event) {
    console.log('Follow Event is running');
    //get user's twitter handler (screen name)
    var name = event.source.name,
    var screenName = event.source.screen_name;
    // function that replies back to the user who followed
    tweetNow('@' + screenName + ' Thank you for the follow up.');
}
```

## Replying with tweetnow()

In the followed callback, we pass an event argument which gets the Twitter handle and the screen name of the user. In the last line, we invoke a `tweetnow()` function that replies back to the user who followed our bot.

The `tweetnow()` function takes a string as an argument and updates our bots status. In other terms, it tweets by using `.post()`function provided by the `twit` API to post to the `statuses/update`Twitter API endpoint.

This endpoint gets called whenever you tweet from your Twitter account.

If you noticed in the [previous tutorial](https://community.risingstack.com/node-js-twitter-bot-tutorial/) when retweeting or to favorite a tweet, we used `.post()` to update our status.

```js
function tweetNow(tweetTxt) {
  var tweet = {
    status: tweetTxt
  };
  Twitter.post('statuses/update', tweet, function (err, data, response) {
    if (err) {
      console.log('Error in Replying');
    } else {
      console.log('Gratitude shown successfully');
    }
  });
}
```

Unlike in the previous tutorial, we don't need JavaScripts Timer function this time, since we are using the Streaming API which helps to keep the connection alive.

Here comes the complete code of our bot:

```js
// Use Streams API for interacting with a USER ==========
// set up a user stream

var stream = Twitter.stream('user');

// FOLLOW-Reply BOT ===========================

// when someone follows
stream.on('follow', followed);

// ...trigger the callback
function followed(event) {
  console.log('Follow Event is running');
  //get their twitter handler (screen name)
  var name = event.source.name,
    screenName = event.source.screen_name;
  // function that replies back to the user who followed
  tweetNow('@' + screenName + ' Thank you for the follow up.');
}

// function definition to tweet back to user who followed
function tweetNow(tweetTxt) {
  var tweet = {
    status: tweetTxt
  };
  Twitter.post('statuses/update', tweet, function (err, data, response) {
    if (err) {
      console.log('Error in Replying');
    } else {
      console.log('Gratitude shown successfully');
    }
  });
}
```

## Running the Twitter Bot

To run this bot, go to your terminal:

```shell
node bot.js
```

To avoid this monotonous process, you can use npm scripts or `nodemon`. You can also deploy this app on Heroku for a continuous deployment.

If you are planning to deploy on Heroku, make sure to include a `Procfile` in the root of your directory structure and add the following line to the file:

```shell
worker: node bot.js
```

If you are using npm scripts, make sure you edit the `scripts` attribute in the`package.json` file:

```json
{
  "scripts": {
    "start": "node bot.js"
  }
}
```

Then to run from terminal:

```shell
$ npm start
```

## Next up

To do further smart things with your bot, go and check out the [twit documentation](https://www.npmjs.com/package/twit) for other RESTful API methods and Streaming API events.

If you are interested in Twitter Bots, check [Botwiki.org](https://botwiki.org/bots/twitterbots/) - as they have the vast collection of Twitter Bots in different programming languages.

The sole purpose of Bot as a web application is automation. For example, when I created my first Twitter Bot [@nodejstweets](https://x.com/nodejstweet), the whole idea was to remain up to date with the most recent happenings.

You can do a lot of things with a Twitter Bot, whether for your own sole purpose or to solve a purpose for a community. See [@100DaysOfCode](http://twitter.com/@_100DaysOfCode) as a great example.

[Originally Published at RisingStack.com](https://community.risingstack.com/how-to-make-a-twitter-bot-with-node-js/)

---

## Writing a Node.js Twitter Bot Part 1
Slug: node-js-twitter-bot-tutorial

In this tutorial, we will create a Twitter Bot with Node.js that retweets or favorites based on hashtags, and replies to users if they follow the account.

## What do you need to create this bot?

- You must have [Node.js](http://nodejs.org) installed on your system.
- A Twitter Account.
- Your bot will be using [`twit`](https://www.npmjs.com/package/twit) which is an npm module to manipulate tweets and streams, and to communicate with the [Twitter API](https://dev.twitter.com/docs).

## Letâ€™s Start

Setup an empty directory and initialise it with:`$ npm init` to configure this web application with `package.json` file. Then create two new files: `bot.js` & `config.js` in that directory.

`bot.js` will be our main app file in which we will be writing the source code of our Twitter Bot, and so in `package.json` edit the `main` field to:

```json
{
  "main": "bot.js"
}
```

Your current directory structure should look like this:

```shell
root/project-name
|- bot.js
|- config.js
|- package.json
```

## Configuring and granting permissions from TwitterÂ API

After logging to to your Twitter account, follow to this link: [https://apps.twitter.com/app/new](https://apps.twitter.com/app/new) to create a new application. Fill out the necessary fields in the form click on the button _Create Your Twitter Application._ After creating the application, look for `Keys and Access Tokens` under the nav-panes and click on `Generate Token Actions\` and then copy:

- Consumer Key
- Consumer Secret
- Access Token
- Access Token Secret

Open the `config.js` file and paste all four values inside it. Expose those values using `module.export`:

```js
//config.js
/\*\* TWITTER APP CONFIGURATION
 \* consumer\_key
 \* consumer\_secret
 \* access\_token
 \* access\_token\_secret
 \*/

module.exports = {
  consumer\_key: '',
  consumer\_secret: '',
  access\_token: '',
  access\_token\_secret: ''
}
```

Now, the Twitter botâ€™s configuration is step is complete. _Please note,_ for every different application, the `consumer key`, `consumer secret`, `access_token` and `access_token_secret` will differ.

## Building theÂ bot

Since the configuration step is complete, now letâ€™s install our third requisite that is [Twitter API client for node](https://www.npmjs.com/package/twit) and will help us to communicate to Twitter API and provide an API for all necessary actions _(such as retweet and favorite a tweet)._

We will start by installing the dependency we need for our application.

```shell
$ npm install --save twit
```

After the dependency has finished installing, go to the `bot.js` file and require the dependency and `config.js` file.

```js
var twit = require(â€™twitâ€™);
var config = require(â€™./config.jsâ€™);
```

Pass the configuration (_consumer and access tokens_) of our Twitter application in `config.js` to `twit:`

```js
var Twitter = new twit(config);
```

So far, so good?

**PLEASE NOTE: You must refer to** `[**twit**](https://www.npmjs.com/package/twit)` [**documentation**](https://www.npmjs.com/package/twit) **for a deep reference.**

#### Retweet Bot

Letâ€™s write a function expression that finds the latest tweets according to the query passed as a parameter. We will initialise a `params` object that will hold various properties to search a tweet, but most importantly `query` or `q` property that will refine our searches. Whatever value you feed in this property, our bot will search the tweets to retweet based on this criteria. You can feed this property values like a twitter handler, to monitor a specific twitter account or a #hashtag. For our example bot, we have find latest tweets on #nodejs.

This is how the functionality of the retweet bot starts:

```js
var retweet = function() {
  var params = {
    q: '#nodejs, #Nodejs',
    result\_type: 'recent',
    lang: 'en'
  }
```

The other two properties: `result_type` and `lang` are optional. On defining the `result_type: 'recent'` notifies bot to only search for the latest tweets, tweets that have occurred in the time period since our bot has started or it made the last retweet.

[There is a list of parameters provided by the Twitter API](//%20for%20more%20parametes,%20see:%20https://dev.twitter.com/rest/reference/get/search/tweets).

Our next step is to search for the tweets based on our parameters. For this, we will use `Twitter.get` function provided by `twit` API to GET any of the REST API endpoints. The REST API endpoint is a reference to the T[witter API endpoint](https://dev.twitter.com/docs) we are going to make a call to search for tweets. The `Twitter.get` function accepts three arguments: API endpoint, params object (defined by us) and a callback.

```js
// RETWEET BOT ==========================

// find latest tweet according the query 'q' in params
var retweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  // for more parameters, see: https://dev.twitter.com/rest/reference/get/search/tweets

  Twitter.get('search/tweets', params, function (err, data) {
    // if there no errors
    if (!err) {
      // grab ID of tweet to retweet
      var retweetId = data.statuses[0].id_str;
      // Tell TWITTER to retweet
      Twitter.post(
        'statuses/retweet/:id',
        {
          id: retweetId
        },
        function (err, response) {
          if (response) {
            console.log('Retweeted!!!');
          }
          // if there was an error while tweeting
          if (err) {
            console.log(
              'Something went wrong while RETWEETING... Duplication maybe...'
            );
          }
        }
      );
    }
    // if unable to Search a tweet
    else {
      console.log('Something went wrong while SEARCHING...');
    }
  });
};
```

To post or to retweet the tweet our bot has found we use `Twitter.post()` method to _POST any of the REST API endpoints_. It also takes the same number of arguments as `Twitter.get()`.

Now to automate this action we defined above, we can use JavaScriptâ€™s timer function `setInterval()` to search and retweet after a specific period of time.

```js
// grab & retweet as soon as program is running...
retweet();
// retweet in every 50 minutes
setInterval(retweet, 3000000);
```

Please note that all JavaScriptâ€™s Timer functions take the _amount of time_ argument in milliseconds.

#### Favorite Bot

Similar to `retweet` bot we can define and initialise another function expression that will search and _favorite_ a tweet randomly. Yes, the difference here is to search and grab the tweet randomly. We will start by creating a parameter object `params` that will consist of three properties as in `retweet()` function expression. The bot will search for tweets using the sameÂ `.get()` function provided by `twit` API to GET any of the Twitter API endpoints. In our case, we need `search/tweets`. Then we will store the status of the search for tweet to _favorite_ in a variable and in a another variable we will apply the random function by passing the â€œstatus of the searchâ€ variable as an argument.

```js
// FAVORITE BOT====================

// find a random tweet and 'favorite' it
var favoriteTweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  // for more parameters, see: https://dev.twitter.com/rest/reference

  // find the tweet
  Twitter.get('search/tweets', params, function (err, data) {
    // find tweets
    var tweet = data.statuses;
    var randomTweet = ranDom(tweet); // pick a random tweet

    // if random tweet exists
    if (typeof randomTweet != 'undefined') {
      // Tell TWITTER to 'favorite'
      Twitter.post(
        'favorites/create',
        { id: randomTweet.id_str },
        function (err, response) {
          // if there was an error while 'favorite'
          if (err) {
            console.log('CANNOT BE FAVORITE... Error');
          } else {
            console.log('FAVORITED... Success!!!');
          }
        }
      );
    }
  });
};
// grab & 'favorite' as soon as program is running...
favoriteTweet();
// 'favorite' a tweet in every 60 minutes
setInterval(favoriteTweet, 3600000);

// function to generate a random tweet tweet
function ranDom(arr) {
  var index = Math.floor(Math.random() * arr.length);
  return arr[index];
}
```

Note that the tweets searched by our bot are all stored in an array. Again, we use JavaScriptâ€™s timer function `setInterval()`to search and favorite the tweet after a specific period of time in milliseconds.

The complete module: `bot.js`Â :

```js
// Dependencies =========================
var twit = require('twit'),
  config = require('./config');

var Twitter = new twit(config);

// RETWEET BOT ==========================

// find latest tweet according the query 'q' in params
var retweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  Twitter.get('search/tweets', params, function (err, data) {
    // if there no errors
    if (!err) {
      // grab ID of tweet to retweet
      var retweetId = data.statuses[0].id_str;
      // Tell TWITTER to retweet
      Twitter.post(
        'statuses/retweet/:id',
        {
          id: retweetId
        },
        function (err, response) {
          if (response) {
            console.log('Retweeted!!!');
          }
          // if there was an error while tweeting
          if (err) {
            console.log(
              'Something went wrong while RETWEETING... Duplication maybe...'
            );
          }
        }
      );
    }
    // if unable to Search a tweet
    else {
      console.log('Something went wrong while SEARCHING...');
    }
  });
};

// grab & retweet as soon as program is running...
retweet();
// retweet in every 50 minutes
setInterval(retweet, 3000000);

// FAVORITE BOT====================

// find a random tweet and 'favorite' it
var favoriteTweet = function () {
  var params = {
    q: '#nodejs, #Nodejs', // REQUIRED
    result_type: 'recent',
    lang: 'en'
  };
  // find the tweet
  Twitter.get('search/tweets', params, function (err, data) {
    // find tweets
    var tweet = data.statuses;
    var randomTweet = ranDom(tweet); // pick a random tweet

    // if random tweet exists
    if (typeof randomTweet != 'undefined') {
      // Tell TWITTER to 'favorite'
      Twitter.post(
        'favorites/create',
        { id: randomTweet.id_str },
        function (err, response) {
          // if there was an error while 'favorite'
          if (err) {
            console.log('CANNOT BE FAVORITE... Error');
          } else {
            console.log('FAVORITED... Success!!!');
          }
        }
      );
    }
  });
};
// grab & 'favorite' as soon as program is running...
favoriteTweet();
// 'favorite' a tweet in every 60 minutes
setInterval(favoriteTweet, 3600000);

// function to generate a random tweet tweet
function ranDom(arr) {
  var index = Math.floor(Math.random() * arr.length);
  return arr[index];
}
```

#### Usage

To run this bot, go to your terminal:

```shell
$ node bot.js
```

To avoid this monotonous process you can use `npm scripts` or `nodemon.` You can also deploy this app on `Heroku` for a continuous integration.

To use npm scripts, make this edit under `scripts` in `package.json`Â :

```json
{
  "scripts": {
    "start": "node bot.js"
  }
}
```

Then from terminal:

```shell
$ npm start
```

## Conclusion

There are various ways to write a Twitter Bot, this is just one way. Your bot can be smart and you can do various things with it. You just have to refer to [twit documentation](https://www.npmjs.com/package/twit) for other RESTful API methods to manipulate [Twitter API endpoints](http://REST%20API%20Endpoints:%20https://dev.twitter.com/rest/public).

For further reading check out [Botwiki.org](https://botwiki.org/bots/twitterbots/) for various types of bots on vast amount of platforms. For advanced reading, check out [Botwikiâ€™s list of tutorials of Twitter Bots in different programming languages](https://botwiki.org/tutorials/twitterbots/).

Update: the second part of this tutorial is available [here!](https://community.risingstack.com/how-to-make-a-twitter-bot-with-node-js/)

[Originally Published at RisingStack.com](https://community.risingstack.com/node-js-twitter-bot-tutorial/)

---

## The Node.js system
Slug: nodejs-system

When I started learning Node.js, I always wondered, how does it work? How is it inside Node.js? Event loop and Event Queue jargons are digested. But what exactly is going on? Where do those jargons Event Loop and Event Queue come from.To satisfy my curiosity as well to know the answer to my previous question, I went in depth as much as I can and came across some things which Iâ€™d like to share with you. In brief, this article is about **Node.js System** â€” a glimpse of internal workings of Node.

If you are familiar with Node.js, it is a known fact that Node.js is single threaded. If you are from programming/computer science background you know what a thread means. Consider this scenario: traditionally â€” an I/O request comes to a web server and is assigned to an available thread, and for each concurrent connection there is one thread available. That request is handled on the specific thread until it is fulfilled and the response is sent.

This scenario is a perfect example of **Blocking I/O** because while handling a particular request by a specific thread, there will be some idle time when the operations are being done (such as retrieving a file, opening it, reading it, and so on). A single thread consumes memory. A longer running thread for each connection and then sitting idly for some amount of time is not considered an efficient way in the [world of Node.js](https://medium.com/@amanhimself/the-node-way-philosophy-of-a-platform-f9738ed5f9d2).

## Enter Reactor Pattern- Heart of Node.js

Reactor Pattern is an idea of non-blocking I/O operations in Node.js. This pattern provides a handler(in case of Node.js, a callback function) that is associated with each I/O operation. When an I/O request is generated, it is submitted to a demultiplexer.

This demultiplexer is a notification interface that is used to handle concurrency in non-blocking I/O mode and collects every request in form of an event and queues each event in a queue. Thus, the demultiplexer provides the Event Queue, which we often hear. When a request is collected by the demultiplexer, it returns the control back to the system and does not blocks the I/O. At the same time, there is an Event Loop which iterates over the items in the Event Queue. Every event has a callback function associated with it, and that callback function is invoked when the Event Loop iterates.

The callback function further mostly have other callbacks associated within representing some asynchronous operations. These operations are inserted in the Event Queue by the demultiplexer and are ready to be processed once the Event Loop iterates over them. That is why calls to other operations must be asynchronous.

When all the items in the Event Queue are processed and there are no pending operations left, Node.js terminates the application automatically.

## Building Blocks of Node.js

- Reactor Pattern
- [libuv](http://docs.libuv.org/en/v1.x/)
- A set of Bindings
- Chromeâ€™s V8
- Core JS Library

## libuv

Pronounced as â€œlib u vâ€, is library written in C language to make Node.js compatible with every OS and provide the non-blocking I/O behaviour. libuv is the low-level engine that implements reactor pattern thus providing an API for creating the Event Loop, managing an Event Queue and running asynchronous I/O operations. It is built specifically to provide a unified experience over different Operating Systems.

## Need for libuv?

Each operating system has its own interface for the demultiplexer. Such as Kqueue for Mac OS X, IOCP for Windows and Epoll for Linux. Different multiplexers will behave differently when handling an I/O request. And then, each I/O operation can differ in its behaviour within the same operating system. This creates an inconsistency and to overcome this inconsistency libuv is the solution.

I am not going to talk about internal workings of libuv here, not an expert on that, myself. For more info on libuv [check their docs](http://docs.libuv.org/) or this [slide](http://www.slideshare.net/saghul/libuv-nodejs-and-everything-in-between) by SaÃºl Ibarra CorretgÃ© [(@saghul)](https://x.com/saghul) is a good start.

[Also, libuv is independently maintained by awesome developers.](https://github.com/libuv/libuv)

## Set of Bindings

These set of bindings are responsible for wrapping and exposing libuv and other low-level functionality to JavaScript.

## V8

Itâ€™s a runtime engine[ developed by Google for Chrome browser for JavaScript](https://developers.google.com/v8/). It is the reason Node.js is fast and efficient.

## Core Library

This is a JavaScript library that implements high-level Node.js API (a.k.a. node-core).

<img src='https://miro.medium.com/max/451/1*dTYKv5fII4doUAqJSA51Qg.png' />

The image borrowed above clarifies and represents a complete Node.js System. I hope this article has made things more clear as it did to me.

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/the-node-js-system-51090c35dddc)

---

## Build a Not Hotdog clone with ReactÂ Native
Slug: not-hotdog-clone-react-native

If you're a fan of HBO's Silicon Valley, you'll remember when they launched a real AI-powered mobile app that classifies hotdogs from a given image (or not). Using Google's Vision API, let's try to recreate a working model of the application in React Native.

Google's Vision API is a machine learning tool that classifies details from an image provided as an input. The process of these classifications is based on thousands of different categories that are included in pre-trained API models. The Vision API enables access to these pre-trained models via a REST API.

## What are we building?

<img src='https://cdn-images-1.medium.com/max/800/1*Hg6nlnaROCavW5_YLygtEA.gif' />

## Table of Contents

- Prerequisites
- Setup Firebase Project
- Integrate Firebase SDK with React Native app
- Generate a Google Vision API Key
- Setting Permissions for Camera & Camera Roll
- Create a Header component
- Adding an Overlay Spinner
- Access Camera and Camera Roll
- Add functionality to determine a Hot dog
- Display final results
- Conclusion

## Prerequisites

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- [Node.js](https://nodejs.org/en/) (>=`10.x.x`) with npm/yarn installed.
- [expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli/?) (>=`3.0.9`), previously known as create-react-native-app.
- a [Google Cloud Platform](https://cloud.google.com/) account
- [Firebase Storage](https://console.firebase.google.com/) setup
- Expo Client app for Android or iOS, used for testing the app

## Setup Firebase Project

In this section, let us set up a new Firebase project. If you are already familiar with the process and know how to get a config keys from a Firebase project, you can skip this step.

Visit [Firebase](https://console.firebase.google.com/) and sign-in with your Google ID. Once signed in, click on a new project and enter a name. Lastly, hit the **Create project** button.

<img src='https://cdn-images-1.medium.com/max/800/1*BDhg-K1-ekeYg4D2AAir3A.jpeg' />

After creating the project and being redirected to the dashboard screen, on the left side menu, click the **settings** icon, and then go to **Project settings**.

<img src='https://cdn-images-1.medium.com/max/800/1*yJvioMA9wqdBcPGS5HiwYQ.png' />

The whole the `firebaseConfig` object, as shown above, is required to integrate Firebase with a React Native or Expo app. Save them somewhere or make sure you know how to navigate to this page.

The next step is to setup Firebase storage rules such as to allow to upload image files through the app. From the left-hand side menu in the Firebase console, open **Storage** tab and then choose **Rules**. Modify them as follows.

```shell
service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write
    }
  }
}
```

Firebase setup is complete.

## Integrate Firebase SDK with React Native app

To get started, create a new React Native project. For this demonstration, let us use `expo-cli`, an awesome tool that helps to create React Native apps at a faster rate. Open a terminal window, and run the following series of commands.

```shell
# generate a new app
expo init not-hotdog-app

# navigate inside the app folder
cd not-hotdog-app

# install the firebase SDK & other dependencies
yarn add firebase@6.0.1 expo-permissions
expo-image-picker uuid react-native-elements
```

> Also, this tutorial is using `yarn` as the package manager but you are most welcome to use `npm`.

Now that the project is generated open the directory in your favorite text editor. Then create a new folder called `config` and inside it, a new file called `Firebase.js`. This file will be responsible for integrating Firebase with the Expo app.

```js
import * as firebase from 'firebase';

const firebaseConfig = {
  apiKey: 'XXXX',
  authDomain: 'XXXX',
  databaseURL: 'XXXX',
  projectId: 'XXXX',
  storageBucket: 'XXXX',
  messagingSenderId: 'XXXX',
  appId: 'XXXX'
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);

export default firebase;
```

All the Xs are values of each key in the `firebaseConfig` object from the previous section. This completes the step to integrate a Firebase Web SDK with an Expo app.

## Generate a Google Vision API Key

Once you are signed in to Google Cloud Platform, you can visit the [Google Cloud Console](https://console.cloud.google.com/), to create a new project.

<img src='https://cdn-images-1.medium.com/max/800/1*xVCIMrUY0EDtGMfUKJC5Hg.png' />

From the dropdown menu center, select a project. Then click the button **New Project** in the screen below. Notice you have already generated a Firebase project, select that from the list available.

<img src='https://cdn-images-1.medium.com/max/800/1*FUsemE_BjGBUN2T1gorSUg.png' />

Right now you are at the screen called **Dashboard** inside the console. From the top left, click on the menu button and a sidebar menu will pop up. Select **APIs & Services > Dashboard**.

<img src='https://cdn-images-1.medium.com/max/800/1*ggHFyid_JjNABDZh6JfsMA.png' />

At the Dashboard, select the button **Enable APIs and Services**.

<img src='https://cdn-images-1.medium.com/max/800/1*rhVkQAIWdeqV9wSZsjacew.jpeg' />

Then search for the **Vision API** and make sure to click the button **Enable**.

<img src='https://cdn-images-1.medium.com/max/800/1*DzHGkXJQyTeYCHqETkhIPA.jpeg' />

Now, go back to the **Dashboard** and go to **Credentials** to generate an API key. Click the button **Create Credentials** and you will undergo a small process to generate the API key.

<img src='https://cdn-images-1.medium.com/max/800/1*8SdYi2l3aGS3VcvG7PU-Fg.jpeg' />

Once it is done, save the API key in `App.js` file after all the import statements.

```js
const VISION_API_KEY = 'XXXX';
```

The setup is complete. Let us move to the next section and start building the application.

## Setting Permissions for Camera & Camera Roll

To set permissions in any Expo app, all you need is to utilize an asynchronous method from the module `expo-permissions`. For this clone, there are two permissions that need to be set. The required permissions are for Camera and Camera Roll (or Photos of your device).

Camera roll is used in a case where the user wants to upload an image. For iOS simulator devs, you cannot access the camera so if you are not planning to use a real device until the end of this tutorial, but want to follow along. It is recommended to add Camera Roll functionality.

Import the permissions module in `App.js` file.

```js
import * as Permissions from 'expo-permissions';
```

Next step is to set an initial state that will control the `View` in the `render` method by determining whether the user has granted the permission to your app to use Camera and Camera roll or not.

```js
class App extends Component {
  state = {
    hasGrantedCameraPermission: false,
    hasGrantedCameraRollPermission: false,
  }
```

Next, using a lifecycle method `componentDidMount()`, define a promise for each permission. In the below snippet, you will find two functions `cameraRollAccess()` and `cameraAccess()` performing this operation. Respectively, each of these permission component has a [permission type](https://docs.expo.io/versions/v34.0.0/sdk/permissions/#permissions-types):

- for Camera Roll: `Permissions.CAMERA_ROLL`
- for Camera: `Permissions.CAMERA`

```js
async componentDidMount() {
    this.cameraRollAccess()
    this.cameraAccess()
  }

  cameraRollAccess = async () => {
    const { status } = await Permissions.askAsync(Permissions.CAMERA_ROLL)

    if (status === 'granted') {
      this.setState({ hasGrantedCameraRollPermission: true })
    }
  }

  cameraAccess = async () => {
    const { status } = await Permissions.askAsync(Permissions.CAMERA)

    if (status === 'granted') {
      this.setState({ hasGrantedCameraPermission: true })
    }
  }
```

Each of the permission components returns a `status` value of `granted` or `denied`. In case of the permissions are granted, the value of state variables `hasGrantedCameraRollPermission` and `hasGrantedCameraPermission` are both set to true. The method `Permissions.askAsync()` to prompt the user for the type of permission.

Next, go to the render method of the `App` component and add condition using the two-state variables. If both are set to true, it will display the first screen of the application.

```js
 render() {
    const {
      hasGrantedCameraPermission,
      hasGrantedCameraRollPermission,
    } = this.state

    if (
      hasGrantedCameraPermission === false &&
      hasGrantedCameraRollPermission === false
    ) {
      return (
        <View style={{ flex: 1, marginTop: 100 }}>
          <Text>No access to Camera or Gallery!</Text>
        </View>
      )
    } else {
      return (
        <View style={styles.container}>
          {*/ Rest of the content in the next section*/ }
        </View>
      )
    }
  }

// Corresponding StyleSheet Object

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  }
})
```

If either or both are not granted, the app will display the message `No access to Camera or Gallery!`, also as shown below.

<img src='https://cdn-images-1.medium.com/max/800/1*RPW_mo8N7A303-1dKqHsRA.png' />

When tested on a real android device, it did ask for permissions.

<img src='https://cdn-images-1.medium.com/max/800/1*Z-YtLTjjd-jbDtNKA9gWNw.jpeg' />

Similarly, to use camera:

<img src='https://cdn-images-1.medium.com/max/800/1*c0BRdUMxfP_WTYt0VoVTRA.jpeg' />

## Create a Header component

Using `react-native-elements` UI library for React Native, let us quickly create a useful header that will hold two buttons and the app's title in text. The left button will be to open the phone's gallery or camera roll consisting of user photos. The right button will be to open access the Camera on a real device.

Import the `Header` component from the `react-native-elements` library.

```js
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Header, Icon } from 'react-native-elements';
```

The UI library has a pre-defined component called `Header` that you can use right away. This component accepts the icons on the left and right side. Since the app needs these icons to be clickable, use `TouchableOpacity` such that its `prop` can be later used to open the camera or the camera roll.

```js
<View style={styles.container}>
  <Header
    statusBarProps={{ barStyle: 'light-content' }}
    backgroundColor="black"
    leftComponent={
      <TouchableOpacity onPress={() => alert('soon')}>
        <Icon name="photo-album" color="#fff" />
      </TouchableOpacity>
    }
    centerComponent={{
      text: 'Not Hotdog?',
      style: { color: '#fff', fontSize: 20, fontWeight: 'bold' }
    }}
    rightComponent={
      <TouchableOpacity onPress={() => alert('soon')}>
        <Icon name="camera-alt" color="#fff" />
      </TouchableOpacity>
    }
  />
</View>
```

The `Header` component also has a `statusBarProps` prop to change the color of the Status bar and works cross-platform. It will give the following output.

<img src='https://cdn-images-1.medium.com/max/800/1*HUDX6p1wtfbrBGmNNanPVw.png' />

Both the icons are touchable, but right now they do not have an associated handler method except that a dummy `alert` message.

<img src='https://cdn-images-1.medium.com/max/800/1*uKMGmdh-AQESyamwCwZ3tA.png' />

The `react-native-elements` library by default uses Material Icons and has a peer dependency of [`react-native-vector-icons`](https://github.com/oblador/react-native-vector-icons).

## Adding an Overlay Spinner

The next element to add in the initial state object is `uploading` with a value of false. This variable will be used in the app to display an animated spinner whenever an image is being uploaded from the Camera Roll or analyzed by the Vision API for the result.

```js
state = {
  //... rest,
  uploading: false
};

// also make sure to include deconstruct the state inside render()
const {
  hasGrantedCameraPermission,
  hasGrantedCameraRollPermission,
  uploading
} = this.state;
```

Create a new file inside `components/UploadingOverlay.js`. This file is going to contain a presentational component with the same name as the filename. Using `ActivityIndicator` from `react-native` you can animate this component by using its prop called `animating`.

```js
import React from 'react';
import { ActivityIndicator, StyleSheet, View } from 'react-native';

const UploadingOverlay = () => (
  <View style={[StyleSheet.absoluteFill, styles.overlay]}>
    <ActivityIndicator color="#000" animating size="large" />
  </View>
);

const styles = StyleSheet.create({
  overlay: {
    backgroundColor: 'rgba(255,255,255,0.9)',
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export default UploadingOverlay;
```

Adding `StyleSheet.absoluteFill` to the `style` prop of the `View` component which holds the spinner, you can create an overlay screen. An _overlay_ is just a screen or a `View` in terms of React Native that allows the current screen to appear on top of other screens. Using the `backgroundColor` property, you can add the `opacity` in the last after defining RBG values.

For example, when asking permission to access the Camera, a dialog box appeared on the app screen (_as shown in the previous section_). Notice how the box was position on top of the screen in the background.

Now, go back to `App.js` and add this component at the bottom of the `render()` section, just before the root `View` component is ending. Do not forget to import the component.

```js
import UploadingOverlay from './components/UploadingOverlay';

// ... rest
{
  uploading ? <UploadingOverlay /> : null;
}
```

The above condition states that, if the value of `this.state.uploading` is true, it will show the overlay screen. To test it out, temporarily set the value of `uploading` in the state object to `true`.

<img src='https://cdn-images-1.medium.com/max/800/1*xcmtOrumJIUGwTIVaV8lSQ.png' />

An endless spinner will continue to appear. Set the value of `uploading` back to false before proceeding.

## Access Camera and Camera Roll

In this section, you are going to add the functionality of accessing Camera and Camera Roll by defining three different handler functions in `App` component. Make sure you are inside the file `App.js`. First, import the following statement since this section is going to make use of Firebase's storage and `uuid` module to create a unique referent to each image.

```js
import firebase from './config/Firebase';
import uuid from 'uuid';
```

Next, modify the initial state of the object to add the following for the final time.

```js
state = {
  hasGrantedCameraPermission: false,
  hasGrantedCameraRollPermission: false,
  uploading: false,
  image: null,
  googleResponse: false
};
```

To enable both of these functionalities in the current app, let us leverage another Expo module called `expo-image-picker`. First, import the module after the rest of the import statements.

```js
import * as ImagePicker from 'expo-image-picker';
```

Expo documentation has the best definition of what this module is used for. Take a look.

> [Image Picker] Provides access to the system's UI for selecting images and videos from the phone's library or taking a photo with the camera.

That's all you need right now. Define the first function, `takePhoto` that is going to access the phone's camera to click a photo.

```js
takePhoto = async () => {
  let pickerResult = await ImagePicker.launchCameraAsync({
    allowsEditing: true,
    aspect: [4, 3]
  });

  this.handleImagePicked(pickerResult);
};
```

The asynchronous method `ImagePicker.launchCameraAsync()` accepts two arguments:

- `allowsEditing` shows the UI to edit the image after it is clicked. Mostly used to crop images.
- `aspect` is an array to maintain a consistent aspect ratio if the `allowsEditing` is set to true.

Similarly, `ImagePicker.launchImageLibraryAsync()` is used with the same set of arguments to access Camera roll.

```js
pickImage = async () => {
  let pickerResult = await ImagePicker.launchImageLibraryAsync({
    allowsEditing: true,
    aspect: [16, 9]
  });

  this.handleImagePicked(pickerResult);
};
```

Both of these asynchronous functions, return the `uri` of the image selected (_among other arguments that you can view in the official docs [here](https://docs.expo.io/versions/v34.0.0/sdk/imagepicker/#returns)_). Lastly, both of these methods are calling another callback `handleImagePicked` after their job is done. This method contains the business of logic of how to handle the image after it is picked from the camera roll or clicked.

```js
handleImagePicked = async pickerResult => {
  try {
    this.setState({ uploading: true });

    if (!pickerResult.cancelled) {
      uploadUrl = await uploadImageAsync(pickerResult.uri);
      this.setState({ image: uploadUrl });
    }
  } catch (e) {
    console.log(e);
    alert('Image Upload failed');
  } finally {
    this.setState({ uploading: false });
  }
};
```

Initially, set the state of `uploading` to true. Then, if an image is selected, call the custom method `uploadImageAsync` (_which will be defined at the end of this section_) and pass the URI of the image selected. This will also set the value of the `image` from the state object to the URL of the uploaded image. Lastly, set the state of the `uploading` in the `finally` block back to false if the results are positive and the image has uploaded without any errors.

The custom method `uploadImageAsync` has to be defined outside the `App` component. It will upload the image by creating a unique image ID or blob with the help of `uuid`. It uses `xhr` to make an Ajax call to send a request to the Firebase storage to upload the image.

```js
async function uploadImageAsync(uri) {
  const blob = await new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      resolve(xhr.response);
    };
    xhr.onerror = function (e) {
      console.log(e);
      reject(new TypeError('Network request failed'));
    };
    xhr.responseType = 'blob';
    xhr.open('GET', uri, true);
    xhr.send(null);
  });

  const ref = firebase.storage().ref().child(uuid.v4());
  const snapshot = await ref.put(blob);

  blob.close();

  return await snapshot.ref.getDownloadURL();
}
```

> Note that the source code for accessing and uploading an image to Firebase is taken from [this example](https://github.com/expo/firebase-storage-upload-example) of using Expo with Firebase.

Now you can add both the functions, `pickImage` and `takePhoto` as the value of `onPress` props for the corresponding icons.

```js
<Header
  statusBarProps={{ barStyle: 'light-content' }}
  backgroundColor="#000"
  leftComponent={
    <TouchableOpacity onPress={this.pickImage}>
      <Icon name="photo-album" color="#fff" />
    </TouchableOpacity>
  }
  centerComponent={{
    text: 'Not Hotdog?',
    style: styles.headerCenter
  }}
  rightComponent={
    <TouchableOpacity onPress={this.takePhoto}>
      <Icon name="camera-alt" color="#fff" />
    </TouchableOpacity>
  }
/>
```

Here is an example of accessing Camera roll.

<img src='https://cdn-images-1.medium.com/max/800/1*dEcP_2OfNpFepEiWpwg3lA.gif' />

## Add functionality to determine a Hotdog

As most of the app is now set up, this section is going to be an interesting one. You are going to leverage the use of Google's Vision API to analyze whether the image provided by the user is a hot dog or not.

Inside the `App` component, add a new method called `submitToGoogle`. It is going to send requests and communicate with the API to fetch the result when a button is pressed by the user after the image has been uploaded. Again, while analyzing and fetching results, this method is going to set the state variable `uploading` to true. Then, it will send the URI of the image from the state object's `image` as the body of the request.

Along with the URI, the type of category you want to use is also defined along with a number of results it can fetch as a response. You can change the value of `maxResults` for the `LABEL` category. Currently, the value of the is set to `7`. There are other detection categories provided by the Vision API other the one being used below, `LABEL_DETECTION`, such as a human face, logo, landmark, text, and so on.

```js
submitToGoogle = async () => {
  try {
    this.setState({ uploading: true });
    let { image } = this.state;
    let body = JSON.stringify({
      requests: [
        {
          features: [{ type: 'LABEL_DETECTION', maxResults: 7 }],
          image: {
            source: {
              imageUri: image
            }
          }
        }
      ]
    });
    let response = await fetch(
      `https://vision.googleapis.com/v1/images:annotate?key=${VISION_API_KEY}`,
      {
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: body
      }
    );
    let responseJson = await response.json();
    const getLabel = responseJson.responses[0].labelAnnotations.map(
      obj => obj.description
    );

    let result =
      getLabel.includes('Hot dog') ||
      getLabel.includes('hot dog') ||
      getLabel.includes('Hot dog bun');

    this.setState({
      googleResponse: result,
      uploading: false
    });
  } catch (error) {
    console.log(error);
  }
};
```

In the above snippet, the result is fetched in an array. Each array, in the current scenario, will have seven different objects. Using JavaScript's `map` let us extract the value of `description` from each object. All you need is to detect whether the description contains the word `hotdog` or not. This is done in the variable `result`. Lastly, the state of `uploading` overlay is set back to false, and the result of whether the uploaded image contains a hot dog or not is going to update `googleResponse` as boolean.

On a side note, the Vision API uses HTTP Post request as a REST API endpoint to perform data analysis on images you send in the request. This is done via the URL `https://vision.googleapis.com/v1/images:annotate`. To authenticate each request, you need the API key. The body of this POST request is in JSON format. For example:

```json
{
  "requests": [
    {
      "image": {
        "content": "/9j/7QBEUGhvdG9...image contents...eYxxxzj/Coa6Bax//Z"
      },
      "features": [
        {
          "type": "LABEL_DETECTION",
          "maxResults": 1
        }
      ]
    }
  ]
}
```

## Display final results

Using the boolean value from `googleResponse`, the end result is going to be output. The output will be displayed using `renderImage`.

```js
renderImage = () => {
  let { image, googleResponse } = this.state;
  if (!image) {
    return (
      <View style={styles.renderImageContainer}>
        <Button
          buttonStyle={styles.button}
          onPress={() => this.submitToGoogle()}
          title="Check"
          titleStyle={styles.buttonTitle}
          disabled
        />
        <View style={styles.imageContainer}>
          <Text style={styles.title}>Upload an image to verify a hotdog!</Text>
          <Text style={styles.hotdogEmoji}>ðŸŒ­</Text>
        </View>
      </View>
    );
  }
  return (
    <View style={styles.renderImageContainer}>
      <Button
        buttonStyle={styles.button}
        onPress={() => this.submitToGoogle()}
        title="Check"
        titleStyle={styles.buttonTitle}
      />

      <View style={styles.imageContainer}>
        <Image source={{ uri: image }} style={styles.imageDisplay} />
      </View>

      {googleResponse ? (
        <Text style={styles.hotdogEmoji}>ðŸŒ­</Text>
      ) : (
        <Text style={styles.hotdogEmoji}>âŒ</Text>
      )}
    </View>
  );
};
```

The `Button` component used above is from `react-native-elements` library. It is going to be disabled until no image is selected. On its prop `onPress` the handle function `submitToGoogle` is called. The second view displays the image, and beneath it, an emoji is showcased whether the image has the desired result or not. Do note that by default the cross emoji will be showcased since the default value of `googleResponse` is set to false when defining the initial state. Only after clicking the button, the emoji displayed is the final result.

Lastly, do not forget to add `renderImage` inside `App` component's `render` method, just before the `UploadingOverlay` component.

```js
// inside the render method
{
  this.renderImage();
}
{
  uploading ? <UploadingOverlay /> : null;
}
```

Here is a short demo of how the app looks and works on a real android device using Expo client to run the app.

<img src='https://cdn-images-1.medium.com/max/800/1*Hg6nlnaROCavW5_YLygtEA.gif' />

Here is complete source code for `StyleSheet` object.

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#cafafe'
  },
  headerCenter: {
    color: '#fff',
    fontSize: 20,
    fontWeight: 'bold'
  },
  renderImageContainer: {
    marginTop: 20,
    alignItems: 'center'
  },
  button: {
    backgroundColor: '#97caef',
    borderRadius: 10,
    width: 150,
    height: 50
  },
  buttonTitle: {
    fontWeight: '600'
  },
  imageContainer: {
    margin: 25,
    alignItems: 'center'
  },
  imageDisplay: {
    width: 300,
    height: 300
  },
  title: {
    fontSize: 36
  },
  hotdogEmoji: {
    marginTop: 20,
    fontSize: 90
  }
});

export default App;
```

If you visit the storage section in Firebase, you can notice that each image is stored with a name of base64 binary string.

<img src='https://cdn-images-1.medium.com/max/800/1*CIWmTd4__kyKZRBBqQG0iw.png' />

## Conclusion

By integrating Firebase storage and using Google's Vision API with React Native, you have completed this tutorial. The API is amazing with endless use cases. I hope you learned a thing or two by reading this post. The complete source code for this app is available at [this Github repo](https://github.com/amandeepmittal/not-hotdog-app). Some of the resources used in this post:

- [react-native-elements](https://react-native-training.github.io/) UI component library
- [expo-image-picker](https://docs.expo.io/versions/v34.0.0/sdk/imagepicker/#returns)
- [firebase-storage-upload-example with expo](https://github.com/expo/firebase-storage-upload-example)

[Originally published at Heartbeat](https://heartbeat.fritz.ai/build-a-not-hotdog-clone-with-react-native-8f9b9eb75bd2)

---

## Old blog, new tech
Slug: old-blog-new-tech

Since 2016, Iâ€™ve been blogging, and I launched this website in 2019. Before that, I primarily wrote for various publications on Medium and other platforms, including respected sites like FreeCodeCamp and Logrocket. This website was built with Gatsby, my first experience using a static site generator and the React framework to create something substantial.

In 2020, I started using Next.js and decided to migrate the blog to it in the middle of the year. I was writing and publishing posts a lot more at that time than I do now. Part of the reason for creating a personal blog was to write and post things that publications rejected, but they were good ideas.

Another reason was to have one place to keep or link all of my online content. With time, things on the internet multiplied and got hard to track. Writing mostly tutorials at that time was closer to a portfolio for me in the world of tech writing.

## Back to using Next.js

As a React framework, Next.js was more flexible than Gatsby but too flexible for me as things started to get overwhelming when I migrated this blog. The initial migration appeared encouraging, but soon, I faced issues with the build configuration. The build times increased significantly, taking approximately 10 minutes to complete.

After struggling with optimization attempts for a few weeks, I [reverted back to Gatsby](/blog/year-rewind-2020/#i-moved-my-blog-from-gatsby-to-nextjs-and-back-to-gatsby-again). By implementing that change, I reduced the build time with Next.js, which had been around 10 minutes, by 70%. This made me recognize that I was achieving better results with Gatsby that I couldn't with Next.js.

At the end of 2021, I was offered a role to join Vercel's documentation team. Before that offer, I had experimented with Next.js for hobby projects since 2020 and wanted to get something running in the weeks between jobs. I decided to dive into Next.js documentation and some tutorials to learn more about the framework and took this blog as a dogfooding project. I was happy with the state in which this blog ended up.

Over the span of the next three years, maintaining a static blog with Next.js became difficult. Between breaking major upgrades, API changes, and the new app router, I spent more time maintaining the blog rather than writing new posts.

## The new setup with Astro

In the middle of 2024, tired of the amount of maintenance I had to do, I came across [Astro](https://astro.build/) and thought it had a lower barrier to entry. It is compatible with React as a templating library, so I decided to migrate this blog to use Astro. The migration introduced multiple enhancements compared to my Next.js setup: quicker build times, easier content management using Markdown files, and default zero-JavaScript, leading to improved performance.

Right now, I'm using Astro to generate this site and deploy it on Vercel. I have chosen [AstroPaper](https://github.com/satnaing/astro-paper) as the primary theme, which comes with minimal configuration &mdash; all I needed to get started, though I have done some customizations.

Some of the customizations I have done are:

- **Layout Changes**: Modified the header to include my social links and adjusted the main content width for better readability

- **Dark Mode Tweaks**: Customized the light and dark mode color palettes to use a different color palette than the default one that came with AstroPaper

- **Typography**: Switched to `Helvetica Neue` as the primary font

- **Code Blocks**: Switched to a different code syntax highlighting with [Catppuccin](https://github.com/catppuccin) VS Code-inspired theme colors and added copy-to-clipboard functionality

The best experience so far is how lightweight Astro and AstroPaper are. Upgrading major versions for Astro is also a nice experience. With the recent version 5 upgrade, there were no breaking changes this time that affected this blog.

While I donâ€™t intend to undertake significant customizations, Iâ€™ve discovered that itâ€™s feasible either by developing custom React components or by utilizing basic JavaScript. The styling of this blog is written and handled by Tailwind CSS. Even though I haven't written as much as I wanted in 2024, I've also spent less time maintaining the site.

Since I have been bad at capturing screenshots and keeping a historical record of how this blog has looked, here is one from 2024:

<img src="/images/old-blog.png" alt="amanhimself.dev's landing pages screenshot." class="sm:w-2/3 mx-auto" />

## Looking forward

These migrations over the years have taught me valuable lessons about static-site web development and why simpler is often better for personal projects like this blog. While it is tempting to use the latest and most flexible frameworks, what matters most is having a stable platform that allows you to focus on writing more than maintenance.

Some key takeaways from this migration:

- Start with your core needs. A blog primarily needs good content management. Usually, a blog like this is all about putting content in markdown files, and those files are sourced from one folder.

- Don't over-engineer it. Focus on features you need, and most of the time, they are already available with an open-source theme/template.

- Consider the long-term maintenance to focus more on writing.

This journey from Gatsby to Next.js and Astro has been a good one.

---

## How to paginate records in MySQL using Sequelize and Nodejs
Slug: paginate-records-in-mysql-using-sequelize-and-nodejs

Often at times, I find my self struggling with Sequelize to find a direct answer for my query. Recently, I have been working on a fullstack application in which there was a basic requirement of paginating results from backend (REST API) to the frontend. I struggled for two reasons. Firstly, coming from NoSQL background itâ€™s hard to grasp SQL DBs. Second reason being is Sequelize documentation does not provide a clear and direct solution to this very basic abstraction. Lot of people assume things in the world of SQL databases.

Thus, in this post we will be talking about a basic paginating module using Sequelize, MySQL and Node.js. I am using you have some tables and records inside your MySQL database. To setup a new app and making database connection, read my post on [**Getting started with Sequelize**](https://hackernoon.com/getting-started-with-sequelize-for-nodejs-applications-2854c58ffb8c)**.**

### Defining aÂ Model

I am directly jumping on `user` model definition:

```js
'use strict';
module.exports = function (sequelize, DataTypes) {
  var user = sequelize.define(
    'user',
    {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: DataTypes.INTEGER
      },
      username: DataTypes.INTEGER,
      first_name: DataTypes.STRING,
      last_name: DataTypes.STRING,
      date_of_birth: DataTypes.STRING,
      created: DataTypes.INTEGER,
      updated: DataTypes.INTEGER
    },
    {
      timestamps: false,
      freezeTableName: true,
      underscore: true
    }
  );
  return user;
};
```

I am using that we a table that contains hundred of user records that we want to display on an web application, say in the admin panel, and we want to show just 50 records at once.

In the `api/user.js` I am defining an endpoint `/:page` that will fetch number of results we need from the database.

```js
router.get('/:page', (req, res) => {
  let limit = 50; // number of records per page
  let offset = 0;
  db.user
    .findAndCountAll()
    .then(data => {
      let page = req.params.page; // page number
      let pages = Math.ceil(data.count / limit);
      offset = limit * (page - 1);
      db.user
        .findAll({
          attributes: ['id', 'first_name', 'last_name', 'date_of_birth'],
          limit: limit,
          offset: offset,
          $sort: { id: 1 }
        })
        .then(users => {
          res
            .status(200)
            .json({ result: users, count: data.count, pages: pages });
        });
    })
    .catch(function (error) {
      res.status(500).send('Internal Server Error');
    });
});
```

`findAndCountAll` is the model for searching multiple records in the database and it returns both the data required and the count of elements in that table. The above query will get 50 user records at once until the next page is called to fetch the next 50 records. `limit` and `offset` are required in queries related to pagination in which `limit` fetches the number of rows based on the query whereas `offset` is used to skip the number of rows in the database table.

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/how-to-paginate-records-in-mysql-using-sequelize-and-nodejs-a3465d12aad5)

---

## Passing Data Between Pages in an Ionic Application
Slug: passing-data-between-pages-in-an-ionic-application

In the previous posts, we have seen [how to setup a basic navigation between multiple Ionic app Pages](https://hackernoon.com/https-medium-com-amanhimself-basic-navigation-in-ionic-applications-ecb199cdf15b). This post concerns what if you want to send some data from the previous page to the next page in the stack? For the Ionic provides `NavParams` class to transfer data from one page to another.

### Generate the application

In this demo application we will first setup a home page with a text box to enter data that will be transferred to the next page. First, letâ€™s generate a new Ionic application:

```shell
$ ionic start -a 'Passing Data between Pages' -i
app.passdata.pages ionic-pass-data-pages blank
```

Create a new about page:

```shell
$ ionic g page about
```

And lastly, to complete our setup, we must add about page in the app module:

```ts
import { BrowserModule } from '@angular/platform-browser';
import { ErrorHandler, NgModule } from '@angular/core';
import { IonicApp, IonicErrorHandler, IonicModule } from 'ionic-angular';
import { SplashScreen } from '@ionic-native/splash-screen';
import { StatusBar } from '@ionic-native/status-bar';

import { MyApp } from './app.component';
import { HomePage } from '../pages/home/home';
import { AboutPage } from '../pages/about/about';

@NgModule({
  declarations: [MyApp, HomePage, AboutPage],
  imports: [BrowserModule, IonicModule.forRoot(MyApp)],
  bootstrap: [IonicApp],
  entryComponents: [MyApp, HomePage, AboutPage],
  providers: [
    StatusBar,
    SplashScreen,
    { provide: ErrorHandler, useClass: IonicErrorHandler }
  ]
})
export class AppModule {}
```

### Add Input Text in HomeÂ Page

Then we will update `home.html`:

```html
<ion-header>
  <ion-navbar>
    <ion-title> Passing Data in Pages </ion-title>
  </ion-navbar>
</ion-header>

<ion-content padding>
  <ion-list>
    <ion-item>
      <ion-label>Enter</ion-label>
      <ion-input placeholder="Your fav color..." #color></ion-input>
    </ion-item>
  </ion-list>
  <button
    ion-button
    color="secondary"
    (click)="goTo(color.
  value)"
  >
    About Page
  </button>
</ion-content>
```

`#color` is a local variable whose value we will be referencing to pass on to the next page in our navigation stack. We will now update our `home.ts` with business logic behind the only click event in our template:

```ts
import { Component } from '@angular/core';
import { NavController } from 'ionic-angular';
import { AboutPage } from './../about/about';

@Component({
  selector: 'page-home',
  templateUrl: 'home.html'
})
export class HomePage {
  constructor(public navCtrl: NavController) {}

  goTo(color) {
    color = color || 'No Color Entered';

    this.navCtrl.push(AboutPage, {
      data: color
    });
  }
}
```

Note the second argument in `this.navCtrl.push()` which is being used to pass the data.

### About Page

To Pass data from Home page to About page we will need to import `NavParams` class. Since, I am using Ionic CLI to generate pages, class `NavParams` will already be imported in the about page.

```ts
import { Component } from '@angular/core';
import { IonicPage, NavController, NavParams } from 'ionic-angular';

@IonicPage()
@Component({
  selector: 'page-about',
  templateUrl: 'about.html'
})
export class AboutPage {
  color: string;

  constructor(
    public navCtrl: NavController,
    public navParams: NavParams
  ) {
    this.color = navParams.get('data');
  }

  ionViewDidLoad() {
    console.log('ionViewDidLoad AboutPage');
  }
}
```

### Display FetchedÂ Data

To catch the data from the previous page in the navigation stack, we are using `get()` method of `NavParams` class. We fetch data inside the constructor function of `AboutPage` class.

Finally, to display data on about page:

```html
<ion-header>
  <ion-navbar>
    <ion-title>About</ion-title>
  </ion-navbar>
</ion-header>

<ion-content padding>
  <label>Color Entered: {{color}}</label>
</ion-content>
```

### Summary

Here are some screenshots:

Home Page:

<img src='https://cdn-images-1.medium.com/max/800/0*eftZuH7QmZQqs4-Y.png' />

User Input being entered:

<img src='https://cdn-images-1.medium.com/max/800/0*g25oMDTJV3TS7mTB.png' />

Data passed form Home Page displayed on About Page:

<img src='https://cdn-images-1.medium.com/max/800/0*ay_xx0zGGCDDuXXY.png' />

When nothing entered in the input field, a default text passed and displayed:

<img src='https://cdn-images-1.medium.com/max/800/0*5lhp42R9R5pQVjSi.png' />

_To get the full code of this demo app, you can visit_ [**this Github Repository**](https://github.com/amandeepmittal/ionic-pass-data-pages).

> [Originally Published at Hackernoon.com](https://medium.com/hackernoon/passing-data-between-pages-in-an-ionic-application-129b387c93b8)

---

## Patterns and Anti-patterns in Node.js
Slug: patterns-and-anti-patterns-in-nodejs

![cover_image](https://blog.appsignal.com/_next/image?url=%2Fimages%2Fblog%2F2022-02%2Fpatterns.png&w=2048&q=50)

> Originally posted at [AppSignal Blog](https://blog.appsignal.com/2022/02/23/patterns-and-anti-patterns-in-nodejs.html)

Node.js is a back-end JavaScript runtime built on Chrome's V8 engine that's asynchronous and event-driven by nature. It's relatively simple to create a REST API with Node.js and use frameworks like [Express.js](https://expressjs.com/). With this simplicity comes a lot of flexibility. However, you can get side-tracked on what patterns to follow when building scalable network-driven applications.

This article focuses on some of the patterns and practices to follow when building Node.js applications. You will learn about coding style, error handling, loggers, and testing.

Let's dive in!

## Node.js Coding Style and Best Practices

### const and let Keywords to Declare Variables

There are different ways to declare variables in JavaScript: the old school `var` and the more recent `let` and `const`.

`var` declares a function-scoped (when declared within a function) or globally-scoped variable (when declared outside a function).

`let` and `const` declare block-scoped variables.

`let` allows you to create variables whose value can change. When pointing to an object, it can be assigned to another object.

```js
let myInt = 3;
myInt = 6;
console.log(myInt); // 6
let myArray = [0, 1, 2, 3];
console.log(myArray); // [ 0, 1, 2, 3 ]
let myOtherArray = ['one', 'two', 'three'];
myArray = myOtherArray;
console.log(myArray); // [ 'one', 'two', 'three' ]
```

The `const` keyword can be a little confusing. It doesn't necessarily define a constant value, it defines a constant reference to a value. It creates a read-only reference to a value, but this doesn't mean the value it holds is immutable, just that it cannot be reassigned.

```js
const myInt = 3;
myInt = 6; // TypeError: Assignment to constant variable.
const myArray = [0, 1, 2, 3];
console.log(myArray); // [ 0, 1, 2, 3 ]
myArray[0] = 'eleven';
console.log(myArray); // [ 'eleven', 1, 2, 3 ]

let myOtherArray = ['one', 'two', 'three'];
myArray = myOtherArray; // TypeError: Assignment to constant variable
```

As shown above, if it holds a primitive, you cannot assign it another value. When it holds an object/array, you can alter the value of that object (its properties/elements), but you cannot assign it another object.

With the definitions down, let's look at why you should consider using `let` and `const` over `var`.

1. Duplicate variable declarations using `var` will not trigger an error.

With `var` you can declare a variable in the same scope as a similarly named variable. Because of this, you can unknowingly overwrite another variable's value.

```js
function thisFunction() {
  var x = 1;

  // In another part of the code, declare another variable x
  var x = 2;

  console.log(x); // 2
}

thisFunction();
```

Both `const` and `let` cannot be re-declared, so you cannot accidentally create a duplicate variable in the same scope.

```js
function thisFunction() {
  let x = 1;

  // In another part of the code, declare another variable x
  let x = 2;

  console.log(x);
}

thisFunction();
```

If you try to run the above code, you will get the following error:

```shell
SyntaxError: Identifier 'x' has already been declared
```

2. `var` allows you to read a variable that has not been declared.

When you try to access a `var` before it is declared, it will return `undefined`. This might cause bugs when you try to use a variable in your code that has not been declared. Tracking down the bug might be difficult since the code might cause no errors that will cause it to crash, but it might cause unexpected results when you use the `undefined`.

The following code will run just fine.

```js
console.log(bar); // undefined
var bar = 1;
```

With `let` and `const`, you won't be able to use a variable that has not been declared.

```js
console.log(foo); // ReferenceError
let foo = 2;
```

Trying to run the above will give the below error:

```shell
ReferenceError: Cannot access 'foo' before initialization
```

3. Because they are block-scoped, `let` and `const` make for more readable and straightforward code, that is less error-prone.
   With block-scoped variables, it is easier to read through code and track down the scope in which a variable operates. You just have to look at the inner-most block in which it has been declared to know its scope.

Look at the following code.

```js
let x = 5;

function thisFunction() {
  let x = 1;

  if (true) {
    let x = 2;
  }

  console.log(x); // 1
}

thisFunction();

console.log(x); // 5
```

Since `let x = 2;` is declared inside the block of the `if` statement, you know it only operates inside that block. As you can see, it doesn't affect similarly named variables outside the block. You can declare variables inside blocks without worrying that you might be re-declaring them.

When using `var`, it's not so straightforward.

```js
var x = 5;

function thisFunction() {
  var x = 1;

  if (true) {
    var x = 2;
  }

  console.log(x); // 2
}

thisFunction();

console.log(x); // 5
```

With `var`, you have to be more careful with variables.

In the above, we declare a variable `var x = 2;` inside the `if` statement. The scope of `x` is the entire function `thisFunction()`. Since there is a similarly named variable in the function, we re-declared `x`, and when we later use the function's `x`, it has the value `2`. So you need to be aware of the variables in scope, so as not to accidentally overwrite them.

### Proper Naming Conventions

It's important to follow a naming convention when naming constants, variables, classes, and functions in an app. This helps you visually differentiate between local variables, global variables, functions, classes, and so on, and maintain a consistent style throughout your codebase.

For naming local variables and functions, use lowerCamelCase.

```js
const myFunction() {
  let someVariable;
}
```

Even if you define variables using the `const` keyword within the scope of a function, lowerCamelCase is preferred.

```js
const myFunction() {
  const someVariable = "That holds a string value";
}
```

Variables can also be defined by a `const` keyword in a specific use case. If you intend to declare a variable whose value (or nested values, in the case of declaring an object) is not going to change throughout the lifecycle of a codebase, use UPPER_SNAKE_CASE with the `const` keyword.

```js
const ANOTHER_VAR = 3;
```

Define classes in Node.js applications with UpperCamelCase:

```js
class MyClass() {
  // ...
}
```

Following these naming conventions will help you write more readable code. Naming your functions is vital, especially when you are about to profile a Node.js project. Profiling makes it simpler to understand what function to look for when checking a memory snapshot. However, if you use anonymous functions, profiling can make it challenging to debug production issues.

### ESLint and Style Guides

Instead of overthinking a project's coding style, use a linting tool like [ESLint](https://eslint.org/). Over the years, it has become the JavaScript ecosystem's standard for fixing code styles automatically. ESLint checks for possible code errors, fixes code styles such as spacing issues, avoids anti-patterns and small errors, and keeps project code uniform. Using ESLint with a tool like [Prettier](https://prettier.io/) can help you fix formatting issues as well.

By default, ESLint contains standard rules for vanilla JavaScript. It has a plugin system specific to the framework. For Node.js, you can use plugins like eslint-plugin-node and eslint-plugin-node-security.

It is much easier to understand a large project when its code is written in a consistent style. This is where style guides come in handy. Using a style guide enhances a team's productivity and avoids arguments about the best style guide for Node.js projects. In addition, you can opt-in to already existing style guides created at companies like [Google](https://github.com/google/eslint-config-google) and [Airbnb](https://github.com/airbnb/javascript) that have been tested with time.

## Error Handling in Node.js

You can handle errors using `async/await` syntax and the built-in error object in Node.js. Let's take a look at both.

### async/await Syntax to Catch Errors

When Node.js first came out, handling asynchronous code meant using callbacks. From my experience, it doesn't take too long for nested callbacks to get out of hand. This is known as 'callback hell', and here is a typical example:

```js
function getData(err, function(err, res) {
  if(err !== null) {
    function(valueA, function(err, res) {
      if(err !== null) {
        function(valueB, function(err, res) {
          // it continues
        }
      }
    })
  }
})
```

The example above is quite ergonomic. In a real scenario, there will be many more lines of code in each function's scope. This is considered an anti-pattern: handling the callback style of errors gets more awkward and only gets more un-maintainable with more nested functions.

You can avoid nested callbacks or callback hell by using ES6 `async/await` syntax (completely supported by Node.js version 8 and onwards). `async/await` is a way to deal with asynchronous code. It provides a much more compact way of writing code and familiar code syntax. To handle errors, you can use `try/catch` blocks along with `async/await` syntax.

If we use `async/await`, we can rewrite the previous example like this:

```js
async function getData(err, res) {
  try {
    let resA = await functionA(res);
    let resB = await functionB(resA);

    return resB;
  } catch (err) {
    logger.error(err);
  }
}
```

### Built-in Node.js Error Object

Errors are impossible to avoid. However, in many cases you'll want to handle errors such as rejected promises and thrown exceptions.

To avoid complications in error-handling, use the built-in error object in Node.js. It helps you maintain uniformity and prevent loss of information. You can also reap the advantages of finding information with StackTrace.

As an example, throw a string as shown below:

```js
if (!data) {
  throw 'There is no data';
}
```

This lacks any stack trace information and is an anti-pattern.

Instead, use the built-in Error object:

```js
if (!data) {
  throw new Error('There is no data');
}
```

## Loggers for Your Node.js Project

There's no denying it&mdash;we've all used `console` statements at times. They can be good for quickly debugging something or printing a standard output. But the console lacks proper configuration options for production-grade applications.

It is also crucial for a logger to be high-performant in identifying errors and possible issues. A slow logging library might harm your application's runtime performance.

A typical logger lets you use correct log levels such as fatal, warn, info, error, debug, and trace. These levels help to identify and distinguish between different critical events. A logger will also help provide contextual information in a JSON object, with timestamped log lines for you to determine when the log entry occurred. The logging format should be readable by human beings.

A good logging library provides features that make it easier to centralize and format logs. In the Node.js ecosystem, the following are some of the options available:

- [Winston](https://github.com/winstonjs/winston): A popular logging library that is easily configurable.
- [Bunyan](https://github.com/trentm/node-bunyan): Another popular logging library that outputs in JSON by default.
- [Log4js](https://github.com/log4js-node/log4js-node): A logger for the Express framework that supports colored console logging out of the box.
- [Pino](https://github.com/pinojs/pino): A logger that is focused on performance. It is considered to be faster than its alternatives.

An example of configuring Pino:

```js
const app = require('express')();
const pino = require('pino-http')();

app.use(pino);

app.get('/', function (req, res) {
  req.log.info('something');
  res.send('hello world');
});

app.listen(3000);
```

Pino also supports [various Web frameworks in the Node.js ecosystem](https://github.com/pinojs/pino/blob/HEAD/docs/web.md#express), such as Fastify, Express, Hapi, Koa, and Nest.

## Writing Tests in Node.js

If you work on a big application, you'll make continuous changes to the app's source code. By writing tests, you can avoid breaking existing features when pushing a new change. Failing tests will also help you determine where to make changes in specific sections of your code.

### Write API Tests

In a Node.js application, writing API tests is a good start. They provide more coverage than unit testing. You can use frameworks like [Supertest](https://github.com/visionmedia/supertest), [Jest](https://jestjs.io/), or any other library that provides a high-level abstraction for testing APIs.

Consider the example below. It is a simple Express app that serves one route:

```js
const express = require('express');
const bodyParser = require('body-parser');

const app = express();

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Other middlewares...

app.get('/', (req, res, next) => {
  res.json({ hello: 'Hello World' });
});

module.exports = app;
```

Here's appropriate way to write this using Supertest:

```js
const request = require('supertest');
const app = require('./index');

describe('hello test', () => {
  it('/ should return a response', async () => {
    const res = await request(app).get('/');
    expect(res.statusCode).toEqual(200);
    expect(res.body).toEqual({ hello: 'Hello World' });
  });
});
```

### Write Clear Test Names

A test name should be descriptive and self-explanatory for other people working on your team and include what is being tested, the scenario, and expected result.

### Inspect Outdated Packages

You can check for outdated packages with commands like `npm outdated` or use a package like `npm-check`. This will prevent build fails related to outdated packages.

### Inspect for Vulnerable Dependencies

A package can have vulnerabilities. Use community-based tools such as [npm audit](https://docs.npmjs.com/cli/audit) or commercial tools like [snyk](https://snyk.io/) to discover vulnerabilities. If you don't use these tools, your only alternative is to keep up with tech communities online.

## Wrap Up: Write Better Code for Your Node.js Apps

In this article, we covered practices and patterns to help you avoid anti-patterns and write better code for your Node.js applications.

We looked at some key principles around coding style, error handling, loggers, and testing. Some of the practices we discussed are more general&mdash;like checking for outdated packages or vulnerable dependencies. Others&mdash;such as using a performant logging library using ESLint and style guides&mdash;will help you maintain a consistent way of writing code, especially when working on large projects.

Happy coding!

---

## Pomodoro technique with CLI on macOS
Slug: pomodoro-with-cli

I often turn to the [Pomodoro Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique) when I'm overwhelmed by my to-do list. This method involves working for a set period (X minutes), followed by a short break (Y minutes), promoting focused sessions.

After trying various apps that lacked the simplicity I desired, I discovered a straightforward command line tool.

## Prerequisites

Before diving into the specifics, here is what you will need:

- Install [timer](https://github.com/caarlos0/timer) &mdash; a small utility written in Go that has features such as displaying progress using a progress bar, showing remaining time and named timers.
- Make sure that you are using a terminal app (such as iTerm) with alert notifications enabled.

## Using timer

The timer command accepts a duration argument with a unit specifier (`s` for seconds, `m` for minutes, `h` for hours, and so on). For example, to set a timer for 30 seconds:

```shell
timer 30s
```

![Executing the timer command with a duration of 30 seconds.](/images/pomodoro-1.png)

You can also add a description to your timer using the `-n` flag:

```shell
timer 30s -n "Some task"
```

## Notification using tput bel

[`tput`](https://www.gnu.org/software/termutils/manual/termutils-2.0/html_chapter/tput_1.html) is a versatile command that allows shell scripts to perform things such as clear the screen, underline the text, or ring a bell (beep).

You can combine it with `timer` to get an alert when your session ends.

```shell
timer 30s -n "Short break" && tput bel
```

If your terminal window is in the background and alerts are enabled, you will receive a notification as shown below:

![A notification is sent by tput command after the timer is complete.](/images/pomodoro-2.png)

## Conclusion

This setup offers a minimalistic approach to a commonly used technique to manage your focus sessions.

---

## Prop types in React and TypeScript
Slug: prop-types-in-react-and-typescript

[PropTypes](https://www.npmjs.com/package/prop-types) provide built-in typechecking capabilities when writing a React app. Checking the type of prop in a React component in a large application helps catch bugs at run-time.

Typically in a React app, you will need to install the package `yarn add prop-types`. Then, inside a component, explicitly define the type of a prop.

```js
import React from 'react';
import PropTypes from 'prop-types';

// A component that accepts "color" prop
function FavoriteColor({ color }) {
  return <h2>My favorite Color is {color}</h2>;
}

FavoriteColor.propTypes = {
  color: PropTypes.string
};

// Parent component
function App() {
  return (
    <div className="App">
      <FavoriteColor color={'Red'} />
    </div>
  );
}

export default App;
```

Above code snippet will run fine, and there no errors or warnings yet. If you use VS Code, hover over the prop `color` in the `App` component. You will see the expected data type on the prop.

![s1](https://res.cloudinary.com/amanmittal/image/upload/v1624823701/s1_beblnm.png)

But what if in the `App` component, the value of prop `color` is changed to a number by mistake. The component will still render in the web browser.

```js
function App() {
  return (
    <div className="App">
      <FavoriteColor color={120} />
    </div>
  );
}
```

But if you open the browser's Developer Tools and go to console, you will see the error.

![s2](https://res.cloudinary.com/amanmittal/image/upload/v1624823701/s2_p9h3mq.png)

The `prop-types` package provide validation at run-time. Not a great developer experience (imagine large applications). Using TypeScript in a React application can make the developer experience better.

## PropTypes with TypeScript and React

Take the previous code snippet, copy it in a `.tsx` file. Here is how the components will look. Notice the red squiggly line beneath the prop `color`.

![s3](https://res.cloudinary.com/amanmittal/image/upload/v1624823702/s3_okboft.png)

TypeScript is smart enough not to compile the code if a prop has a type of `any`.

## Inferring PropTypes in TypeScript

`PropTypes` package offers `InferProps` that enables to infer the types for an existing prop-type definition on a component. It uses the `@types/prop-types` package to create type definitions.

To use `InferProps`, import it from the `prop-types` library and then define type declarations on the components prop.

```tsx
import PropTypes, { InferProps } from 'prop-types';

function FavoriteColor({ color }: InferProps<typeof FavoriteColor.propTypes>) {
  return <h2>My favorite Color is </h2>;
}

FavoriteColor.propTypes = {
  color: PropTypes.string
};
```

Code compiles, and there are no errors.

## Using type keyword to declare prop type definitions

TypeScript comes with a `type` keyword. It can be used to define prop types without using the `prop-types` package.

```tsx
type Props = {
  color: string;
};

function FavoriteColor({ color }: Props) {
  return <h2>My favorite Color is {color} </h2>;
}
```

The VS Code IntelliSense will detect the type of `color` prop in the `App` component. It will allow you to provide anything other than a `string` value for this prop.

![s4](https://res.cloudinary.com/amanmittal/image/upload/v1624823701/s4_fyz6bw.png)

## Props are required in TypeScript

Another difference to notice here is that, with TypeScript, all props required by default. In the `prop-types` package, all props are optional by default. To make a prop required, you will have to use `.isRequired` explicitly.

With TypeScript, that is not the case.

![s5](https://res.cloudinary.com/amanmittal/image/upload/v1624823702/s5_m36cnq.png)

## Optional props in TypeScript

If a component has an optional prop, add a question mark when declaring prop type:

```tsx
type Props = {
  color?: string;
};
```

---

## How to push local git tag to remote repository on GitHub
Slug: push-local-git-tag-to-remote-repository-on-github

After creating a git tag locally on a local project, I needed to push it on GitHub. The reason is that I'm hosting the project repository on GitHub.

## Pushing a tag to GitHub

Pushing a tag in git is similar to pushing a branch. The only difference is that it needs the specific git tag name.

```shell
git push -u origin <tag_name>
```

Here is an example. I had already created a new tag, `v0.1` on my local project. To push it to GitHub, I had to run:

```shell
gpush v0.1
Total 0 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/amandeepmittal/[project-name].git
 * [new tag]         v0.1 -> v0.1
```

Note: I use the `gpush` alias for `git push -u origin`. Complete list of all the aliases I use for git, check this [dotfile](https://github.com/amandeepmittal/dotfiles/blob/master/.zshrc).

## Checking for if a tag is already pushed

To check if a tag is only available on local, run:

```shell
git push --tags --dry-run
```

The `--dry-run` option in the above command summarizes what will be included in the next commit.

If the output of the above command states `Everything up-to-date`, it means there are no tags available to push.

In case when the above command comes back with an output like the below, it means that the tag is available to push.

```shell
To https://github.com/amandeepmittal/[project-name].git
 * [new tag]         v0.1 -> v0.1
```

---

## Implement Push notifications for Android apps with React Native
Slug: push-notifications-android-apps-react-native

Relevant Push notifications are a great way to boost a user's engagement towards an application. According to some [analysis](http://info.localytics.com/blog/6-stats-that-prove-how-important-push-notifications-in-app-messaging-are-to-your-apps-success), push notifications increase app engagement by 88%. Itâ€™s also curious to see that the [click-through rate](https://clevertap.com/blog/mobile-marketing-stats-2019/) for push notifications in Android (4.06%) is much higher than in iOS (1.7%).

In this tutorial, you are going to learn how to implement push notifications as an app feature using React Native and Firebase. I will be testing out the notification feature on an Android device, but you can go ahead and try it out on iOS yourself.

There are two main ways you can send push notifications to your app users: local and remote. Local notifications are sent from a React Native application, while remote push notifications are sent from the server or a push notification service such as Google's Cloud Messaging Service (GCM). We will explore both approaches.

## Requirements

To follow this tutorial, please make sure you have the following installed on your local development environment and have access to the services mentioned below:

- Nodejs (>=`10.x.x`) with npm/yarn installed.
- react-native-cli
- Windows/Linux users must be running an Android emulator or a real device via USB
- Active [Firebase](https://firebase.google.com/) project

To know more about how to set up a development environment for React Native using react-native-cli, please refer to the [official documentation](https://facebook.github.io/react-native/docs/getting-started).

You can find the complete code for this tutorial at [this GitHub repository](https://github.com/amandeepmittal/RNnotifications-demo).

## Install and Set Up react-native-push-notifications

The [react-native-push-notifications](https://github.com/zo0r/react-native-push-notification#readme) library helps you set up controllers to consume local or remote notifications for iOS and Android devices. To begin, follow the instructions from the terminal window. Create a new React Native project and then install this library.

```shell
react-native int RNnotifications

cd RNnotifications

yarn add react-native-push-notification
```

For iOS devices, this library depends on the manual installation instructions mentioned at [PushNotificationIOS](https://github.com/react-native-community/react-native-push-notification-ios) &mdash; an API that is maintained by react-native-community.

For Android devices, you are going to make the following edits in the appropriate files mentioned below. First, open the file `android/build.gradle` and add the following:

```groovy
buildscript {
    ext {
        // add the following two lines
        googlePlayServicesVersion = "16.1.0" // default: "+"
        firebaseVersion = "17.3.4" // default: "+"
    }
    repositories {
        google()
        jcenter()
    }
    dependencies {
        // add the following dependency
        classpath 'com.google.gms:google-services:4.3.2'
    }
}
```

Next, open `android/settings.gradle` and add the following before `include ':app'`.

```groovy
include ':react-native-push-notification'
project(':react-native-push-notification').projectDir = file('../node_modules/react-native-push-notification/android')
```

Do note that, if you are not looking forward to using remote notifications, you can ignore the above step. However, the following step is important for both types of notifications to work. Open the `android/app/src/main/AndroidManifest.xml` file. Before the `<application>` tag, add the following.

```xml
  <uses-permission android:name="android.permission.WAKE_LOCK" />
    <permission
        android:name="${applicationId}.permission.C2D_MESSAGE"
        android:protectionLevel="signature" />
    <uses-permission android:name="${applicationId}.permission.C2D_MESSAGE" />
    <!-- < Only if you're using GCM or localNotificationSchedule() > -->

    <uses-permission android:name="android.permission.VIBRATE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
```

Then, inside the `<application>` tag (and without deleting any existing tags) add:

```xml
 <meta-data  android:name="com.dieam.reactnativepushnotification.notification_channel_name"
                android:value="YOUR NOTIFICATION CHANNEL NAME"/>
        <meta-data  android:name="com.dieam.reactnativepushnotification.notification_channel_description"
                    android:value="YOUR NOTIFICATION CHANNEL DESCRIPTION"/>
        <!-- Change the resource name to your App's accent color - or any other color you want -->
        <meta-data  android:name="com.dieam.reactnativepushnotification.notification_color"
                    android:resource="@android:color/white"/>

        <!-- < Only if you're using GCM or localNotificationSchedule() > -->
        <receiver
            android:name="com.google.android.gms.gcm.GcmReceiver"
            android:exported="true"
            android:permission="com.google.android.c2dm.permission.SEND" >
            <intent-filter>
                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
                <category android:name="${applicationId}" />
            </intent-filter>
        </receiver>
        <!-- < Only if you're using GCM or localNotificationSchedule() > -->

        <receiver android:name="com.dieam.reactnativepushnotification.modules.RNPushNotificationPublisher" />
        <receiver android:name="com.dieam.reactnativepushnotification.modules.RNPushNotificationBootEventReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
        <service android:name="com.dieam.reactnativepushnotification.modules.RNPushNotificationRegistrationService"/>

        <!-- < Only if you're using GCM or localNotificationSchedule() > -->
        <service
            android:name="com.dieam.reactnativepushnotification.modules.RNPushNotificationListenerServiceGcm"
            android:exported="false" >
            <intent-filter>
                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
            </intent-filter>
        </service>
        <!-- </ Only if you're using GCM or localNotificationSchedule() > -->

        <!-- < Else > -->
        <service
            android:name="com.dieam.reactnativepushnotification.modules.RNPushNotificationListenerService"
            android:exported="false" >
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT" />
            </intent-filter>
        </service>
```

Lastly, go to `android/app/src/res/values/colors.xml`. If the file does not exist, create it. This file determines the color of the notification on an Android device. For example, the notification can be white:

```xml
<resources>
    <color name="white">#FFF</color>
</resources>
```

_Note:_ To use this library with Expo, you have to eject the Expo SDK app.

## Configure Local Push Notifications

In this section, you are going to write a configure function such that, when a button is pressed, a local notification is triggered. Create a new file inside `src/services/LocalPushController.js`. Start by importing `PushNotification` from the library you initialized in the previous step.

```js
import PushNotification from 'react-native-push-notification';
```

Add `PushNotification.configure()` to the file. This accepts an object with a required method `onNotification`. This method handles what happens after the notification is opened or received. Since it is a required method, it has to be invoked whether the notification is local or remote. The demo application only invokes a `console` statement stating the properties of the local notification object used in the current demo app.

```js
PushNotification.configure({
  // (required) Called when a remote or local notification is opened or received
  onNotification: function (notification) {
    console.log('LOCAL NOTIFICATION ==>', notification);
  },

  popInitialNotification: true,
  requestPermissions: true
});
```

Next, export `LocalNotification` in the snippet below which gets invoked when a button pressed by the user _or as the value of the `onPress` attribute_.

```js
export const LocalNotification = () => {
  PushNotification.localNotification({
    autoCancel: true,
    bigText:
      'This is local notification demo in React Native app. Only shown, when expanded.',
    subText: 'Local Notification Demo',
    title: 'Local Notification Title',
    message: 'Expand me to see more',
    vibrate: true,
    vibration: 300,
    playSound: true,
    soundName: 'default',
    actions: '["Yes", "No"]'
  });
};
```

`PushNotification.localNotification` has plenty of properties for each mobile platform (such as iOS or Android). From the above snippet, properties like `vibrate`, `vibration`, `bigText`, `subText` are Android only. However, properties like `actions`, `title`, `message`, `playSound` & `soundName` are cross-platform.

Import this method in the `App.js` file. Import `LocalNotification` from the `src/services/LocalPushController.js` file. Then, inside the functional `App` component, add a handler method `handleButtonPress` to invoke only when the user presses the button.

```js
import React from 'react';
import { Text, View, Button, StyleSheet } from 'react-native';
import { LocalNotification } from './src/services/LocalPushController';

const App = () => {
  const handleButtonPress = () => {
    LocalNotification();
  };

  return (
    <View style={styles.container}>
      <Text>Press a button to trigger the notification</Text>
      <View style={{ marginTop: 20 }}>
        <Button title={'Local Push Notification'} onPress={handleButtonPress} />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  buttonContainer: {
    marginTop: 20
  }
});

export default App;
```

Now, from a terminal window, run `react-native run-android`. Make sure you have a device connected via USB and have USB debugging enabled, or you can test on an Android Emulator.

The output of the above code snippet should look like this:

![ss1](https://i.imgur.com/Pq3hR5P.png)

When the button is pressed, it displays the notification, vibrates the device, and plays a default notification sound.

![ss2](https://i.imgur.com/KKhYuLE.gif)

Expanding the notification displays the message from `bigText`. Pressing the notification results in triggering the console statement from `onNotification` method.

![ss3](https://i.imgur.com/JSHRAXh.png)

You can add scheduled notifications by using the `PushNotification.localNotificationSchedule(details: Object)` method or you can repeat notifications after a particular time too. Read how to do this or add more customizations in the [module's official docs](https://github.com/zo0r/react-native-push-notification#readme).

## Configure Remote Notifications

To test out how remote notifications work, let us integrate the Cloud Messaging Service using Firebase. To follow the steps below, make sure you have an active Firebase project.

From the main **Dashboard** page, go to **Project Settings**. In the **Your apps** section, click on **Add app** and set up a new Android app.

Next, it will ask you to register the application.

![ss4](https://i.imgur.com/gcW6Giq.png)

Download the file `google-services.json` and save it at the location `android/app/` inside your React Native project.

![ss5](https://i.imgur.com/mTEX4G9.png)

Then, open the `android/app/build.gradle` file and add the following.

```groovy
dependencies {
    implementation project(':react-native-push-notification')
    // ... rest remains same
}

// at the end of the file, add
apply plugin: 'com.google.gms.google-services'
```

Next, create a new service file called `RemotePushController.js` inside the `src/services/` directory. This file contains all the configuration to handle a remote push notification. Inside the mandatory `onNotification` method, let us again display the result of the remote notification in the console.

It also requires a mandatory Android property called `senderID`. This can be fetched form **Project Settings** > **Cloud Messaging**.

![ss7](https://i.imgur.com/CbXvImG.png)

```js
import React, { useEffect } from 'react';
import PushNotification from 'react-native-push-notification';

const RemotePushController = () => {
  useEffect(() => {
    PushNotification.configure({
      // (optional) Called when Token is generated (iOS and Android)
      onRegister: function (token) {
        console.log('TOKEN:', token);
      },

      // (required) Called when a remote or local notification is opened or received
      onNotification: function (notification) {
        console.log('REMOTE NOTIFICATION ==>', notification);

        // process the notification here
      },
      // Android only: GCM or FCM Sender ID
      senderID: '256218572662',
      popInitialNotification: true,
      requestPermissions: true
    });
  }, []);

  return null;
};

export default RemotePushController;
```

Also, the Cloud Messaging service works based on using a `Token` between the app and the notification service. The `onRegister` method registers the remote server and obtains this token. You can view this by adding a console statement.

![ss6](https://i.imgur.com/EjCkPNd.png)

The controller component returns `null` to avoid having any effects on the final layout. Add this method inside the `App.js` file as shown below:

```js
// after other import statements
import RemotePushController from './src/services/RemotePushController'

// before the ending <View>
  <RemotePushController />
</View>
```

To test it out, go to **Cloud Messaging** section and compose a notification.

![ss8](https://i.imgur.com/VlclUtb.png)

Click the button **Send test message**. You will have the following output.

![ss9](https://i.imgur.com/uq1KGhW.gif)

The Log in the terminal is shown for the same notification.

![ss10](https://i.imgur.com/1wZOjG7.png)

You can customize the title, message and another behavior of the Firebase Cloud Messaging service to send notifications at a particular time or date by composing the notification.

## Conclusion

Congratulations! You have successfully implemented both ways to send a push notification in a React Native app. Go ahead and try to implement a scheduled notification as a challenge.

Originally published at [Jscrambler](https://jscrambler.com/blog/implementing-react-native-push-notifications-in-android-apps)

---

## Creating Quarantine Pro â€” A Fun Learning Experiment in React Native
Slug: quarantine-pro-app

Covid-19 changed our way of life since the start of 2020 &mdash; a year some of us want to fast forward like a button on that TV remote. That said, self-isolating is the best thing you can do right now, and thus, isolating ourselves at Jscrambler, we came up with a fun, simple React Native app idea.

The app is all about how long you have been quarantining. As a user, you input the date when you started isolating and the app is going to display a fun message to tell you how far you have come in the quarantine â€œgameâ€.

That said, apart from being fun, this tutorial is going to show you how to use the Expo's SDK version `37.x.x.` of [Expo](https://expo.io) to build a demo app. You will learn:

- How to use [Expo font hook](https://github.com/byCedric/use-expo/blob/master/packages/font/docs/use-fonts.md);
- How to use a [date time picker modal](https://github.com/mmazzarolo/react-native-modal-datetime-picker) to select a date;
- Use [Moment.js](https://momentjs.com/) to convert the data input provided by the user and calculate the difference between the current date.

Here is a sneak peek of what we intend to build in this tutorial:

![js16](https://i.imgur.com/R9zCaz7.png)

You can find the complete code for this tutorial at this [GitHub repo](https://github.com/amandeepmittal/CheckQuarantineLevel).

## Create a New Expo App

Start by creating a new Expo app at your favorite side-projects location in your local development environment. Run the following command from a new terminal window to generate a new React Native app using `expo-cli`.

```shell
npx expo-cli init DaVinciOfIsolation
```

When asked to select a template, choose the template `blank` from `Managed workflow`.

![js1](https://i.imgur.com/MXEazbt.png)

After that, press enter and let expo-cli install the dependencies required to start this project.

Once the project has initialized generating, go to the project directory from the terminal window and start the Expo bundler service.

```shell
expo start
```

This will start the Expo app in a simulator or device of your choice where the Expo client is installed. For more information on how to install an Expo client, please visit the [official documentation](https://docs.expo.io/get-started/installation/#running-the-expo-client-on-your-computer).

Once the app is running in the Expo client, you are going to be welcomed by the following default screen:

![js2](https://i.imgur.com/DqKf72F.png)

Let us install the npm dependencies we are going to need to build this project by executing the following command:

```shell
expo install expo-font @use-expo/font @react-native-community/datetimepicker
```

The `expo install` adds dependencies using a specific version that is compatible with the Expo SDK.

Also, install the following npm packages either using `npm install` or using `yarn`:

```shell
yarn add react-native-modal-datetime-picker moment
```

With that, we have installed the required set of npm dependencies. Let us move further and start building the app.

## How To Use Custom Fonts In An Expo App

### Install a New Font

In this app, we are going to use a specific custom font that is free to download from Google Fonts - `Press Start 2P`. It is available to download [here](https://fonts.google.com/specimen/Press+Start+2P?sidebar.open&selection.family=Press+Start+2P).

![js3](https://i.imgur.com/Ftrt9os.png)

To use this font or any other custom font, create a new directory called `fonts` inside the `assets/` folder. Then place the font file(s) you have just downloaded. The path to the fonts directory `./assets/fonts` is a convention that Expo developers recommend using when placing custom fonts in your app.

After placing the file inside the newly created directory, the file structure will look like below.

![js4](https://i.imgur.com/uZLhovM.png)

When you are downloading a font to use in an Expo React Native app, make sure you download either a font in either `.otf` or `.ttf` format. Those are the two formats that work across all Expo platforms such as web, iOS, and Android.

### Use The useFonts Hook

To use any [hook](https://jscrambler.com/blog/introducing-react-hooks) in a React or React Native app, you have to use functional components. To set up a new font, start by importing the following statements.

```js
import React from 'react';
import { View, Text } from 'react-native';
import { useFonts } from '@use-expo/font';
import { AppLoading } from 'expo';
```

The `useFonts` hook takes one argument as a JavaScript object and returns a single item list containing a value telling you whether the font is loaded or not. This eliminates the need for a lot of boilerplate code to make this check.

After you have imported the statements, create a new object called `customFont`. It will have a key - the name of the font itself - and the value of this key - the path to the font file in `assets/fonts/` directory.

```js
const customFont = {
  'Press-Start2p': require('./assets/fonts/PressStart2P-Regular.ttf')
};
```

Next, inside the function component, define the `isLoaded` variable from the `useFonts` hook and pass the `customFont` object as its argument.

Also, when the font is in the loading state or has not loaded yet, it is a good practice to make use of the `AppLoading` component from Expo and render nothing on the screen. Once the font has loaded, the screen will display the content of the functional component.

Here is the complete code of the `App` component. Right now, we are displaying the title of the app using the new font we have just installed.

```js
export default function App() {
  const [isLoaded] = useFonts(customFont);

  if (!isLoaded) {
    return <AppLoading />;
  }

  return (
    <View
      style={{
        flex: 1,
        alignItems: 'center',
        backgroundColor: '#ffbd12'
      }}
    >
      <Text
        style={{
          fontFamily: 'Press-Start2p',
          fontSize: 24,
          marginTop: 80,
          paddingHorizontal: 20
        }}
      >
        {`Are You a Quarantine Pro?`}
      </Text>
    </View>
  );
}
```

From the above snippet, make sure you describe the `fontFamily` property on the `Text` component. This is the only way the font is going to be used for a specific text component.

Go back to the Expo client and you are going to see the following result.

![js5](https://i.imgur.com/TdsTeq1.png)

That's it! You have completed the first step of loading fonts and using them in a React Native app. Thanks to [Cedric van Putten](https://x.com/cedricvanputten) who has made the process of loading and mapping fonts easier for us. For more information check out Cedric's collection of hooks that you can use in an Expo app [here](https://github.com/byCedric/use-expo).

## Create a Button To Use The Datetime Picker Modal

Since we have already installed the required npm dependencies to show a date picker modal (that uses the native date picker module), let us add a button to the current `App.js` file in order to display this modal.

Start by modifying the import statements as stated below and add the new ones.

```js
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Dimensions,
  TouchableWithoutFeedback
} from 'react-native';
import {
  Fontisto,
  MaterialCommunityIcons,
  FontAwesome
} from '@expo/vector-icons';
import DateTimePickerModal from 'react-native-modal-datetime-picker';
```

To set the width and the height of the button, we are going to use the `Dimensions` API from the `react-native` core. The width and height of the button are going to be calculated based on the width of the current window.

Define a variable `W` that is going to represent the width of the window before the `App` functional component.

```js
const W = Dimensions.get('window').width;
```

Next, after the app's title text, define another container `View` component for the button. We are going to wrap the contents of the `TouchableWithoutFeedback` button inside a separate `View` component since this touchable component from React Native is only allowed to have a child component. However, we are going to have two child components: the icon of the button and the text. Modify the return statement of the `App` component as per the code snippet below.

```js
return (
  <View style={styles.container}>
    <Text style={styles.title}>{`Are You a Quarantine Pro?`}</Text>
    <TouchableWithoutFeedback>
      <View style={styles.pickerContainer}>
        <Fontisto style={styles.icon} name="calendar" size={48} />
        <Text style={styles.pickerText}>{`Tap here to\nselect a date`}</Text>
      </View>
    </TouchableWithoutFeedback>
  </View>
);
```

Add the following styles for the above code snippet. Let's make use of the `StyleSheet` object to manage styles in the current component file.

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    backgroundColor: '#ffbd12'
  },
  title: {
    fontFamily: 'Press-Start2p',
    fontSize: 24,
    marginTop: 80,
    paddingHorizontal: 20,
    lineHeight: 30
  },
  pickerContainer: {
    marginTop: 20,
    backgroundColor: '#00c6ae',
    width: W / 1.2,
    height: W / 4,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#000',
    borderBottomWidth: 5,
    borderBottomColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row'
  },
  pickerText: {
    fontFamily: 'Press-Start2p',
    fontSize: 14,
    paddingHorizontal: 10,
    lineHeight: 20
  },
  icon: {
    color: '#000'
  }
});
```

Refresh the Expo client to get the following result.

![js6](https://i.imgur.com/68IjJHf.png)

Now, let us bind the date picker modal to this button. We already imported the npm package `react-native-modal-datetime-picker` we need for this step. Why are we using this library over the default [`@react-community/react-native-datetimepicker`](https://github.com/react-native-community/datetimepicker) because this special library exposes a cross-platform interface for showing the native date-picker and time-picker inside a modal.

For our app, we are also going to evaluate the number of days the user has already spent in quarantine based on the date they choose as the input. Let us define a few state variables using the `useState` hook from React for the following reasons:

- `pickedDate` to store the date picked by the user;
- `isDatePickerVisible` to show or hide the date picker modal.

We have to define three helper functions along with these state variables. The first two will handle the visibility of the date picker modal. The third one will handle the confirm button from the date picker modal - as to what action to take when the user has to choose a date. The action we have to take here is to hide the date picker modal as well as store the value of the date in the state variable `pickedDate`.

```js
export default function App() {
  // ... rest of the component remains same

  const [pickedDate, setPickedDate] = useState(null);
  const [isDatePickerVisible, setDatePickerVisibility] = useState(false);

  function showDatePicker() {
    setDatePickerVisibility(true);
  }

  function hideDatePicker() {
    setDatePickerVisibility(false);
  }

  function handleConfirm(date) {
    console.log('A date has been picked: ', date);
    hideDatePicker();
    setPickedDate(date);
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{`Are You a Quarantine Pro?`}</Text>
      <TouchableWithoutFeedback onPress={showDatePicker}>
        <View style={styles.pickerContainer}>
          <Fontisto style={styles.icon} name="calendar" size={48} />
          <Text style={styles.pickerText}>{`Tap here to\nselect a date`}</Text>
        </View>
      </TouchableWithoutFeedback>
      <DateTimePickerModal
        isVisible={isDatePickerVisible}
        mode="date"
        onConfirm={handleConfirm}
        onCancel={hideDatePicker}
        headerTextIOS="When did you start isolating?"
      />
    </View>
}
```

The `showDatePicker` method is going to be triggered every time a user taps the button to display the picker modal. The component will only render on the device's screen when this method triggers.

![js7](https://i.imgur.com/GP0TyL8.gif)

When the user taps anywhere outside the modal or taps on the `Cancel` button, the modal is hidden again and nothing happens.

![js8](https://i.imgur.com/4CmuZlb.gif)

![js9](https://i.imgur.com/ZKeWQIi.gif)

However, when a date is selected and the user taps `Confirm`, further actions can be taken. For now, let us show the date picked by the user in a console statement.

The output is shown in the Expo server that is running in the terminal window.

![js11](https://i.imgur.com/QyAAfoM.png)

This means that the user input is now stored in the state variable `pickedDate`.

Also, you can apply other props available in [`@react-community/react-native-datetimepicker`](https://github.com/react-native-community/datetimepicker). In the date picker modal we are implementing, there is small customization using the prop `headerTextIOS`. This prop allows changing the title of the picker modal for iOS devices.

## Evaluate The â€œQuarantine Scoreâ€

The second missing piece of the puzzle in our current app is to have a button to calculate the day(s) difference between the user's input and the current date (we will use this as our â€œquarantine scoreâ€).

We are going to follow the same strategy design-wise as in the previous section. Display a button that users can tap to see their score.

Start by importing the `moment` library in the `App.js` file after the rest of the import statements. It is going to handle the calculation between the user's input and the current date.

```js
// rest of the import statements
import moment from 'moment';
```

This library is also going to help us format the input from the date picker modal and display only the date (and not time) from the user's input in the format `YYYY-MM-DD`.

Modify the return statement by adding a new `View` container that consists of a text message and the button to calculate the difference between the days.

Also, before modifying the `return` statement of the functional component, add a helper method called `daysRemaining()` that is going to calculate the difference. We are going to store this difference in a state variable called `days`. This state variable is going to be used in the next section to display the correct result on the screen.

The difference is going to be calculated between the `pickedDate` (which is the user's input) and the `todaysDate` (which is the current date).

```js
export default function App() {
const [days, setDays] = useState('');

function daysRemaining() {
  // user's input
    let eventdate = moment(pickedDate);
    // getting current date
    let todaysdate = moment();
    let remainingDays = todaysdate.diff(eventdate, 'days');
    setDays(remainingDays);
    return remainingDays;
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{`Are You a Quarantine Pro?`}</Text>
      <TouchableWithoutFeedback onPress={showDatePicker}>
        <View style={styles.pickerContainer}>
          <Fontisto style={styles.icon} name="calendar" size={48} />
          <Text style={styles.pickerText}>{`Tap here to\nselect a date`}</Text>
        </View>
      </TouchableWithoutFeedback>
      <DateTimePickerModal
        isVisible={isDatePickerVisible}
        mode="date"
        onConfirm={handleConfirm}
        onCancel={hideDatePicker}
        headerTextIOS="When did you start isolating?"
      />
      {/* ADD BELOW */}
      <View style={styles.showDateContainer}>
        <Text style={styles.showDateText}>
          You started isolating on{' '}
          {pickedDate && (
            <Text style={styles.showDateText}>
              {moment(pickedDate).format('YYYY-MM-DD')}.
            </Text>
          )}
        </Text>
        <TouchableWithoutFeedback onPress={daysRemaining}>
          <View style={styles.evaluateButtonContainer}>
            <Text style={styles.evaluateButtonText}>Check your level</Text>
          </View>
        </TouchableWithoutFeedback>
      </View>
    </View>
}
```

The picked date is displayed in the desired format using `moment().format()` functions. The `pickedDate` will only show once the user has provided input by selecting the date from the date picker modal.

Here are the corresponding styles for the above snippet.

```js
const styles = StyleSheet.create({
  // rest of the styles remain same
  showDateContainer: {
    marginTop: 20,
    backgroundColor: '#F95A2C',
    width: W / 1.2,
    height: W / 2,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#000',

    alignItems: 'center'
  },
  showDateText: {
    fontFamily: 'Press-Start2p',
    fontSize: 14,
    padding: 10,
    marginTop: 20,
    lineHeight: 20
  },
  evaluateButtonContainer: {
    marginTop: 20,
    backgroundColor: '#1947E5',
    width: W / 1.4,
    height: W / 6,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#000',
    borderBottomWidth: 5,
    borderBottomColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row'
  },
  evaluateButtonText: {
    color: '#fff',
    fontFamily: 'Press-Start2p',
    fontSize: 14,
    paddingHorizontal: 10,
    lineHeight: 20
  },
}
```

Here is the initial result you are going to get in the Expo client.

![js13](https://i.imgur.com/ePDFXIz.png)

Select the date from the picker modal. After the date has been picked, it will be shown as below.

![js14](https://i.imgur.com/SXIJ4nR.gif)

## Rendering The â€œQuarantine Levelâ€

The last piece of this current app is to display the result when the user presses the button that says `Check your level`.

![js15](https://i.imgur.com/49oXGbD.png)

Modify the return statement of the `App` component. When the result is available, we are going to show the user's quarantine level - but, when itâ€™s not available, this UI box will display a default message. Just after the previous section's snippet, add another `View` container component.

When the evaluation is done, `renderAchievements()` is going to return only the icon and the text message that is based on the score (difference between the current date and the user's input date). Since we are using a state variable called `days` to store this difference, it becomes easy to conditionally render the message.

```js
export default function App() {
// rest of the code remains the same

function renderAchievements() {
    if (days > 1 && days < 5) {
      return (
        <>
          <MaterialCommunityIcons
            name="guy-fawkes-mask"
            color="#000"
            size={54}
          />
          <Text style={styles.resultText}>
            Quarantine Noob. Don't forget to wear a mask. Keep self-isolating.
          </Text>
        </>
      );
    } else if (days >= 5 && days <= 7) {
      return (
        <>
          <MaterialCommunityIcons name="glass-wine" color="#000" size={54} />
          <Text style={styles.resultText}>Quarantine Connoisseur. Welcome to the (literal) dark side!</Text>
        </>
      );
    } else if (days >= 8 && days <= 15) {
      return (
        <>
          <MaterialCommunityIcons
            name="seat-legroom-reduced"
            color="#000"
            size={54}
          />
          <Text style={styles.resultText}>Quarantine Proficient. AKA â€œWhat is pants?â€</Text>
        </>
      );
    } else if (days >= 16 && days <= 22) {
      return (
        <>
          <MaterialCommunityIcons
            name="star-circle-outline"
            color="#000"
            size={54}
          />
          <Text style={styles.resultText}>Quarantine Veteran. #StayHome became your life motto.</Text>
        </>
      );
    } else if (days >= 23) {
      return (
        <>
          <FontAwesome name="paint-brush" color="#000" size={54} />
          <Text style={styles.resultText}>THE ULTIMATE QUARANTINE PRO! You are part of the solution - thank you!</Text>
        </>
      );
    } else
      return (
        <Text style={styles.resultText}>Your level will be shown here.</Text>
      );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{`Are You a Quarantine Pro?`}</Text>
      <TouchableWithoutFeedback onPress={showDatePicker}>
        <View style={styles.pickerContainer}>
          <Fontisto style={styles.icon} name="calendar" size={48} />
          <Text style={styles.pickerText}>{`Tap here to\nselect a date`}</Text>
        </View>
      </TouchableWithoutFeedback>
      <DateTimePickerModal
        isVisible={isDatePickerVisible}
        mode="date"
        onConfirm={handleConfirm}
        onCancel={hideDatePicker}
        headerTextIOS="When did you start isolating?"
      />
      <View style={styles.showDateContainer}>
        <Text style={styles.showDateText}>
          You started isolating on{' '}
          {pickedDate && (
            <Text style={styles.showDateText}>
              {moment(pickedDate).format('YYYY-MM-DD')}.
            </Text>
          )}
        </Text>
        <TouchableWithoutFeedback onPress={daysRemaining}>
          <View style={styles.evaluateButtonContainer}>
            <Text style={styles.evaluateButtonText}>Check your level</Text>
          </View>
        </TouchableWithoutFeedback>
      </View>

      {/* ADD BELOW */}

      <View style={styles.resultContainer}>{renderAchievements()}</View>
    </View>
}
```

Here are styles for the `renderAchievements()`.

```js
const styles = StyleSheet.create({
  // rest of the styles remain same
  resultContainer: {
    marginTop: 20,
    backgroundColor: '#FF89BB',
    width: W / 1.2,
    height: W / 2,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#000',
    justifyContent: 'center',
    alignItems: 'center'
  },
  resultText: {
    color: '#fff',
    fontFamily: 'Press-Start2p',
    fontSize: 16,
    padding: 15,
    lineHeight: 20
  }
});
```

Now, go back to the Expo client and you will be welcomed by the following screen:

![js16](https://i.imgur.com/R9zCaz7.png)

Try to run the app and select different dates to see different results as shown below.

![js17](https://i.imgur.com/3vcjgbH.gif)

## Conclusion

We hope you had fun building this app and learning as well. The main objectives of this tutorial are complete now and summarized for better understanding as below.

- How to use [Expo font hook](https://github.com/byCedric/use-expo/blob/master/packages/font/docs/use-fonts.md)
- How to use the [datetime picker modal](https://github.com/mmazzarolo/react-native-modal-datetime-picker) to select a date
- Use [Moment.js](https://momentjs.com/) to convert the date input provided by the user and calculate the difference between the current date (â€œquarantine scoreâ€).

Check out [@react-native-community/datetimepicker](https://github.com/react-native-community/datetimepicker) for more information on how to customize the date picker modal or try to use a time picker. The Moment.js library is full of functions to help you manage date and time in JavaScript apps (another tutorial [here](https://jscrambler.com/blog/a-momentjs-in-time)).

The app is available at Expo [here](https://expo.io/@amanhimself/quarantinepro), you just need to scan the QR code with the Expo client ([iOS](https://apps.apple.com/app/apple-store/id982107779) | [Android](https://play.google.com/store/apps/details?id=host.exp.exponent&referrer=www)) app on your device.

Originally published at [Jscrambler's blog](https://jscrambler.com/blog/creating-quarantine-pro-a-fun-learning-experiment-in-react-native).

---

## How to solve RCTBridge required dispatch_sync to load warning on iOS for React Native
Slug: rctbridge-required-dispatch-sync-to-load-warning

The _RCTBridge required dispatch_sync to load RCTDevLoadingView_ has become a common occurrence when developing React Native apps with version `0.64` and `0.65`.

![ss1](https://i.imgur.com/IqzhnvQ.png)

I came across this warning when installing packages like:

- react-native-bootsplash
- react-navigation v6

Recently, I came across an open issue on [github.com/facebook/react-native](https://github.com/facebook/react-native/issues/16376) that contains the following resolution for this.

Open the file `./ios/AppName/AppDelegate.m`. First, add the following just after the import statement `#import "AppDelegate.h"`:

```c
#import "AppDelegate.h"

// Add this
#if RCT_DEV
#import <React/RCTDevLoadingView.h>
#endif
// ---------------
```

Then, in the `@implementation AppDelegate`, before `RCTRootView`, add the following:

```c
  #if RCT_DEV
    [bridge moduleForClass:[RCTDevLoadingView class]];
  #endif

  RCTRootView *rootView ...
```

Build the iOS app again by running:

```shell
yarn run ios

# or

npx react-native run-ios
```

The warning will be gone now.

---

## React Native: Building a Minimalist Weather App using Expo XDE
Slug: react-native-building-a-minimalist-weather-app-using-expo-xde

React Native is a great framework to develop cross-platform mobile applications for the platforms iOS and Android. In this, I am going to take you through the process of building a â€œminimalistâ€ weather application using React Native by fetching real-time data. If you have never worked with React Native, you can use this walkthrough as kickstart in your journey of becoming a mobile application developer and will be a cool project for your portfolio.

### Getting Started: Requirements

You have some experience of working your way with Reactjs, you will have no problem following this tutorial. If you newbie to JavaScript or Reactjs ecosystem, I want to halt right here and go through [this awesome resource](http://www.react.express/) that can help you with understanding the basic concepts in this tutorial. Donâ€™t spend too much time if you are not interested in building web applications using Reactjs, just go through the nitty-gritty.

Please note that React Native is not a hybrid mobile app framework like others available. It uses a bridge between Javascript and native APIs of a specific platform. Do take a look at [React Native Official Docs](https://facebook.github.io/react-native/docs/getting-started.html) to read more about this.

I will be using [Expo](https://expo.io/) which is described as â€œthe fastest way to build an appâ€. It is an open-source set of tools and services that come in handy, especially if you are getting started in the React Native world. The development tool I am going to use for Expo is [Expo XDE](https://expo.io/).

**Requirements summary**

- You know how to write JavaScript
- Familiar with React
- Nodejs installed on your local machine
- Simple `npm` commands

Thatâ€™s all. Let us get started with the development process.

### Getting Started: In real thisÂ time

Open the Expo XDE after its installation and click on the â€œCreate New Projectâ€.

<img src='https://cdn-images-1.medium.com/max/800/0*6kAET2qSInCk6rtP.png' />

Enter the name of your application and click on â€œCreateâ€. The name of the application will be in lowercase, I donâ€™t know why, Expo XDE UI does not support uppercase characters.

<img src='https://cdn-images-1.medium.com/max/800/0*NyV0f0GPNVnTeJHd.png' />
![](https://cdn-images-1.medium.com/max/800/0*JIjaFynv5BRNDAh4.png)

Expo, behind the scenes using React Native Package manager to simulate the application and the load dependencies from the appâ€™s `package.json` file. The benefit of using Expo XDE is that you do not have to open multiple terminal windows and you can test the app while still developing on a real device. Once it is done with the process of generating a source code of our app, we can start it in a simulator on our local machine to see the default app it comes with.

<img src='https://cdn-images-1.medium.com/max/800/0*ft82CkCgUzl2AFoj.png' />

If you are on Mac, make sure, you have Xcode installed. If you are using Windows, please follow the instructions to install Android Studio to run the simulator.

If you want to skip simulating the app and run it on an actual device without generating anyÂ `.apk` orÂ `.ipa`, install the Expo client and scan the QR code generated by default by Expo XDE.

<img src='https://cdn-images-1.medium.com/max/800/0*gp1nRwd4sg051Weh.png' />

Once, bundling of the source code is done you will be prompt with a success message on the Expo XDE terminal:

<img src='https://cdn-images-1.medium.com/max/800/0*1pOjz1x6gdMbCuxJ.png' />

And you will be able to see that our default app is running on the device:

<img src='https://cdn-images-1.medium.com/max/800/0*vvy0yzLxdw5BHhIy.png' />

<img src='https://cdn-images-1.medium.com/max/800/0*VQREoYLkE45Iw2Ku.png' />

The message displayed here is the same code that is rendered by `App.js` in the root of our app.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class App extends React.Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>Minimalist Weather App</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

Change the `<Text>` to:

```js
<Text>Minimalist Weather App</Text>
```

and you will see the output being rendered and the app is reloaded live. You donâ€™t have to refresh it to see the changes.

<img src='https://cdn-images-1.medium.com/max/800/0*HGCr4kSfTugsZq9-.png' />

This completes our first getting started step. In the next step, we will build a static prototype of what our app is going to look like.

### The Prototype

In this step, we will be developing our first screen, that is going to be loading screen.

In your `App.js`, define a local state:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class App extends React.Component {
  state = {
    isLoading: false
  };

  render() {
    const { isLoading } = this.state;
    return (
      <View style={styles.container}>
        {isLoading ? null : (
          <View>
            <Text>Minimalist Weather App</Text>
          </View>
        )}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

The above code states that when our local state object `isLoading` is false, we will show the name of the application. This is what we are going to render. Later on, instead of displaying the name of application we will be showing the weather here once our API has successfully fetches the data. For now, I am sticking to this message because first, we are going to work on, what if our app is in the state of loading? Let's add a text message to indicate that the app is fetching the data.

```js
import React from 'react';
import { StyleSheet, Text, View, Animated } from 'react-native';

export default class App extends React.Component {
  state = {
    isLoading: true
  };

  render() {
    const { isLoading } = this.state;
    return (
      <View style={styles.container}>
        {isLoading ? (
          <Text>Fetching The Weather</Text>
        ) : (
          <View>
            <Text>Minimalist Weather App</Text>
          </View>
        )}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

When our app is done loading the data from the API, we will set the state of `isLoading` to false.

<img src='https://cdn-images-1.medium.com/max/800/0*1ii9x6Eoi02W3d6h.png' />

### First Screen

We will define a new Weather component atÂ `./components/Weather.js`. The boilerplate code for every weather condition screen is going to be the same. It will be divided into two views, a header, and a body. The header will show the weather condition icon and temperature and the body will display the text associated with the weather condition.

In Weather.js, we will start by defining two containers inside the main container: `headerContainer` and `bodyContainer`. Do note that we are defining `Weather` component not as a class but a function in order to receive props and since it will not be managing a state.

```js
import React from 'react';
import { View, Text, Stylesheet } from 'react-native';

const Weather = () => {
  return (
    <View style={styles.container}>
      <View style={styles.headerContainer} />
      <View style={styles.bodyContainer} />
    </View>
  );
};

const styles = StyleSheet({
  container: {
    flex: 1
  },
  headerContainer: {},
  bodyContainer: {}
});

export default Weather;
```

We will be using `MatericalCommunityIcons` that comes with expo (one of the perks) as a sub-library of a humongous library called `vector-icons`.

```js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

const Weather = () => {
  return (
    <View style={styles.weatherContainer}>
      <View style={styles.headerContainer}>
        <MaterialCommunityIcons size={48} name="weather-sunny" color={'#fff'} />
        <Text style={styles.tempText}>TemperatureËš</Text>
      </View>
      <View style={styles.bodyContainer}>
        <Text style={styles.title}>So Sunny</Text>
        <Text style={styles.subtitle}>It hurts my eyes!</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  weatherContainer: {
    flex: 1,
    backgroundColor: '#f7b733'
  },
  headerContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  tempText: {
    fontSize: 48,
    color: '#fff'
  },
  bodyContainer: {
    flex: 2,
    alignItems: 'flex-start',
    justifyContent: 'flex-end',
    paddingLeft: 25,
    marginBottom: 40
  },
  title: {
    fontSize: 48,
    color: '#fff'
  },
  subtitle: {
    fontSize: 24,
    color: '#fff'
  }
});

export default Weather;
```

This how our app looks after the prototypal stage is complete.

<img src='https://cdn-images-1.medium.com/max/800/0*cpkJvjx_VETikRV5.png' />

### Fetching TheÂ Data

To fetch real-time weather data I found [Open Weather Map API](https://openweathermap.org/) to be highly useful and consistent. To communicate with the API you are going to need an API key. Register yourself as a user on the site, and get your API key. Please note that it takes at least 10 minutes for Open Weather API to activate the API key. Once it is available, tag along.

Go to the [API section](https://openweathermap.org/api) and you will see that our need is satisfied by the Current Weather data. I am going to store my API key inÂ `./utils/WeatherAPIKey.js` file. I know not the best name for a file.

```js
export const API_KEY = 'YOUR_API_KEY HERE';
```

The way the Open Weather API works is that we need to provide it coordinates using deviceâ€™s location in terms of longitude and latitude. It will then fetch the data from its server which will be a JSON object. From the server, right now we need two things, the temperature, and the weather condition. We should have temperature and the weather condition stored in our local state in `App.js`.

```js
import React from 'react';
import { StyleSheet, Text, View, Animated } from 'react-native';

import { API_KEY } from './utils/WeatherAPIKey';

import Weather from './components/Weather';

export default class App extends React.Component {
  state = {
    isLoading: false,
    temperature: 0,
    weatherCondition: null,
    error: null
  };

  componentDidMount() {
    navigator.geolocation.getCurrentPosition(
      position => {
        this.fetchWeather(position.coords.latitude, position.coords.longitude);
      },
      error => {
        this.setState({
          error: 'Error Getting Weather Conditions'
        });
      }
    );
  }

  fetchWeather(lat = 25, lon = 25) {
    fetch(
      `http://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&APPID=${API_KEY}&units=metric`
    )
      .then(res => res.json())
      .then(json => {
        console.log(json);
      });
  }

  render() {
    const { isLoading } = this.state;
    return (
      <View style={styles.container}>
        {isLoading ? <Text>Fetching The Weather</Text> : <Weather />}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  }
});
```

We start by importing the API key we just defined and then updating our state with `temperature`, `weatherCondition`, and `error`. We are using `componentDidMount()` a lifecycle method which helps us re-render once our API is done fetching the data. It will also help us in updating the state. We are also using JavaScript `navigator` API to get the current location. This is where a JavaScript API will communicate with a native one using a bridge. We pass on the values of latitude and longitude to our custom function `fetchWeather` where the API of Open Weather Map is called.

The result we get is in JSON format, and if you console log it, you will be able to see the result as a JSON object in Expo terminal where there are a lot of values. We only need the value of temperature and the weather condition. We then update local state with the new values obtained. `&units=metric` at the end of our API call converts the temperature from Kelvin to Celsius.

```js
.then(json => {
        // console.log(json);
        this.setState({
          temperature: json.main.temp,
          weatherCondition: json.weather[0].main,
          isLoading: false
        });
```

Now, all we have to do is pass the value two of our local state as props to the `Weather` Component and then update it such that it can receive those props.

First, in `App.js`:

```js
<Weather weather={weatherCondition} temperature={temperature} />
```

Update the `Weather.js`:

```js
const Weather = ({ weather, temperature }) => {
  return (
    <View style={styles.weatherContainer}>
      <View style={styles.headerContainer}>
        <MaterialCommunityIcons size={48} name="weather-sunny" color={'#fff'} />
        <Text style={styles.tempText}>{temperature}Ëš</Text>
      </View>
      <View style={styles.bodyContainer}>
        <Text style={styles.title}>{weather}</Text>
        <Text style={styles.subtitle}>It hurts my eyes!</Text>
      </View>
    </View>
  );
};
```

<img src='https://cdn-images-1.medium.com/max/800/0*IUfQ_1hTKAa-U0m4.png' />

Since we have done the hard part of fetching the real-time data, we must make `Weather` component behave [dynamically to the values](https://openweathermap.org/weather-conditions) it is getting. All this dynamic part is going to be associated with one thing which we are getting from our local state, `weatherCondition`.

### Dynamic Behaviour

Using `weatherCondition` we can define the background changes, title, subtitle and weather icon changes. Let's start by pre-defining weather conditions in a fileÂ `./utils/WeatherConditions.js`.

```js
export const weatherConditions = {
  Rain: {
    color: '#005BEA',
    title: 'Raining',
    subtitle: 'Get a cup of coffee',
    icon: 'weather-rainy'
  },
  Clear: {
    color: '#f7b733',
    title: 'So Sunny',
    subtitle: 'It is hurting my eyes',
    icon: 'weather-sunny'
  },
  Thunderstorm: {
    color: '#616161',
    title: 'A Storm is coming',
    subtitle: 'Because Gods are angry',
    icon: 'weather-lightning'
  },
  Clouds: {
    color: '#1F1C2C',
    title: 'Clouds',
    subtitle: 'Everywhere',
    icon: 'weather-cloudy'
  },

  Snow: {
    color: '#00d2ff',
    title: 'Snow',
    subtitle: 'Get out and build a snowman for me',
    icon: 'weather-snowy'
  },
  Drizzle: {
    color: '#076585',
    title: 'Drizzle',
    subtitle: 'Partially raining...',
    icon: 'weather-hail'
  },
  Haze: {
    color: '#66A6FF',
    title: 'Haze',
    subtitle: 'Another name for Partial Raining',
    icon: 'weather-hail'
  },
  Mist: {
    color: '#3CD3AD',
    title: 'Mist',
    subtitle: "Don't roam in forests!",
    icon: 'weather-fog'
  }
};
```

These weather conditions are provided from Open Weather API [here](https://openweathermap.org/weather-conditions). Then, letâ€™s import this file in our `Weather.js`. We will also define PropTypes now for the two props we are receiving from `App.js`. Take a look below, it is simple.

```js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import PropTypes from 'prop-types';
import { weatherConditions } from '../utils/WeatherConditions';

const Weather = ({ weather, temperature }) => {
  return (
    <View
      style={[
        styles.weatherContainer,
        { backgroundColor: weatherConditions[weather].color }
      ]}
    >
      <View style={styles.headerContainer}>
        <MaterialCommunityIcons
          size={72}
          name={weatherConditions[weather].icon}
          color={'#fff'}
        />
        <Text style={styles.tempText}>{temperature}Ëš</Text>
      </View>
      <View style={styles.bodyContainer}>
        <Text style={styles.title}>{weatherConditions[weather].title}</Text>
        <Text style={styles.subtitle}>
          {weatherConditions[weather].subtitle}
        </Text>
      </View>
    </View>
  );
};

Weather.propTypes = {
  temperature: PropTypes.number.isRequired,
  weather: PropTypes.string
};

const styles = StyleSheet.create({
  weatherContainer: {
    flex: 1
  },
  headerContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-around'
  },
  tempText: {
    fontSize: 72,
    color: '#fff'
  },
  bodyContainer: {
    flex: 2,
    alignItems: 'flex-start',
    justifyContent: 'flex-end',
    paddingLeft: 25,
    marginBottom: 40
  },
  title: {
    fontSize: 60,
    color: '#fff'
  },
  subtitle: {
    fontSize: 24,
    color: '#fff'
  }
});

export default Weather;
```

Most of the source code is same. We are now just making some additions by using available props with weather conditions and to dynamically change the background, icon, weather name, and the subtitle. You can play around with the styling to make it look more minimalistic or more exquisite, it is up to you.

<img src='https://cdn-images-1.medium.com/max/600/0*xjM1JAPtNLWtzvau.gif' />

**Note:** Before running the application on your actual device make sure you have internet access and location â€œonâ€ the device for this app to work. We havenâ€™t talked about App Permissions in this article and it is a bit out of the scope too.

The whole code for this application is available at this [Github Repo](https://github.com/amandeepmittal/rn-minimalist-weather-app). I have also published the application on [Expo Store here](https://expo.io/@amanhimself/rn-minimalist-weather-app) for you to test out. Just scan the QR code and run the application to see what you will be working in this tutorial.

[Originally this article was published on Blog.expo.io](https://blog.expo.io/building-a-minimalist-weather-app-with-react-native-and-expo-fe7066e02c09)

---

## How to use React Native Geolocation to get Postal Address
Slug: react-native-geolocation-to-get-postal-address

Geolocation in React Native applications is the ability to fetch the geographic position of the device when it is connected to the internet. It takes advantage of an API that provides the current location of the device in the form of Longitude and Latitude coordinates. It can be used to add features such as fetching simple location coordinates of a device or getting the current location of the device. Ultimately, Geolocation provides support to the development functionalities seen in delivery or ride-hailing applications.

In this tutorial, let's learn how you can implement a feature to get the current location of a device in a React Native app. To do this weâ€™ll be using an API provided by Expo in the form of a package called `expo-location`. We will then convert the location coordinates into human-readable postal address format.

The source code is available at this [GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/expo-geolocation-example).

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements in your local dev environment:

- Have [Node.js](https://nodejs.org/) version >= `12.x.x` installed.
- Have access to one package manager such as npm or yarn or npx.
- Have [expo-cli](https://github.com/expo/expo-cli) installed, or use npx

## Create a React Native app with expo-cli

Create a new React Native project using `expo-cli` and then install the dependencies required to build this demo app. Let's break down what we are going to implement:

- The demo app is going to mimic a food delivery app feature where when an end-user opens the app, the first thing they are prompted for is to fetch their current location. Let's call this screen a Welcome screen.
- Only once the location is fetched, will the end-user be taken to the Home screen of the app. This is a condition we are going to put in our demo.
- We will be using a stack navigator from [React Navigation](https://reactnavigation.org/docs/getting-started) library. This is just an example of understanding the concepts of using Geolocation data in a React Native app. You can use the same concepts in the way you want to implement the feature of fetching the current location.

Open a terminal window and execute the following commands:

```shell
npx expo init expo-geolocation-example

# navigate into that directory
cd expo-geolocation-example
yarn add @react-navigation/native @react-navigation/stack

# install dependencies with Expo specific package version
expo install expo-location react-native-gesture-handler react-native-reanimated
react-native-screens react-native-safe-area-context
@react-native-community/masked-view
```

After installing these dependencies, let's create two mock screens that are going to be the two core screens for the demo app. Create a new `screens/` directory and inside it, create the first screen file `Welcome.js`. This screen is going to display an image, a title, and a dummy mock location address for now. Later in this post, this dummy mock location address is going to display a real address based on the current location.

Add the following code snippet to this file:

```js
import React, { useState, useEffect } from 'react';
import { StyleSheet, Text, View, Image } from 'react-native';

const Welcome = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Image source={require('../assets/geo.png')} style={styles.image} />
        <Text style={styles.title}>What's your address?</Text>
      </View>
      <Text style={styles.text}>Mock Address</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#070707',
    alignItems: 'center',
    paddingTop: 130
  },
  contentContainer: {
    alignItems: 'center',
    marginBottom: 20
  },
  image: {
    width: 150,
    height: 150,
    resizeMode: 'contain',
    marginBottom: 20
  },
  title: {
    fontSize: 22,
    fontWeight: '700',
    color: '#FD0139'
  },
  text: {
    fontSize: 20,
    fontWeight: '400',
    color: '#fff'
  }
});

export default Welcome;
```

Create the second screen file `Home.js` with the following code snippet:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const Home = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text>Home</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#070707',
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export default Home;
```

Let's hook up the stack navigation container in the `App.js` file since we do not have multiple files and different ways to navigate in this demo app. I am not going through how to set up and use the React Navigation library. If you'd like to learn more on that subject please go through the post [How to Set Up and Use Navigators in React Native](https://jscrambler.com/blog/how-to-set-up-and-use-navigators-in-react-native).

Open up the `App.js` file and add the following:

```js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

// Custom screens
import Welcome from './screens/Welcome';
import Home from './screens/Home';

const Stack = createStackNavigator();

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Welcome" headerMode="none">
        <Stack.Screen name="Welcome" component={Welcome} />
        <Stack.Screen name="Home" component={Home} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

Once the navigator is set, you can open up a terminal window and run the command `expo start`. You can either choose an iOS simulator or an Android emulator or the Expo Go client app to view the results so far. Here is current the state of the demo app in an iOS simulator:

<img src="https://i.imgur.com/l0cuYI1.png" width="300" />

## Check if the device's location service enabled

The first thing in the demo app we are going to implement is to check whether a device's location services are enabled or not. For this, let's create a state variable called `locationServiceEnabled`.

To check the status of the service let's create a new handler method called `CheckIfLocationEnabled`. The `expo-location` has an asynchronous method called `Location.hasServicesEnabledAsync()`. It returns a boolean value of true if the location service on the device is enabled and if otherwise, it returns false. In case of the value false, let's display an alert box indicating the same. If the location service is enabled, then update the value of the state variable using the `setLocationServiceEnabled` method.

The handler method is then called inside a `useEffect` React hook with no dependency such that it triggers only after the first render.

Modify the `Welcome.js` screen as shown below. Do note the placeholder message displayed in the place of the mock location address using a state variable called `displayCurrentAddress`. It will get an update once the current location of the device is found.

```js
import React, { useState, useEffect } from 'react';
import { StyleSheet, Text, View, Image, Alert } from 'react-native';
import * as Location from 'expo-location';

const Welcome = ({ navigation }) => {
  const [locationServiceEnabled, setLocationServiceEnabled] = useState(false);
  const [displayCurrentAddress, setDisplayCurrentAddress] = useState(
    'Wait, we are fetching you location...'
  );

  useEffect(() => {
    CheckIfLocationEnabled();
  }, []);

  const CheckIfLocationEnabled = async () => {
    let enabled = await Location.hasServicesEnabledAsync();

    if (!enabled) {
      Alert.alert(
        'Location Service not enabled',
        'Please enable your location services to continue',
        [{ text: 'OK' }],
        { cancelable: false }
      );
    } else {
      setLocationServiceEnabled(enabled);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Image source={require('../assets/geo.png')} style={styles.image} />
        <Text style={styles.title}>What's your address?</Text>
      </View>
      <Text style={styles.text}>{displayCurrentAddress}</Text>
    </View>
  );
};

// styles remain same

export default Welcome;
```

To test it out in the iOS simulator, go to **Settings > Privacy > Location Services**.

<img src="https://i.imgur.com/Q0yZjbv.png" width="300" />

If it says on, as shown in the above image, tap it and make sure to switch off the **Location Services**.

<img src="https://i.imgur.com/yic9jlo.gif" width="250" />

Now open the app and you will notice that the alert box appears.

<img src="https://i.imgur.com/xzE8giE.gif" width="250" />

Similarly, on Android device, the location can be disabled from the following menu:

<img src="https://i.imgur.com/TKFYDhq.png" width="300" />

And the alert message will appear on the opening of the app:

<img src="https://i.imgur.com/Mk9egWP.png" width="300" />

Make sure to enable the location service again on the device before proceeding to the next section.

## Get current location and postal address

It is necessary to request access to a device's information whether it is location or any other sensitive information. Fortunately, `expo-location` has methods that can be directly used when fetching the current location of the device.

Let's break down the steps on how we are going to fetch the current location of the device and obtain the information of the current address (which includes name, street name, city, and postal code) to display on the app screen.

- First, create a new asynchronous handler method called `GetCurrentLocation`. Make sure to call it inside the `useEffect` hook after the previous code.
- Inside it, using the Location API method `requestPermissionsAsync`, ask the device's user to grant permission for the location. If, in any case, the user denies it, display them an alert box stating the same.
- If the permission is granted, get the current coordinates of the device's location using the Location API method `getCurrentPositionAsync`. The coordinates here are an object representing the location.
- Then, when the coordinates object is present, destructure the value of Latitude and Longitude. The Location API has a method called `reverseGeocodeAsync` which reverses the geocode of a location to a postal address. Using the result from this, we can update the value of `setDisplayCurrentAddress` to display the device's current address.

Update the code snippet in `Welcome.js` as shown below:

```js
// first update the useEffect hook
useEffect(() => {
  CheckIfLocationEnabled();
  GetCurrentLocation();
}, []);

// create the handler method

const GetCurrentLocation = async () => {
  let { status } = await Location.requestPermissionsAsync();

  if (status !== 'granted') {
    Alert.alert(
      'Permission not granted',
      'Allow the app to use location service.',
      [{ text: 'OK' }],
      { cancelable: false }
    );
  }

  let { coords } = await Location.getCurrentPositionAsync();

  if (coords) {
    const { latitude, longitude } = coords;
    let response = await Location.reverseGeocodeAsync({
      latitude,
      longitude
    });

    for (let item of response) {
      let address = `${item.name}, ${item.street}, ${item.postalCode}, ${item.city}`;

      setDisplayCurrentAddress(address);
    }
  }
};
```

Here is the output after this step:

<img src="https://i.imgur.com/JW51WSR.gif" width="250" />

The complete postal address is an object in JSON format and has the following fields (some of them might be useful for various cases):

```json
Object {
    "city": "Stockholm",
    "country": "Sweden",
    "district": "Stockholm City",
    "isoCountryCode": "SE",
    "name": "Gustav Adolfs torg",
    "postalCode": "111 52",
    "region": "Stockholm",
    "street": "Gustav Adolfs torg",
    "subregion": "Stockholm",
    "timezone": "Europe/Stockholm",
}
```

Once the location is fetched, we can send the current postal address as an object and navigate to the Home screen after a delay of two seconds using a `setTimeout` function.

Add the following code snippet after the statement `setDisplayCurrentAddress(address)`:

```js
if (address.length > 0) {
  setTimeout(() => {
    navigation.navigate('Home', { item: address });
  }, 2000);
}
```

Then, update the `Home.js` file to get the `item` object from `route.params` as well as its styles:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const Home = ({ route }) => {
  const { item } = route.params;
  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>Home Delivery address: </Text>
        <Text style={styles.text}>{item}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#070707',
    alignItems: 'center',
    justifyContent: 'center'
  },
  contentContainer: {
    paddingHorizontal: 20,
    alignItems: 'center'
  },
  title: {
    fontSize: 22,
    fontWeight: '700',
    color: '#FD0139',
    paddingBottom: 10
  },
  text: {
    fontSize: 20,
    fontWeight: '400',
    color: '#fff'
  }
});

export default Home;
```

Here is the final output:

<img src="https://i.imgur.com/48csotO.gif" width="250" />

## Further Reading

That's it! We hope you have found this tutorial helpful. We are adding some references for you to learn more about using Location API in Expo and React Native apps, plus which different packages can be used for your particular use case.

- [Reverse Geocode from expo-location](https://docs.expo.io/versions/latest/sdk/location/#locationreversegeocodeasynclocation)
- [@react-native-community/geolocation](https://github.com/react-native-geolocation/react-native-geolocation#README.md)
- [react-native-geolocation-service](https://github.com/Agontuk/react-native-geolocation-service)
- [Hiring a React Native Developer: What Should You Look For? by Jess Marranco](https://www.g2i.co/blog/hiring-a-react-native-developer)

**The source code is available at this [GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/expo-geolocation-example).**

_Originally Published at [Jscrambler's Blog](https://jscrambler.com/blog/how-to-use-react-native-geolocation-to-get-postal-address/)_

---

## React Native: Getting Started with Lottie and Expo
Slug: react-native-getting-started-with-lottie-and-expo

In this tutorial, we will be using [Lottie](https://www.lottiefiles.com/) with React Native. Lottie is an opensource library that renders Adobe Effects by providing easy to use animations just like static images. These animations are beautiful. Lottie is a mobile library developed by AirBnB. These animations are exported as JSON files using [Bodymovin](https://github.com/airbnb/lottie-web) to render the natively on mobile and in web applications.

> _ðŸ‘ for designers who spend their time contributing in LottieFiles._

### Requirements

I will be using Expo XDE for brevity and to get started quickly. Create a new project using it. I am going to call `rn-lottie-example` but you can call whatever you want.

<img src='https://cdn-images-1.medium.com/max/800/0*POyT_Icv07TuPXTE.png' />

When the XDE completes running ReactNative Package Manager and builds up the project, you can go to `Device` dropdown menu at the right and click on whichever simulator you have installed depending on the operations system you are using. Windows users please make sure you have android studio and necessary files installed and MacOS users, please have XCode installed or up to date.

<img src='https://cdn-images-1.medium.com/max/800/0*fX2Q-CxR1HRTvJA-.png' />

You can also view the application, by running it using Expo Client on your mobile device. Note that, depending on your internet connection, this can be slow and your mobile device and development machine must be on same wifi. Scan the QR code in `Share` section, you are ready to go. Once, the app is rendered, you will be welcomed by the default screen:

<img src='https://cdn-images-1.medium.com/max/800/0*MiGY3Fi2WDSbBXvP.png' />

Now open your favorite text editor/IDE because we are going to start writing code in next section.

### Getting Started

Installing Lottie as a dependency in a project can a bit tricky but fortunately, Expo provides support for it. We do not have to install anything since we are using Expo. We directly import the dependency in our `App.js`:

```js
import { DangerZone } from 'expo';
const { Lottie } = DangerZone;
```

Sine Lottie in Expo project is in Alpha mode, do not get worried by the word `DangerZone`.

Include a local state in our application called `animation`. We will call this help in playing and restarting the animation itself. I am using [this file](https://www.lottiefiles.com/110-location) for our animation from [LottieFiles.com](https://gist.github.com/www.lottiefiles.com) so you can download it. Of course, you are free to choose any other. Animations listed on the site are open source.

```js
state = {
  animation: null
};
```

Later, we will using the `state.animation` to source the animation file fetched directly in `Lottie` component.

### Defining the animation

We will define two custom functions: `_playAnimation` and `_loadAnimationAsync` that perform the animation and load the animation from the internet using the `fetch` API. We will also be pre-mounting our animation using `componentWillMount()` method available to us by core React. In this Life cycle method, when the state is set, it can be called before the initial render.

In general, it is used to prepare either the first render or update the state before the render. This is why we are using it. We need to update the state we defined.

```js
componentWillMount() {
    this._playAnimation();
  }

  _playAnimation = () => {
    if (!this.state.animation) {
      this._loadAnimationAsync();
    } else {
      this.animation.reset();
      this.animation.play();
    }
  };

  _loadAnimationAsync = async () => {
    let result = await fetch(
      'https://www.lottiefiles.com/storage/datafiles/a795e9d1bd5672fd901329d51661db5c/JSON/location.json'
    );

     this.setState(
      { animation: JSON.parse(result._bodyText) },
      this._playAnimation
    );
  };
```

Inside, `_loadAnimationAsync()` we use JavaScript's `fetch` API to get the animation from its source. This does mean, that the animation is coming from internet so if you are testing on your mobile device, make sure you have access to internet.

This how our render function looks like:

```js
render() {
    return (
      <View style={styles.container}>
        <View style={styles.animationContainer}>
          {this.state.animation && (
            <Lottie
              ref={animation => {
                this.animation = animation;
              }}
              style={styles.loadingAnimation}
              source={this.state.animation}
            />
          )}
        </View>
      </View>
    );
  }
```

We separately define styling for the overall container and the animation. To load the animation, we will set its `backgroundColor` to `transparent` in order to remove any background color it has by default.

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  },
  animationContainer: {
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1
  },
  loadingAnimation: {
    width: 400,
    height: 400,
    backgroundColor: 'transparent'
  }
});
```

You can see the application working

<img src='https://cdn-images-1.medium.com/max/800/0*ojXTyWvdJ70ut1Yl.gif' />

This tutorial shows how you can get started with Lottie animation library using React Native and Expo. There are other ways to define animations and you can go in-depth as much as you want. This article is written for a beginnerâ€™s point of view.

For alternative to Lottie, you can check [Facebookâ€™s Keyframes](https://github.com/facebookincubator/Keyframes) that also uses Adobe After Effects to create one.

Complete code of our demo application:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { DangerZone } from 'expo';
const { Lottie } = DangerZone;

export default class App extends React.Component {
  state = {
    animation: null
  };

  componentWillMount() {
    this._playAnimation();
  }

  _playAnimation = () => {
    if (!this.state.animation) {
      this._loadAnimationAsync();
    } else {
      this.animation.reset();
      this.animation.play();
    }
  };

  _loadAnimationAsync = async () => {
    let result = await fetch(
      'https://www.lottiefiles.com/storage/datafiles/a795e9d1bd5672fd901329d51661db5c/JSON/location.json'
    );

    this.setState(
      { animation: JSON.parse(result._bodyText) },
      this._playAnimation
    );
  };

  render() {
    return (
      <View style={styles.container}>
        <View style={styles.animationContainer}>
          {this.state.animation && (
            <Lottie
              ref={animation => {
                this.animation = animation;
              }}
              style={styles.loadingAnimation}
              source={this.state.animation}
            />
          )}
        </View>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  },
  animationContainer: {
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1
  },
  loadingAnimation: {
    width: 400,
    height: 400,
    backgroundColor: 'transparent'
  }
});
```

You can also find the complete code at this [**Github repo**](https://github.com/amandeepmittal/rn-lottie-example)**,** in case you just want to play around thisÂ concept.

_[Originally this article was published on Hackernoon.com](https://medium.com/hackernoon/react-native-getting-started-with-lottie-and-expo-8b2105fbb496)_

---

## React Native: How to Setup Your First App
Slug: react-native-how-to-setup-your-first-app

**PLEASE NOTE**

_At the start of the year 2019, I updated this post and re-wrote it here ðŸ‘‡_

Getting Started with React Native in 2019: Build Your First App Learn how to build your first React Native app with important basic concepts and where to go from [here](https://amanhimself.dev/blog/getting-started-with-react-native-in-2019-build-your-first-app).

_It is more in-depth, and covers almost every basic aspect about React Native ecosystem. By reading the new post, you will also built a more advance version of a typical â€œhello worldâ€ app._

React Native is a framework for building mobile applications with JavaScript and leveraging ReactJS. It uses native UI components. If you are familiar with React or come from front end development background, React uses a virtual DOM which acts as a shadow to real DOM available. When an element changes, that change is reflected on the real DOM by Virtual DOM using a node that corresponds to each element. However, in React Native, there is no DOM rather than Native Components which are provided by platforms such as iOS and Android. There are no web views here.

React Native has an instance of [JavaScriptCore](https://facebook.github.io/react-native/docs/javascript-environment.html) to execute JS code when an application starts. React Native uses RCTBridgeModule to make a connection between native code and JavaScript code. It is assumed that as you dwell more in development with React Native, you might come across using a third-party SDK for a specific mobile platform. This bridging will be very helpful.

### Difference between React Native andÂ Reactjs

React Native has its own wrappers around the native components and do not make use of every HTML element. For example, `<View>` which is considered similar to `div` of HTML. This is a major difference between React Native and Reactjs. This also means that you cannot reuse every library that renders HTML and is available for Reactjs. It has its own navigation modules.

### Platform Specific Designing

Designing a mobile application for multiple platforms available with the same set of code can be a bit overwhelming. In this case, a developer or a development team is left with two choices. Either they come up with a user interface that universal to their application. This means the UI of the app looks the same on every platform. However, this is not going to be the case with every application you develop. React Native can detect the platform you are running and conditions can be used to apply the styling.

Diving deeply in the bridging part or platform specific designing part of this article is out of the scope. This is written to familiarize you with the basic ecosystem of React Native but I wanted to discuss these topics briefly such that to give an idea of what you are getting into.

### Developer Environment for ReactÂ Native

These are required dependencies to set up a local environment and further, to develop any type of application using it, on your machine.

Dependencies required:

Note: Note that you have a Node.js version `>=4.0` to continue.

To setup Native SDKs for specific platforms:

- **iOS** (install/have Xcode, it is free and most probably pre-installed)
- **Android** (Iâ€™d recommend that you follow instructions [here](https://facebook.github.io/react-native/docs/getting-started.html))

The last step is to install React Native CLI using this command:

```shell
npm install -g react-native-cli
```

The above instructions work best if you need to build native code in your application or want to integrate React Native in an existing application. If you want to quickly prototype an application and you can use [_Create React Native App_](https://facebook.github.io/react-native/docs/getting-started.html) module that is very similar to Create React App. For _Create React Native App_ you are not required to install above dependencies (of course you need Node.js for _npm_ modules) and platform-specific SDKs. Facebook itself recommends using [Expo](https://expo.io/) client on your phone to see the app in action. I will be using `react-native-cli` for the brevity of the subject of this article.

### Hello World with ReactÂ Native

To scaffold an app, use the React Native command line interface we just installed in the previous step.

If you sneak peak inside the directory to see the structure, you will see a similar one:

```shell
react-native init HelloWorld

cd HelloWorld
```

<img src='https://cdn-images-1.medium.com/max/800/0*30ZgnW1lf7SY3UVM.png' />

Let us try running the app before making any changes. Since I am on a mac, I will be using command:

```shell
react-native run-ios
```

To run the same application in an Android Emulator or device (if connected), you can use the command:

```shell
react-native run-android
```

Since you are running any of the above command for the first time, it takes some minutes for the app show up in an emulator. Do not worry, if everything runs successfully, it will show up.

<img src='https://cdn-images-1.medium.com/max/800/0*YczCUc-cdJpnJd_b.png' />

The code you see above running is available in `App.js`:

<img src='https://cdn-images-1.medium.com/max/800/0*qtqjP_V2kuuGEuku.png' />

If you are familiar with Reactjs, you can easily understand this code. `<View>` stands for wrapper element such as `div` in HTML and `<Text>` stands for `<p>` in HTML.

You will be prompted with a success message and in a new terminal window, _Metro Bundler (developed by Facebook)_ will be running until the application closes.

<img src='https://cdn-images-1.medium.com/max/800/0*5EZJZ55baUagTXGM.png' />

<img src='https://cdn-images-1.medium.com/max/800/0*CMeu3NOHz3Gcgpx3.png' />

The file that renders this `App` component is `index.js` in the root directory. You will see this code:

<img src='https://cdn-images-1.medium.com/max/800/0*NsVZtz_ZooVZxt1F.png' />

Do you notice something? There is no `react-dom` because there is no DOM in React Native. `AppRegistry` is the entry point to run a React Native application. `App` component or any other root component in the app should register by using `AppRegistry.registerComponent` such that a native system can load the bundle of the app and run the app by starting `AppRegistry.runApplication`.

You can read more about `AppRegistry` [here](https://facebook.github.io/react-native/docs/appregistry.html).

You have successfully setup your first React Native application. You can read my other articles on React Native:

[**Building a Minimalist Weather App with React Native and Expo** React Native is a great framework to develop cross-platform mobile applications for the platforms iOS and Android](https://blog.expo.io/building-a-minimalist-weather-app-with-react-native-and-expo-fe7066e02c09)

Link to the [**Github Repo**](https://github.com/amandeepmittal/rn-HelloWorld) for this project if you are still curious too see the how the project structure looks rather than trying it out yourself.

### React Native inÂ 2019

_At the starting of the year 2019, I updated this post and re-wrote it here ðŸ‘‡_

[**Getting Started with React Native in 2019: Build Your First App** Learn how to build your first React Native app with important basic concepts and where to go from here!](https://levelup.gitconnected.com/getting-started-with-react-native-in-2019-build-your-first-app-a41ebc0617e2)

It is more in-depth, and covers almost every basic aspect about React Native ecosystem.

[Originally published at Gitconnected.com](https://levelup.gitconnected.com/react-native-how-to-setup-your-first-app-a36c450a8a2f)

---

## React Native Performance Do and Dont
Slug: react-native-performance-do-and-dont

Performance is one of the few topics that change the overall perspective of using a framework like React Native in real-world mobile applications. React Native is fast by default. While working on a React Native app you can experience performance issues and do not assume it can be fixed by testing components. In this post, there is a list of suggestions that can be applied while building a React Native app.

## DO: Use an Image Caching Solution

React Native offers an [Image](https://reactnative.dev/docs/image) component as the part of [a core set of components](https://reactnative.dev/docs/components-and-apis). This component is used to display an image but out of the box does not have the solution for issues like:

- rendering a lot of images on one screen
- low performance in general
- low-performance loading from cache
- flickering

The Image component in React Native handles caching images like web browsers and sometimes the above issues are a result of that. These issues are easily resolved by using a third-party library called [react-native-fast-image](https://github.com/DylanVann/react-native-fast-image). It is available for both iOS and Android and is efficient in caching images.

## DO: Use appropriate image size

Optimizing an image is important for a React Native app's performance if the app relies on using a huge amount of images. Rendering a large number of images could lead to high memory usage on a device if the images are not appropriately optimized in terms of size. This may lead the app to crash.

Somethings that can be done to optimized images in a React Native app are:

- Use PNG format instead of JPG
- Use smaller sized images
- Use WEBP format for images. It can help [reduce the binary size](https://medium.com/@tgpski/react-native-webp-reducing-bundle-binary-sizes-increase-speed-with-webp-image-format-aa9b1aa11405) on iOS and Android by 29%.

## DO: Avoid unnecessary renders

React Native is based on the React library and similarly handles rendering components as React.js does. Here to the optimization techniques that are valid with React do apply to React Native applications. One of the few optimization techniques is to avoid unnecessary renders and in functional components, this can be done by using `React.memo()`.

`React.memo()` is used to handle memoization. The concept of memoization is described as that if a component receives the same set of props more than once, it will use previously cached props and render the JSX returned by the functional component only once.

For example, consider the following of a parent and a child component. The `Parent` component has a state variable called count that is updated when the button press.

Whenever the button is pressed, the `Child` component also gets re-rendered even though its prop `text` does not change on each render. It is not doing anything special to its parent component and is just displaying some text. This can be optimized by wrapping the contents of the `Child` component with `React.memo()`.

```js
// Parent.js

const Parent = () => {
  const [count, setCount] = useState(0);

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Button title="Press me" onPress={() => setCount(count + 1)} />
      <Child text="Placeholder text" />
    </View>
  );
};

// Child.js
const Child = React.Memo(({ text }) => {
  return <Text>{text}</Text>;
});
```

## DO: Use nativeDriver with Animated library

There are many ways to create Animations in a React Native app. One of the most popular ways to do this is to use [Animated](https://reactnative.dev/docs/animated.html) library.

Animated library uses `nativeDriver` to send animations over the native bridge before animation starts. This helps the animations to execute independently of a blocked JavaScript thread. Thus, resulting in a smoother experience and without dropping many frames.

To use `nativeDriver` with an Animated library, you can set its value to `true`. In the example below, the `useNativeDriver` is used on an `onScroll` Animated event in a `ScrollView` component.

```js
<ScrollView
  showsVerticalScrollIndicator={false}
  scrollEventThrottle={1}
  onScroll={Animated.event(
    [{ nativeEvent: { contentOffset: { y: animatedValue } } }],
    { useNativeDriver: false }
  )}
>
  // Component's content
</ScrollView>
```

## DO: Use a tool to debug issues

React Native version `0.62.0` introduced a new tool called [Flipper](https://fbflipper.com/docs/features/react-native/). It is a debugging platform for iOS, Android, and React Native apps. It integrates directly with the native code and its integrations with a React Native app is enabled out of the box.

Using Flipper to debug apps, does not require remote debugging. It requires a locally connected instance of Metro to interact with the React Native app. It has React DevTools to inspect the component tree and check out the state and props of a React component.

It uses a native plugin ecosystem for debugging both iOS and Android applications. These plugins are used for device logs, crash reports, inspecting network requests, inspecting the local database of an app, inspecting cached images, etc.

## DO: Use Hermes

[Hermes](https://reactnative.dev/docs/hermes) is an open-source JavaScript engine optimized for mobile applications. Since React Native version `0.60.4` Hermes has been available for the Android platform. It helps with reducing the download size of an app (APK for Android), reduces memory consumption, and reduces the time it takes for an app to become usable (TTI - Time to interact).

To enable Hermes engine in an Android app, open `build.gradle` file and modify the following:

```java
def enableHermes = project.ext.react.get("enableHermes", true);
```

Since React Native version `0.64-rc.0` Hermes is also available to be used on iOS platform. To enable it for iOS app, open Podfile and modify the following code:

```c
+  use_react_native!(:path => config[:reactNativePath], :hermes_enabled => true)
```

## DON'T: Leave console statements in the source code

Using `console.log` statements is one of the favorites and common method to debug in JavaScript applications in general, as well as in React Native apps. However, leaving the console statements in the source code when building a React Native app for a platform could cause some big bottleneck in the JavaScript thread.

One way to keep track of console statements and remove them is to use a third-party package called `babel-plugin-transform-remove-console`. To use it, install the package by using the following command in a terminal window:

```shell
yarn add babel-plugin-transform-remove-console
```

Then, modify the `.babelrc` file to remove all console statements:

```json
{
  "env": {
    "production": {
      "plugins": ["transform-remove-console"]
    }
  }
}
```

## DON'T: Use ScrollView to render a huge list of data items

There are few ways to create scrollable lists in React Native. Two of the common ways available in React Native core are `ScrollView` and `FlatList` components.

A `ScrollView` component is simple to implement. It is often used to traverse over a list of finite number of items using a JavaScript's `map()` function. For example:

```js
<ScrollView>
  {items.map(item => {
    return <Item key={item.id.toString()} />;
  })}
</ScrollView>
```

The `ScrollView` component renders all children at once. This is good for use cases where the number of items in a list to render is quite low. Dealing with a large amount of data can directly affect the performance of the app.

To deal with large lists of items, React Native provides a component called `FlatList`. This component ensures that the items are lay loaded such that the app does not consume an inconsistent amount of memory.

For example:

```js
<FlatList
  data={elements}
  keyExtractor={item => `${items.id}`}
  renderItem={({ item }) => <Item key={item.id.toString()} />}
/>
```

## Conclusion

React Native is an open-source framework used to create cross-platform mobile applications. It uses JavaScript at its core and has a primitive API of components to build mobile interfaces and functionalities. Itâ€™s a high-performance framework as long as you build with performance in mind from the start.

_[Originally Published at Crowdbotics](https://medium.com/crowdbotics/react-native-performance-do-and-dont-88424e873bbd)_

---

## How to remove bottom tab bar border in React Navigation
Slug: react-navigation-remove-tab-bar-border

> Updated: May 2, 2022

![cover_image](https://i.imgur.com/Tu5dv1l.png)

Navigation plays an important role in mobile applications and the React Navigation library does an awesome job in providing a completely customizable interface for utilizing different navigation patterns to React Native apps.

Having the liberty to customize tab bars with React Navigation, one customizable option available (depending on the UI design of an app) is to remove the border from the Tab bar.

Here is an example of the border that is the default when the React Navigation Bottom Tabs library is utilized to create a tab bar.

![ss1](https://i.imgur.com/ttIMI5V.png)

For the demonstration purpose, I am using an Expo project created using the `expo-cli` command-line tool. To create a similar new Expo project, you can execute the command and choose the `tabs` option.

```shell
expo init yourProjectName

# when prompted, choose the tabs option
# in managed workflow
```

This expo project comes with a default bottom tab navigator whose configuration can be found in the file `navigation/BottomTabNavigator.tsx`.

## Customize the TabBar

The Bottom Tab Bar React Navigation library gives an object called `screenOptions` to customize a tab bar. This object contains props that can be used to apply custom styles and one of the generic property it has is called `tabBarStyle`. This property is commonly used to change the styles of the tab bar, for example, by applying the `backgroundColor` styles' property.

To remove the border, add the `screenOptions` prop and inside it, add a `tabBarStyle` property called `borderTopWidth` with a value `0`.

```js
<BottomTab.Navigator
  initialRouteName='TabOne'
  screenOptions={{
    // ...
    tabBarStyle: {
       borderTopWidth: 0
    }
  }}
>
```

Here is the output:

![ss2](https://i.imgur.com/WqR3X9I.png)

Do note that this property can also be used to increase the width of the top border.

## Removing shadow on Android Device

After applying this `tabBarStyle` property, the width of the top border is removed from an Android device. However, there is a shadow at the top border of the tab bar that remains.

![ss3](https://i.imgur.com/ofnBBis.jpg)

To remove this shadow, set the `elevation` to `0`:

```js
tabBarStyle: {
  borderTopWidth: 0,
  elevation: 0
}
```

![ss4](https://i.imgur.com/3TEx5ib.jpg)

[Source code available at GitHub](https://github.com/amandeepmittal/react-native-examples/tree/main/remove-tabbar-border)

---

## Getting Started with React Navigation v6 and TypeScript in React Native
Slug: react-navigation-v6-and-typescript-in-react-native

> Originally published at [Jscrambler.com](https://jscrambler.com/blog/getting-started-with-react-navigation-v6-and-typescript-in-react-native/)

When you have a complex mobile application structure or many screens in your application, handling navigation can become tricky. However, with open-source libraries like [React Navigation](https://reactnavigation.org/), the process of implementing navigation patterns does become easier.

React Navigation library is one of the most used navigation libraries in React Native ecosystem. It is written in TypeScript, and you can create React components and apply any navigation patterns from Stack, Tab, and Drawer.

In this tutorial, let's look at how you can set up and use React Navigation and TypeScript together in a React Native app. One cool advantage that TypeScript provides is type checking for [route names](https://reactnavigation.org/docs/glossary-of-terms/#route) and [route parameters](https://reactnavigation.org/docs/params/).

## Pre-requisites

If you are going to code along, make sure you have already installed the following:

- [Nodejs](https://nodejs.org/en/) (`>=12.x.x`) with npm/yarn installed
- [expo-cli](https://docs.expo.dev/workflow/expo-cli/)
- Access to a real device or an iOS simulator or an Android Emulator so that you can run your code example

The source code used in this tutorial is available at [this GitHub repository](https://github.com/amandeepmittal/react-native-examples/tree/main/react-navigation-v6-typescript).

## Creating a React Native project with expo-cli

Before diving deep into configuring TypeScript with React Navigation, let us create an example app that uses React Navigation to navigate between different screens. This example screen will also have example screens.

You can skip this section if you are already familiar with Stack and Tab navigators in React Navigation.

Open the terminal and run the following command to create a new React Native app. When asked to "choose a template", select _blank (TypeScript)_. This template creates a React Native project with TypeScript already configured. Enough for us to get started.

```shell
expo init myApp

# This will prompt a "Choose a template" question
# Select "blank (TypeScript)"

# After the project is created, navigate inside the project directory
cd myApp
```

After navigating inside the project directory, run the following command to install React Navigation libraries and its packages in the terminal window.

```shell
yarn add @react-navigation/native @react-navigation/bottom-tabs @react-navigation/native-stack && expo install react-native-screens react-native-safe-area-context
```

The above command will install packages for implementing Stack and Tabs navigators. In the example app, we will use both of these patterns.

## Adding a stack navigator

React Navigation's stack navigator allows your app to transition between screens and manage navigation history. The stack navigator you will implement in this section will allow the app user to navigate from one screen to another.

Start by creating a `src/` directory that will contain the screen and navigation related code files.

The next step in the example app is to create mock screens. Create a `screens/` directory inside `src/`. Inside this directory, let's create four component files:

- `HomeScreen.tsx`
- `DetailsScreen.tsx`

The `HomeScreen` component displays a list of characters from the [Star Wars API](https://swapi.dev/). On pressing any item from the list, the app user will be able to navigate to the `DetailsScreen` where they can view the details of each character.

Add the following code snippet to the `HomeScreen.tsx`:

```tsx
import { StyleSheet, View, Text, Pressable, FlatList } from 'react-native';
import { useNavigation } from '@react-navigation/native';

const DATA = [
  {
    id: 1,
    name: 'Luke Skywalker',
    birth_year: '19BBY'
  },
  {
    id: 2,
    name: 'C-3PO',
    birth_year: '112BBY'
  },
  {
    id: 3,
    name: 'R2-D2',
    birth_year: '33BBY'
  },
  {
    id: 4,
    name: 'Darth Vader',
    birth_year: '41.9BBY'
  },
  {
    id: 5,
    name: 'Leia Organa',
    birth_year: '19BBY'
  }
];

const HomeScreen = () => {
  const navigation = useNavigation();

  const renderListItems = ({ item }) => {
    return (
      <Pressable
        onPress={() =>
          navigation.navigate('Details', {
            name: item.name,
            birthYear: item.birth_year
          })
        }
      >
        <Text
          style={{ fontSize: 18, paddingHorizontal: 12, paddingVertical: 12 }}
        >
          {item.name}
        </Text>
        <View
          style={{
            borderWidth: StyleSheet.hairlineWidth,
            borderColor: '#ccc'
          }}
        />
      </Pressable>
    );
  };

  return (
    <View style={{ flex: 1, paddingTop: 10 }}>
      <FlatList data={DATA} renderItem={renderListItems} />
    </View>
  );
};

export default HomeScreen;
```

In the above code snippet, observe that the `onPress` prop on the `Pressable` component is used to pass the `name` and `birthYear` of the character to the `Details` screen as **route parameters**.

Add the following code snippet to the `DetailsScreen.tsx`:

```tsx
import { View, Text } from 'react-native';
import { useRoute } from '@react-navigation/native';

const DetailScreen = () => {
  const route = useRoute();
  const { name, birthYear } = route.params;

  return (
    <View style={{ flex: 1, paddingTop: 12, paddingHorizontal: 10 }}>
      <Text style={{ fontSize: 18, paddingBottom: 12 }}>Name: {name}</Text>
      <Text style={{ fontSize: 18 }}>Birth Year: {birthYear}</Text>
    </View>
  );
};

export default DetailScreen;
```

In the above code snippet, notice that the `route.params` is used to read the parameters passed from the `HomeScreen`.

After setting up the screens, create the `navigation/` directory inside the `src/` and inside it, add two files:

- `index.tsx`: to keep the Root Navigator configuration
- `HomeStack.tsx`: to create a Stack Navigator for Home and Details screens

Inside the `HomeStack.tsx` file, add the following code snippet:

```tsx
import * as React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import HomeScreen from '../screens/HomeScreen';
import DetailsScreen from '../screens/DetailsScreen';

const HomeStack = createNativeStackNavigator();

const HomeStackNavigator = () => {
  return (
    <HomeStack.Navigator>
      <HomeStack.Screen name="Home" component={HomeScreen} />
      <HomeStack.Screen name="Details" component={DetailsScreen} />
    </HomeStack.Navigator>
  );
};

export default HomeStackNavigator;
```

In the above code snippet, notice that the `name` prop on the `HomeStack.Screen` component is used to define the route name. For example, the `DetailsScreen` has the route name defined as `Details`. Any time you navigate the Details screen, the route name is used to identify the screen either in the `navigation.navigate()` or `navigation.push()` method.

Next, add the following code snippet to the `index.tsx` file:

```tsx
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';

import HomeStackNavigator from './HomeStack';

const RootNavigator = () => {
  return (
    <NavigationContainer>
      <HomeStackNavigator />
    </NavigationContainer>
  );
};

export default RootNavigator;
```

Lastly, modify the `App.tsx` file to include the `RootNavigator` component:

```ts
import { StatusBar } from 'expo-status-bar';

import RootNavigator from './src/navigation';

export default function App() {
  return (
    <>
      <RootNavigator />
      <StatusBar style="auto" />
    </>
  );
}
```

The `HomeStack` navigator configuration is done. Next, run any of the following commands to see the navigator in action:

```shell
# for iOS
expo start --ios

# for Android
expo start --android
```

Here is the output you will get after this step:

![ss1](https://i.imgur.com/DhLWELt.gif)

## Adding type checking for stack navigator

To type check route name and parameters in both the `HomeStack` and `RootStack` navigators, you need to create type mappings for each route name and params.

Start by creating a new file called `types.ts` inside the `src/navigation/` directory. This file will contain mappings for all route names and route params. Throughout this tutorial, it is used to define types for each type of navigator.

Inside the file `types.ts`, define the types for the route names: `Home` and `Details`.

```ts
export type HomeStackNavigatorParamList = {
  Home: undefined;
  Details: {
    name: string;
    birthYear: string;
  };
};
```

A route name that doesn't have any parameters being passed is specified with `undefined`. So, for example, in the above snippet, the `Home` route name doesn't have any parameters being passed to it.

The `Details` route receives two parameters from the `HomeScreen`. This is why the mapping object contains two properties in the above snippet.

After creating the mappings, you must let the stack navigator know about them. Go back to the `HomeStack.tsx` file and inside it, import `HomeStackNavigatorParamList`. It is passed as a generic to the `createNativeStackNavigator` function.

```tsx
// rest of the import statements remain same
import { HomeStackNavigatorParamList } from './types';

const HomeStack = createNativeStackNavigator<HomeStackNavigatorParamList>();

// rest of the code remains the same
```

## Testing type checking and IntelliSense

All the configurations in the previous section will enable type checking for the `HomeStack` navigator. For example, in the `HomeStack.tsx` file, change the name of the `Details` to `Detail`.

```tsx
<HomeStack.Screen name="Detail" component={DetailsScreen} />
```

After the modification, you will see a red squiggly line appears on the `name` prop.

![ss3](https://i.imgur.com/VtNtO6v.png)

If you hover over the `name` prop, it will show a similar error message like the following:

![ss4](https://i.imgur.com/ZUiHjsU.png)

The `HomeStack` navigator expects a `HomeStackNavigatorParamList` type with either `Home` or `Details`.

Another advantage of type checking is that it provides intelliSense for navigator props (depending on which IDE or Code editor you are using). For large applications where there are a lot of screens, this helps. You do not have to remember each route params for every screen.

## Adding type checks for screens

In this section, let's learn how to add type checking for the Home screen. It is the screen where an app user will interact with a button to navigate to the Details screen.

To add type checking for a screen, the first step is to use a generic type to define types for the individual screens. Each navigator pattern in React Navigation library exposes its own generic type. For example, `NativeStackNavigationProp` is used for `@react-navigation/native-stack`. Import that in the `types.ts` file.

```ts
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

export type HomeStackNavigatorParamList = {
  Home: undefined;
  Details: {
    name: string;
    birthYear: string;
  };
};

export type HomeScreenNavigationProp = NativeStackNavigationProp<
  HomeStackNavigatorParamList,
  'Details'
>;
```

The `NativeStackNavigationProp` accept two parameters. The first is the type that maps the route names and their params. Hence, the navigator itself. The second is the name of the screen as a string that matches the route name from the first parameter. In the above code snippet, the first parameter is `HomeStackNavigatorParamList`, and the second parmater, in this case, can only be `Details`.

The second parameter of `NativeStackNavigationProp` represents that the `Home` screen gets only the described route name as a possibility that the Home screen can navigate to. If the second parameter is not defined, then the `Home` screen will get all the route names from the `HomeStack` navigator as possibilities that it can navigate to.

Now, open the `HomeScreen` file, import the `HomeScreeProps` type, and use it to annotate the `useNavigation` hook.

```tsx
// after other import statements

// import HomeScreenNavigationProp
import { HomeScreenNavigationProp } from '../navigation/types';

// inside the HomeScreen, component modify the following line
const HomeScreen = () => {
  const navigation = useNavigation<HomeScreenNavigationProp>();

  // rest of the code remains the same
};
```

If you are using the `navigation` prop directly on the functional component, you can pass the `HomeScreenNavigationProp` type to the functional component.

```tsx
function HomeScreen({ navigation }: HomeScreenNavigationProp) {
  // ...
}
```

If you are using `@react-navigation/stack`, you can use `StackScreenProps` instead of `StackNavigationProp`.

## Adding type checks for route params

To add type checking for a screen that receives route params (for example, in the example app Details screen receives two route params), you need to import the `RouteProp` from `@react-navigation/native`.

After importing it, create a type for the `Details` screen using the `HomeStackNavigatorParamList` as the first parameter and the route name of the Details screen as the second parameter to the `RouteProp`.

```ts
// after other import statements
import type { RouteProp } from '@react-navigation/native';

export type DetailsScreenRouteProp = RouteProp<
  HomeStackNavigatorParamList,
  'Details'
>;

// rest of the code remains the same
```

Open the `DetailsScreen` file, import the `DetailsScreenRouteProp` type, and use it to annotate the `useRoute` hook.

```tsx
// after other import statements
import { DetailsScreenRouteProp } from '../navigation/types';

// inside the DetailsScreen, the component modify the following line

const DetailScreen = () => {
  const route = useRoute<DetailsScreenRouteProp>();

  // rest of the code remains the same
};
```

## Adding a bottom navigator

Let's continue the saga of adding type checks to the app screens by adding a Bottom Tab Navigator to the example app. We have already installed the bottom tabs package when creating the example app.

Let's add two more screens to the `src/screens/` directory. Inside it, create a new file `FeedScreen.tsx` and add the following code snippet:

```tsx
import { View, Text } from 'react-native';

const FeedScreen = () => {
  return (
    <View style={{ flex: 1, paddingTop: 12, paddingHorizontal: 10 }}>
      <Text style={{ fontSize: 18 }}>Feed Screen</Text>
    </View>
  );
};

export default FeedScreen;
```

Create another new file called `SettingsScreen.tsx` and add the following code snippet:

```tsx
import { View, Text } from 'react-native';

const SettingsScreen = () => {
  return (
    <View style={{ flex: 1, paddingTop: 12, paddingHorizontal: 10 }}>
      <Text style={{ fontSize: 18 }}>Settings Screen</Text>
    </View>
  );
};

export default SettingsScreen;
```

Next, add the type check mapping objects for the bottom tab navigator in the `src/navigation/types.ts` file. The name of the navigator is `BottomTabNavigatorParamList`.

The bottom tab navigator will contain the `Home` screen as its first tab. The second tab will be the `Feed` screen. The third tab will be the `Settings` screen. You can specify `HomeStackNavigatorParamList` as the value for the `Home` key.

```ts
export type BottomTabNavigatorParamList = {
  Home: HomeStackNavigatorParamList;
  Feed: undefined;
  Settings: undefined;
};
```

Inside the `src/navigation/` directory, add a new file called `Tabs.tsx` with the following code snippet:

```tsx
import * as React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

import { BottomTabNavigatorParamList } from './types';
import HomeStackNavigator from './HomeStack';
import FeedScreen from '../screens/FeedScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator<BottomTabNavigatorParamList>();

const BottomTabs = () => {
  return (
    <Tab.Navigator>
      <Tab.Screen
        name="HomeStack"
        component={HomeStackNavigator}
        options={{ headerShown: false }}
      />
      <Tab.Screen name="Feed" component={FeedScreen} />
      <Tab.Screen name="Settings" component={SettingsScreen} />
    </Tab.Navigator>
  );
};

export default BottomTabs;
```

Annotating types for the bottom tab navigator with `BottomTabNavigatorParamList` will add type checks for each screen in the tab navigator.

Let's also modify the `src/navigation/index.tsx` file to replace the previous `HomeStack` by importing the `BottomTabs` component and rendering it.

```tsx
// rest of the import statements remain same
import BottomTabs from './Tabs';

const RootNavigator = () => {
  return (
    <NavigationContainer>
      <BottomTabs />
    </NavigationContainer>
  );
};

export default RootNavigator;
```

Here is the output you get after this step:

![ss5](https://i.imgur.com/YNAcmXn.png)

## Composing nested navigator types

In the current state of the example app, you will notice that the `HomeStack` navigator is now nested inside the bottom tab navigator.

Let's assume, for some reason, you want to provide a button for the app user to navigate from the Home screen to the Feed screen. This is doable since both of these screens share the same parent navigator.

Add a button above the `FlatList` in the `HomeScreen.tsx` file that allows an app user to navigate to the Feed screen as shown below:

```tsx
return (
  <View style={{ flex: 1, paddingTop: 10 }}>
    <Pressable
      onPress={() => navigation.navigate('Feed')}
      style={{
        padding: 8,
        borderWidth: 1,
        borderRadius: 4,
        borderColor: 'red',
        margin: 12,
        alignItems: 'center'
      }}
    >
      <Text style={{ fontSize: 16, fontWeight: '600' }}>Go to Feed screen</Text>
    </Pressable>
    <FlatList data={DATA} renderItem={renderListItems} />
  </View>
);
```

Here is how the button looks on the Home screen:

![ss6](https://i.imgur.com/ZG1ExAB.png)

If you look closely at the JSX just added, a red squiggly line has appeared underneath `Feed`.

![ss7](https://i.imgur.com/QWz4bPj.png)

The error states that the Feed screen is not part of the `HomeScreenNavigationProp`, which is true because the Feed screen is not part of the param list we defined for the Home stack navigator in the `src/navigation/types.tsx` file.

React Navigation library exposes the `CompositeNavigationProp` type that allows annotating the navigation prop when nesting navigators. It takes two parameters. The first parameter is the primary navigator, in this case, the Home Stack navigator itself. The second parameter is the type of a parent navigator or any other source of secondary navigation. In this case, it will be the bottom tab navigator.

Modify the type `HomeScreenNavigationProp` as shown below:

```ts
import type {
  CompositeNavigationProp,
  RouteProp
} from '@react-navigation/native';
// rest of the import statements remains same

export type HomeScreenNavigationProp = CompositeNavigationProp<
  NativeStackNavigationProp<HomeStackNavigatorParamList, 'Details'>,
  BottomTabNavigationProp<BottomTabNavigatorParamList, 'Feed'>
>;

// rest of the code remains the same
```

If you go back to the `HomeScreen.tsx` file, you will see the red squiggly gone.

## Conclusion

In this tutorial, we discussed how to add type checks to the app screens and how to add type checks to the React Navigation navigators. Using type checks and annotating navigators is a great way to make your app more robust and maintainable when using TypeScript with React Navigation.

I recommend you to check the complete type checking with TypeScript official documentation [here](https://reactnavigation.org/docs/typescript) provided by React Navigation library maintainers.

---

## How to use React Router and real time user monitoring in React apps
Slug: react-router-real-time-user-monitoring-react-apps

React is often used for building single-page applications (SPAs). SPAs tend to have multiple page views so when navigating from one-page view to another, reloading the entire page view is tedious and inefficient. To work as it should, a SPA must render different parts of a view when required instead of reloading the entire page.

Routing comes into the picture when navigating from one page to another in a SPA app. Routing can be categorized in two ways: static and dynamic. SPAs follow a dynamic approach. In this tutorial, we will discuss a popular routing library used with React applications known as [React Router](https://reacttraining.com/react-router/web/guides/quick-start). After setting up our routes, we are also going to discuss how to set up performance monitoring with [Sematext](https://sematext.com/) in React apps with React Router library.

## Prerequisites

Before you begin this tutorial, youâ€™re going to need the following:

- [Node.js](https://nodejs.org/) version above 12.x.x installed on your local machine
- Access to a package manager such as npm or yarn or npx
- Basic JavaScript and ES6 knowledge
- Basic knowledge of Reactjs
- Access [Sematext](https://sematext.com/) account (_trial version also acceptable_)

## Getting started

Start by creating a new React project. Run the following command using [npx](https://www.npmjs.com/package/npx). Once the project is generated, navigate inside the newly created directory and install the `react-router-dom` library.

```shell
npx create-react-app react-router-demo

# navigate inside the directory
cd react-router-demo

# install react-router-dom
yarn add react-router-dom
```

React Router library (as per version 5) contains three different npm packages.

- react-router
- react-router-dom
- react-router-native

Each of the packages has a different use case. The first one, `react-router` is the core package and is used with the next two packages listed above. The `react-router-dom` is used when building a web application. This is what we are going to use in this tutorial. The last one `react-router-native` is used in apps using [React Native](https://amanhimself.dev/getting-started-with-react-native-in-2019-build-your-first-app/).

To see the React app generated, currently in action, make sure you are inside the root directory of the React project before you run the following command.

```shell
yarn run start
```

This is going to open the boilerplate React app screen at the URL `http://localhost:3000/` in a browser window.

![ss1](https://i.imgur.com/HtBY0g4.png)

### Create the first route with React Router

To create the first route in the React app, import the `Router` and `Route` from the `react-router-dom` library. Open `src/App.js` file and add the following import statement.

```js
import React from 'react';
import { Router, Route } from 'react-router-dom';
```

Let's also add a `history` object to use with navigation. Unlike `BrowserRouter`, the `Router` component is a low-level interface for all router components. This means that you have to manually pass the `history` object to make it work. Later, this `history` object is going to be used for the monitoring tool. Import `createBrowserHistory` as following:

```js
import { createBrowserHistory as createHistory } from 'history';

const history = createHistory();
```

A `Route` is required to create an actual route. It is where the logic of routing is placed. It renders the UI of a component. It has a prop called `path` that is always matched with the current location of the app. Based on this prop, the desired component gets rendered. When the component is not getting rendered, `Route` returns null. The `component` name is also passed as a prop. All `Routes` are wrapped inside the `Router` component.

```js
function App() {
  return (
    <Router>
      <Route path="/" component={Home} />
    </Router>
  );
}
```

The path is currently pointing towards the Home component which has the following UI logic. Create a `Home` component inside `src/components/Home.js` file.

```js
import React from 'react';

export default function Home() {
  return (
    <div>
      <h1> Home Page</h1>
    </div>
  );
}
```

Now, import this component inside the `App.js` file.

```js
import Home from './components/Home';
```

Visit the web browser and see the Home component being rendered right now.

![ss2](https://i.imgur.com/Q2IwXJ7.png)

This is a bare minimum example. Now let us add another route with the same props as the Home. Call this route About with a similar rendering logic as Home.

## Adding the second route

Start by adding another component file inside `src/components` and name it `About.js`. Add the following code snippet to it.

```js
import React from 'react';

export default function About() {
  return (
    <div>
      <h1>About</h1>
    </div>
  );
}
```

Now add this function component as the second route, below the `Home` route in `App.js` file. Make sure to import it.

```js
// After other import statements
import About from './components/About';

// Add another route
function App() {
  return (
    <Router history={history}>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
    </Router>
  );
}
```

Visit the URL `http://localhost:3000/about`. You will notice that both the components are being rendered right now on the path /about.

![ss3](https://i.imgur.com/krpy60b.png)

The reason for this is that the regular expression engine that React Router uses internally considers both the routes that are being started with a forward slash `/` equal. To solve this issue, we can use another essential prop on the Home route called `exact`.

```js
<Route path="/" exact component={Home} />
```

This `exact` prop is also known as a qualifier which states that the path must match exactly the `/` and nothing after it, such as `/about`. Now, if you visit the browser window at the URL `http://localhost:3000/about` you will notice that only the about component is getting rendered this time.

![ss4](https://i.imgur.com/rTVSwFM.png)

## Wrapping routes with Switch

The `Switch` component is a unique one since it renders the component at the `path` of the `Route` exclusively. It renders a default component once the app initially renders by matching the first child `Route`. It allows switching between different routes when a path is matched. It is helpful if you are using the `Redirect` component with the `Route` component. Even though in this current demo, we are not going to have any redirects, let's wrap all our routes inside a `Switch`. Modify the `App.js` file as follows:

```js
// import the Switch component
import { Router, Route, Switch } from 'react-router-dom';

// App component
function App() {
  return (
    <Router history={history}>
      <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/about" component={About} />
      </Switch>
    </Router>
  );
}
```

### Adding a navbar

To navigate between to web pages in HTML, there is an `<a href=""></a>` anchor tag available. However, using this traditional approach will lead to a browser refresh. To overcome this, React Router API offers a `NavLink` component that can be used to navigate to a particular URL or a component.

Let us try to create a navigation menu with this new knowledge. Import `NavLink` from `react-router-dom` in App.js file. Here is the modified snippet of App component.

```js
import { Router, Route, Switch, NavLink } from 'react-router-dom';

function App() {
  return (
    <Router history={history}>
      <nav style={{ margin: 10 }}>
        <NavLink exact to="/" style={{ padding: 10 }}>
          Home
        </NavLink>
        <NavLink to="/about" style={{ padding: 10 }}>
          About
        </NavLink>
      </nav>
      <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/about" component={About} />
      </Switch>
    </Router>
  );
}
```

In the above snippet, notice that all the links are being added before all the `Route` components. The styling attributes inside `style` are optional for now. Go to the browser window, you are going to notice a navigation menu pops up at the top. Try clicking links to navigate between different components.

![ss5](https://i.imgur.com/P0xZkiI.gif)

## Adding Parameters to the Routes

In this section, you will learn how to create and manage dynamic routes based on a query parameter such as `:id`. We start by creating a static array that will serve as the mock data.

The idea is to demonstrate a route as `/posts` which displays all the posts that are coming from the array. However, each post in the array will be having an `id` or a unique identifier. Using that unique identifier, you will be approaching the concept of dynamic content rendering by writing the logic for URLs such as `/posts/:id` where `:id` will be represented by the specific id of a post.

To start, let us add a bunch of mock posts in the state inside a new component file called `components/Posts.js`. Import the following statements.

```js
import React, { useState } from 'react';
import { Link, Route } from 'react-router-dom';
```

A `Link` component is similar to `NavLink` with the difference being that it can be used for other purposes rather than a navigation menu where an `anchor` tag is required.

Next, declare a static array of different posts.

```js
const POSTS = [
  {
    id: 1,
    title: 'Hello Blog World!'
  },
  {
    id: 2,
    title: 'My second post'
  },
  {
    id: 3,
    title: 'What is React Router?'
  }
];
```

Next, define a function component called `Child`. It reads anything coming from the URL parameters, such as, in this case, the `id` of each post. This component is going to accept one prop called `match` object. This object contains information about how a `<Route path>` matched the URL. It has four different props, but the prop you are going to use is an object called `params` to read the `id` of the post. A `params` object contains key/value pairs that are parsed from the URL corresponding to the dynamic segments of the `path`.

```js
function Child({ match }) {
  return (
    <div>
      <h3>ID: {match.params.id}</h3>
    </div>
  );
}
```

Then, define the `Posts` function component. It is going to have a state variable called `posts` that are going to have a default value of the mock array `POSTS`. Using the JavaScript's `map` function is going to render the list of Posts and display them as a list whenever the current location in the web browser matches `/posts`. The `Child` component is going to be the value of displaying the content (`id` in this case) of each post.

```js
export default function Posts() {
  const [posts, setPosts] = useState(POSTS);

  return (
    <div className="posts">
      <h1>Posts List</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <Link to={`/posts/${post.id}`}>{post.title}</Link>
          </li>
        ))}
      </ul>
      <Route path="/posts/:id" component={Child} />
    </div>
  );
}
```

Now, import the newly created component inside `App.js` where other routes already exist.

```js
import Posts from './components/Posts';

function App() {
  return (
    <Router history={history}>
      <nav style={{ margin: 10 }}>
        <NavLink exact to="/" style={{ padding: 10 }}>
          Home
        </NavLink>
        <NavLink to="/about" style={{ padding: 10 }}>
          About
        </NavLink>
        <NavLink to="/posts" style={{ padding: 10 }}>
          Posts
        </NavLink>
      </nav>
      <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/about" component={About} />
        <Route path="/posts" component={Posts} />
      </Switch>
    </Router>
  );
}
```

Now, visit the URL `http://localhost:3000/posts` and you are going to see the list of posts.

![ss6](https://i.imgur.com/79STiT7.png)

Clicking one of the posts is going to show the contents of that post.

![ss7](https://i.imgur.com/LmscMwA.png)

![ss8](https://i.imgur.com/a6np7at.png)

## Real user monitoring tool with Sematext

Configuring a monitoring tool can be a good asset for your React application. It is helpful to determine a user's experience in terms of performance. If you're web app is not loading as expected, when in production, you can lose a lot of users and potential customers.

A monitoring tool like Sematext Real user monitoring tool provides a way to test out performance-related issues regarding the user experience in your web app. It allows you to track page loading time, HTTP requests, UI interactions, application crashes, and so on.

This tool can be a critical part of understanding how a user behaves when using your web app. The features provided by their tool are hard to implement otherwise.

This tool can be a critical part of understanding how a user behaves when using your web app. The features provided by their tool are hard to implement otherwise.

## Configure a Sematext monitoring app

To follow further, you do require a [Sematext account](https://sematext.com/experience/) and do note that they have a 30 day trial period that you can leverage. If you are planning to use this in production, you can also leverage their pricing plan that is defined per app.

![ss9](https://i.imgur.com/y8Nekfj.png)

Once you are logged in to your account, you are going to be welcomed by a dashboard screen that might look similar to below.

![ss10](https://i.imgur.com/tuLIO58.png)

To start configuring Sematext Experience in the current demo React app, click on the `New App` button in the top right corner and then select `Experience`.

![ss11](https://i.imgur.com/A40CG1G.png)

Then, enter the name of the app in the modal screen as well as make sure to check the `About Website` option since the current React app is trying to simulate a SPA behavior. Click the button `Continue`.

![ss12](https://i.imgur.com/sRIIczJ.png)

## Installing monitoring scripts in React app

In the Sematext dashboard, you will be redirected to a page where there are steps to install the Experience tool. It contains some installation scripts that are necessary to add. These scripts are the integration point between the monitoring tool and your React app.

Go back to the React app and open the `public/index.html` file. Paste the first installation script as similar to one below, inside the `head` tag of the HTML file. The installation script contains the unique token provided by SemaText.

```html
<script type="text/javascript">
  (function (e, r, n, t, s) {
    var a = [];
    e[s] = function () {
      a.push(arguments);
    };
    e[s].queue = a;
    var o = [];
    var i = [];
    var c = true;
    var p = void 0;
    if (
      window.PerformanceObserver &&
      window.PerformanceObserver.supportedEntryTypes &&
      (PerformanceObserver.supportedEntryTypes.indexOf('longtask') >= 0 ||
        PerformanceObserver.supportedEntryTypes.indexOf('element') >= 0)
    ) {
      p = new PerformanceObserver(function (e) {
        e.getEntries().forEach(function (e) {
          switch (e.entryType) {
            case 'element':
              i.push(e);
              break;
            case 'longtask':
              o.push(e);
              break;
            default:
              break;
          }
        });
      });
      p.observe({ entryTypes: ['longtask', 'element'] });
    }
    e[s + 'lt'] = {
      longTasks: o,
      timingElements: i,
      inPageLoad: c,
      observer: p
    };
    if (t) {
      var u = r.createElement(n);
      u.async = 1;
      u.src = t;
      var f = r.getElementsByTagName(n)[0];
      f.parentNode.insertBefore(u, f);
    }
  })(window, document, 'script', '//cdn.sematext.com/rum.js', 'strum');
</script>
<script type="text/javascript">
  strum('config', {
    token: 'e3451b53-a95f-45c6-ba8e-1368cb4f2407',
    receiverUrl: 'https://rum-receiver.sematext.com'
  });
</script>
```

Follow this by the second step where you have to add an event listener called `routeChange` at the top component in your React app or where the navigation configuration is written.

Open the file `src/App.js` and paste the following after you have defined the `history` object.

```js
history.listen((location, action) => {
  if (action !== 'REPLACE') {
    window.strum('routeChange', window.location.href);
  }
});
```

This event listener is responsible for tracking whenever a route changes. It is essential, as discussed previously, the nature of a Single Page Application is to change the routes dynamically.

That's it. These are the only two steps required to configure and add the Sematext Real-time User Monitoring tool in your React app.

### Testing out the Real-time User Monitoring tool

After integrating the installation scripts, the next step is to build the React app by running the command from a terminal window:

```shell
yarn run build
```

Once this command runs successfully, you can serve it by using the command below:

```shell
npx serve -s build
```

This command serves all the files in the `build` folder as a single page application to simulate the hosted version experience. It is going to give you an URL that you can paste in a browser window.

Once the React app is built and served, you can test it out by playing around with the different routes. It might take a moment, but the Sematext monitoring tool is fast at detecting the user interactions in the React app.

The overview of the dashboard screen as shown below tells as the initial page loading time is excellent.

![ss13](https://i.imgur.com/n7rIiE2.png)

It also goes in detail by determining the exact page load time.

![ss14](https://i.imgur.com/cugGBau.png)

To check out the number of resources that are downloading for a particular URL, navigate to the `Resources` tab from the sidebar.

![ss15](https://i.imgur.com/tnetw9K.png)

From the `Users` tab in the sidebar menu, you can monitor the user data such as the number of active users on the web app at a given time, the top browser being used, the maximum number of users located in which country and so on.

![ss16](https://i.imgur.com/BPimzAR.png)

## Conclusion

Monitoring user experience in Real-time brings an advantage to single-page applications. It not only allows you to figure out how the user experience is going on for the majority of customers but you can use this information to improve the areas of your web app to provide a much better experience. Using the [Sematext Real-time User Monitoring tool](https://sematext.com/) with a React app is helpful in the scenario.

---

## How to use redux-persist in React Native with Asyncstorage
Slug: redux-persist-in-react-native-with-async-storage

[Redux persist](https://github.com/rt2zz/redux-persist) is a library that allows saving a Redux store in the local storage of an application. In React Native terms, [Asyncstorage](https://jscrambler.com/blog/how-to-use-react-native-asyncstorage) is a key value-based, unencrypted, asynchronous storage system that is global and can be used as the local storage for the app.

Using a state management library like [Redux](https://jscrambler.com/blog/asynchronous-operations-in-react-redux) in a React Native app is beneficial to manage the state of an application from one place. As your application advances in terms of features, you may want to persist some of the information for each user that is local to them.

For example, you are building a shopping cart application and it requires persisting the data related to products a user is adding to the cart before making a purchase order. What if the user closes the application for an arbitrary reason before making that purchase but comes back later and finds that number of items to vanish completely from their cart. This is not a good user experience.

To improve this user experience, you could save the items in their device's local storage. This is where redux-persist along with Asyncstorage comes in handy for a React Native app. In this tutorial, we are going to set up the `redux-persist` library in a React Native app that uses Redux as its state management library and preserve the data in Asyncstorage for scenarios where the app is closed.

[The source code is available at this GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/master/redux-persist-asyncstorage).

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements in your local dev environment:

- [Node.js](https://nodejs.org/) version >= `12.x.x` installed.
- Have access to one package manager such as npm or yarn or npx.
- Have a basic understanding of Redux store, actions, and reducers.
- [expo-cli](https://github.com/expo/expo-cli) installed, or use npx

## Create a React Native app with expo-cli

Create a new React Native project using `expo-cli` and then install the dependencies required to build this demo app. Open a terminal window and execute the following commands:

```shell
npx expo init redux-persist-asyncstorage-example

# navigate into that directory
cd redux-persist-asyncstorage-example

yarn add @react-navigation/native @react-navigation/bottom-tabs axios@0.21.0
redux@4.0.5 redux-persist@6.0.0 redux-thunk@2.3.0 react-redux@7.2.2

# install dependencies with Expo specific package version
expo install react-native-gesture-handler react-native-reanimated
react-native-screens react-native-safe-area-context @react-native-community/
masked-view @react-native-async-storage/async-storage
```

After installing these dependencies, let's create two mock screens that are going to be the core screens for the demo app. Create a new `screens/` directory and inside it, create the first screen file `BooksList.js` with the following code snippet:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function BooksListApp() {
  return (
    <View style={styles.container}>
      <Text>BooksList</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

Then create the second screen file `BookmarksList.js` with the following code snippet:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function BookmarksList() {
  return (
    <View style={styles.container}>
      <Text>BookmarksList</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

The `BooksList` screen is going to show a list of books. I am going to fetch the data to display the books and will be using [Draftbit's Example API](https://example-data.draftbit.com/) route as the base URL.

Each book item shown on this screen is going to have a functionality for the end-user to bookmark or save it in real-time to view later. All the book items saved by the user are going to be shown in the `BookmarksList` tab.

Since a Base URL is required to fetch the data, let's add it. Create a new directory called `config/` and inside it create a file called `index.js` and export the following Base URL:

```js
export const BASE_URL = 'https://example-data.draftbit.com/books?_limit=10';
```

Now, this Base URL is ready to use to send HTTP requests.

## Add tab navigation to switch between the screens

In this section, let's create a custom tab navigator at the bottom for the app to display the two mock screens created in the previous section. Start by creating a `navigation/` directory and inside a new file called `RootNavigator.js`. Add the following import statements in this file:

```js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { MaterialCommunityIcons } from '@expo/vector-icons';

// Import mock screens
import BooksList from '../screens/BooksList';
import BookmarksList from '../screens/BookmarksList';

const Tab = createBottomTabNavigator();
```

To customize the tab bar appearance, let's add some styling and custom icons from the `@expo/vector-icons` library which comes pre-installed with the `expo` package.

```js
const tabBarOptions = {
  showLabel: false,
  inactiveTintColor: '#2D3038',
  activeTintColor: '#FFFFFF',
  style: {
    height: '10%',
    backgroundColor: '#1E1B26'
  }
};

const screenOptions = (route, color) => {
  let iconName;

  switch (route.name) {
    case 'BooksList':
      iconName = 'view-dashboard';
      break;
    case 'BookmarksList':
      iconName = 'bookmark-multiple-outline';
      break;
    default:
      break;
  }

  return <MaterialCommunityIcons name={iconName} color={color} size={24} />;
};
```

The `tabBarOptions` config object is going to customize the appearance of the bottom tab shared between different app screens. The `screenOptions` are used to add a custom icon for each tab.

Lastly, let's define and export the `RootNavigator` component that is going to render these two tab screens.

```js
const RootNavigator = () => {
  return (
    <NavigationContainer>
      <Tab.Navigator
        initialRouteName="BooksList"
        tabBarOptions={tabBarOptions}
        screenOptions={({ route }) => ({
          tabBarIcon: ({ color }) => screenOptions(route, color)
        })}
      >
        <Tab.Screen name="BooksList" component={BooksList} />
        <Tab.Screen name="BookmarksList" component={BookmarksList} />
      </Tab.Navigator>
    </NavigationContainer>
  );
};

export default RootNavigator;
```

To see the `RootNavigator` in action, import it inside the `App.js` file and return it. Add the following code snippet to the `App.js` file:

```js
import React from 'react';

import RootNavigator from './navigation/RootNavigator';

export default function App() {
  return <RootNavigator />;
}
```

To run the application, execute the command `yarn start` from the terminal window.

Here is the output after this step:

![ss1](https://i.imgur.com/BPjPOgp.png)

## Add action types and creators

Using Redux to manage the state of the whole application, the state itself is represented by one JavaScript object. This object is read-only which means that manipulation of the state is not done directly. Changes are done by triggering actions.

Let us begin by defining action types. Create a new directory called `redux/` and inside it create a new file called `actions.js`. Add the following action types to it:

```js
// Define action types
export const GET_BOOKS = 'GET_BOOKS';
export const ADD_TO_BOOKMARK_LIST = 'ADD_TO_BOOKMARK_LIST';
export const REMOVE_FROM_BOOKMARK_LIST = 'REMOVE_FROM_BOOKMARK_LIST';
```

Action types defined in the above file are self-explanatory. The first one, `GET_BOOKS`, is going to be used to make the HTTP request to fetch the data from the Base URL. The second, `ADD_TO_BOOKMARK_LIST`, is going to add each book item to the list of bookmarks. Similarly, the third action type `REMOVE_FROM_BOOKMARK_LIST` is going to remove the book from the list of bookmarks.

An action type is used to trigger the event to update the state stored using Redux. Each action type has action creators for this purpose. The first action creator required in the demo app is to fetch the data from the [Draftbit's Example API](https://example-data.draftbit.com/).

To fetch data, we will use a library called `axios`. It has an API of methods such as `.get`, `.put`, and so on. to make the appropriate HTTP requests.

To make the HTTP request to retrieve the data, a `BASE URL` of the API is required. Inside the `actions.js` file, import the `axios` library and the Base URL:

```js
import axios from 'axios';

import { BASE_URL } from '../config';
```

After defining the action types, define a new action creator called `getBooks` that has the action type of `GET_BOOKS` with the following code snippet:

```js
export const getBooks = () => {
  try {
    return async dispatch => {
      const response = await axios.get(`${BASE_URL}`);
      if (response.data) {
        dispatch({
          type: GET_BOOKS,
          payload: response.data
        });
      } else {
        console.log('Unable to fetch data from the API BASE URL!');
      }
    };
  } catch (error) {
    // Add custom logic to handle errors
    console.log(error);
  }
};
```

## Add a reducer

Whenever an action is triggered, the state of the application changes. The handling of the applicationâ€™s state is done by a reducer.

A reducer is a pure function that calculates the next state based on the initial or previous state. It always produces the same output if the state is unchanged. It takes two inputsâ€”the state and actionâ€”and must return the default state.

Create a new file in the `redux/` directory called `reducers.js`. Import the action type `GET_BOOKS` and then define the initial state with two empty arrays. Then define a `booksReducer` function that takes `initialState` as the default value for the first argument, and `action` as the second argument.

```js
import { GET_BOOKS } from './actions';

const initialState = {
  books: [],
  bookmarks: []
};

function booksReducer(state = initialState, action) {
  switch (action.type) {
    case GET_BOOKS:
      return { ...state, books: action.payload };
    default:
      return state;
  }
}

export default booksReducer;
```

## Configure a store

A store is an object that brings actions and reducers together. It provides and holds state at the application level instead of individual components.

Create a new file called `store.js` inside the `redux/` directory. A store in redux is created using a function called `createStore` that takes the `rootReducer` as the first argument and middleware or a collection of middleware functions as the second argument.

The `rootReducer` is a combination of different reducers across the app. In the demo app, there is only one reducer called `booksReducer`.

The middleware function `thunk` allows a redux store to make asynchronous AJAX requests such as fetching data from an API URL like in this demo app.

Add the following code snippet to it:

```js
import { createStore, combineReducers, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

import booksReducer from './reducers';

const rootReducer = combineReducers({ booksReducer });

export const store = createStore(rootReducer, applyMiddleware(thunk));
```

To bind this Redux store in the React Native app, open the entry point file `App.js`. Inside it, import the `store` and the High Order Component `Provider` from the `react-redux` package. This HOC helps to pass the `store` down to the rest of the app such as all components, which are now able to access the state. It is also going to wrap the `RootNavigator` since all screens are children of this custom navigator.

Modify the `App.js` file as shown below:

```js
import React from 'react';
import { Provider } from 'react-redux';

import { store } from './redux/store';
import RootNavigator from './navigation/RootNavigator';

export default function App() {
  return (
    <Provider store={store}>
      <RootNavigator />
    </Provider>
  );
}
```

## Fetching data from the API

The `BooksList.js` file is the tab where the data is going to fetch from the Base URL. Import the following statements.
To access the state from a Redux store, the `useSelector` hook is used. Inside the `BooksList` component, access the `books` from the state.

```js
export default function BooksList() {
  const { books } = useSelector(state => state.booksReducer);

  //...
}
```

To dispatch an action from the Redux store, the `useDispatch` hook is used. To fetch the books from the API, you need to dispatch the action `getBooks`. Add the following code snippet after accessing the state.

```js
const dispatch = useDispatch();

const fetchBooks = () => dispatch(getBooks());

useEffect(() => {
  fetchBooks();
}, []);
```

Next, add return JSX with a `FlatList` component to render the list of books.

The `books` fetched from the API is an array and is passed as the value for the `data`.

```js
return (
  <SafeAreaView style={{ flex: 1, backgroundColor: '#1E1B26' }}>
    <View style={{ flex: 1, paddingHorizontal: 16 }}>
      <Text style={{ color: 'white', fontSize: 22 }}>Bestsellers</Text>
      <View style={{ flex: 1, marginTop: 8 }}>
        <FlatList
          data={books}
          keyExtractor={item => item.id.toString()}
          renderItem={renderItem}
          showsVerticalScrollIndicator={false}
        />
      </View>
    </View>
  </SafeAreaView>
);
```

The JSX returned from the `renderItem` contains all the information to display for each book item in the list.

Each book item is going to have:

- a book cover displayed using the `Image` component.
- a book title displayed using the `Text` component.
- some meta information such as the number of pages and the average rating of the book item.
- the touchable button to add the book to the `BookmarksList` screen.

Add the following `renderItem` just before the main `return` function.

```js
const renderItem = ({ item }) => {
  return (
    <View style={{ marginVertical: 12 }}>
      <View style={{ flexDirection: 'row', flex: 1 }}>
        {/* Book Cover */}
        <Image
          source={{ uri: item.image_url }}
          resizeMode="cover"
          style={{ width: 100, height: 150, borderRadius: 10 }}
        />
        {/* Book Metadata */}
        <View style={{ flex: 1, marginLeft: 12 }}>
          {/* Book Title */}
          <View>
            <Text style={{ fontSize: 22, paddingRight: 16, color: 'white' }}>
              {item.title}
            </Text>
          </View>
          {/* Meta info */}
          <View
            style={{
              flexDirection: 'row',
              marginTop: 10,
              alignItems: 'center'
            }}
          >
            <MaterialCommunityIcons
              color="#64676D"
              name="book-open-page-variant"
              size={20}
            />
            <Text style={{ fontSize: 14, paddingLeft: 10, color: '#64676D' }}>
              {item.num_pages}
            </Text>
            <MaterialCommunityIcons
              color="#64676D"
              name="star"
              size={20}
              style={{ paddingLeft: 16 }}
            />
            <Text style={{ fontSize: 14, paddingLeft: 10, color: '#64676D' }}>
              {item.rating}
            </Text>
          </View>
          {/* Buttons */}
          <View style={{ marginTop: 14 }}>
            <TouchableOpacity
              onPress={() => console.log('Bookmarked!')}
              activeOpacity={0.7}
              style={{
                flexDirection: 'row',
                padding: 2,
                backgroundColor: '#2D3038',
                borderRadius: 20,
                alignItems: 'center',
                justifyContent: 'center',
                height: 40,
                width: 40
              }}
            >
              <MaterialCommunityIcons
                color="#64676D"
                size={24}
                name="bookmark-outline"
              />
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </View>
  );
};
```

Here is the output you are going to get after this step:

![ss2](https://i.imgur.com/x0meApG.png)

## Add action creators and update the reducer

In the `redux/action.js` file, let's add two more action creators that are going to update the state when the bookmarks are added or removed by the user. Each action creator is going to be based on the action type we defined earlier. Also, each action creator is going to accept the book item that is added to the bookmark list.

```js
export const addBookmark = book => dispatch => {
  dispatch({
    type: ADD_TO_BOOKMARK_LIST,
    payload: book
  });
};

export const removeBookmark = book => dispatch => {
  dispatch({
    type: REMOVE_FROM_BOOKMARK_LIST,
    payload: book
  });
};
```

The next step is to update the state of the redux store. Open `redux/reducers.js` and modify the following code snippet to perform the actions we just added.

```js
import {
  GET_BOOKS,
  ADD_TO_BOOKMARK_LIST,
  REMOVE_FROM_BOOKMARK_LIST
} from './actions';

const initialState = {
  books: [],
  bookmarks: []
};

function booksReducer(state = initialState, action) {
  switch (action.type) {
    case GET_BOOKS:
      return { ...state, books: action.payload };
    case ADD_TO_BOOKMARK_LIST:
      return { ...state, bookmarks: [...state.bookmarks, action.payload] };
    case REMOVE_FROM_BOOKMARK_LIST:
      return {
        ...state,
        bookmarks: state.bookmarks.filter(book => book.id !== action.payload.id)
      };
    default:
      return state;
  }
}

export default booksReducer;
```

## Configure and integrate redux persist

Import the following statements inside `redux/store.js` file to create a persisted reducer.

```js
import AsyncStorage from '@react-native-async-storage/async-storage';
import { persistStore, persistReducer } from 'redux-persist';
```

Then, add a `persistConfig` object with the following properties:

```js
const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['bookmarks']
};
```

In the above snippet, the `key` and `storage` are required to create the config for a persisted reducer. The `storage` has the value of the storage engine which is used to save and persist the data. In React Native, it is essential to pass the value of the `storage` explicitly. In the current demo app, let's use `AsyncStorage`.

The `whitelist` takes an array of strings. It is used to define which object key to use from the initial state to save the data. If no `whitelist` is provided, then redux persists for both `books` and `bookmarks`. Providing `bookmarks` as the value of the `whitelist` is going to only save the data that is in the `bookmarks` array (_which is empty at the moment but will be populated later when a bookmark is added or removed_).

Then, update `rootReducer` with the persisted reducer with two arguments: `persistConfig` and `booksReducer`.

Also, export the `persistor`. It is an object that is returned by `persistStore` which wraps the original `store`.

```js
const rootReducer = combineReducers({
  booksReducer: persistReducer(persistConfig, booksReducer)
});

export const store = createStore(rootReducer, applyMiddleware(thunk));
export const persistor = persistStore(store);
```

In React Native apps, you have to wrap the root component with `PersistGate`. This component delays the rendering of the app's UI until the persisted state is retrieved and saved to redux.

Import the `PersistGate` from the `redux-persist` library and import `persistor` from the `redux/store` file in the `App.js` file:

```js
// Add
import { PersistGate } from 'redux-persist/integration/react';

// Modify to add persistor
import { store, persistor } from './redux/store';

// Then, modify the JSX returned from App component
// Wrap the root component with PersistGate
return (
  <Provider store={store}>
    <PersistGate loading={null} persistor={persistor}>
      <RootNavigator />
    </PersistGate>
  </Provider>
);
```

That's it to configure and integrate the `redux-persist` library to the React Native and Redux application.

## Create functionality to add or remove a bookmark

All book items are shown in the `BooksList.js` file that is fetched from the API. It is from the tab screen that a user can add or remove a bookmark to a book item.

Let's start by importing other action creators as well:

```js
// Modify
import { getBooks, addBookmark, removeBookmark } from '../redux/actions';
```

The `booksReducer` is used to access the state. Modify it to access the `bookmarks` array:

```js
const { books, bookmarks } = useSelector(state => state.booksReducer);
```

Now, dispatch two actions using the `useDispatch` hook and create their handler functions. These handler functions are going to be triggered when the touchable component is pressed by the user. Each handler function is going to accept one argument and that is the current book item from `FlatList`.

```js
const addToBookmarkList = book => dispatch(addBookmark(book));
const removeFromBookmarkList = book => dispatch(removeBookmark(book));

const handleAddBookmark = book => {
  addToBookmarkList(book);
};

const handleRemoveBookmark = book => {
  removeFromBookmarkList(book);
};
```

Let's add another handler function called `ifExists` that is going to dynamically change the UI of the app based on the action triggered. This function is going to use `filter` on the `bookmarks` array to make the changes on the UI based on whether a book item already exists in the array (that is stored on the AsyncStorage) or not.

```js
const ifExists = book => {
  if (bookmarks.filter(item => item.id === book.id).length > 0) {
    return true;
  }

  return false;
};
```

Modify the `TouchableOpacity` component to dynamically change the UI of the app when an action is triggered to add or remove an item from the bookmarks list.

```js
<TouchableOpacity
  onPress={() =>
    ifExists(item) ? handleRemoveBookmark(item) : handleAddBookmark(item)
  }
  activeOpacity={0.7}
  style={{
    // rest remains same
    backgroundColor: ifExists(item) ? '#F96D41' : '#2D3038'
    //
  }}
>
  <MaterialCommunityIcons
    color={ifExists(item) ? 'white' : '#64676D'}
    size={24}
    name={ifExists(item) ? 'bookmark-outline' : 'bookmark'}
  />
</TouchableOpacity>
```

## Display bookmarks

Any book item that is bookmarked is going to be shown in the `BookmarksList.js` tab. Apart from displaying the list of bookmarked items, it is also going to have the functionality of removing book item from the list.

Start by importing the following statements. This time, only import `removeBookmark` action creator.

```js
import React from 'react';
import {
  SafeAreaView,
  Text,
  View,
  FlatList,
  TouchableOpacity,
  Image
} from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { MaterialCommunityIcons } from '@expo/vector-icons';

import { removeBookmark } from '../redux/actions';
```

Using the `useSelector` hook allows us to access the `bookmarks` state. Then, using the `useDispatch` hook defines the action creator and handler function to remove a book from the bookmarks list.

```js
export default function BookmarksList() {
  const { bookmarks } = useSelector(state => state.booksReducer);
  const dispatch = useDispatch();

  const removeFromBookmarkList = book => dispatch(removeBookmark(book));

  const handleRemoveBookmark = book => {
    removeFromBookmarkList(book);
  };

  //...
}
```

Lastly, the UI of this tab screen is going to be similar to that of the `BooksList.js` tab. Using the `FlatList` component, let's show the list of all the items that are bookmarked.

If there are no items that are bookmarked, let's display a simple message to convey that. This is done by checking the length of the `bookmarks` array from the state.

Here is the complete JSX snippet returned by the `BookmarksList` tab component:

```js
export default function BookmarksList() {
  // ...
  const renderItem = ({ item }) => {
    return (
      <View style={{ marginVertical: 12 }}>
        <View style={{ flexDirection: 'row', flex: 1 }}>
          {/* Book Cover */}
          <Image
            source={{ uri: item.image_url }}
            resizeMode="cover"
            style={{ width: 100, height: 150, borderRadius: 10 }}
          />
          {/* Book Metadata */}
          <View style={{ flex: 1, marginLeft: 12 }}>
            {/* Book Title */}
            <View>
              <Text style={{ fontSize: 22, paddingRight: 16, color: 'white' }}>
                {item.title}
              </Text>
            </View>
            {/* Meta info */}
            <View
              style={{
                flexDirection: 'row',
                marginTop: 10,
                alignItems: 'center'
              }}
            >
              <MaterialCommunityIcons
                color="#64676D"
                name="book-open-page-variant"
                size={20}
              />
              <Text style={{ fontSize: 14, paddingLeft: 10, color: '#64676D' }}>
                {item.num_pages}
              </Text>
              <MaterialCommunityIcons
                color="#64676D"
                name="star"
                size={20}
                style={{ paddingLeft: 16 }}
              />
              <Text style={{ fontSize: 14, paddingLeft: 10, color: '#64676D' }}>
                {item.rating}
              </Text>
            </View>
            {/* Buttons */}
            <View style={{ marginTop: 14 }}>
              <TouchableOpacity
                onPress={() => handleRemoveBookmark(item)}
                activeOpacity={0.7}
                style={{
                  flexDirection: 'row',
                  padding: 2,
                  backgroundColor: '#2D3038',
                  borderRadius: 20,
                  alignItems: 'center',
                  justifyContent: 'center',
                  height: 40,
                  width: 40
                }}
              >
                <MaterialCommunityIcons
                  color="#64676D"
                  size={24}
                  name="bookmark-remove"
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </View>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: '#1E1B26' }}>
      <View style={{ flex: 1, paddingHorizontal: 16 }}>
        <Text style={{ color: 'white', fontSize: 22 }}>Bookmarks</Text>
        <View style={{ flex: 1, marginTop: 8 }}>
          {bookmarks.length === 0 ? (
            <Text style={{ color: '#64676D', fontSize: 18 }}>
              Add a book to bookmark list.
            </Text>
          ) : (
            <FlatList
              data={bookmarks}
              keyExtractor={item => item.id.toString()}
              renderItem={renderItem}
              showsVerticalScrollIndicator={false}
            />
          )}
        </View>
      </View>
    </SafeAreaView>
  );
}
```

## Running the app

Go to the simulator or the real device where you are running the Expo client, and you can test the functionality by adding or removing the bookmark to an item. Also, notice the dynamic UI changes of the bookmark button in the first tab.

![ss3](https://i.imgur.com/ckD9Pcc.gif)

Make sure to close the Expo client and then start it to see if the state from the Redux store persists or not.

![ss4](https://i.imgur.com/tP4SSP5.gif)

And that's it! I hope you have found this tutorial helpful.

## Further Reading

- [Deep Dive Into React &mdash; Separation of Concerns by Andrei Calazans](https://www.g2i.co/blog/react-separation-of-concerns)

_Originally published at [Jscrambler.com](https://jscrambler.com/blog/how-to-use-redux-persist-in-react-native-with-asyncstorage)_

---

## How to remove AsyncStorage warning when using Firebase JS SDK with React Native
Slug: remove-asyncstorage-has-been-extracted-warning-using-firebase

The [Firebase JS SDK](https://github.com/firebase/firebase-js-sdk) is a library that provides a set of JavaScript APIs for interacting with Firebase services. I use it with some of the production React Native apps built with Expo, mainly for authentication, database, and storage. I also use it for an open-source template that I am currently maintaining called [expo-firebase-stater], which provides a head start when building a React Native app with Firebase.

For React Native apps, the Firebase SDK uses AsyncStorage under the hood to store an authentication session when an app restarts. It is one of the out-of-the-box features that Firebase provides that I like and use when implementing authentication in React Native apps using the Firebase Auth service.

## Why does the AsyncStorage warning occur

Typically, the Firebase Auth module is configured as shown below in a React Native app:

```js
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
```

Using this code snippet to initialize Firebase auth service in the app will cause the warning:

```shell
AsyncStorage has been extracted from the react-native core and will be removed in a future release ...
```

![ss1](https://i.imgur.com/pBiiXzY.png)

Firebase SDK uses the AsyncStorage module from the `react-native` core. From React Native versions `0.59` and up, the AsyncStorage module has been moved to its own package: `@react-native-async-storage/async-storage`.

[Here](https://github.com/firebase/firebase-js-sdk/blob/96ab56bac05ccaf506ed3a02ccad5ff7e01a07d0/packages/app/index.rn.ts#L27) is the line of code in Firebase JS SDK repo that imports AsyncStorage from `react-native` core:

![ss2](https://i.imgur.com/uWt9gRQ.jpg)

## Remove the AsyncStorage warning

To remove the AsyncStorage warning, start by installing the `@react-native-async-storage/async-storage` package:

```shell
# for Expo projects
npx expo install @react-native-async-storage/async-storage
```

Firebase SDK provides another method in its Auth module called `initializeAuth`. This method allows more control over the Auth instance from the `getAuth` method. In addition, it provides a way to define what persistence layer to use to store the authentication session using the method `getReactNativePersistence` and using which Dependency. Since we are using the Firebase auth service in a React Native app, we can use the React Native Dependency.

> Note: [Dependencies interface](https://firebase.google.com/docs/reference/js/auth.dependencies.md#dependencies_interface) in Firebase enables tree shaking. This means that a web app does not have to include all the dependencies that Firebase supports, such as Cordova or React Native.

Start by importing `initializeAuth` and `getReactNativePersistence` from `firebase/auth/react-native`. To initialize `auth`, pass an object as the second argument to the `initializeAuth` method. This object has a `persistence` key that takes the value of which persistence layer to use.

```js
import AsyncStorage from '@react-native-async-storage/async-storage';
import { initializeApp } from 'firebase/app';
import {
  initializeAuth,
  getReactNativePersistence
} from 'firebase/auth/react-native';

// add firebase config here

// initialize firebase app
const app = initializeApp(firebaseConfig);

// initialize auth
const auth = initializeAuth(app, {
  persistence: getReactNativePersistence(AsyncStorage)
});

export { auth };
```

Using the same strategy as the above code snippet should resolve the warning about AsyncStorage.

---

## Remove bottom border or shadow on header in React Navigation or Expo Router
Slug: remove-bottom-border-shadow-on-header-in-react-navigation

> **Update:** This blog post was originally written on June 5, 2022. It is now up-to-date to include Expo Router relevant information.

Expo Router and React Navigation are both amazing navigation libraries in the React Native ecosystem. I have been a big fan of React Navigation as I have used it for a while but lately, I have started using Expo Router.

Both libraries share `screenOptions` since Expo Router is built on top of React Navigation. Using these options, the border at the bottom of the header can be removed. By default, the Stack and Tab Navigators in the React Navigation library add a header on the screen. Expo Router version 2 also follows the same pattern. The example described on this blog post applies to both libraries.

## Header with a shadow

The header has a default bottom border or shadow. Here is an example of a border on the header on iOS:

![ss1](https://i.imgur.com/PnxIHxT.png)

The orange arrows are used to highlight the shadow. Similarly, on Android, the width is thin and hard to notice.

![ss2](https://i.imgur.com/MoP6J0t.png)

To make it more visible, you can populate the `screenOptions` of the navigator as shown below:

```js
screenOptions={{
  headerStyle: {
    borderBottomWidth: 4,
  },
}}
```

Increasing the value of the property `borderBottomWidth` will make the border thicker.

![ss3](https://i.imgur.com/I7l8INR.png)

## Disable the shadow

At times, the UI of the screen might not require a header border or shadow at all. In such cases, you can always customize the `screenOptions` by adding the property `headerShadowVisible` and setting it to `false`.

```js
screenOptions={{
  headerShadowVisible: false,
}}
```

You will get the desired output both on iOS and Android:

![ss4](https://i.imgur.com/bBQuIJJ.png)

![ss5](https://i.imgur.com/NId2zbQ.png)

## Conclusion

To learn more about navigation in React Native apps, [React Navigation docs](https://reactnavigation.org/) are a great asset for learning more about the library and what customization options it provides. Also, see [Expo Router](https://docs.expo.dev/routing/introduction/) documentation if you want to implement file-based routing.

Also, check out my other post on [how to remove the bottom tab bar border in React Navigation](https://amanhimself.dev/blog/react-navigation-remove-tab-bar-border/).

> [Source code available at GitHub.](https://github.com/amandeepmittal/react-native-examples/tree/main/remove-header-border-react-navigation)

---

## How to remove console statements from React Native apps
Slug: remove-console-from-react-native-apps

<!-- ![cover_image](https://i.imgur.com/wTa1g5A.png) -->

For debugging purposes, I often use `console.log` statements in React Native and Expo applications.

A babel plugin called [babel-plugin-transform-remove-console](https://github.com/babel/minify/tree/master/packages/babel-plugin-transform-remove-console) takes care of removing any `console` statements from the code. This is a great plugin that I like to use, especially before releasing apps in production.

## How to use it

Install the plugin as a dev dependency in the project:

```shell
yarn add -D babel-plugin-transform-remove-console
```

Then, add it as a plugin under `env.production` in the `babel.config.js` file:

```js
module.exports = function () {
  return {
    // ... other project config such as presets and plugins
    env: {
      production: {
        plugins: ['transform-remove-console']
      }
    }
  };
};
```

This will remove any `console` statements from the code.

## Why does it work

React Native uses [Babel](https://babeljs.io/) as a tool to read and parse React and ES6 (or later) syntax into a specific version of JavaScript code that can run in an environment (that doesn't support newer ES6 or React syntax).

---

## Remove node_modules Recursively
Slug: remove-node-modules-recursively

`node_modules` tend to take a lot of space in your local system especially if you work with Node.js or related frameworks (such as client side frameworks: React or Angular). They are the part and parcel of modern day JavaScript applications and workflow.

Each day `npm` registry is getting around [350 million downloads](https://x.com/seldo/status/864298310785310720) daily, at the current time of writing this post. That's almost 2.2 billion downloads per week and you can take the calculation further.

Hereâ€™s Laurie Voss [(@seldo)](https://x.com/seldo) [tweet](https://x.com/seldo/status/864298310785310720), sharing the aforementioned details:

<img src='https://cdn-images-1.medium.com/max/800/0*HHMm699bdI2QMoOy.jpg' />

Nonetheless, after all your efforts are paid of and everything is deployed and is over cloud, either Github or some deployment service you or your client prefers, I think it will be generous to remove `node_modules` that take useful space on our local machines (especially, Mac users with limited GigaBytes of SSD).

Thereâ€™s a simple command that you can run in your terminal either in a folder or from the root.

```shell
find . -name "node_modules" -exec rm -rf '{}' +
```

This will delete `node_modules` folder in every local repository/directory that's on your system so take precaution or exclude those projects that you are currently working on.

However, donâ€™t panic. Everything can be back to normal just by going into the projectâ€™s directory and running package installing command:

```shell
npm install
```

I have used this command earlier today it saved me up to 9 GB of space from local system over several projects that I am currently not working or are already on [Github](https://github.com/amandeepmittal).

I even replaced `node_modules` with `bower_components` to do the same thing:

```shell
find . -name "bower_components" -exec rm -rf '{}' +
```

---

## Resolve merge conflicts with git rebase
Slug: resolve-merge-conflicts-with-git-rebase

Resolving merge conflicts can sometimes be difficult, and using the GitHub UI may not always be the most effective solution. As the complexity of the conflicts increases, it may be necessary to rely on tools on your local machine rather than the web interface provided by GitHub.

I have discovered that using the `git rebase` command is a useful method for resolving merge conflicts in my feature branch before merging it into the `main` branch. Although it took some time to fully understand the process and the necessary steps.

## Problem

I have been working on a `feature-branch` in an open-source repository for work for quite some time. However, recent commits merged into the main branch have caused conflicts in my branch, preventing me from merging my own commit. I have two options to proceed:

- Resolve the conflicts to merge the branches.
- Create a new pull request if the conflicts are too complex and my changes are of low priority.

## Solution: Resolve conflicts with git rebase

Using `git rebase` in the `feature-branch` allows to bring changes from the `main`, and resolve the merge conflicts. Then, I can use VS Code (which has a Resolve merge conflict editor and is pretty handy) and push the changes back to my feature branch. Once the conflicts are resolved, I can merge my branch into the `main` without any issues which will make GitHub happy.

### 1: Fetch the latest changes from the main

Open a fresh terminal tab, and navigate into the repository. On the `main` branch, run:

```shell
git pull
```

This makes sure that the local copy of the `main` branch on my machine has all the latest changes.

### 2: Run git log to verify

Running `git log` helps verifying that `main` branch has all the latest commits:

```shell
git log --oneline --graph --decorate --color

# I use an alias: glog
```

### 3: Checkout to the feature-branch

Time to switch to the `feature-branch`:

```shell
git checkout feature-branch

# I use an alias: gck feature-branch
```

### 4: Run git rebase to bring changes from the main

To bring changes from the `main` to the `feature-branch`, run:

```shell
git rebase main
```

Then run `git status` to know the status of the branch:

```shell
git status

# I use an alias: gs
```

### 5: Resolve merge conflicts

If there are merge conflicts, running `git status` will let you know. Open VS Code, click on open Resolve Merge Conflict editor and you can now accept changes in the left tab which shows the latest changes from `main` branch.

On the right side, changes from the current `feature-branch` (probably the ones that are causing conflicts) are shown.

After resolving conflicts, save the file and from the terminal run the following command to stage the modified files:

```shell
git add file-name

# I use an alias: ga file-name

# In case, multiple files modified and need to be staged, run:
git add .
```

Then, run `git status` once again to see if the modified files are staged.

Then run the following command to commit those changes:

```shell
git commit -m "commit message..."

# I use an alias: gc "commit message..."
```

### 6: Continue the rebase

Run `git rebase` command with `--continue` flag to continue the rebase process:

```shell
git rebase --continue
```

> **Tip:** If required, save changes by pressing `:wq!` in the terminal.

### 7: Verify new commits

Run the following command to verify that the new commits from `feature-branch` are at the top of the commit history and changes from the `main`:

```shell
git log --oneline --graph --decorate --color

# I use an alias: glog
```

### 8: Commit changes from local to remote

Finally, push the changes from the local `feature-branch` to the remote `feature-branch`:

```shell
git push --force
```

## Summary

A few added rules I think are worth mentioning in this process:

- Only use rebase for local branches and if you are the owner of that branch.
- If you anticipate that the conflicts can become messy, use the strategy described above at regular intervals to avoid a lot of conflicts.

> A big thank you to my colleague [Sundeep Peswani](https://www.sundeeppeswani.com/) for teaching this via live coding and jumping on a call to help me understand the process and making my life easier.

---

## Resolving invalid custom Tailwind classname ESLint warning
Slug: resolving-custom-tailwind-classname-eslint-warning

When working on a large web project with Tailwind CSS, you may have custom CSS classes defined. For instance, if you directly use a class name like `code-annotation` in the markdown content, you might run into an ESLint issue about the class name being invalid.

The custom class, as shown below, is used to indicate to readers how highlights are used inside many code snippets within the beginner-friendly tutorial I have recently updated:

```markdown
<span className="code-annotation">highlighted in green</span>
```

This class is defined in the global CSS file of my project and is a special class name.

In this project, I utilize ESLint for Tailwind ([`eslint-plugin-tailwind`](https://github.com/francoismassart/eslint-plugin-tailwindcss/blob/master/docs/rules/no-custom-classname.md#detect-classnames-which-do-not-belong-to-tailwind-css-no-custom-classname) with the `tailwindcss/no-custom-classname` rule activated. This rule identifies any class names from the extensive utility classes Tailwind CSS offers. Rightly, it throws the following warning when I run the lint tool in my project:

```shell
warning: Classname 'code-annotation' is not a Tailwind CSS class! tailwindcss/no-custom-classname
```

My use case may be unique or could be implemented differently, but since that custom class name is used only once in this extensive documentation site, I attempted to determine how I could address this issue without re-implementing the class.

## Using Tailwind's safelist

One option I quickly learned that could have helped resolve this issue is to add the custom class name inside the `safelist` in the project's `tailwind.config.js` file:

```js
module.exports = {
// ... rest of the configuration
safelist: ['code-annotation]
}

```

Since the error in my case is coming from ESLint, this solution didn't work, but I was curious to learn more. So I found out that any class name added to the `safelist` array, as shown above, prevents it from being excluded from Tailwind's build process.

During the build process, all content and source files (HTML, CSS, JS, and more) are scanned to identify which Tailwind utility classes and custom classes are in use. After the scan, any used class goes through class preservation, and any unused class identified is purged from the final CSS bundle.

To understand how Tailwind's build process works, I imagine the following diagram is how the build process looks:

<img src="/images/mmd01.png" alt="Diagram that shows Tailwind CSS build process" width="640" />

Adding a class to `safelist` only affects the build process. It doesn't communicate with the ESLint plugin, which runs a separate code analysis process based on pre-defined and custom rules. The plugin configuration is defined inside the `.eslintrc` file. This is why adding the custom class name to the `safelist` didn't work in my case. However, the class is preserved in the final CSS bundle.

## Whitelisting the custom class in ESLint plugin configuration

Since this is a linting issue, [`no-custom-classname`](https://github.com/francoismassart/eslint-plugin-tailwindcss/blob/master/docs/rules/no-custom-classname.md#whitelist-default-) allows whitelisting any custom class inside the `.eslintrc` file:

```js
module.exports = {
  // ...
  overrides: [
    // ...
    {
      rules: {
        'tailwindcss/no-custom-classname': [
          'warn',
          {
            whitelist: ['code-annotation']
          }
        ]
      }
    }
  ]
};
```

This approach works because the rule defined tells ESLint to accept the custom class name as a valid utility. In general, this approach is functional when:

- You have established custom classes as part of your design system
- You are using these class names in your markdown content (as shown in the beginning of this blog post)

## Wrapping up

Sometimes, finding an approach to solve the problem you are encountering allows you to go in-depth to investigate why the approach you want to take to resolve it is not working. This resonates with my recent experience, which is described in this post. Understanding the distinction between the two approaches and knowing which one to use was crucial to keep the lint tool happy.

---

## RSS feed in an Astro blog
Slug: rss-feed-in-an-astro-blog

One of the easiest ways to follow a site without being tracked or throttled by an Algorithm, with no login walls, is having content delivered to a reader app of your choice. This is why so many personal blogs opt to include an RSS feed.

This post is just a quick guide about the implementation of RSS feed for my blog &mdash; [amanhimself.dev](https://amanhimself.dev).

## The core RSS setup

This blog you are reading right now is built using [Astro](https://astro.build). Astro is a static site builder that allows you to build your blog with ease. At least, now I have to pay [less attention](/blog/old-blog-new-tech/) to maintaining it than writing.

Astro provides a plugin called `@astro/rss` to build RSS feeds. It exports an `rss()` method that takes your site's metadata (such as title, description, post URL, and so on), an array of entries, handles boilerplate logic, and returns the XML string that you can use to serve on a path like `/rss.xml`.

The recommended approach from `@astro/rss` is to create a separate file called `rss.xml.ts` in the `src/pages` directory. This file will export a `GET` function that will be used by Astro to build the RSS feed.

Here's how the `rss.xml.ts` file looks in my blog:

```ts
import rss from '@astrojs/rss';
import { getCollection, render } from 'astro:content';
import getSortedPosts from '@utils/getSortedPosts';
import { SITE, LOCALE } from '@config';

const extractDescription = (body?: string) => {
  if (!body) return '';

  const plainLines = body
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length && !line.startsWith('<!--'));

  const summary = plainLines.slice(0, 2).join(' ');

  return summary
    .replace(/!\[[^\]]*\]\([^)]*\)/g, '') // strip images
    .replace(/\[(.*?)\]\([^)]*\)/g, '$1') // strip links, keep text
    .replace(/[`*_>#~]/g, '') // strip basic markdown symbols
    .replace(/\s+/g, ' ')
    .trim();
};

export async function GET() {
  const posts = await getCollection('blog');
  const sortedPosts = getSortedPosts(posts);
  const items = await Promise.all(
    sortedPosts.map(async post => {
      const { data, slug } = post;
      const rendered = await render(post);
      const html =
        typeof rendered === 'string'
          ? rendered
          : ((rendered as any).html ?? '');
      const updated =
        data.modDatetime && data.modDatetime !== data.pubDatetime
          ? new Date(data.modDatetime)
          : null;

      const description =
        data.description || extractDescription(post.body) || SITE.desc;

      return {
        link: `blog/${slug}/`,
        title: data.title,
        description,
        pubDate: new Date(data.pubDatetime),
        categories: data.tags ?? [],
        content: html,
        customData: updated
          ? `<atom:updated>${updated.toISOString()}</atom:updated>`
          : undefined
      };
    })
  );

  return rss({
    title: SITE.title,
    description: SITE.desc,
    site: SITE.website,
    items,
    xmlns: {
      atom: 'http://www.w3.org/2005/Atom',
      content: 'http://purl.org/rss/1.0/modules/content/'
    },
    customData: [
      LOCALE.lang ? `<language>${LOCALE.lang}</language>` : '',
      `<atom:link href="${new URL('/rss.xml', SITE.website).href}" rel="self" type="application/rss+xml" />`
    ]
      .filter(Boolean)
      .join('')
  });
}
```

Let's break down the code in this file to understand the important elements. First, `getCollection('blog')` loads every Markdown file entry from `src/content/blog` directory (latter is the directory where all the blog's content is stored in `.md` files).

```ts
const posts = await getCollection('blog');
```

Then, `getSortedPosts` sorts the posts by their publication date and hides any draft posts.

```ts
const sortedPosts = getSortedPosts(posts);
const items = await Promise.all(
  sortedPosts.map(async post => {
    const { data, slug } = post;
    // ...
  })
);
```

The `getSortedPosts` is a utility function that is used in other places in my blog. It filters the posts by their publication date:

```ts
import type { CollectionEntry } from 'astro:content';
import postFilter from './postFilter';

const getSortedPosts = (posts: CollectionEntry<'blog'>[]) => {
  return posts
    .filter(postFilter)
    .sort(
      (a, b) =>
        Math.floor(
          new Date(b.data.modDatetime ?? b.data.pubDatetime).getTime() / 1000
        ) -
        Math.floor(
          new Date(a.data.modDatetime ?? a.data.pubDatetime).getTime() / 1000
        )
    );
};

export default getSortedPosts;
```

The `render(post)` function renders the post's content into HTML so I can embed full articles in the feed.

```ts
const rendered = await render(post);
const html =
  typeof rendered === 'string' ? rendered : ((rendered as any).html ?? '');
```

The `extractDescription` is a unique case in my blog because not all posts have a description in the frontmatter. So, I decided to extract the first two lines from the Markdown files into the `extractDescription` function so that these two lines can act as a fair description of the post within the `rss.xml` content. If the `description` is present for a post, it will be used instead of the `extractedDescription`.

```ts
const extractDescription = (body?: string) => {
  if (!body) return '';

  const plainLines = body
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length && !line.startsWith('<!--'));

  const summary = plainLines.slice(0, 2).join(' ');

  return summary
    .replace(/!\[[^\]]*\]\([^)]*\)/g, '') // Strip images
    .replace(/\[(.*?)\]\([^)]*\)/g, '$1') // Strip links, keep text
    .replace(/[`*_>#~]/g, '') // Strip basic markdown symbols
    .replace(/\s+/g, ' ')
    .trim();
};

export async function GET() {
  // ...
  const description =
    data.description || extractDescription(post.body) || SITE.desc;
  // ...
}
```

The feed also declares both Atom and content module namespaces using `<atom:link>` and `<content:encoded>` tags.

## Wrap-up

Astro's `@astro/rss` plugin is really helpful for building RSS feeds for my blog, without over-complicating the setup. The result of this setup is a rich feed at [`https://amanhimself.dev/rss.xml`](https://amanhimself.dev/rss.xml).

You can find the full code for this setup in my blog's [RSS feed file](https://github.com/amandeepmittal/amanhimself.dev/blob/master/src/pages/rss.xml.ts).

---

## How to avoid notches with Safe Area Context in React Native apps
Slug: safe-area-context-in-react-native-apps

Most devices nowadays come with a notch or some kind of status bar. Therefore, when building a mobile application using React Native, it is vital to ensure that the content of an app screen is rendered correctly across different types of devices.

In this article, let's take a look at two different approaches to make app screens in React Native to avoid the content being positioned behind a notch or status bar.

The first approach will discuss `SafeAreaView` component from React Native components API. The second approach will discuss the advantage of using [react-native-safe-area-context](https://github.com/th3rdwave/react-native-safe-area-context#readme) open source library and how it provides a cross-platform solution.

## The Notch Problem

When you are starting to build a screen in React Native app, you might add use the following code snippet to display text:

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export const HomeScreen = () => {
  return (
    <View style={[styles.container]}>
      <View style={{ backgroundColor: 'blue' }}>
        <Text style={{ fontSize: 28, color: 'white' }}>Hello World</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'red'
  }
});
```

The above code snippet has a parent `View` component with a background color of `red`. It wraps another `View` component with a background color of `blue` that contains a `Text` component to display some text on the screen.

This will display the content of the app screen on an iOS device as shown below:

![ss1](https://i.imgur.com/Qfizjpr.png)

The contents of the nested `View` component hides behind the status bar and the notch on the iOS device.

On an Android device, the behavior is exactly the same:

![ss2](https://i.imgur.com/RY1tEfz.png)

## How to Use the SafeAreaView component from React Native

One approach is to use [SafeAreaView component](https://reactnative.dev/docs/safeareaview) available in React Native.

```js
import { SafeAreaView } from 'react-native';
```

It can be used in the place of the top-level `View` component. It renders content within the safe area boundaries around the nested content and automatically applies padding.

Modify the previous code snippet:

```js
import React from 'react';
import { StyleSheet, Text, View, SafeAreaView } from 'react-native';

export const HomeScreen = () => {
  return (
    <SafeAreaView style={[styles.container]}>
      <View style={{ backgroundColor: 'blue' }}>
        <Text style={{ fontSize: 28, color: 'white' }}>Hello World</Text>
      </View>
    </SafeAreaView>
  );
};
```

It works perfectly on iOS:

![ss3](https://i.imgur.com/Mve0Nhu.png)

In React Native, this component is only applicable to iOS devices with iOS version 11 or later. Unfortunately, that means it doesn't work for Android devices as the screen's content is still behind the status bar.

## How to Use React Native's Safe Area Context Library

To use a cross-platform solution to handle safe areas on notch devices, there is a library called [react-native-safe-area-context](https://github.com/th3rdwave/react-native-safe-area-context). It provides a flexible API to handle safe area insets in JS and works on iOS, Android, and Web.

Start by installing it in your React Native app:

```shell
# for plain React Native apps
yarn add react-native-safe-area-context

# install pod dependency for iOS only
npx pod-install

# for Expo apps
expo install react-native-safe-area-context
```

This library provides a `SafeAreaProvider` that needs to wrap either your Root Navigator or the screen where you want to handle safe area insets.

For example, in the code snippet below, the `SafeAreaProvider` wraps the `HomeScreen` component since there is only one screen in the example app.

```js
import React from 'react';
import { SafeAreaProvider } from 'react-native-safe-area-context';

import { HomeScreen } from './src/screens';

export default function App() {
  return (
    <SafeAreaProvider>
      <HomeScreen />
    </SafeAreaProvider>
  );
}
```

Now, you can import the `SafeAreaView` component from the `react-native-safe-area-context` library and replace it with the one from React Native.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';

export const HomeScreen = () => {
  return (
    <SafeAreaView style={[styles.container]}>
      <View style={{ backgroundColor: 'blue' }}>
        <Text style={{ fontSize: 28, color: 'white' }}>Hello World</Text>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'red'
  }
});
```

It works both for iOS and Android:

![ss4](https://i.imgur.com/lfOTL3J.png)

If you give the nested `View` component, a property of `flex: 1` as:

```js
<View style={{ backgroundColor: 'blue', flex: 1 }}>
```

You can observe the safe are edges for iOS:

![ss5](https://i.imgur.com/86uwW7N.png)

The `SafeAreaView` acts like a regular `View` component from React Native and includes additional padding to position the content after the notch or the status bar of a device.

It also comes with an `edges` prop that customizes safe area insets around different edges such as top, bottom, left, and right.

## How to Use the useSafeAreaInsets Hook

Another advantage of using this library is that it provides a hook called `useSafeAreaInsets`. It offers more flexibility. It also gives more control, and you can apply padding for each edge using a property from this hook. For example, a `View` component below uses only wants the padding to be applied at the top edge:

```js
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export const HomeScreen = () => {
  const insets = useSafeAreaInsets();

  return (
    <View
      style={{
        paddingTop: insets.top
      }}
    >
      {children}
    </View>
  );
};
```

## Conclusion

Handling status bars and notches across different devices become seamless with the [react-native-safe-area-context](https://github.com/th3rdwave/react-native-safe-area-context#readme) library. Try it out in your next React Native app.

_[Source code at this GitHub repository](https://github.com/amandeepmittal/react-native-examples/tree/master/rnSplashAndIconExample)_

_This post was also published at [freeCodeCamp](https://www.freecodecamp.org/news/how-to-use-safe-area-context-to-avoid-notches-in-react-native-apps/)._

---

## Set default location for images, files and attachments in Obsidian
Slug: set-default-folder-for-images-files-and-attachments-in-obsidian

I've used Obsidian as my primary note-taking app for over six months. One thing I've found myself often doing (either work or personal) is using screenshots as images in my notes.

Now, if you have used Obsidian or started using it, all images or attachments are stored in the root vault folder. If you are fine with it, you can skip reading this article and spend your time on something more useful. However, if you are like me, and want to stick to using a note-taking app and keep things organized, then keep reading.
I organize my notes into two top-level folders:

I organize my notes into two top level folders:

- `Areas`: Notes on stuff related to my personal life, books I read, and things I'm learning.
- `Inbox`: Notes on work, meetings, people, and the articles I'm working on.

I wanted a separate folder for images and attachments that could serve both folders and keep things organized in the vault. In Obsidian, it's doable by changing one setting:

- Click **Settings** in the Obsidian desktop app and in the Settings menu, click **Files & Links**.
- In the **Default location for new attachments**, in the dropdown, select **In the folder specified below**.
- In the **Attachment folder path**, choose the path of the folder you want to save all images and other files.

![ss1](https://i.imgur.com/D2AyGqt.png)

---

## Gatsby.js: How to set up and use the React Static Site Generator
Slug: setting-up-and-getting-used-to-gatsby

[Gatsby](https://www.gatsbyjs.org/) is a static site generator for React that released its first major version last month. Itâ€™s a tool that not only scaffolds projects (or websites) for you but claims that those sites are fast in performance. If you decide to use Gatsby you will be enjoying the power of the latest web technologies such as React.js, Webpack, and so on.

There are a lot of modern paradigms that Gatsby takes care for its developer behind the scenes to start building and launch their project. Another cool thing about Gatsby that I like is its ever-growing data plugin ecosystem. It lets a developer fetch data directly into a Gatsby generated application using GraphQL.

Here are some of the advantages of using Gatsby:

- HTML code is generated server side
- Easily extensible by plugin ecosystem
- Pre-configured Webpack based build system (no need to break your head)
- Optimized for speed. Gatsby loads only critical parts, so that your site loads as fast as possible. Once loaded, Gatsby pre-fetches resources for other pages so that clicking on the site feels incredibly fast.
- Automatic routing based on your directory structure. (no need for separate routing/navigation library)

If you know the nitty-gritty of React, you can definitely get started with Gatsbyjs in no time by reading this tutorial. I am not asking you to be advanced with React but only the familiar with its concepts. If you like to refresh your knowledge on the same or learn more about it, I recommend following links:

- [Facebookâ€™s Official](https://reactjs.org/)
- [React Express (not the server Express.js)](http://www.react.express/)

Enough with the introduction. Letâ€™s get started.

### Installing GatsbyÂ CLI

We will be using `npm` to install our first and basic tool that we need to setup any Gatsby project. You can use `yarn` too. In your terminal, please execute this command:

```shell
npm install --global gatsby-cli
```

You might need to add `sudo` at the start of the command if it gives an error for permissions.

To start a new site, go to your desired project directly. Select a place on your system where you might be storing all the playground or applications in their initial stage and then in terminal:

```shell
gatsby new first-gatsby-site
```

You can name your project anything you like, I named that just for the brevity.

<img src='https://cdn-images-1.medium.com/max/800/0*D0A60lp-sDgjvHi1.png' />

Finish the installation and set up of the project. Then change the directory into the newly created folder. Run `gatsby develop` from the command line to see your site running live at http://localhost:8000.

<img src='https://cdn-images-1.medium.com/max/800/0*jAK-XXvfqorbpKcv.png' />

In your browser window, the default Gatsby.js application looks like this:

<img src='https://cdn-images-1.medium.com/max/800/0*_ajd3MY423FW8PO6.png' />

Leave the command running since it enables Hot Reloading. Now any change we make to our project will be reflected directly, without refreshing the page.

Currently, our application contains two pages. Hence, the bare minimum routing is already done for us. Before diving into the code and making any amendments to it, we need to understand the project structure. Then you can make use of it by manipulating it in your future projects.

### Diving deep in the Project Structure

<img src='https://cdn-images-1.medium.com/max/800/0*9eiAcl39nN1Uj08q.png' />

Every Gatsby project contains at least these files. You might be familiar with some such as `node_modules,` `public` directory, which is served when deployed. It also contains `package.json,` which contains the metadata of any modern Javascript application.

Our main focus and concern are in the directory `src` and file `gatsby-config.js.`These contain the metadata and other essential information about our current application.

Inside the `src/` there are two sub-directories: `layouts/` and `pages/`.

The `layouts/` contain further two files: `index.css` and `index.js`. These serve as the starting point of our application.

```js
import React from 'react';
import PropTypes from 'prop-types';
import Link from 'gatsby-link';
import Helmet from 'react-helmet';

import './index.css';

const Header = () => (
  <div
    style={{
      background: 'rebeccapurple',
      marginBottom: '1.45rem'
    }}
  >
    <div
      style={{
        margin: '0 auto',
        maxWidth: 960,
        padding: '1.45rem 1.0875rem'
      }}
    >
      <h1 style={{ margin: 0 }}>
        <Link
          to="/"
          style={{
            color: 'white',
            textDecoration: 'none'
          }}
        >
          Gatsby
        </Link>
      </h1>
    </div>
  </div>
);

const TemplateWrapper = ({ children }) => (
  <div>
    <Helmet
      title="My First Gatsby Site"
      meta={[
        { name: 'author', content: 'amanhimself' },
        { name: 'keywords', content: 'sample, something' }
      ]}
    />
    <Header />
    <div
      style={{
        margin: '0 auto',
        maxWidth: 960,
        padding: '0px 1.0875rem 1.45rem',
        paddingTop: 0
      }}
    >
      {children()}
    </div>
  </div>
);

TemplateWrapper.propTypes = {
  children: PropTypes.func
};

export default TemplateWrapper;
```

The `Header` component contains the styles and markup that is currently serving as the header of our application. It is reflected on every page by `TempplateWrapper` which is our main layout component in the application. This certainly means that this component can be used for displaying navigation menu (which we are going to do in a while) or a footer.

The `Link` tag you are seeing is the way Gatsby let our visitors navigate from one page to another. The `react-helmet` library that serves the purpose of attaching header information in HTML. It is being currently generated by the JSX. You can read about this useful, beginner friendly library on its [official doc here](https://github.com/nfl/react-helmet).

Do notice the `{children()}` prop. This is a function that executes within the JSX code to determine the exact location for the child components to render.

### Main Application Page

Our second concerned directory `pages/` contain rest of the pages that build up our application. They are plain React components. Let's take a look at the `index.js` file inside this directory which currently serves as the main page of our application.

```js
import React from 'react';
import Link from 'gatsby-link';

const IndexPage = () => (
  <div>
    <h1>Hi people</h1>
    <p>Welcome to your new Gatsby site.</p>
    <p>Now go build something great.</p>
    <Link to="/page-2/">Go to page 2</Link>
  </div>
);

export default IndexPage;
```

Similarly, you will find the code in `page-2.js`. If in our browser window, we try to navigate to the second page, notice the URL of the site when the second page loads.

<img src='https://cdn-images-1.medium.com/max/800/0*6-NTcYa0m_ZMiJmx.png' />

It is same as the file name. We are also using `Link` tag from Gatsby to navigate back to the homepage.

Letâ€™s add another page to our site. Inside the `pages` directory, create a new file `page-3.js`.

```js
import React from 'react';
import Link from 'gatsby-link';

const ThirdPage = () => (
  <div>
    <h1>Third Page</h1>
    <p>This is my first Gtasby site</p>
    <Link to="/page-2/">Back to Page 2</Link>
    <br />
    <Link to="/">Go back to the homepage</Link>
  </div>
);

export default ThirdPage;
```

Now letâ€™s add the link to our new page to the homepage. Open `index.js` file:

```js
import React from 'react';
import Link from 'gatsby-link';

const IndexPage = () => (
  <div>
    <h1>Hi people</h1>
    <p>Welcome to your new Gatsby site.</p>
    <p>Now go build something great.</p>
    <Link to="/page-2/">Go to page 2</Link>
    <br />
    <Link to="/page-3">New Page!</Link>
  </div>
);

export default IndexPage;
```

<img src='https://cdn-images-1.medium.com/max/800/0*y_FCYqu-Zne_IfXH.png' />

This renders correctly on our page. Do notice the `404.js` file in the directory. This file is rendered when no desired URL is found. More info can be read in [official Gatsby docs](https://www.gatsbyjs.org/docs/add-404-page/).

Now to make things a bit more interesting. Letâ€™s add a navigation menu in the `Header` component of our layout.

### Adding Navigation Menu

Open `layouts/index.js` and inside the `Header` component, add the following code:

```js
const Header = () => (
  <div
    style={{
      background: 'rebeccapurple',
      marginBottom: '1.45rem'
    }}
  >
    <div
      style={{
        margin: '0 auto',
        maxWidth: 960,
        padding: '1.45rem 1.0875rem'
      }}
    >
      <h1 style={{ margin: 0 }}>
        <Link
          to="/"
          style={{
            color: 'white',
            textDecoration: 'none'
          }}
        >
          Gatsby
        </Link>
        <ul style={{ listStyle: 'none', float: 'right' }}>
          <li style={{ display: 'inline-block', marginRight: '1rem' }}>
            <Link
              style={{
                color: 'white',
                textDecoration: 'none',
                fontSize: 'x-large'
              }}
              to="/"
            >
              Home
            </Link>
          </li>
          <li style={{ display: 'inline-block', marginRight: '1rem' }}>
            <Link
              style={{
                color: 'white',
                textDecoration: 'none',
                fontSize: 'x-large'
              }}
              to="/page-2"
            >
              Page 2
            </Link>
          </li>
          <li style={{ display: 'inline-block', marginRight: '1rem' }}>
            <Link
              style={{
                color: 'white',
                textDecoration: 'none',
                fontSize: 'x-large'
              }}
              to="/page-3"
            >
              Page 3
            </Link>
          </li>
        </ul>
      </h1>
    </div>
  </div>
);
```

If you save the file, the results are reflected immediately on the homepage and on every page.

<img src='https://cdn-images-1.medium.com/max/800/0*0ZgP3U6tQtz1rIyz.png' />

### Configuration File

```js
module.exports = {
  siteMetadata: {
    title: `Gatsby Default Starter`
  },
  plugins: [`gatsby-plugin-react-helmet`]
};
```

The last important file of our concern is `gatsby-config.js` in the root folder. This file can contain site's metadata and additional information such plugins that we install using `npm` command. However, their scope of usage and concern are only with a project generated using Gatsby CLI. By default the plugin `gatsby-plugin-react-helmet` is installed.

A complete list of plugins is listed [here](https://www.gatsbyjs.org/docs/plugins/).

### Deployment of our StaticÂ site

So far we have come out with a bare minimum static site that serves the purpose of this walk-through. The last step that I want to focus is on deployment. I will be using GitHub Pages for deployment.

To deploy a project on GitHub pages make sure your current working directory is initialized as a git repository and hosted on GitHub. If that is good, let us add a module called `gh-pages` as a dev dependency.

```shell
npm install --save-dev gh-pages
```

Add a deployment script in `package.json`:

```json
"scripts": {
  "deploy": "gatsby build --prefix-paths && gh-pages -d public",
}
```

In `gatsby.config.js` add the pathname prefix of the repo such:

```js
module.exports = {
  siteMetadata: {
    title: `Gatsby Default Starter`
  },
  pathPrefix: `/first-gatsby-site`,
  plugins: [`gatsby-plugin-react-helmet`]
};
```

See [official docs](https://www.gatsbyjs.org/docs/path-prefix/) on path prefixing.

Now from your terminal run:

```shell
npm run deploy
```

**Great!** Your site is now live on `[https://username.github.io/project-name/](https://username.github.io/project-name/.)`[.](https://username.github.io/project-name/.)

You can find the complete code of this project at this [GitHub Repo](https://github.com/amandeepmittal/first-gatsby-site)

[Originally Published at freeCodeCamp.com](https://medium.com/free-code-camp/setting-up-and-getting-used-to-gatsby-1fc27985ae8a)

---

## Setting up MEAN Stack with Webstorm
Slug: setting-up-mean-stack-with-webstorm

Ever since I got interested in Node.js and started learning to program in JavaScript, both the programming language and the server side platform have been most relevant to me. Due them, I have made my first PR to an open source project on Github, heck, I even built one of my own using them (_see_ [_#100DaysOfCode_](https://github.com/freeCodeCamp/100DaysOfCode-twitter-bot)) which currently has more than 6 people actively contributing and enhancing it.

With Node.js, from quickly building server side application to build fullstack application is not much of a hassle. There are two important solutions to this:

- MEAN Stack
- Meteor.js

### MEAN Stack

MEAN Stack is the used to create complete web development solutions. With JavaScript itâ€™s base, it has lot of advantages to offer and the important of all is one programming language both on server and client side. No context switching. A perfect fullstack solution for me personally.

MEAN is an acronym for MongoDB, ExpressJS, AngularJS, and Node.js. So instead of learning four different programming languages, you just need to know JavaScript.

### Setup MEAN Stack inÂ Webstorm

I am sharing a video here which shows on how to get started with MEAN using JetBrainâ€™s Webstorm (_A JavaScript IDE_) by [John Lindquist](https://www.youtube.com/watch?feature=player_embedded&v=JnMvok0Yks8).

---

## Setting up Nodejs Backend for a React App
Slug: setting-up-nodejs-backend-for-a-react-app

In this article, I am going to walk you through setting up your own [Node.js](http://crowdbotics.com/build/node-js) backend server for a [React application](https://crowdbotics.com/build/react). Both frameworks are often used together to build real time, fullstack web applications. A database, such as MySQL, Postgresql, or a NoSQL database such as MongoDB, is used to store information. For brevityâ€™s sake, I will not use a database in this walkthrough.

_Requirements:_ You need Node.js and npm installed on your local machine as well as `create-react-app` installed as a global dependency. If you do not have it, run the following command and install it.

```shell
npm install -g create-react-app
```

_In some cases, you might have to give root permissions when installing a global dependency._

For the Nodejs backend, I am going to use [**HapiJS**](https://hapijs.com/). If you are not familiar with it, it will be fun as you will be learning a lot of new things.

### Getting Started with theÂ Backend

To start, we need an empty directory inside which we can have our server and client live alongside each other. Initialize it by running the command `npm init` and you are ready to install Hapijs as a framework to build the web server.

```shell
npm install hapi --save
```

After Express, Hapi is quite popular among teams and individuals who write the server side of their application using Node. Hapi is currently being used by organizations such as Walmart and Yahoo and has an active community. After the dependency is successfully installed, create a new file called `server.js`.

```js
'use strict';

const Hapi = require('hapi');

// Create a server with a host and port
const server = Hapi.server({
  host: 'localhost',
  port: 8000
});

// Add the route
server.route({
  method: 'GET',
  path: '/',
  handler: (request, h) => {
    return 'hello world';
  }
});

// Start the server
async function start() {
  try {
    await server.start();
  } catch (err) {
    console.log(err);
    process.exit(1);
  }

  console.log('Server running at:', server.info.uri);
}

start();
```

This is the most basic server you can create using Hapi.

We start as usual by requiring Hapijs dependency and create a new object with a configuration of our own. See the `host` and `port` above.

After that, we add a simple route that uses HTTP method `GET` and has a handler function or usually called a callback function to return the response back to the client when a request comes in. Lastly, we are creating an asynchronous function to bootstrap the server using `async/await` syntax.

The `async/await` requires you to add a `try/catch` block every time you want to catch the errors. We `console.log` in case any error occurs running the program and use Nodejs global `process` object to make sure that program exits gracefully in case of one. To see it in action, run `node server.js` and it will eventually run on port `8000`.

<img src='https://cdn-images-1.medium.com/max/800/1*yR_UcIKCzTeNoN9HPYCNdQ.png' />

### Setting up a ReactÂ app

Now that we have built our server, let us create the front end of our application. We have already installed the main ingredient we need to start with. Open your terminal and type:

```shell
create-react-app client
```

This will create a react application named `client` inside the folder where we previously built our server. Simple as that.

Now you can traverse to the `client` directory and run the React app separately on a different port. However, this is not what we want.

### The proxy

We want a setup that will make our React app and use the server URL as a global variable. This is easier than you might think.

Navigate to client directory and locate `package.json` file. Add the following configuration to it.

<img src='https://cdn-images-1.medium.com/max/800/1*jEgu48E180zXD0Z3_NyuHA.png' />

And thatâ€™s it. This is all you need to do. _But wait! How is this even possible?_ The answer lies with the `create-react-app`.

`create-react-app` does all this automatically and behind the scene because it is using [_webpack_](https://webpack.js.org/).

Webpack has a development server that uses a proxy to handle the API server or in other terms, it requests to our Hapi server running on port `8000`. This is one of the biggest advantages I have found for using create-react-app so far. Webpack handles all the configuration.

### Conclusion: Running theÂ app

Let us now test a route that sends the data from the Hapi backend server to React front-end side whenever a request comes from the client. Create a route /`mock`in `server.js` to serve the data the dummy data defined as an array `data` itself.

```js
'use strict';

const Hapi = require('hapi');

// mock data

const data = [
  { id: 1, name: 'Alex', age: 21 },
  { id: 2, name: 'Alice', age: 23 }
];

// Create a server with a host and port
const server = Hapi.server({
  host: 'localhost',
  port: 8000
});

// Add the route
server.route({
  method: 'GET',
  path: '/',
  handler: (request, h) => {
    return 'hello world';
  }
});

server.route({
  method: 'GET',
  path: '/mock',
  handler: (request, h) => {
    return { data };
  }
});

// Start the server
async function start() {
  try {
    await server.start();
  } catch (err) {
    console.log(err);
    process.exit(1);
  }

  console.log('Server running at:', server.info.uri);
}

start();
```

To test this route, let us use REST client like POSTMAN or Insomnia and see if the data is being requested at the route `/mock`.

<img src='https://cdn-images-1.medium.com/max/1200/1*ygiAUjIzThy-NHFfbi9Rsg.png' />

Now let us display this data in our front end. Traverse to `client/App.js` file and do the following.

```js
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  state = {
    data: []
  };

  componentDidMount() {
    this.fetchData()
      .then(res => this.setState(res))
      .catch(err => console.log(err));
  }

  fetchData = async () => {
    const response = await fetch('/mock');
    const body = response.json();

    return body;
  };

  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1>Data from the Backend</h1>
          {this.state.data.map(person => (
            <p key={person.id}>
              Name: {person.name} <br /> Age: {person.age}
            </p>
          ))}
        </header>
      </div>
    );
  }
}

export default App;
```

We start by defining a local state that will contain the data coming from the backend inside `componentDidMount()` life-cycle hook method. This further calls the asynchronous method`fetchData()` that actually requests the data from the API url `/mock`. Since we have already defined the complete URL as `proxy` we do not have to write the complete url.

Finally, we are able to see the data as below.

<img src='https://cdn-images-1.medium.com/max/1200/1*79TNeMIHMbzT1Vcnh7ZNZw.png' />

_You can find the complete source code for the above article at_ [**_Github Repo_**](https://github.com/amandeepmittal/hapi-react-example)

_[Originally published at Crowdbotics](https://medium.com/crowdbotics/setting-up-nodejs-backend-for-a-react-app-fe2219f26ea4)_

---

## Setup Macbook M1 for Web and React Native development
Slug: setup-macbook-m1

> **Note**: A new version of this post was written in 2024. See [My 2024 Macbook setup](/blog/macbook-setup-2024/) for more information.

> ðŸ•‘ This article was originally written on March 14, 2021. Since then, it has been updated many times to reflect my setup process. In 2023, I decided to re-write this article from scratch.

![cover_image](https://i.imgur.com/tAJjTOU.png)

It's 2023, and I am still coming back to this article. I wrote this originally in 2021 to keep track of what I need to start when setting up a new laptop. Since then, I have had two Macbook Pros using an Apple Silicon processor (M1). I try to keep this article up to date.

I believe small optimizations help you go faster in the long run. Also, a flavor of personalization makes my developer experience more enjoyable. I like to keep two separate setups, one for work and the other for personal use and fun. However, often I end up switching between both. Having the same set of tools and configurations helps me just be me. It also helps me keep my setup portable and up-to-date (have had those days where I lost everything).

## 1: Install Xcode and Command Line Tools

To get started, open the App Store on the Mac and install [Xcode](https://apps.apple.com/in/app/xcode/id497799835?mt=12). It's a large download, so it might take a while.

Once installed, open the Terminal app on the Mac and run:

```shell
xcode-select --install && sudo xcodebuild -license
```

#### 1.1: Verify Command Line Tools installation

After installing Xcode and command line tools, open the app. Then, from the menu bar, open **Xcode > Preferences > Locations** and make sure that **Command Line Tools** point towards the current Xcode app.

![ss3](https://i.imgur.com/ZXS88QM.png)

## 2: Install Warp terminal

> Previously, I've used iTerm2 as y default terminal app over the years. Find more info about iterm2 in the Alternate tools section at the end of this post.

I recently started using [Warp](https://warp.dev) as my first choice for a terminal app on Mac. After downloading the app, start the app:

- Go to **Appearance**
- Set theme to Dracula
- Window Opacity: 95
- Window Blur Radius: 17

### 2.1: Install Oh My Zsh

[ZSH](https://github.com/zsh-users/zsh) is the default shell in macOS. However, I like to use [Oh My Zsh](https://ohmyz.sh/) to manage the ZSH configuration, plugins, and a theme to prettify the terminal (especially when using iterm2 previously).

To install, run the command below:

```shell
sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
```

After installation, make sure that the file `.zshrc` is exporting the below path at the top:

```shell
# Path to your oh-my-zsh installation
export ZSH="$HOME/.oh-my-zsh"
```

The `$HOME` should be `/Users/<your-macos-username>`. You can verify this by running:

```shell
echo $HOME
```

### 2.2: Install syntax highlighting plugin

The first I like to do after setting up the bare minimum ZSH configuration is to install a plugin called [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md). It provides syntax highlighting for the ZSH shell. Execute the series below commands in the terminal window:

```shell
# depending on the /plugins folder in your local setup
cd $HOME/.oh-my-zsh/plugins

# then clone the git repository
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git

echo "source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" >> ${ZDOTDIR:-$HOME}/.zshrc
```

On iterm2, after installing the syntax highlight plugin, it starts to recognize the commands:

![ss4](https://i.imgur.com/UxRzm98.png)

### Only for iterm2: Install a theme

The next step is to install [spaceship-prompt](https://github.com/spaceship-prompt/spaceship-prompt) theme. Follow the steps described in [oh-my-sh](https://github.com/spaceship-prompt/spaceship-prompt#oh-my-zsh) section.

### Final ZSH configuration

This is [my final ZSH configuration](https://github.com/amandeepmittal/dotfiles/blob/master/.zshrc) in the file `~/.zshrc` file:

```shell
# Path to your oh-my-zsh installation
export ZSH="/Users/amanhimself/.oh-my-zsh"

export PATH=/opt/homebrew/bin:$PATH

export ANDROID_HOME=$HOME/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/tools/bin
export PATH=$PATH:$ANDROID_HOME/platform-tools

# ZSH_THEME="spaceship"

# Uncomment the following line to disable bi-weekly auto-update checks.
DISABLE_AUTO_UPDATE="true"

plugins=(
  git
  node
  vscode
  zsh-syntax-highlighting
)

source $ZSH/oh-my-zsh.sh
source /Users/amanhimself/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
```

## 3: Change system settings

System preferences and settings that I prefer. These settings are available in the Systems Settings:

- **Siri**:
  - Disable Ask Siri
- **Desktop & Dock**:
  - Enable "Automatically hide and show the Dock"
  - Set "Automatically hide and show the menu bar in full screen" to "In Full Screen Only"
  - Set Recent documents, applications and servers to "None"
  - Size: 30%
  - Magnification: 45%-50%
- **Trackpad**:
  - Point & click
    - Enable secondary click with the bottom right corner
    - Enable Tap to click with one finger
    - Tracking speed: 90%
    - Click: Medium
    - Force click and haptic feedback: Disable
    - Look up & data detectors: Disable
  - Scroll & zoom
    - Natural scrolling: Disable
  - More Gestures
    - Swipe between pages: Off
- **Spotlight**:
  - Disable search except for Applications, Calculator, Conversion, Developer, Definition, and System Settings.
- **Finder settings**:
  - Advanced > Show filename extensions
  - Enable showing hidden files (hold Cmd + Shift dot(`.`) in a Finder window)
  - Enable: View -> Show Path Bar, Show Status Bar
- **Lock Screen**:
  - Start screen saver when inactive: 1 hour
  - Turn display off on battery when inactive: For 3 hours
  - Turn display off on power adapter when inactive: For 3 hours

## 4: Install homebrew

On December 1, 2020, the Homebrew team announced on their [website](https://brew.sh/2020/12/01/homebrew-2.6.0/) about the version release `2.6.0`. The most significant changes they listed were:

- The support for macOS Big Sur.
- Using `brew` commands instead of `brew cask`.
- Beginning to support macOS M1 and Apple Silicon or ARM-based chips.

Using the terminal, you can install the Homebrew by executing the default command:

```shell
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

## 5: Install Git

To install Git, run the command:

```shell
brew install git
```

To authenticate GitHub to be used from the terminal environment, I recommend you check out the [official document](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token) on creating and accessing personal tokens.

> _ðŸ”¥ Tip:_ As of Git version `2.28`, there is a new config option to set the default branch to `main`. Set it globally and forget about it.

```shell
git config --global init.defaultBranch main
```

To enable colors in the output, run the command:

```shell
git config --global color.ui auto
```

## 6: Install homebrew packages

- Node.js and npm via Node Version Manager (NVM). [Read the entire blog post on how to install Node.js using NVM](https://amanhimself.dev/blog/install-nodejs-using-nvm-on-macos-m1/).

Run the following script to install other packages from homebrew:

```shell
brew install yarn
brew install scrcpy
brew install watchman
brew install exa
brew install imageoptim
```

Some highlights from the above script:

- [Watchman](https://facebook.github.io/watchman/) to watch changes in the filesystem.
- [scrcpy](https://github.com/Genymobile/scrcpy) (control Android devices connect via USB on Mac)
- [exa](https://github.com/ogham/exa#readme) a modern replacement for `ls`.
- [imageoptim](https://imageoptim.com/mac) for compressing image files. See [ImageOptim Settings](#imageoptim-settings) for how to set it up.

## 7: After installing Node.js

Node.js comes with the default package manager `npm`. Set defaults for it:

```shell
npm config set init-author-name "your name"
npm config set init-author-url "example.com"
npm config set init-license MIT
```

### 8: Install global npm packages

- [eas-cli](https://www.npmjs.com/package/eas-cli) For work and personal use:

```shell
npm i -g eas-cli
```

Also, I use the following command to update global packages:

```shell
npx npm-check -gu
```

## 9: VS Code

VS Code and VS Code Insiders are currently supported on ARM chips (March 13, 2021). Download the installer for Insiders edition from [here](https://code.visualstudio.com/insiders/) and for VS Code [here](https://code.visualstudio.com/download).

![ss5](https://i.imgur.com/Yd4wQ10.png)

I am using the following VS Code configuration:

```json
{
  "workbench.startupEditor": "welcomePage",
  "workbench.iconTheme": "material-icon-theme",
  "workbench.editor.tabSizing": "shrink",
  "security.workspace.trust.untrustedFiles": "open",
  "explorer.confirmDelete": false,
  "explorer.confirmDragAndDrop": false,
  "workbench.editor.enablePreview": false,
  "window.restoreFullscreen": true,
  "editor.tabSize": 2,
  "editor.fontSize": 13.5,
  "editor.minimap.enabled": false,
  "editor.cursorBlinking": "phase",
  "editor.fontLigatures": false,
  "editor.wordWrap": "on",
  "editor.cursorSmoothCaretAnimation": "on",
  "editor.tabCompletion": "on",
  "editor.formatOnPaste": true,
  "editor.formatOnSave": true,
  "editor.semanticHighlighting.enabled": true,
  "editor.guides.bracketPairs": true,
  "explorer.openEditors.visible": 0,
  "files.trimTrailingWhitespace": true,
  "search.exclude": {
    "**/node_modules": true,
    "**/*.code-search": true,
    "dist/": true,
    "yarn.lock": true,
    "package-lock.json": true,
    ".gitignore": true,
    ".expo": true,
    ".vscode": true
  },
  "extensions.autoUpdate": false,
  // --------------------------------------
  // --------------------------------------
  // CODE::STATS EXTENSION
  // --------------------------------------
  // READ TIME EXTENSION
  "readTime.enabled": true,
  // --------------------------------------
  // HIGHLIGHT MATCHING TAG EXTENSION
  "highlight-matching-tag.styles": {
    "opening": {
      "name": {
        // surround is border
        "surround": "yellow"
      }
    }
  },
  // --------------------------------------
  // INTEGRATED TERMINAL
  "terminal.external.osxExec": "iTerm.app",
  // "terminal.external.osxExec": "warp.app",
  "terminal.integrated.fontSize": 12,
  // --------------------------------------
  // NPM
  "npm-intellisense.importES6": true,
  // --------------------------------------
  // TS IMPORT SUGGESTION
  "typescript.suggest.paths": false,
  // --------------------------------------
  // NATIVE BRACKET PAIR COLOR SETTINGS
  "editor.bracketPairColorization.enabled": true,
  "workbench.colorCustomizations": {
    "editorBracketHighlight.foreground1": "#ffb86c",
    "editorBracketHighlight.unexpectedBracket.foreground": "#ff5555",
    "[morgan.codes]": {
      "gitDecoration.ignoredResourceForeground": "#434343"
    },
    "[Expo Dark]": {
      // "activityBar.background": "#635985",
      "activityBarBadge.background": "#fc4384",
      "activityBarBadge.foreground": "#ffffff",
      // "activityBar.activeBackground": "#bd93f9",
      "activityBar.activeBorder": "#fc4384",
      "gitDecoration.ignoredResourceForeground": "#434343",
      "statusBar.background": "#fc4384",
      "statusBar.noFolderBackground": "#fc4384",
      // Gutter
      "editorGutter.deletedBackground": "#ff0055",
      "editorGutter.addedBackground": "#fc4384",
      "editorGutter.modifiedBackground": "#9765c9",

      // Selection and matches
      "editor.selectionHighlightBorder": "#e18cc9",
      "editor.selectionHighlightBackground": "#635985",
      "editor.selectionForeground": "#eff8ff",
      "editor.findMatchHighlightBackground": "#ff2b7c8e",
      "editor.hoverHighlightBackground": "#ff000013",
      "editor.lineHighlightBackground": "#2b2b2b50",
      "editor.lineHighlightBorder": "#00000000",
      "editorOverviewRuler.bracketMatchForeground": "#635985"
    }
  },
  // --------------------------------------
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  // Markdown
  "[markdown]": {
    "editor.quickSuggestions": {
      "comments": "on",
      "strings": "on",
      "other": "on"
    }
  },
  // JSON
  "[json]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // JavaScript
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // JavaScript + React
  "[javascriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // TypeScript
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // TypeScript + React
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // JSON with Comments
  "[jsonc]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // HTML
  "[html]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  // ----------------------------------
  // ESLINT
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  // --------------------------------------
  // ERROR LENS
  // "errorLens.fontSize": "11",
  // "errorLens.onSave": true,
  // "errorLens.enabledDiagnosticLevels": ["error", "warning", "hint"],
  // "workbench.colorCustomizations": {
  //   "errorLens.hintForeground": "#ffc600A1",
  //   "errorLens.hintBackground": "#ff00dd2f",
  //   "errorLens.errorBackground": "#ff000005",
  //   "editor.selectionBackground": "#ff1493",
  //   "editor.selectionHighlightBackground": "#ff1493",
  //   "editor.findMatchBackground": "#ff1493",
  //   "editor.findMatchHighlightBackground": "#3cb371"
  // },
  // "errorLens.exclude": ["never (read|used)"],
  // --------------------------------------
  // LANGUAGES SPECIFIC
  "javascript.updateImportsOnFileMove.enabled": "always",
  "security.workspace.trust.banner": "never",
  "emmet.includeLanguages": {
    "typescript": "typescriptreact",
    "javascript": "javascriptreact"
  },
  "cSpell.userWords": [
    "Appbar",
    "asyncstorage",
    "backgrounded",
    "backoff",
    "Cacheable",
    "cancelation",
    "Chakra",
    "concurrencies",
    "Contentful",
    "Ecommerce",
    "Entypo",
    "Firestore",
    "Grammarly",
    "Ionicons",
    "launchable",
    "nocheck",
    "Parens",
    "Podfile",
    "prefetch",
    "Pressable",
    "Transifex",
    "Turborepo",
    "undeployed",
    "Vercel",
    "vercelians",
    "yantramanav",
    "zustand"
  ],
  "git.autofetch": true,
  "cSpell.language": "en,en-US",
  "cSpell.enableFiletypes": ["markdown", "mdx"],
  "editor.inlineSuggest.enabled": true,
  "github.copilot.enable": {
    "*": true,
    "yaml": true,
    "plaintext": true,
    "markdown": true
  },
  "workbench.colorTheme": "Expo Light",
  "window.commandCenter": true,
  "customizeUI.fontSizeMap": {
    "13px": "12px",
    "12px": "11px",
    "window-title": "12px", // Window title font when using custom titlebar
    "tab-title": "12px", // Used for editor tab titles
    "monospace": "11px" // Used for monospace fonts in user interface
  },
  "react-native-tools.showUserTips": false,
  "errorLens.fontSize": "12",
  "grammarly.files.include": [
    "**/README.md",
    "**/readme.md",
    "**/*.txt",
    "**/*.md",
    "**/*.mdx"
  ],
  "css.lint.unknownAtRules": "ignore",
  "workbench.editorAssociations": {
    "*.js": "default"
  },
  "githubPullRequests.pullBranch": "never"
```

### VS Code themes

I usually like to switch between a dark and a light theme.

For a light theme, I prefer:

- Quiet Light (built-in)
- [Expo Light](https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-theme) (based on [Expo Docs](https://docs.expo.dev/))

For the dark theme where I spent most of my time with fairyFloss.

- [fairyFloss](https://marketplace.visualstudio.com/items?itemName=nopjmp.fairyfloss)
- [Expo Dark theme](https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-theme) (based on [Expo Docs](https://docs.expo.dev/))

For file icons, I love [Material-Icon-Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme).

### VS Code extensions

- [Auto Close tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag)
- [Auto Complete Tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-complete-tag)
- [Auto Rename Tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag)
- [Babel JavaScript](https://marketplace.visualstudio.com/items?itemName=mgmcdermott.vscode-language-babel)
- ~~Bracket Pair Colorizer 2~~: VSCode now supports this natively. See [How to configure VSCode Bracket Pair Colors Natively](https://amanhimself.dev/blog/how-to-configure-vscode-bracket-colors-natively/)
- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)
- [Code::Stats](https://codestats.net/)
- [Color Highlight](https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight)
- [Customize UI](https://marketplace.visualstudio.com/items?itemName=iocave.customize-ui)
- [DotENV](https://marketplace.visualstudio.com/items?itemName=mikestead.dotenv)
- [Error Lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens)
- [ESLint](https://eslint.org/)
- [Expo Tools](https://marketplace.visualstudio.com/items?itemName=byCedric.vscode-expo)
- [GitHub Copilot](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot)
- [GitHub Pull Requests and Issues](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github)
- [Grammarly](https://marketplace.visualstudio.com/items?itemName=znck.grammarly)
- [Highlight Matching Tag](https://marketplace.visualstudio.com/items?itemName=vincaslt.highlight-matching-tag)
- [Indent rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow)
- [iOS common files](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-ios-common-files)
- [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)
- [MDX](https://marketplace.visualstudio.com/items?itemName=silvenon.mdx) - For syntax highlighting of `.mdx` files
- [npm intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense)
- [Prettier](https://prettier.io/)
- [Paste JSON as code](https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype)
- [React Native Tools](https://marketplace.visualstudio.com/items?itemName=msjsdiag.vscode-react-native)
- [Read Time](https://marketplace.visualstudio.com/items?itemName=johnpapa.read-time)
- [TODO Highlight](https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight)
- [Version Lens](https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens)
- [WakaTime](https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime)
- [Word Count](https://marketplace.visualstudio.com/items?itemName=ms-vscode.wordcount)

## Apps

### 10: Download browsers

- [Arc Browser](https://arc.net/)
- [Google Chrome](https://www.google.com/chrome/?brand=YTUH&gclid=EAIaIQobChMI9vmFxpL0-AIVDJ1LBR11UATAEAAYASAAEgJBQPD_BwE&gclsrc=aw.ds) Login to work and personal Gmail.
- [Brave Browser](https://brave.com/download/).

Use Safari for personal email.

### Other apps on my macOS

- Android Studio
- [Insomnia](https://insomnia.rest/) as a REST API client
- Slack and Discord (for work and community)
- There (to track team mate's timezones)
- Zoom (for work)
- GitHub Desktop App
- [Cleanshot](https://cleanshot.com/) (for screenshots and recording videos)
- Spotify
- Bandwidth +
- Linear (for work)
- Skype
- Discord
- The Unarchiver
- HiddenMe
- Numbers
- Telegram
- [Android file transfer](https://www.android.com/filetransfer/)

#### Chrome settings

- Sync settings and switch **"Developer Mode"** on.
- **Extensions** that I use:
  - [Detailed SEO extension](https://chrome.google.com/webstore/detail/detailed-seo-extension/pfjdepjjfjjahkjfpkcgfmfhmnakjfba?hl=en)
  - [Redefined GitHub](https://chrome.google.com/webstore/detail/refined-github/hlepfoohegkhhmjieoechaddaejaokhf)
  - [Twemex: Sidebar for Twitter](https://chrome.google.com/webstore/detail/twemex-sidebar-for-twitte/amoldiondpmjdnllknhklocndiibkcoe?hl=en)
  - [Minimal Twitter](https://chrome.google.com/webstore/detail/minimal-twitter/pobhoodpcipjmedfenaigbeloiidbflp?hl=en)
  - [Medium Enhanced Stats](https://chrome.google.com/webstore/detail/medium-enhanced-stats/jnomnfoenpdinfkpaaigokicgcfkomjo?hl=en)
  - [JSON Viewer](https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh)
  - Grammarly
  - [Toby](https://www.gettoby.com/) to organize tabs
  - [DF Tube (Distraction Free for YouTubeâ„¢)](https://chrome.google.com/webstore/detail/df-tube-distraction-free/mjdepdfccjgcndkmemponafgioodelna?hl=en)

### ImageOptim settings

The custom config I use for ImageOptim app:

![General settings in ImageOptim](https://i.imgur.com/zkKRiyK.png)

![Quality settings in ImageOptim](https://i.imgur.com/2rMbsUW.png)

![Optimization settings in ImageOptim](https://i.imgur.com/CwQtSbL.png)

> Copy [dotfiles](https://github.com/amandeepmittal/dotfiles)

## For React Native Development

Follow [React Native documentation for info on how to install open JDK and Android Studio](https://reactnative.dev/docs/environment-setup?platform=android).

## Alternate tools

Tools and apps that I've used in the past that I may come back to one day.

### iterm2

My favorite terminal app that I have been using for years is [iTerm2](https://iterm2.com/downloads.html).

- Enable Working Directory for New Split Panes: General -> Advanced Configuration

![iterm1](https://i.imgur.com/3aJWgxM.jpg)

- Text:

![iterm2](https://i.imgur.com/VwIK2Be.jpg)

- Colors: For the overall looks and appearance, I use [Dracula Pro Color Presets created by Zen Rocha](https://draculatheme.com/pro).

![iterm3](https://i.imgur.com/lu2R7Mr.jpg)

- Window:
  - Transparency: 5
  - Blur: 20

## Rosetta 2

> Update: I am not using the Rosetta environment to install anything on the secondary machine since August 2021. That is why I've mentioned it at the end of the post.

[Rosetta 2](https://developer.apple.com/documentation/apple_silicon/about_the_rosetta_translation_environment) is the lifeline that allows you to run apps designed for Intel-based chips that use `x86` architecture on ARM-based chips (in this case M1). This solution is provided by Apple as an emulator and doesn't come pre-installed. You have to install it manually. Fire up the Terminal application that comes pre-installed on the macOS and execute the following command:

```shell
/usr/sbin/softwareupdate --install-rosetta --agree-to-license
```

If you decide not to put the flag ` --agree-to-license`, you will be prompted by Apple's interactive install, and you will have to agree to their terms and license conditions to use it.

## Conclusion

Thatâ€™s the setup I now use for my JavaScript, Node.js, React, React Native and documentation work. I think it's a _great_ machine. Hopefully, M1 is just the beginning of a new era of powerful computers for daily work use.

ðŸ¤” The only thing left for me is to find a way to transfer all laptop swag/stickers from my Macbook Air 2017 to Pro. I miss having them on this one.

[**isapplesiliconready.com**](https://isapplesiliconready.com/for/developer) is another helpful link I found to check what is compatible to work on Apple Silicon chips natively or using Rosetta or not optimized at all.

---

## Set up a Next.js project with ESLint, Prettier, Husky, and Lint Staged
Slug: setup-nextjs-project-with-eslint-prettier-husky-lint-staged

Working on a large codebase, having a consistent style guide is important. Inconsistencies can occur by using single quotes instead of double quotes, tabs instead of spaces, and so on.

A pre-commit hook can address this problem. Before making a new commit, a pre-commit hook can check for types in TypeScript files, run a lint test, use prettier to format files, and so on. All of this is possible by using:

- ESLint
- Prettier
- Husky
- Lint Staged

I'll share my personal and minimal configuration that I have recently started using for Next.js projects in this post.

## Setting up a new Next.js project

Creating a new Next.js project with TypeScript enabled is done by running the following command from a terminal:

```shell
npx create-next-app@latest --typescript

# After the project directory is created
# Navigate inside it
cd next-typescript-config
```

After the project directory generated, navigate inside it.

The `--typescript` flag prepares the Next.js app with all the configuration required to enable and use TypeScript. In addition, it comes with a `tsconfig.json` file:

```js
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

The flag also installs the required dependencies and type definitions installed as devDependencies found in the `package.json` file.

## ESLint is already set up

Linting is a technique to check the code for syntax errors. It also allows checking for code style issues. All the checking happens based on the defined set of rules and plugins.

Since [Next.js version 11](https://nextjs.org/blog/next-11#conformance), it comes with ESLint integration out-of-the-box. This means that Next.js installs devDependencies like `eslint` and `eslint-config-next` and creates an `eslintrc.json` file. Next.js uses the `next lint` command to catch ESLint errors.

The [eslint-config-plugin](https://github.com/vercel/next.js/tree/canary/packages/eslint-config-next) by Next.js team contains pre-defined set of rules. You do not have to define them explicitly. These rules include some common and best practices in React ecosystem.

For example, the `eslint-config-plugin` uses `eslint-plugin-react-hooks` and `eslint-plugin-react` as dependencies, and the recommended set of rules from both these packages are already included. This takes care of installing the standard eslint packages for React apps in the Next.js app and then manually adding them as `plugins`.

Next.js ESLint plugin also includes best practices around Core Web Vitals and accessibility.

## Setting up Prettier

Prettier is a code formatter that ensures that all the code files follow a consistent styling. If you are into Web development, chances are you are already using it.

ESLint rules in Next.js already come with some code formatting rules. To override them and initiate your personal prettier config, start by installing the following devDependencies:

```shell
yarn add --dev prettier eslint-plugin-prettier eslint-config-prettier
```

To do Prettier work with ESLint, add `"prettier"` to the `extends` and the `plugins` array in the `.eslintrc.json` file.

```json
{
  "extends": ["next/core-web-vitals", "prettier"],
  "plugins": ["prettier"]
}
```

In the `extends` array, make sure `prettier` is the last item so that when you define your Prettier configuration that takes precedence over other configurations that may have their way of formatting code.

You can also define the `rules` in this file. For example, whenever there is a code formatting issue with any of the files in my Next.js app, I like it to be exposed as a warning rather than an error.

```json
{
  "extends": ["next", "next/core-web-vitals", "prettier"],
  "plugins": ["prettier"],
  "rules": {
    "prettier/prettier": "warn",
    "no-console": "warn"
  }
}
```

Create a new file `.prettierrc` and add a custom Prettier configuration:

```json
{
  "singleQuote": true,
  "trailingComma": "none",
  "arrowParens": "avoid",
  "proseWrap": "preserve",
  "quoteProps": "as-needed",
  "bracketSameLine": false,
  "bracketSpacing": true,
  "tabWidth": 2
}
```

Also, add a `.prettierignore` file to ignore formatting on certain directories and files:

```js
.next
.cache
package-lock.json
public
node_modules
next-env.d.ts
next.config.ts
yarn.lock
```

## Installing Husky

[Husky](https://typicode.github.io/husky/#/) is a utility that allows linting and testing when committing the code.

To set it up, initially, install the package as a dev dependency:

```shell
yarn add --dev husky
```

To enable Husky run:

```shell
yarn husky install
```

In the next step, I will configure Husky's pre-commit hook after setting up lint-staged.

## Setting up Lint Staged

The [lint-staged](https://github.com/okonet/lint-staged) package allows linting staged git files. It also checks for the changed files instead of the whole source code.

You can configure lint-staged to not lint files in markdown or json format. You can also separate ESLint checks based on a file's extension.

Create a `.lintstagedrc.js` file at the root of the Next.js app and add the following snippet:

```js
module.exports = {
  // Type check TypeScript files
  '**/*.(ts|tsx)': () => 'yarn tsc --noEmit',

  // Lint & Prettify TS and JS files
  '**/*.(ts|tsx|js)': filenames => [
    `yarn eslint ${filenames.join(' ')}`,
    `yarn prettier --write ${filenames.join(' ')}`
  ],

  // Prettify only Markdown and JSON files
  '**/*.(md|json)': filenames => `yarn prettier --write ${filenames.join(' ')}`
};
```

After setting up the lint-staged configuration, open the `/.husky/pre-commit` file and add the following pre-commit hook:

```shell
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Add the following
yarn lint-staged

# If using npm, remove above and uncomment below
# npm run lint-staged
```

To test it, I have modified the `/pages/_app.tsx` file and removed the reference of `AppProps`. This will return a type error when committing this file:

![ss1](https://i.imgur.com/ubLHL12.png)

## Conclusion

That's all for setting up ESLint, Prettier, Husky, and Lint Staged with a minimal configuration. You can expand the configuration for any tools as per your needs or modify the pre-commit hook.

---

## Setup Nodemon to auto restart Nodejs application server
Slug: setup-nodemon-to-auto-restart-nodejs-application-server

Manually restarting Node.js application is a tiring and tedious job. [Nodemon](https://www.npmjs.com/package/nodemon) is the best solution available to autorestart a nodejs app server in development mode.

### First step

Organize the source directory `src` and initiate it with an `app.js` or `index.js` or `server.js` or any other convention you use to bootstrap a Node.js server.

Update the `package.json` file accordingly by adding a `start` script.

```json
{
  "name": "nodemon-auto-restart",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "keywords": [],
  "author": "Aman Mittal <amandeepmittal@live.com> (http://amandeepmittal.github.io/)",
  "license": "MIT"
}
```

### Second step

Add `express` or any other framework as dependency to bootstrap a minimal server.

Code for a minimal server:

```js
'use strict';

const express = require('express');
const app = express();

app.use('/', (req, res) => {
  res.status(200).send('Hello World!');
});

app.listen(3000);
```

In first terminal window start the server:

```shell
$ npm run start
> node src/index.js
```

In second terminal window, request the url to test if the api is working and to see the response message:

```shell
$ curl -X GET http://localhost:3000/
Hello World!
```

Now if I change the response message, I have to restart the server to get the desired result:

```js
app.use('/', (req, res) => {
  res.status(200).send('Lorem Ipsum');
});
```

Use `Ctrl + C` to stop the currently running server and restart it by using the same command before: `npm run start`.

Using the curl command again from terminal window we get the desired result:

```shell
curl -X GET http://localhost:3000/
Lorem Ipsum
```

This whole process is repetitive will slow your development of any package or application. Better solution is to use `nodemon`.

### Third step

Add nodemon as `devDependency`:

```shell
$ npm i -D nodemon
```

```json
{
  "name": "nodemon-auto-restart",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "keywords": [],
  "author": "Aman Mittal <amandeepmittal@live.com> (http://amandeepmittal.github.io/)",
  "license": "MIT",
  "dependencies": {
    "express": "4.15.3"
  },
  "devDependencies": {
    "nodemon": "1.11.0"
  }
}
```

### Fourth step

Make another script `dev` under npm scripts in `package.json` file:

```json
{
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon --watch src src/index.js"
  }
}
```

Now run `$ npm run dev` and request using curl command, we will see the last familiar result:

```shell
curl -X GET http://localhost:3000/
Lorem Ipsum
```

If I change the response message in `index.js` file back to `Hello World`, this time I don't I have to restart the server since `nodemon` is watching for the changes using inside the src directory, through its `--watch`parameter. If I use the curl command again, the result is familiar with the update:

```shell
curl -X GET http://localhost:3000/
Hello World
```

One can verify by observing the log messages in the terminal window where nodemon is running:

```shell
$ npm run dev

> nodemon-auto-restart@1.0.0 dev /Users/amandeepmittal/github/nodemon-auto-restart
> nodemon --watch src src/index.js

[nodemon] 1.11.0
[nodemon] to restart at any time, enter `rs`
[nodemon] watching: /Users/amandeepmittal/github/nodemon-auto-restart/src/**/*
[nodemon] starting `node src/index.js`
[nodemon] restarting due to changes...
[nodemon] starting `node src/index.js`
```

To stop the nodemon process, use `Ctrl + C`.

Full Source at [this Github Repository](https://github.com/amandeepmittal/nodemon-auto-restart).

[Originally Published at Hackernoon.com](https://medium.com/hackernoon/setup-nodemon-to-auto-restart-nodejs-application-server-8d8993b7dfd9)

---

## How to use shared element transitions in React Native
Slug: shared-element-transitions

![cover_image](https://blog.logrocket.com/wp-content/uploads/2021/01/reactnavigationv5.png)

> Originally Published at [Logrocket](https://blog.logrocket.com/how-to-use-shared-element-transition-with-react-navigation-v5/)

Transitions in mobile applications provide design continuity. This continuity is provided by connecting common elements from one view to the next while navigating in the app. This tutorial is going to provide a guide for you who is a React Native developer and is able to create such interfaces and make sure they are tangible.

Source code is available at this [GitHub repo.](https://github.com/amandeepmittal/react-native-examples/tree/master/shared-element-transitions)

## What are shared elements transition?

Transitions between different views or activities involve enter and exit transitions that animate the entire view hierarchies independent of each other. There are times when two different views in continuity have common elements. Providing a way to transit these common elements from one view to the second view and back, emphasizes the continuity between transitions. The nature of these transitions maintain focus for the end-users on the content and provides a seamless experience. A shared element transition determines how two different views share one or elements to maintain the focus and experience.

## Pre-requisites

Before you begin, please make sure to have the following installed on a local environment:

- [Node.js](https://nodejs.org/en/) version >= 12.x.x installed
- Access to one package manager such as npm or yarn or npx
- [expo-cli](https://github.com/expo/expo-cli) installed, or use npx

Do note that to demonstrate Iâ€™ll be using an iOS simulator. If you prefer to use an Android device or an emulator, the code snippets shared in this post will run the same.

## Install shared element transition libraries

To get started, let's create a new React Native project using `expo-cli`. From a terminal window, execute the command below and then navigate inside the newly created project directory. After navigating, install the libraries that are required in order to create shared element transitions. Let's use `react-navigation` from one screen to another using a stack navigation pattern.

To install the React Navigation library, please take a look at the [following instructions](https://reactnavigation.org/docs/getting-started) from the official documentation. These dependencies change with time.

```shell
npx expo init shared-element-transitions

cd shared-element-transitions

yarn add @react-navigation/native react-native-animatable

expo install react-native-gesture-handler react-native-reanimated react-native-screens react-native-safe-area-context @react-native-community/masked-view

yarn add react-native-shared-element react-navigation-shared-element@next
```

After installing these libraries, let's checkout how to run the Expo app. From the terminal, run the `yarn start` command to trigger a build for the Expo app. Then depending on the simulator or the device, please select the correct option from the terminal prompt. For example, to run this app in its initial state on an iOS simulator, press `i`.

Here is how the output on an iOS simulator is shown:

![lg1](https://i.imgur.com/oQ8BvbK.png)

This output verifies that the Expo app is up and running.

## Create a home screen

The transition in this example app is going to be between a home screen and a details screen. The home screen is going to be a scrollable list of images and some data. I am going to use a set of the mock data array. You are free to use whatever data you might want to try out. Without bothering about the data set, you can use the mock data. Create a new directory called `config/` and inside it create a new file called `data.js` with the following array and objects:

```js
export const data = [
  {
    id: '1',
    title: 'Manarola, Italy',
    description: 'The Cliffs of Cinque Terre',
    image_url:
      'https://images.unsplash.com/photo-1516483638261-f4dbaf036963?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=633&q=80',
    iconName: 'location-pin'
  },

  {
    id: '2',
    title: 'Venezia, Italy',
    description: 'Rialto Bridge, Venezia, Italy',
    image_url:
      'https://images.unsplash.com/photo-1523906834658-6e24ef2386f9?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&auto=format&fit=crop&w=630&q=80',
    iconName: 'location-pin'
  },
  {
    id: '3',
    title: 'Prague, Czechia',
    description: 'Tram in Prague',
    image_url:
      'https://images.unsplash.com/photo-1513805959324-96eb66ca8713?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=634&q=80',
    iconName: 'location-pin'
  }
];
```

After that create a new directory called `screens/` where the two app screens are going to live. Create a file inside it called `HomeScreen.js` and import the following statements.

```js
import React from 'react';
import {
  ScrollView,
  Text,
  View,
  TouchableOpacity,
  Image,
  Dimensions
} from 'react-native';
import { StatusBar } from 'expo-status-bar';
import { SimpleLineIcons } from '@expo/vector-icons';
import { data } from '../config/data';
```

Using the `Dimensions` API from React Native, let's define the initial width and height of the image component. In the code snippet below, I am calculating both the width and the height using the `width` of the screen.

```js
const { width } = Dimensions.get('screen');

const ITEM_WIDTH = width * 0.9;
const ITEM_HEIGHT = ITEM_WIDTH * 0.9;
```

The `HomeScreen` component is going to be a functional React component that accepts one prop called `navigation`. It will allow the navigation from the Home screen to the `DetailScreen`. In any React Native app, the React Navigation library provides a context that further gives access to the `navigation` object as a prop automatically. The prop contains various functions that dispatch navigation actions.

```js
export default function HomeScreen({ navigation }) {
  return (
    <View style={{ flex: 1, backgroundColor: '#0f0f0f' }}>
      <StatusBar hidden />
      {/* Header */}
      <View style={{ marginTop: 50, marginBottom: 20, paddingHorizontal: 20 }}>
        <Text style={{ color: '#888', textTransform: 'uppercase' }}>
          Saturday 9 January
        </Text>
        <Text style={{ color: '#fff', fontSize: 32, fontWeight: '600' }}>
          Today
        </Text>
      </View>
  )
}
```

This functional component is going to render the header stating some dummy information to display and beneath it, a `ScrollView` to scroll through a list of images. Each image displays an icon and some information regarding what the image is about. This image and the text on it will play a huge role later when a transition is going to happen between the home and detail screen.

Inside the `ScrollView` component, let's render the mock data using JavaScript's `map()` method. If you are injecting data from a REST API that is hosted somewhere and you are not sure about the number of items in that particular data set, please use a `FlatList` component from React Native instead of `ScrollView`.

```js
return (
  {/* Scrollable content */}
<View style={{ flex: 1, paddingBottom: 20 }}>
  <ScrollView
    indicatorStyle='white'
    contentContainerStyle={{ alignItems: 'center' }}
  >
    {data.map(item => (
      <View key={item.id}>
        <TouchableOpacity
          activeOpacity={0.8}
          style={{ marginBottom: 14 }}
          onPress={() => navigation.navigate('DetailScreen', { item })}
        >
          <Image
            style={{
              borderRadius: 14,
              width: ITEM_WIDTH,
              height: ITEM_HEIGHT
            }}
            source={{ uri: item.image_url }}
            resizeMode='cover'
          />
          <View
            style={{
              position: 'absolute',
              bottom: 20,
              left: 10
            }}
          >
            <View style={{ flexDirection: 'row' }}>
              <SimpleLineIcons size={40} color='white' name={item.iconName} />
              <View style={{ flexDirection: 'column', paddingLeft: 6 }}>
                <Text
                  style={{
                    color: 'white',
                    fontSize: 24,
                    fontWeight: 'bold',
                    lineHeight: 28
                  }}
                >
                  {item.title}
                </Text>
                <Text
                  style={{
                    color: 'white',
                    fontSize: 16,
                    fontWeight: 'bold',
                    lineHeight: 18
                  }}
                >
                  {item.description}
                </Text>
              </View>
            </View>
          </View>
        </TouchableOpacity>
      </View>
    ))}
  </ScrollView>
</View>);
```

## Create a detail screen

The `DetailScreen` component is going to render the details for each image that is part of the scroll list on the home screen. On this screen, an image is shown with a back navigation button that is positioned on the top of the screen. It receives the data in form of an `item` object that is destructured using `route.params` from React Navigation library. Beneath the image, it is going to show the title that will be shared with the home screen and some dummy text.

Create a new file called `DetailScreen.js` inside the `screens/` directory and add the following code snippet:

```js
import React, { useRef } from 'react';
import {
  StyleSheet,
  Text,
  View,
  ScrollView,
  Image,
  Dimensions
} from 'react-native';

import { SimpleLineIcons, MaterialCommunityIcons } from '@expo/vector-icons';

const { height } = Dimensions.get('window');
const ITEM_HEIGHT = height * 0.5;

const DetailScreen = ({ navigation, route }) => {
  const { item } = route.params;

  return (
    <View style={{ flex: 1, backgroundColor: '#0f0f0f' }}>
      <Image
        source={{ uri: item.image_url }}
        style={{
          width: '100%',
          height: ITEM_HEIGHT,
          borderBottomLeftRadius: 20,
          borderBottomRightRadius: 20
        }}
        resizeMode="cover"
      />
      <MaterialCommunityIcons
        name="close"
        size={28}
        color="#fff"
        style={{
          position: 'absolute',
          top: 40,
          right: 20,
          zIndex: 2
        }}
        onPress={() => {
          navigation.goBack();
        }}
      />
      <View
        style={{ flexDirection: 'row', marginTop: 10, paddingHorizontal: 20 }}
      >
        <SimpleLineIcons size={40} color="white" name={item.iconName} />
        <View style={{ flexDirection: 'column', paddingLeft: 6 }}>
          <Text
            style={{
              color: 'white',
              fontSize: 24,
              fontWeight: 'bold',
              lineHeight: 28
            }}
          >
            {item.title}
          </Text>
          <Text
            style={{
              color: 'white',
              fontSize: 16,
              fontWeight: 'bold',
              lineHeight: 18
            }}
          >
            {item.description}
          </Text>
        </View>
      </View>
      <ScrollView
        indicatorStyle="white"
        style={{
          paddingHorizontal: 20,
          backgroundColor: '#0f0f0f'
        }}
        contentContainerStyle={{ paddingVertical: 20 }}
      >
        <Text
          style={{
            fontSize: 18,
            color: '#fff',
            lineHeight: 24,
            marginBottom: 4
          }}
        >
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
          minim veniam, quis nostrud exercitation ullamco laboris nisi ut
          aliquip ex ea commodo consequat. Duis aute irure dolor in
          reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
          pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
          culpa qui officia deserunt mollit anim id est laborum.
        </Text>
        <Text
          style={{
            fontSize: 18,
            color: '#fff',
            lineHeight: 24,
            marginBottom: 4
          }}
        >
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
          minim veniam, quis nostrud exercitation ullamco laboris nisi ut
          aliquip ex ea commodo consequat. Duis aute irure dolor in
          reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
          pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
          culpa qui officia deserunt mollit anim id est laborum.
        </Text>
      </ScrollView>
    </View>
  );
};

export default DetailScreen;
```

## Add navigation to the app

To navigate from the home screen to the detail screen and back, the app needs to have a navigation flow. This is going to be provided by `createSharedElementStackNavigator` method from `react-navigation-shared-element` module. It contains the React Navigation library for `react-native-shared-element`. This method allows us to create a stack-navigator which is the initial process of sharing elements between two separate screens. It wraps each route with the shared element and it detects route changes to trigger the transitions. The process of defining the navigation flow using this method is similar to React Navigation's stack-navigator module.

Create a new directory called `navigation/` and inside it create a new file called `RootNavigator.js`. Import the following statements and create an instance called `Stack` of the `createSharedElementStackNavigator` method. Then define the Root Navigator.

```js
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createSharedElementStackNavigator } from 'react-navigation-shared-element';

import HomeScreen from '../screens/HomeScreen';
import DetailScreen from '../screens/DetailScreen';

const Stack = createSharedElementStackNavigator();

export default function RootNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator headerMode="none" initialRouteName="HomeScreen">
        <Stack.Screen name="HomeScreen" component={HomeScreen} />
        <Stack.Screen name="DetailScreen" component={DetailScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

To see it in action, modify the `App.js` file as shown below:

```js
import React from 'react';
import RootNavigator from './navigation/RootNavigator';

export default function App() {
  return <RootNavigator />;
}
```

Here is the result after this step in the iOS simulator:

![lg2](https://i.imgur.com/4QGKdLn.png)

## Shared element mapping

The image component is going to be responsible to support a seamless back and forth transition between home and detail screen. This transition should happen from the scroll grid to the detail screen and back to the relevant image. To make this happen, wrap the `Image` component with `<SharedElement>` and provide a unique `id` to it in the `HomeScreen`.

Also, make sure to import the `<SharedElement>` component from the `react-navigation-shared-element` module.

```js
import { SharedElement } from 'react-navigation-shared-element';

// Wrap the image component as
return (
  // ...

  <SharedElement id={`item.${item.id}.image_url`}>
    <Image
      style={{
        borderRadius: 14,
        width: ITEM_WIDTH,
        height: ITEM_HEIGHT
      }}
      source={{ uri: item.image_url }}
      resizeMode="cover"
    />
  </SharedElement>
);
```

The `<SharedElement>` component accepts a prop called `id` that is the shared id between the two screens. The child it is wrapped around is the actual component where the transition happens.

To enable the shared element transitions, the above process has to be followed in `DetailScreen`.

```js
import { SharedElement } from 'react-navigation-shared-element';

// Wrap the image component as
return (
  // ...
  <SharedElement id={`item.${item.id}.image_url`}>
    <Image
      source={{ uri: item.image_url }}
      style={{
        width: '100%',
        height: ITEM_HEIGHT,
        borderBottomLeftRadius: 20,
        borderBottomRightRadius: 20
      }}
      resizeMode="cover"
    />
  </SharedElement>
);
```

To animate the transition between the home and the detail screens, define a `sharedElements` configuration in the `DetailScreen` component. This will map the transition of the `Image` component between the two screens.

Before the `export` statement in `DetailScreen.js` add the code snippet:

```js
DetailScreen.sharedElements = route => {
  const { item } = route.params;
  return [
    {
      id: `item.${item.id}.image_url`,
      animation: 'move',
      resize: 'clip'
    }
  ];
};
```

The config object above triggers the transition effects on shared elements between screens based on the unique ID shared between those two screens. This is done by defining a property called `id`.

The property `animation` determines how the animation is going to happen when navigating between two screens. For example, in the above code snippet, the `animation` has a value called `move`. It is also the default value of this property. There are other values available such as `fade`, `fade-in`, and `fade-out`. The property `resize` is the behavior that determines the shape and size of the element should be modified or not. For example, in the above snippet, the value `clip` adds a transition effect which is similar to a text reveal effect.

Here is the output after this step:

![lg3](https://i.imgur.com/qzCGF2F.gif)

In the above example, please note that when the transition happens, the screen slides from left to right in between. To modify this behavior to apply transition effects of the shared elements, let's add an `options` configuration object to the `DetailScreen`. In Root Navigator file, add the following configuration:

```js
const options = {
  headerBackTitleVisible: false,
  cardStyleInterpolator: ({ current: { progress } }) => {
    return {
      cardStyle: {
        opacity: progress
      }
    };
  }
};

// Then add it to the DetailScreen

return (
  <Stack.Screen
    name="DetailScreen"
    component={DetailScreen}
    options={() => options}
  />
);
```

The `cardStyleInterpolator` function specifies the interpolated styles for different parts of a card. It allows us to customize the transitions when navigating between two screens. It receives a property value called `current.progress` that represents the animated node progress value of the current screen. Applying this value to the property `opacity` changes the animated node to the value of animation defined in the shared element config object. Its `cardStyle` property applies the style on the view that is representing the card.

## Update Shared elements mapping

In the previous demonstration, you can see that the transition on the image component is seamless but other components shared such as the location pin icon, the title and the description of the item between two screens is not.

To resolve this, let's map them using `<SharedElement>` component. First, in home screen, modify the following components:

```js
return (
  // Icon
  <SharedElement id={`item.${item.id}.iconName`}>
    <SimpleLineIcons size={40} color='white' name={item.iconName} />
  </SharedElement>

  //Title
  <SharedElement id={`item.${item.id}.title`}>
  <Text
    style={{
      color: 'white',
      fontSize: 24,
      fontWeight: 'bold',
      lineHeight: 28
    }}
  >
    {item.title}
  </Text>
</SharedElement>

  // Description
  <SharedElement id={`item.${item.id}.description`}>
  <Text
    style={{
      color: 'white',
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 18
    }}
  >
    {item.description}
  </Text>
</SharedElement>
);
```

Similarly, modify the following elements in `DetailScreen.js` file:

```js
// Icon
<SharedElement id={`item.${item.id}.iconName`}>
  <SimpleLineIcons size={40} color='white' name={item.iconName} />
</SharedElement>

// Title
<SharedElement id={`item.${item.id}.title`}>
  <Text
    style={{
      color: 'white',
      fontSize: 24,
      fontWeight: 'bold',
      lineHeight: 28
    }}
  >
    {item.title}
  </Text>
</SharedElement>

// Description
<SharedElement id={`item.${item.id}.description`}>
  <Text
    style={{
      color: 'white',
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 18
    }}
  >
    {item.description}
  </Text>
</SharedElement>
```

Then add the configuration:

```js
DetailScreen.sharedElements = route => {
  const { item } = route.params;
  return [
    {
      id: `item.${item.id}.image_url`,
      animation: 'move',
      resize: 'clip'
    },
    {
      id: `item.${item.id}.title`,
      animation: 'fade',
      resize: 'clip'
    },
    {
      id: `item.${item.id}.description`,
      animation: 'fade',
      resize: 'clip'
    },
    {
      id: `item.${item.id}.iconName`,
      animation: 'move',
      resize: 'clip'
    }
  ];
};
```

Here is the output after this step:

![lg4](https://i.imgur.com/umfe3gL.gif)

## Delayed loading

Shared element transitions are a great way to support a smooth end-user experience but it can become tricky when dealing with elements that need to be loaded before or after the transition happens. For example, in the previous demonstration, the back button renders before the transition happens. To control its behavior, let's animate it using the React Native Animatable library.

Import it inside the `DetailScreen.js` file:

```js
import * as Animatable from 'react-native-animatable';
```

The close button icon is going to be wrapped inside the `<Animatable.View>`. This component has a prop called `delay` that delays the animation. Using a prop called `duration` you can control the amount of time the animation will run. Values to both of these props are provided in milliseconds. Using a `ref` value, the `fadeOut` animation is applied on the icon. This animation method is asynchronous and thus, you can use the promise to navigate back to the home screen after the animation has successfully run. The argument passed to this animation method is in milliseconds.

```js
const DetailScreen = ({ navigation, route }) => {
  const buttonRef = React.useRef();

  return (
    <Animatable.View
      ref={buttonRef}
      animation="fadeIn"
      duration={600}
      delay={300}
      style={[StyleSheet.absoluteFillObject]}
    >
      <MaterialCommunityIcons
        name="close"
        size={28}
        color="#fff"
        style={{
          position: 'absolute',
          top: 40,
          right: 20,
          zIndex: 2
        }}
        onPress={() => {
          buttonRef.current.fadeOut(100).then(() => {
            navigation.goBack();
          });
        }}
      />
    </Animatable.View>
  );
};
```

Here is the final output:

![lg5](https://i.imgur.com/FxWw67j.gif)

## Conclusion

I hope you had fun reading this tutorial. Sharing elements in between screens in React Native using the React Navigation Shared Element module makes both the process of development and end-user experience smooth. I would recommend you to check out the [official documentation here](https://github.com/IjzerenHein/react-navigation-shared-element) for more information.

Source code is available at this [GitHub repo.](https://github.com/amandeepmittal/react-native-examples/tree/master/shared-element-transitions)

---

## Create a custom hook to Show/Hide Password Visibility in React Native
Slug: show-hide-password-in-react-native-using-custom-hook

> Updated on May 24, 2023

Building log-in and sign-up forms in a React Native app are fundamentally composed of input fields and buttons. One field that you will often find yourself adding to these forms is the password field. This password field is created using React Native's `TextInput` component. The common behavior of this field is to hide a user's password behind obscure characters.

Take a look at an example of the `TextInput` component that is used to create a password field.

```js
import { useState } from 'react';
import { StyleSheet, TextInput, View } from 'react-native';

export default function App() {
  const [password, setPassword] = useState('');

  return (
    <View style={styles.container}>
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.inputField}
          name="password"
          placeholder="Enter password"
          autoCapitalize="none"
          autoCorrect={false}
          textContentType="newPassword"
          secureTextEntry
          value={password}
          enablesReturnKeyAutomatically
          onChangeText={text => setPassword(text)}
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5EEDC',
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 12
  },
  inputContainer: {
    backgroundColor: 'white',
    width: '100%',
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 4,
    borderColor: '#d7d7d7'
  },
  inputField: {
    padding: 14,
    fontSize: 22,
    width: '90%'
  }
});
```

It uses the `secureTextEntry` prop such that when a text value is entered in the input field, it is not visible as to what is being entered in that field. Here is the output of the above snippet on a device:

![ss1](https://i.imgur.com/kn0yv9z.gif)

However, giving an option to a user to let them see the current value they enter leads to a good experience and might be necessary in most cases.

> [Source code in this GitHub repo](https://github.com/amandeepmittal/react-native-examples/tree/main/password-visibility-custom-hook-example).

## Show or Hide Password Visibility hook

To add the ability to show or hide the password field's visibility, let's create a custom hook in a new file called `useTogglePasswordVisibility.js`.

Start by importing the `useState` hook from React library. You will need to create two different state variables to toggle between the field's visibility and change the icon.

Then define a function called `useTogglePasswordVisibility`. Inside this function, create two new state variables:

- `passwordVisibility`: set its initial value to `true`. The reason is that this variable will be the value of the prop `secureTextEntry` on the `TextInput` component. You would want to hide the password field initially when the user enters the password in the input field.
- `rightIcon`: set its default value to `eye`. This value depends on the icon library you're using in your React Native app. For this example, I'm using **MaterialCommunityIcons** from [Expo Vector Icons](https://docs.expo.dev//guides/icons/#expovector-icons).

```js
export const useTogglePasswordVisibility = () => {
  const [passwordVisibility, setPasswordVisibility] = useState(true);
  const [rightIcon, setRightIcon] = useState('eye');

  // ...
};
```

Next, add a method called `handlePasswordVisibility` that will allow the app user to toggle the password field's visibility between shown and hidden state. Do not forget to return all the variables and the handler method.

```js
export const useTogglePasswordVisibility = () => {
  const [passwordVisibility, setPasswordVisibility] = useState(true);
  const [rightIcon, setRightIcon] = useState('eye');

  const handlePasswordVisibility = () => {
    if (rightIcon === 'eye') {
      setRightIcon('eye-off');
      setPasswordVisibility(!passwordVisibility);
    } else if (rightIcon === 'eye-off') {
      setRightIcon('eye');
      setPasswordVisibility(!passwordVisibility);
    }
  };

  return {
    passwordVisibility,
    rightIcon,
    handlePasswordVisibility
  };
};
```

## Use the Password Visibility hook

Start by updating import statements in the `App.js` file:

```js
import { useState } from 'react';
import { StyleSheet, Pressable, TextInput, View } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

import { useTogglePasswordVisibility } from './hook/useTogglePasswordVisibility';
```

Next, access the required variables and method from the `useTogglePasswordVisibility` hook. Add the following line at the top of the `App` component:

```js
export default function App() {
  const { passwordVisibility, rightIcon, handlePasswordVisibility } =
    useTogglePasswordVisibility();
  const [password, setPassword] = useState('');

  // ...
}
```

Modify the `TextInput` component's prop. Make sure to add the `passwordVisibility` as the value to the `secureTextEntry` prop.

```js
<TextInput
  secureTextEntry={passwordVisibility}
  // ... rest of the props remain unchanged
/>
```

Inside the `View` component that wraps the `TextInput`, add a button using the `Pressable` component. This button will allow the user to toggle between the hidden and shown state of the password field. It also wraps the icon component.

```js
<View style={styles.inputContainer}>
  {/* After TextInput component */}
  <Pressable onPress={handlePasswordVisibility}>
    <MaterialCommunityIcons name={rightIcon} size={22} color="#232323" />
  </Pressable>
</View>
```

That's all! Here is the output after this step:

![ss2](https://i.imgur.com/rTNH2Ud.gif)

Here is the complete code for the `App.js` file:

```js
import React, { useState } from 'react';
import { StyleSheet, Pressable, TextInput, View } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

import { useTogglePasswordVisibility } from './hook/useTogglePasswordVisibility';

export default function App() {
  const { passwordVisibility, rightIcon, handlePasswordVisibility } =
    useTogglePasswordVisibility();
  const [password, setPassword] = useState('');

  return (
    <View style={styles.container}>
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.inputField}
          name="password"
          placeholder="Enter password"
          autoCapitalize="none"
          autoCorrect={false}
          textContentType="newPassword"
          secureTextEntry={passwordVisibility}
          value={password}
          enablesReturnKeyAutomatically
          onChangeText={text => setPassword(text)}
        />
        <Pressable onPress={handlePasswordVisibility}>
          <MaterialCommunityIcons name={rightIcon} size={22} color="#232323" />
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5EEDC',
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 12
  },
  inputContainer: {
    backgroundColor: 'white',
    width: '100%',
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 4,
    borderColor: '#d7d7d7'
  },
  inputField: {
    padding: 14,
    fontSize: 22,
    width: '90%'
  }
});
```

---

## How to show Touch indicator on iOS simulator
Slug: show-touch-indicator-on-ios-simulator

Sometimes it is necessary to highlight a single touch event on the iOS simulator's screen and show the tap that registers it. For example, this is useful when recording a video or a [gif](https://en.wikipedia.org/wiki/GIF) using the simulator.

The iOS simulator comes with a pre-configured list of settings, including to display the touch indicator. However, sometimes, it is hard to find them.

## Enable Touch Indicator on iOS simulator

To enable the touch indicator, open the terminal window and run the following command:

```shell
defaults write com.apple.iphonesimulator ShowSingleTouches 1
```

It accepts a boolean value of `1`.

After running the command, if the iOS simulator is already running, close and restart it.

To test it out, open the simulator and tap on the screen.

![ss1](https://i.imgur.com/h31kDO1.gif)

## Disable Touch Indicator on iOS simulator

To disable the touch indicator from the terminal window, run the following command to change the boolean value to `0`:

```shell
defaults write com.apple.iphonesimulator ShowSingleTouches 0
```

---

## Simple Recipe to Build a Theme App in React Native
Slug: simple-recipe-to-build-a-theme-app-in-react-native

Recently, I have been working on a React Native application that demands a changeable theme based on the user selection. I wanted to do this in a simplest way possible. I have so far avoided any React Native UI toolkit such as NativeBase or React Native Elements. In the article below, I am going to share with you all about this simple recipe.

> This is what we are building. By the end of this article you will have a similar looking React NativeÂ project.

<img src='https://cdn-images-1.medium.com/max/800/1*NK6OqE6SWsT3ibxXDhkx6g.gif' />

### Requirements

You can either clone the application to see how it works from this Github repo here to see everything working properly. Or you can follow the article step by step. It is up to you. To start, generate a react native app using a generator of your choice. We have to choices:

- `react-native cli`
- expo-cli/CRNA

I will use expo-cli for the demo purposes but you can use CRNA(Create-React-Native-Project) if you want. We need to the following dependencies to be installed in our project before we start.

- redux
- redux-logger(optional, it will be better for you to debug in case anything goes wrong)
- react-navigation
- react-native-vector-icons (only install if you are using react-native-cli)

### Getting Started: Navigation

We need only two screen for the demonstration. I am going to call them `Home.js` and `Theme.js`. Both are right now contain only boilerplate code. It is good for them to be dumb until we connect them using `react-navigation`. Create a new file called `navigation.js` and import both the components.

<img src='https://cdn-images-1.medium.com/max/800/1*hBNBbPck6EmD9Bq9NCAhzA.png' />

`createStackNavigator` is the replacement to `StackNavigator` in `react-navigation` version 2+. Notice that, we are not passing a header to the Home Screen.

### Creating a Store usingÂ Redux

Next step is to build a redux store that will make use of an action, action creator and reducer to change theme in our application. In `actions.js` put the following code.

<img src='https://cdn-images-1.medium.com/max/800/1*T86eAgIOjKi5L0xyuqIxCA.png' />

We only have one action and changes the theme color of the app. Now the reducer:

<img src='https://cdn-images-1.medium.com/max/800/1*n6CqWVOCKJw0an8y2UeqkQ.png' />

Notice that we are setting the primary color in the initial state as the hex value. You can also retrieve it from a configuration file or constants file in your application. We are also exporting the `colors.js` file which contains three different hex code values that define different color schemes.

<img src='https://cdn-images-1.medium.com/max/800/1*bKG_BG6i7e7IvwT9p9zm5g.png' />

Lastly, create the store and it to `App.js` for the application components to use it.

<img src='https://cdn-images-1.medium.com/max/800/1*EBI1jplYD7TB4oxkZMlp_A.png' />

Inside `App.js` file we connect our Redux store to manage the state as well as navigation.

<img src='https://cdn-images-1.medium.com/max/800/1*4xA_ue2jr9WWItYKLQzCFA.png' />

You might be wondering why the heck use a Redux Store for such a small application. Well, all I am trying to demonstrate is a pragmatic approach to build a them-able application using React Native and Redux. It is your choice to manage the state.

### Finalizing theÂ App

The last components of our React Native application from where the action happens are `Home.js` and `Theme.js`.

<img src='https://cdn-images-1.medium.com/max/800/1*P08ni2pglIDyhL0h8SIgbg.png' />

By pressing the settings icon, we can navigate to the Themes screen to change background color of the Home screen. We are also passing the title of the Theme Screen here.

The magic of changing the color is happening in `Home.js` at this line:

```js
<View style={[styles.container, { backgroundColor: this.props.primaryColor }]}>
```

We are receiving the `primaryColor` from the props. The `Theme.js` file will be changing the value of this prop on selecting a viable option. Take a look below.

<img src='https://cdn-images-1.medium.com/max/800/1*pqMt7rWFEqGI8H-Ml70rnQ.png' />

In above, `handleThemeChange` handles the dispatching of the only action we defined in `actions.js`. At last, we have our app working.

<img src='https://cdn-images-1.medium.com/max/800/1*NK6OqE6SWsT3ibxXDhkx6g.gif' />

[Originally published at Hackernoon.com](https://medium.com/hackernoon/simple-recipe-to-build-a-theme-app-in-react-native-8e2456f81bc5)

---

## Getting Started with Stack Navigator using react-navigation 5 in React Native and ExpoÂ apps
Slug: stack-navigator-with-react-navigation-v5

[React Navigation](https://reactnavigation.org/) as the library released its 5th stable version recently, just being two years old. Without a doubt, it is one of the most popular navigation solutions in React Native apps that also has support for the Expo.

Recently, it underwent some core changes and how you used to define routes till `react-navigation` version `4.x.x` has some major changes as to how you are going to define routes using the latest version of the library.

Some of the major highlights the team of maintainers released in a [blog post](https://reactnavigation.org/blog/) are that the navigation patterns are now more component-based, common use cases can now be handled with pre-defined Hooks, new architecture allows you to configure and update a screen from the component itself and some other changes that you can dwell in the [blog post here](https://reactnavigation.org/blog/).

The major highlight from these new changes in the component based configuration. If you have experience developing with web development libraries such as Reactjs in combination with `react-router`, you won't experience much of a learning curve here. However, if you are diving into React Native recently, and chances are that you are going to use `react-navigation`, I'd recommend starting with this latest version. I hope this tutorial serves as a starting point or a refreshing one in your journey.

If youâ€™d like to receive **more React Native tutorials** in your inbox, you can sign up for my newsletter **[here](https://amanhimself.substack.com/)**.

## Table of contents

- Install dependencies
- Create mock screens
- Create a basic stack navigator
- Specifying options for each screen in Stack Navigator
- Navigating between two screens
- Enabling gestures in react-navigation
- Passing data between routes
- How to use params in the screen's title
- Using common screenOptions to modify header styles
- Making the back button title invisible on iOS
- Understanding header modes and changing it in an Android app
- Directly navigating from the third screen to the top of the stack screen navigator
- Conclusion

## Requirements

Requirements for this tutorial is simple. Have the following installed on your local dev environment.

- Node.js version >= `10.x.x` installed
- Have access to one package manager such as npm or yarn
- Latest `expo-cli` version installed or use npx

Do note that, without dwelling much into the configuration of native binaries with the `react-navigation` library, I am going to `expo-cli` to generate the project and Expo client to view output from time to time. Make sure you have both installed.

## Install dependencies

To start, generate a new Expo project with a `blank` template by running the following command in a terminal window.

```shell
npx expo init [Project Name]

# after the project directory has been generated

cd [Project Name]
```

Next, install the following dependencies for the `react-navigation` library to work. The first command is going to install core utilities of `react-navigation` that are used by navigators to create the navigation structure in the app. The second command uses `expo install` instead of `npm install` or `yarn add`. The reason is that `expo` is going to install the version of the libraries mentioned that are compatible with the Expo SDK.

```shell
yarn add @react-navigation/native @react-navigation/stack

# use expo install for Expo projects only
expo install react-native-gesture-handler react-native-reanimated
react-native-screens react-native-safe-area-context
@react-native-community/masked-view
```

Do note that the package `@react-navigation/stack` is only required to install when you are going to use the Stack navigation pattern in the app. For example, if you are just going to use tab navigation, you are going to install a different package as shown [here](https://reactnavigation.org/docs/en/material-bottom-tab-navigator.html).

## Create mock screens

Create a new directory `src/screens` and inside it, create two new files called `Home.js` and `Detail.js`. The code snippet for both of these files is listed below:

```js
// src/screens/Home.js

import React from 'react';
import { StyleSheet, View, Text } from 'react-native';

function Home() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Home Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  }
});

export default Home;

// src/screens/Detail.js

import React from 'react';
import { StyleSheet, View, Text } from 'react-native';

function Details() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Details Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  }
});

export default Details;
```

These screen components are for demonstration purposes. You have to feed the routes to the navigator to work with, these screen components are going to the routes.

## Create a basic stack navigator

In this section, let us set up a basic Stack navigator. Start by creating a new directory `src/navigation`. The best definition of what a Stack Navigator does can be read from its docs. I am going to quote it here:

> React Navigation's stack navigator provides a way for your app to transition between screens and manage navigation history. If your app uses only one stack navigator then it is conceptually similar to how a web browser handles navigation state - your app pushes and pops items from the navigation stack as users interact with it, and this results in the user seeing different screens.

Now that you have an idea of what exactly a stack navigation pattern is, let us start by creating one. Inside the `src/navigation` directory, create a new file called `MainStackNavigator.js` and import the following statements:

```js
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

import Home from '../screens/Home';
```

From the above snippet, the `NavigationContainer` is a component that manages the navigation tree. It also contains the navigation state and it has to wrap all navigators structure.

The `createStackNavigator` is a function that is used to implement a stack navigation pattern. This function returns two React components: `Screen` and `Navigator` that help to configure each component screen. For now, let us add one screen to this navigation pattern.

```js
const Stack = createStackNavigator();

function MainStackNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={Home} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

export default MainStackNavigator;
```

In the above snippet, there are two required props with each `Stack.Screen`. The prop `name` refers to the name of the route and prop `component` specifies which screen to render at the particular route.

Do not forget to export the `MainStackNavigator` since it is going to be imported in the root of the app, that is, inside `App.js` file as shown below.

```js
import React from 'react';

import MainStackNavigator from './src/navigation/MainStackNavigator';

export default function App() {
  return <MainStackNavigator />;
}
```

Execute the command `expo start` and make sure the Expo client is running either in a simulator device or a real device. You are going to get the HomeScreen as the following result.

<img src='https://miro.medium.com/max/350/1*xO2cNaDxKiisiipKN6YhdA.png' />

## Specifying options for each screen in Stack Navigator

By default, it shows the title bar on the screen. However, you can set the title of the screen. Let us change the title of the screen shown, from `Home` to render `Home Screen`.

This is done by specifying the options on each screen as shown below. Open `MainStackNavigator.js` file and the prop `options` on `Stack.Screen` for `Home` component.

```js
<Stack.Screen name="Home" component={Home} options={{ title: 'Home Screen' }} />
```

The changes are instantly reflected in the Expo client.

<img src='https://miro.medium.com/max/350/1*YV2HwIMzcnU1-GbSaEAkAg.png' />

## Navigating between two screens

In the current stack navigator structure, let us add the second screen component called `Detail`. Import it from `screens/Detail.js` and another route as shown below.

```js
// rest import statements remain same
import Detail from '../screens/Detail';

function MainStackNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen
          name="Home"
          component={Home}
          options={{ title: 'Home Screen' }}
        />
        <Stack.Screen
          name="Detail"
          component={Detail}
          options={{ title: 'Detail Screen' }}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

To see that `Detail` screen is currently in our stack, try adding the prop `initialRouteName` on `Stack.Navigator`. The first screen that renders is going to be the `Detail` screen.

```js
<Stack.Navigator initialRouteName='Detail'>
```

Here is the output:

<img src='https://miro.medium.com/max/350/1*2FuxHYiJZtynAxlu7XoSog.png' />

But we need a way to navigate from the Home screen to the Detail screen not just display the later screen as the initial route. Change the value of `initialRouteName` to `Home`.

```js
<Stack.Navigator initialRouteName='Home'>
```

Then, open `screen/Home.js` and a button component that is going to navigate to the Detail screen when pressed.

Import `TouchableOpacity` from `react-native` core and make sure to utilize the `navigation` prop passed to the `Home` screen. This prop is passed to every screen that is a route wrapped by the Stack Navigator.

```js
import React from 'react';
import { StyleSheet, View, Text, TouchableOpacity } from 'react-native';

function Home(props) {
  const { navigation } = props;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Home Screen</Text>
      <TouchableOpacity
        style={styles.buttonContainer}
        onPress={() => navigation.navigate('Detail')}
      >
        <Text style={styles.buttonText}>Go to Detail Screen</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  },
  buttonContainer: {
    backgroundColor: '#222',
    borderRadius: 5,
    padding: 10,
    margin: 20
  },
  buttonText: {
    fontSize: 20,
    color: '#fff'
  }
});

export default Home;
```

Here is the changed Home screen:

<img src='https://miro.medium.com/max/350/1*7Ap75E1ik7p3HCUYyDT2jA.png' />

## Enabling gestures in react-navigation

If you press the button, you are going to notice that it navigates you to the Detail screen. On the Detail screen, do note that the back button with the name of the previous screen is shown in the header.

<img src='https://miro.medium.com/max/374/1*c70jHetvl1YYf4dJu3u5Lw.gif' />

The above demo is how the navigation between two-screen works on an iOS device. The default native transition on iOS when using stack navigation is that the screen is pushed or pulled from the right side. On Android, as you will notice below, the behavior is different. The new screen is pushed from the bottom.

<img src='https://miro.medium.com/max/327/1*D8q7w0OjqFJQVUtQZw6U0g.gif' />

Also, in the below demo notice that on iOS swipe gesture works when going back from Detail to Home screen. On Android, it doesn't.

<img src='https://miro.medium.com/max/825/1*1w3g_Wymp31A4siy7PcSNw.gif' />

To enable gestures on Android as well, in `Stack.Navigator` you have to add a prop called `screenOptions`. This prop is used when you want to pass some value to all the children's routes of a stack navigator.

```js
<Stack.Navigator
        initialRouteName='Home'
        screenOptions={{
          gestureEnabled: true
        }}>
```

This is going to enable the gestures on Android as well.

<img src='https://miro.medium.com/max/825/1*0Z0iyNBAjToSldPXaChgHQ.gif' />

## Passing data between routes

You can pass parameters to a route by putting the params in an object as the second argument using `navigation.navigate`. Let's mimic a small example by passing data from Home to Detail screen.

Add the following mock object for some data in `Home.js`.

```js
const character = {
  name: 'Luke Skywalker',
  home: 'Tatooine',
  species: 'human'
};
```

Then, in the same screen component file, modify the `TouchableOpacity` and pass the previous object as the second argument.

```js
<TouchableOpacity
  style={styles.buttonContainer}
  onPress={() => navigation.navigate('Detail', { item: character })}
>
  <Text style={styles.buttonText}>Who is {character.name}?</Text>
</TouchableOpacity>
```

Here is the output:

<img src='https://miro.medium.com/max/350/1*cGivoNSclkmj6yUVdYQVnw.png' />

Open `Detail.js` and add the following code snippet. Using `route.params` this screen component can read the parameters passed from the Home screen. Inside the `Detail` component, let us destructure the `route.params` and then display those values.

```js
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';

function Detail(props) {
  const { route } = props;
  const { item } = route.params;
  const { name, home, species } = item;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Detail Screen</Text>
      <View style={styles.card}>
        <Text style={styles.cardText}>Name: {name}</Text>
        <Text style={styles.cardText}>Home Planet: {home}</Text>
        <Text style={styles.cardText}>Species: {species}</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  },
  card: {
    width: 350,
    height: 100,
    borderRadius: 10,
    backgroundColor: '#101010',
    margin: 10,
    padding: 10,
    alignItems: 'center'
  },
  cardText: {
    fontSize: 18,
    color: '#ffd700',
    marginBottom: 5
  }
});

export default Detail;
```

Here is the output showing above works:

<img src='https://miro.medium.com/max/825/1*dq6r8ObVqOAjyVwg8dFj3A.gif' />

## How to use params in the screen's title

You can use params in the title of the screen component. For example, instead of saying `Detail Screen`, it could say the name of the character.

This can be done by passing `route` as an object in options for Detail screen in `MainStackNavigator.js` file and use the value of the title from `route.params.item.name`.

```js
<Stack.Screen
  name="Detail"
  component={Detail}
  options={({ route }) => ({
    title: route.params.item.name
  })}
/>
```

Here is the output:

<img src='https://miro.medium.com/max/825/1*Pu2ML5XbSihSxOqLloTfGg.gif' />

## Using common screenOptions to modify header styles

You can use the prop `screenOptions` to apply common styles to the header across the navigator. For example, in the code snippet, below, let us set two properties, `headerStyle`, `headerTintColor` and `headerTitleStyle` to change the background color of all screen headers as well as the color of the title on each screen.

```js
<Stack.Navigator
  initialRouteName="Home"
  screenOptions={{
    gestureEnabled: true,
    headerStyle: {
      backgroundColor: '#101010'
    },
    headerTitleStyle: {
      fontWeight: 'bold'
    },
    headerTintColor: '#ffd700'
  }}
>
  {/* ... */}
</Stack.Navigator>
```

The `headerStyle` is a style object that can be used to set the `backgroundColor` of the header for the screen component.

The `headerTitleStyle` is another style object that allows you to customize the title or the text of the header.

The `headerTintColor` is the color property for both the back button and the title of the header.

Here is the output in action after the above changes:

<img src='https://miro.medium.com/max/825/1*Xyt-C0u-SN151ybZTiD6Bw.gif' />

## Making the back button title invisible on iOS

So far, you must have noticed that on iOS the back button shows the name of the previous screen by default. On Android, this behavior is only shown by a back button icon.

To make an iOS app just to show the back button icon instead of the name of the previous screen in the stack, add the following property to `screenOptions` on `Stack.Navigator`.

```js
<Stack.Navigator
  initialRouteName="Home"
  screenOptions={{
    gestureEnabled: true,
    headerStyle: {
      backgroundColor: '#101010'
    },
    headerTitleStyle: {
      fontWeight: 'bold'
    },
    headerTintColor: '#ffd700',
    headerBackTitleVisible: false
  }}
>
  {/* ... */}
</Stack.Navigator>
```

Here is the output:

<img src='https://miro.medium.com/max/825/1*2v_4y5qgHX89sDGEyr326A.gif' />

## Understanding header modes and changing it in the Android app

Using the react-navigation library, there are three header modes available that render the header in different ways. By default on iOS, the `headerMode` is of the value of `float`.

On Android, the value `screen` is commonly used. These are the native patterns of how a header renders on each platform. The last header mode value is `none` which abolishes any header to render.

Take a look at the below demo of how it differs on both platforms.

<img src='https://miro.medium.com/max/825/1*4VtcuE-YrenIvI8NcaLQ6w.gif' />

In the section, let us make the header mode of the Android app behave in the same way as the iOS app. Just add the property `headerMode` with the value of `float` in `Stack.Navigator`.

```js
<Stack.Navigator
  initialRouteName="Home"
  screenOptions={{
    gestureEnabled: true,
    headerStyle: {
      backgroundColor: '#101010'
    },
    headerTitleStyle: {
      fontWeight: 'bold'
    },
    headerTintColor: '#ffd700',
    headerBackTitleVisible: false
  }}
  headerMode="float"
>
  {/* ... */}
</Stack.Navigator>
```

The header in the Android app, when navigating from one screen to another, is going to stay fixed, just link in the iOS app.

<img src='https://miro.medium.com/max/825/1*oKb19-8G5_fBf-SGz6_dGw.gif' />

## Directly navigating from the third screen to the top of the stack screen navigator

In this section, let us create a small demo on how you can leverage a helper method from `navigation` prop to navigate back to the top or first screen in the stack navigator from any other screen in navigator's structure, no matter how deep.

Start by creating a new file called `Settings.js` inside the `src/screens/` directory and the following component snippet.

```js
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';

function Settings() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Settings</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  }
});

export default Settings;
```

Next, modify the `MainStackNavigator.js` file and import a new screen.

```js
import Settings from '../screens/Settings';
```

Add this newly imported screen to the current `Stack.Navigator`.

```js
<Stack.Screen
  name="Settings"
  component={Settings}
  options={{ title: 'Settings' }}
/>
```

Open, `Detail.js` and modify it to add a button. When this button is pressed, the navigator leads to the Settings screen.

```js
import React from 'react';
import { StyleSheet, View, Text, TouchableOpacity } from 'react-native';

function Detail(props) {
  const { route, navigation } = props;
  const { item } = route.params;
  const { name, home, species } = item;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Detail Screen</Text>
      <View style={styles.card}>
        <Text style={styles.cardText}>Name: {name}</Text>
        <Text style={styles.cardText}>Home Planet: {home}</Text>
        <Text style={styles.cardText}>Species: {species}</Text>
      </View>
      <TouchableOpacity
        style={styles.buttonContainer}
        onPress={() => navigation.navigate('Settings')}
      >
        <Text style={styles.buttonText}>Go to Settings</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  },
  card: {
    width: 350,
    height: 100,
    borderRadius: 10,
    backgroundColor: '#101010',
    margin: 10,
    padding: 10,
    alignItems: 'center'
  },
  cardText: {
    fontSize: 18,
    color: '#ffd700',
    marginBottom: 5
  },
  buttonContainer: {
    backgroundColor: '#222',
    borderRadius: 5,
    padding: 10,
    margin: 20
  },
  buttonText: {
    fontSize: 20,
    color: '#fff'
  }
});

export default Detail;
```

In the following demo, you are going to notice that to move back from Settings screen to Home screen, you have to pass through the Detail screen.

<img src='https://miro.medium.com/max/825/1*hNtPWfht4_b3uer51fGrTA.gif' />

However, using the helper method `navigation.popToTop()` without any arguments, you can navigate from Settings screen to the Home screen directly.

To accomplish this, modify the `Settings.js` file as below by adding a button. The `onPress` of this button is going to make use of the helper method.

```js
import React from 'react';
import { StyleSheet, View, Text, TouchableOpacity } from 'react-native';

function Settings(props) {
  const { navigation } = props;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Settings</Text>
      <TouchableOpacity
        style={styles.buttonContainer}
        onPress={() => navigation.popToTop()}
      >
        <Text style={styles.buttonText}>Go to Home</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebebeb'
  },
  text: {
    color: '#101010',
    fontSize: 24,
    fontWeight: 'bold'
  },
  buttonContainer: {
    backgroundColor: '#222',
    borderRadius: 5,
    padding: 10,
    margin: 20
  },
  buttonText: {
    fontSize: 20,
    color: '#fff'
  }
});

export default Settings;
```

Here is the demo:

<img src='https://miro.medium.com/max/825/1*IUWdHNEwH4bLtRzBwQ8yng.gif' />

## Conclusion

_Congratulations! Youâ€™ve completed this tutorial._

In this tutorial, we have discussed many strategies and properties that you can apply and implement in your Stack navigator. The main objective is to get familiar with the component-based configuration of the Stack Navigator in the latest version of the `react-navigation` library.

Here is the link to the complete Stack Navigator API [here](https://reactnavigation.org/docs/en/stack-navigator.html) I'd recommend you to check.

[Source code](https://github.com/amandeepmittal/react-native-examples/tree/master/reactnav5-stack-navigator)

Originally published at [Heartbeat.fritz.ai](https://heartbeat.fritz.ai/getting-started-with-stack-navigator-using-react-navigation-5-in-react-native-and-expo-apps-4c516becaee1)

---

## Starting Over with React Native
Slug: starting-over-with-react-native

## Start of 2018Â ðŸš€

When 2018 arrived I decided to pick up a new framework called [React.js](https://reactjs.org/) to enhance my skillset and get more work done remotely. A day came when I was in the middle of React development that I got interested in [React Native](https://facebook.github.io/react-native/) which is used to develop cross-platform mobile applications and started playing around it. I wrote some articles on it, worked on a few mini projects, read about APIs in its official docs but then due to the load of work from my clients I had to stop in between for three months. I tried hard to continue to learn in my spare time but managing work along with a personal hobby blog (that is not a hobby anymore, I am professional book critic ðŸ˜… and it demands quite some hours in a week) I knew I was going to burn out.

Not to interfere with my day job, I completely stopped reading or doing any React Native stuff. I even deleted my precious Trello board, where I had saved plenty of resources from awesome developers out there who have already mastered the art of React Native and contributing for the community by building courses, writing tutorials, and so on.

> Lesson #1: Tech community runs because of these awesome people who spend countless hours in making things as understandable for a newbie or someone with intermediate skillset.

I did not even think twice before deleting it. How foolish of me! ðŸ˜­

## My Background ðŸ‘¨â€ðŸ’»

I have been in development for two years now. I am a Computer Science graduate and after a false start in my career, I started coding because I met Node.js while working on a project at that time. I was already familiar with HTML, CSS, and JavaScript before I entered the portal of programming heaven as a full-timer from my graduation days, had built two sites using them. Unfortunately, they do not continue to exist, had I known this at that time, I would have took some screenshots. They were hilarious as compared to modern day UIs. ðŸ˜†

I went online and studied various resources to understand Node.js and its ecosystem, then came across freeCodeCamp.org curriculum which helped me sharpen my existing skills and expand my knowledge in web development, especially front-end and gave me a direction. Met some awesome people along the way: [Quincy Larson](https://medium.com/u/17756313f41a), [Scott Spence](https://medium.com/u/cf8522762673), [Alexander Kallaway](https://medium.com/u/c852ec9b2c3d) to name some who motivated to continue this path and not alone altogether.

> Worked with them (and still maintaining) some awesome open source campaigns that you can find at freeCodeCampâ€™s Github! ðŸš€

## Starting OverðŸ“±

There comes a time in life when you are so obsessed with something that there comes a bright light that guides you to the door of your own obsession. Recently, someone wanted to collaborate on a project that needs to build a React Native app. I am not sure if I will get it but this time I have thought hard enough about not giving up like before and I think, whatever happens, I will try to hustle my way through it. Another lesson I have learned over the years that programming has taught me.

> Lesson #2: Be patient and keep on building things (practice)!

Without getting hands-on experience or building things even if they suck, as a coder you are not going to go anywhere. The more you code, the fewer things start to suck if you are open to enhancing your methods and ready to learn. This time I have a blueprint that I am going to follow and will continue to refer it here as I progress ahead in my journey.

> Lesson #3: Learning must neverÂ stop.

This is the biggest lesson I have learned in two years of being a professional developer and in general life.

_Why start with it now, you ask?_ I know companies like Udacity and AirBnb have recently announced that they will stop continuing building their own applications using React Native. Both of them did mention that React Native has its own limitations in a detailed manner. Every framework or library does. Nothing is perfect out there and I do not think there ever will be such a thing. These are all creation of mankind and we ourselves are not perfect so how can you expect to build something that is ðŸ’¯%. These organizations might have a different use case using this framework than a thousand other developers who are still using it. I do not know, neither do I care at this stage.

## Recommended Resources

For a start, I am currently going through [Spencer Carli](https://medium.com/u/1ec17560bf99)â€™s free courses on React Native. One teaches you [to build an app](https://learn.handlebarlabs.com/p/react-native-basics-build-a-currency-converter) and other teaches you to [organise your react native code](https://learn.handlebarlabs.com/p/how-to-set-up-a-new-react-native-project).

_Thank you reading this post. I know I havenâ€™t shared much about React Native which is the focus of this seres but consider this post as chance to explain my motive behind it. I will try to share as much as about my progress in this series of posts and hopefully they might help you in some way or the other. ðŸ™_

---

## Stash changes in a git repository with VS Code
Slug: stash-changes-with-vscode

`git stash` is a useful command that temporarily stores current changes in a Git repository without committing them, making it possible to return to them later.

## Stash using VS Code

Visual Studio Code (VS Code) is a highly capable code editor that offers many well-thought-out functionalities. Even after using it for years, I still find new things about it.

Using in-built **Source Control**, you can quickly view the modified files and temporarily save them by stashing them:

- In VS Code, go to the Source Control tab.
- Click the three-dotted menu (`...`) next to Source Control to open a dropdown menu.
- In the menu, select **Stash** > **Stash (Include Untracked)**.
- That's it. The file changes are now stashed locally.

![Stashing changes locally using VS Code](/images/stash-option-vscode.png)

## Bring the latest stashed changes to a branch

Let's assume you've now created a new branch where you want to bring those changes that are saved temporarily.

- In VS Code's Source Control, open the dropdown menu.
- Select **Stash** > **Apply Latest Stash**.

![Stashing changes locally using VS Code](/images/apply-stash-in-branch.png)

You can now bring those changes to the current branch and commit them.

## Conclusion

Stashing is particularly useful when you want to fix something and keep those changes around so you can return to them later. Collecting the stashed changes can result in a new branch, where local changes can be brought later.

---

## Styling The React Native Way
Slug: styling-the-react-native-way

> [Originally published at Level up coding on January 14, 2019.](https://levelup.gitconnected.com/styling-the-react-native-way-3cc6d3ef52d0)

React Native comes with many in-built components that you can use to style cross-platform applications. Styling a mobile application is essential. I cannot put enough emphasis on how important it is for a mobile app to have a pleasing design and good use of colors can be provide a better user experience. Without a polished user interface, a potential user will be repelled by the lack of design in the mobile app.

React Native uses plain JavaScript to style. In this tutorial, you are going to explore different ways to style a React Native app by getting some hands-on experience and learning tips along the way.

## Introduction

React Native uses JavaScript to style, if you have some experience with the CSS of the web, you know that styling a component is nothing more than writing code by using proper styling syntax. If you do not have any idea what CSS is, stop right here as there would be no advantage for you reading this tutorial. You need to understand a bit of CSS to continue reading the tutorial below. If you understand what `backgroundColor: 'blueâ€™` means, then you are good to go.

React Native comes in with many built-in components. Each having its own specific set of styles. These specific styles may or may not be applicable to other components.

For example, `Text` component supports `fontWeight` whereas a `View` component does not. However, some of the styles are similar but not exactly the same. `View` supports `shadowColor` while `Text` supports `textShadowColor`. Lastly, you have to make note that there are a few platform-specific styles such as `shadowPropTypesIOS`.

## Different Ways to Style a React NativeÂ App

There are different ways you can add styles to your React Native component. First one is **inline styling**. See the example below.

```js
// inline example
import React from 'react';
import { View, Text } from 'react-native';

export default function App() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'blue'
      }}
    >
      <Text style={{ color: 'white', fontSize: 32 }}>Some Text</Text>
    </View>
  );
}
```

The result of the above code of snippet is following.

![ss1](https://i.imgur.com/GHvCHh4.png)

In the post [**Getting Started with React Native in 2019**](https://amanhimself.dev/getting-started-with-react-native-in-2019-build-your-first-app/), I've described about `StyleSheet` object. It is the second way.

Available from React Native API, by importing and using `StyleSheet`, you create an object and refer to each style individually. This brings the separation of styles from the render method and helps you organize the code. Also, it promotes re-using styles across components.

```js
// StyleSheet Example
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.bigText}>Some Text</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'blue'
  },
  bigText: {
    color: 'white',
    fontSize: 32
  }
});
```

This snippet of code will have the same effect on rendering on a mobile device. The only thing changed here is being separation of styles inside the component `App` with `StyleSheet` object. It takes a JavaScript object as it does above, and returns a new `Stylesheet` object from it. There are no classes or ids in React Native like in web development.

**To create a new style object you use** `StyleSheet.create()` **method. Another advantage this way of styling React Native components** hold is that when creating a new style object every time, `StyleSheet` helps to create style objects with an ID which is further used to reference instead of rendering the whole component again.

Another difference comes with **inline** styling is that an inline style property name, if misspelled, does not work and there is no error thrown for the misspelling.

![ss2](https://i.imgur.com/065jq9Y.png)

However there is a valid style property check when styles are defined using `StyleSheet.create()`.

![ss3](https://i.imgur.com/pM0LktI.png)

![ss4](https://i.imgur.com/0iAFAvZ.png)

## Encapsulation ofÂ Styles

In React Native, styles are scoped to the component rather than the whole application. You have seen one preferred way of defining styles used commonly by the React Native community.

Another way to define styles is to organize your application code in such a way that it becomes easier to keep track of them when refactoring, or when the application starts to expand. In this second way, you declare all the styles related to a component in a separate file. Then import that styles file inside the component file. Here is an example for you. Create a new file next to the `App.js` called `AppStyles.js`.

```js
// AppStyles.js
import { StyleSheet } from 'react-native';

export default StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'blue'
  },
  bigText: {
    color: 'white',
    fontSize: 32
  }
});
```

Next step is to import this file inside `App.js`.

```js
//App.js
import React from 'react';
import { View, Text } from 'react-native';

import styles from './AppStyles';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.bigText}>Some Text</Text>
    </View>
  );
}
```

The demo runs and produces the same result as before. This separation of styles in a file other than the component file has its own advantages. It increases the reusability of other style objects.

## Using arrays to passÂ styles

In inline styling, you must have observed that it is nothing but an object that starts with a `style` prop and an object is passed with key-value pairs. Similarly, you can use an array that can contain multiple key-value pairs as the value of the `style` prop.

```js
import React, { Component } from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={[styles.bigText, styles.textYellow]}>Some Text</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'blue'
  },
  bigText: {
    color: 'white',
    fontSize: 32
  },
  textYellow: {
    color: 'yellow'
  }
});
```

The following is the result for the above snippet.

![ss5](https://i.imgur.com/GHvCHh4.png)

Do notice that, the last style passed in overrides the previous style when there is a duplicate `color` property.

## Building an App: Dark/Light Themes

In this section, you are going to build a simple app called **light/dark mode** toggle. It contains a button with some text with a dark background of its own and a light colored background. When the user clicks the button, the background of the app changes to dark mode and the text on the button changes to light mode.

First, let us define styles for it. Open `AppStyles.js` the external styling file.

```js
import { StyleSheet } from 'react-native';

const Colors = {
  light: 'white',
  dark: 'black'
};

const baseContainer = {
  flex: 1,
  justifyContent: 'center',
  alignItems: 'center'
};

const buttonBorderContainer = {
  justifyContent: 'center',
  alignItems: 'center',
  borderWidth: 3,
  height: 50,
  width: 150
};

const lightStyles = StyleSheet.create({
  container: {
    ...baseContainer,
    backgroundColor: Colors.light
  },
  button: {
    ...buttonBorderContainer,
    backgroundColor: Colors.dark
  }
});

const darkStyles = StyleSheet.create({
  container: {
    ...baseContainer,
    backgroundColor: Colors.dark
  },
  button: {
    ...buttonBorderContainer,
    backgroundColor: Colors.light
  }
});

export default function useTheme(darkTheme) {
  return darkTheme ? darkStyles : lightStyles;
}
```

A lot is going on here. First, the two different color variables are defined inside a single `Colors` object. Then, there are two different container objects, one for the background and one for the button.

Both of these container objects then re-used inside the StyleSheet objects, `lightStyles` and `darkStyles`. Similarly, to define the background color, we make re-use of the color object such that we do not have to write the value of each color twice.

Lastly, there is a function that gets exported that returns theme based upon a boolean value. Dark Themeâ€™s value `darkStyles` is returned if its true otherwise light theme is returned.

The file `AppStyles.js` is a clear representation of structuring styles in a React Native app. This file is then imported inside the `App.js` that has the following content.

```js
import React, { useState } from 'react';
import { View, Button } from 'react-native';

import useTheme from './AppStyles';

export default function App() {
  const [darkTheme, setDarkTheme] = useState(false);
  const styles = useTheme(darkTheme);

  const toggleTheme = () => {
    setDarkTheme(!darkTheme);
  };

  return (
    <View style={styles.container}>
      <View style={styles.button}>
        <Button title={'Click Me'} onPress={toggleTheme} />
      </View>
    </View>
  );
}
```

By defining the state, you can declare the default value of the dark theme to be false such as it allows the light theme to be the default. `toggleTheme` is the method that reverses the boolean value for the dark theme accordingly. Next, inside the `render()` you are passing the current value of dark theme from the state. This function is then used to apply the correct theme or set of styles based on the boolean value.

You can see this in action below.

![ss6](https://i.imgur.com/uEQLG9f.gif)

- You can find the complete code for the example at [this Expo Snack](https://snack.expo.io/@amanhimself/38e20d).
- A big thank you to [Catalin Miron](https://x.com/mironcatalin) for proof reading it ðŸ¤—

**Resources & Further Reading:**

- If you are looking for some insight on how to hire a React Native dev, Toptal.com has an [awesome guide here](https://www.toptal.com/react-native#hiring-guide).

---

## How to use multiple iOS simulators at once with Expo CLI
Slug: switch-between-ios-simulators

Opening a React Native app created with Expo in an iOS simulator is a common developer task. By default, the app opens in the last used iOS simulator. In my case, I frequently use the iPhone 17 Pro simulator right now which runs iOS 26 version.

Sometimes, I also want to open the app in another iOS simulator. For example, working on the[ previous blog post](/blog/large-header-title-in-expo-router/), I wanted to observe and simultaneously show how large header titles and native tabs work on iOS 26 and iOS 18. Some of other use cases would be to test other platform-specific behavior across different iOS versions, comparing layouts between different screen sizes, and so on.

Usually, the first option that my mind goes to is to go through the Simulator app menu bar and select **Simulator > Open Simulator > iOS 18.0 > iPhone 16 Pro**, but there's a catch. If you're not using Expo Go or you've switched to development builds, getting your app running on both simulators becomes tedious.

There's a better way. Expo CLI has a built-in option that makes this trivial. It's one of those small CLI features that time once you know it exists.

When you run the `npx expo start` command, you must have seen the familiar developer server output:

<img src="/images/ios-simulators/ss1.png" width="480" />

Pressing `i` from the keyboard opens your most recently used iOS simulator. But here's the trick I was missing. Pressing `?` will bring all available options. Once those options are exposed in the terminal window, you'll notice `shift + i` lets you selected a specific behavior:

<img src="/images/ios-simulators/ss2.png" width="480" />

Press `shift + i`, and Expo CLI presents a searchable list of every simulator you have configured:

<img src="/images/ios-simulators/ss3.png" width="480" />

Select your target device, and Expo CLI will launch it and install your app automatically. No manual steps necessary.

---

## Tag gardening
Slug: tag-gardening

<!-- vale off -->

I recently came across Karl Voit's blog post about the concept of [tag gardening](https://karl-voit.at/2021/01/02/tag-gardening-publicvoit/). He uses this process to trim down the various tags he uses and provides explanation on the decision he took during the cleanup.

His blog post served as a timely reminder of why I should clean up some of the [tags](/tags/) from my blog. I wrote this post to appreciate Karl's efforts and share my thoughts on the topic.

<!-- vale on -->

## What is tag gardening?

According to Karl, tag gardening is a practice of cleaning up the chaos that can result from having too many tags on a blog, over a period of time.

## Best practice: limitation

Karl describes one best practice, which is:

> Limit the number of tags on a blog.

Recently, I refactored my blog to migrate from Next.js to Astro and I noticed that I had a lot of tags. I've never done a tag refactor before and I could see having excessive tags creates a clutter.

I consider tags an integral part of any blog. They easily allow us to navigate and explore a topic of interest deeply by finding related posts written on the same blog.

Limiting the number of tags on a blog is something I've started advocating for on my blog as well.

### Technique to trim down tags

Before writing this post, my blog had 21 tags. To manage this tag cloud, I've done the following:

- Delete the tags that are no longer in use or used only once
- Merge tags that overlap or are similar in nature

### Delete singular tags

<img src="/images/tag-gardening/ss2.png" alt="Cloud of tags before writing this post" class="sm:w-3/3 mx-auto"/>

The above image illustrates the tag cloud before performing the act of trimming them down. Tags such as `#conference`, `#devrel`, and `#writing`, each have one post and the situation hasn't changed since I created them. Currently, I'm not planning to write anything that may fall under those tags so I decided to group them under an existing tag called `#notes`.

I use `#notes` as a general purpose tag where I can share thoughts without focusing on technical details, unlike other tags on my blog.

<img src="/images/tag-gardening/ss1.png" alt="Notes tag highlighted in the tag cloud" class="sm:w-3/3 mx-auto"/>

Another example is about the posts I've written on specific tools I use. I started creating individual tags for each tool so it would be easier to find more posts about them on my blog. Having each tool as a separate tag made sense since I was writing multiple posts about each tool. Some of these tags are `#vscode`, `#xcode`, and `#obsidian`.

After a while, I created a `#tools` tag that included posts about other topics such as writing about my [macbook setup](/blog/macbook-setup-2024/) or the [default apps](/blog/default-apps-2023/) I use. Since this tag was used in a generic way, I found myself repeating topics. To categorize them clearly, now I've created a `#macos` individual tag and rest of the unrelated topics, I've moved them under `#notes`.

This time I had to divert from the practice a bit to create a new tag.

## Tags cloud now

At the time of writing this post, my blog has 18 tags. Four tags deleted, and one new tag added.

<img src="/images/tag-gardening/ss3.png" alt="Notes tag highlighted in the tag cloud" class="sm:w-3/3 mx-auto"/>

## Best practice: use plural forms

Karl suggests using plural forms when creating tags:

> ...singular form contradicts the common convention of using the plural form of tags.

This practice doesn't apply to specific tags like "vscode" or "xcode". It only applies to the general terms such as:

- notes
- year-reviews
- tools (the previous generic tag I had on my blog)

I previously used `#year-review` as a tag for my yearly review posts. Following Karl's advice, I changed it to [`#year-reviews`](/tags/year-reviews/) since I have multiple posts under this category.

## Summary

Over the years while maintaining this blog, I've thought a lot about using tags effectively. I never encountered a concrete example and practice as a **tag gardening**. Karl's post inspired me to and helped me manage the emerging chaos of tags on my blog. I'll continue to nurture this garden.

---

## Tamagui for React Native: Create faster design systems
Slug: tamagui-for-react-native

> Originally Published at [Blog.Logrocket.com](https://blog.logrocket.com/tamagui-react-native-create-faster-design-systems/) on December 24, 2021.

> **Update (6 November, 2023)**: This post is outdated. See [Tamagui documentation](https://tamagui.dev/docs/intro/installation) for up to date information.

The React Native system is gradually progressing towards solutions for sharing code between React Native and React Native web applications.

One recent addition to the React Native ecosystem is [Tamagui](https://tamagui.dev), a UI kit that includes a series of themes, media queries, and typed inline styles, as well as an optimizing compiler. Tamagui aims to close the gap between React Native and React Native web applications by covering the foundational elements of an app, like styling, theming, and providing cross-platform components, all while keeping the appâ€™s performance in mind.

In this article, weâ€™ll learn how to configure Tamagui in a React Native app and a React Native Web app, checking out the components it offers in its current state. Letâ€™s get started!

## Create a new React Native app

Weâ€™ll start by creating a new React Native project using [Expo CLI](https://docs.expo.dev/workflow/expo-cli/), which enhances the developer experience with tools in the React Native ecosystem, for example, a variety of templates. Choosing one of these templates is a great starting point for the demo app weâ€™ll build in this tutorial. Open up a terminal window and execute the following command:

```shell
npx expo init tamagui-app
# after the project directory is created, navigate inside it
cd tamagui-app
```

On running the command, youâ€™ll be prompted to choose a template. Choose `blank (TypeScript)`. It will create a project with minimal TypeScript configuration.

## Installing dependencies

After navigating inside the project directory, weâ€™ll install the libraries required to configure Tamagui inside a React Native project. But first, run the following command from the terminal:

```shell
yarn add tamagui@1.0.0-alpha.37 @tamagui/babel-plugin@1.0.0-alpha.37
```

Since Tamagui is still in its alpha release, I'm using specific package versions. However, when a more stable version is released in the future, this may change. Be sure to refer to the [official documentation](https://tamagui.dev/docs/intro/installation) for the most up to date information on installing dependencies.

`tamagui` is the UI kit, and `@tamagui/babel-plugin` is the babel plugin that loads the design system properties defined inside another file called `tamagui.config.ts`. Youâ€™ll need to create this file in the root of your project, but you can leave it blank for now. Weâ€™ll return to it later.

The `@unimodules/core` dependency is required by the Tamagui UI kit to work with an Expo project. Open the terminal window and execute the following command:

```shell
expo install @unimodules/core
```

Next, we need to install dev dependencies to use Tamagui with Expo web. Open the terminal window and execute the command below:

```shell
yarn add -D @expo/webpack-config@0.16.14 esbuild-loader@2.17.0 tamagui-loader@1.0.0-alpha.37 thread-loader@3.0.4
```

As before, we've installed packages with specific versions. In the `package.json` file, youâ€™ll find the following summary of dependencies and dev dependencies that we installed:

```json
{
  "dependencies": {
    "@tamagui/babel-plugin": "^1.0.0-alpha.37",
    "@unimodules/core": "~7.2.0",
    "expo": "~43.0.2",
    "expo-status-bar": "~1.1.0",
    "react": "17.0.2",
    "react-dom": "17.0.2",
    "react-native": "0.64.3",
    "react-native-web": "0.17.5",
    "tamagui": "^1.0.0-alpha.37"
  },
  "devDependencies": {
    "@babel/core": "^7.12.9",
    "@types/react": "~17.0.21",
    "@types/react-native": "~0.66.6",
    "typescript": "~4.5.2",
    "@expo/webpack-config": "^0.16.14",
    "esbuild-loader": "^2.17.0",
    "tamagui-loader": "^1.0.0-alpha.37",
    "thread-loader": "^3.0.4"
  }
}
```

Now that our dependencies are installed, add `@tamagui/babel-plugin` to the `babel.config.js` file:

```js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        '@tamagui/babel-plugin',
        {
          components: ['tamagui'],
          config: './tamagui.config.ts'
        }
      ]
    ]
  };
};
```

In the code snippet above, ensure that the path defined for `config` is the relative path to the Tamagui config file. `components` contains an array of npm modules containing Tamagui components. For this example app, we're using Tamagui base components. Therefore, we don't need to add any further configuration.

## Setting up Tamagui configuration

Tamagui lets you create themes, define tokens, add shorthands, and more. However, it requires you to describe all the properties and set up the foundation of a design system before you dive into building the components for your React Native app.

To set up the required Tamagui configuration, weâ€™ll use the `createTamagui` function. Weâ€™ll need to define the following:

- `tokens`: Generate variables in `theme` and `app`
- `media`: Defines reusable responsive media queries
- `themes`: Defines your design theme
- `shorthands`: Allows you to define keys that expand the `style value` props. For example, you can define `f` for flex, `ai` for `alignItems`, `jc` for `justifyContent`, and so on.

You can start setting up the configuration with the `size` and `space` properties. Weâ€™ll also need `defaultFont` using the `createFont` function with a configuration object that contains values for font `family`, `size`, `lineHeight`, `fontWeight`, and `letter spacing`.

All of the values above are used inside of the `createTokens` function, which allows you to create tokens, or the variables mapped to CSS variables at build time. The `createTokens` function requires the `size `, `space`, `font`, `color`, `radius`, and `zIndex` properties in its configuration object.

The code block below contains a minimal configuration that I've created for the demo app with all of the required properties:

```ts
import { createFont, createTokens, createTamagui } from 'tamagui';
const size = {
  0: 0,
  1: 4,
  2: 8
};
const space = {
  ...size,
  '-0': -0,
  '-1': -5
};
const defaultFont = createFont({
  family: 'Arial',
  size: {
    1: 14,
    2: 18,
    3: 22
  },
  lineHeight: {
    1: 15,
    2: 20
  },
  weight: {
    4: '300',
    7: '600'
  },
  letterSpacing: {
    4: 0,
    7: -1
  }
});
const tokens = createTokens({
  size,
  space,
  font: {
    title: defaultFont,
    body: defaultFont
  },
  color: {
    lightPurple: '#EDD2F3',
    darkPurple: '#544179'
  },
  radius: {
    0: 0,
    1: 3,
    2: 5,
    3: 10,
    4: 15,
    5: 20
  },
  zIndex: {
    0: 0,
    1: 100,
    2: 200,
    3: 300,
    4: 400,
    5: 500
  }
});
const shorthands = {
  ai: 'alignItems',
  bg: 'backgroundColor',
  br: 'borderRadius',
  f: 'flex',
  h: 'height',
  jc: 'justifyContent',
  m: 'margin',
  p: 'padding',
  w: 'width',
  lh: 'lineHeight',
  ta: 'textAlign'
} as const;
const media = {
  xs: { maxWidth: 660 },
  gtXs: { minWidth: 660 + 1 },
  sm: { maxWidth: 860 },
  gtSm: { minWidth: 860 + 1 },
  md: { minWidth: 980 },
  gtMd: { minWidth: 980 + 1 },
  lg: { minWidth: 1120 },
  gtLg: { minWidth: 1120 + 1 },
  xl: { minWidth: 1280 },
  xxl: { minWidth: 1420 },
  short: { maxHeight: 820 },
  tall: { minHeight: 820 },
  hoverNone: { hover: 'none' },
  pointerCoarse: { pointer: 'coarse' }
};
const config = createTamagui({
  defaultTheme: 'light',
  shorthands,
  media,
  tokens,
  themes: {
    light: {
      bg: tokens.color.lightPurple
    }
  }
});
type Conf = typeof config;
declare module 'tamagui' {
  interface TamaguiCustomConfig extends Conf {}
}
export default config;
```

## Using Tamagui Provider

Tamagui configuration provides a [Tamagui.Provider](https://tamagui.dev/docs/intro/configuration#add-provider) component that wraps all the other components inside your app:

```tsx
import React from 'react';
import Tamagui from './tamagui.config';
export default function App() {
  return <Tamagui.Provider>{/* The rest of your app here */}</Tamagui.Provider>;
}
```

## Tamagui views, utility props, and shorthands

In Tamagui, stacks are the core view elements for creating flex-based layouts. There are three different types of stacks available, `XStack`, `YStack`, and `ZStack`, and each implies a different axis.

In the example below, the `defaultTheme` takes the value of the theme you've defined in the config file. The `XStack` uses several shorthands; for example, `f` stands for `flex`, `ai` for `alignItems`, `jc` for `justifyContent`, and `bg` for `backgroundColor`.

The value of the `$bg` prop is also coming from the config file, where weâ€™ve explicitly defined that the `bg` property for the `light` theme should have a particular color value. The value of `space` on the `YStack` is set to `$2` from the config file itself:

```tsx
import { StatusBar } from 'expo-status-bar';
import React from 'react';
import { YStack, Text, XStack } from 'tamagui';
import Tamagui from './tamagui.config';
export default function App() {
  return (
    <Tamagui.Provider defaultTheme="light">
      <StatusBar style="dark" />
      <XStack f={1} ai="center" jc="center" bg="$bg">
        <YStack space="$2">
          <Text fontSize={20} marginBottom={20}>
            Tamagui
          </Text>
          <Text fontSize={20}>Tamagui</Text>
        </YStack>
      </XStack>
    </Tamagui.Provider>
  );
}
```

You can further define shorthands for properties like `margin`, `marginBottom`, and `padding` and use them as utility props on components, giving you more control over your styles and themes, as seen in the following example

![ss1](https://i.imgur.com/kZX0PQk.png)

## Making Tamagui work on the web

Now, weâ€™ll take advantage of the `@expo/webpack-config` package that we installed earlier, which is used to create a custom webpack configuration. When running the `expo start --web` command, the Expo CLI checks whether the project has a custom webpack configuration in the root directory. If the project does not have a custom webpack configuration, Expo uses the default configuration.

To create our custom webpack configuration, weâ€™ll first run the following command from a terminal window, which will create a `config` file for you to customize the webpack configuration. When you run this command, youâ€™ll be prompted to choose from several options. Select the `webpack.config.js` option:

```shell
expo customize:web
```

Next, add the custom configuration to the `webpack.config.js` file, as recommend by the [Tamagui documentation](http://(https://tamagui.dev/docs/intro/installation). The configuration will allow us to run `tamagui-loader` on the web:

```js
const createExpoWebpackConfigAsync = require('@expo/webpack-config');
module.exports = async function (env, argv) {
      const config = await createExpoWebpackConfigAsync(env, argv);
      // Customize the config before returning it.
      // add TAMAGUI_TARGET = web to defines
      const DefinePlugin = config.plugins.find(
        x => x.constructor.name === 'DefinePlugin'
      );
      DefinePlugin.definitions\['process.env'\]['TAMAGUI_TARGET'] = `"web"`;
      // replace babel-loader with our snackui + esbuild loaders
      const rules = config.module.rules[1].oneOf;
      const ruleIndex = rules.findIndex(x =>
        x.use?.loader?.includes('babel-loader')
      );
      rules[ruleIndex] = {
        test: /\.(mjs|[jt]sx?)$/,
        use: [
          'thread-loader',
          {
            loader: require.resolve('esbuild-loader'),
            options: {
              loader: 'tsx',
              target: 'es2019',
              keepNames: true
            }
          },
          {
            loader: require.resolve('tamagui-loader'),
            options: {
              config: './tamagui.config.ts',
              components: ['tamagui']
            }
          }
        ]
      };
      return config;
};
```

After adding the configuration, execute the command `yarn web` or `expo start --web`.
Youâ€™ll get the following output at `http://localhost:19006/`:

![ss2](https://i.imgur.com/jlLUyaX.png)

## Responsive styles using media queries

You can incorporate media queries directly in the UI elements of your app. After defining your media queries in the `tamagui.config.ts` file, youâ€™ll use a Hook called `useMedia` provided by the library:

```tsx
import { YStack, Text, XStack, useMedia } from 'tamagui';
```

Now, let's add a background color to `YStack`. The color value will vary on the screen's minimum width using the media query `md: { minWidth: 980 }`.

In the code snippet below, the `backgroundColor` value is set to `yellow` if the screen width is less than `980`, otherwise, it's set to `red`:

```tsx
export default function App() {
  const media = useMedia();
  return (
    <Tamagui.Provider defaultTheme="light">
      <StatusBar style="dark" />
      <XStack f={1} ai="center" jc="center" bg="$bg">
        <YStack
          space="$2"
          width={200}
          height={100}
          p={10}
          bg={media.md ? 'red' : 'yellow'}
        >
          <Text fontSize={media.md ? 32 : 18} marginBottom={20}>
            Tamagui
          </Text>
          <Text fontSize={20}>React Native</Text>
        </YStack>
      </XStack>
    </Tamagui.Provider>
  );
}
```

You can check out the following example:

![ss3](https://i.imgur.com/LpckfEH.png).

Similarly, the `fontSize` property also changes based on the media query, as seen in the example:

![ss4](https://i.imgur.com/InzeIX3.gif)

## Conclusion

Although Tamagui is still in its [alpha release](https://tamagui.dev/docs/intro/releases), it provides [benchmarks](https://tamagui.dev/docs/intro/benchmarks) over other UI kits in the React Native space that support web and outperforms them. In this tutorial, we took a first look at Tamagui, learning the best way to configure it for different use cases.

As a developer, I'll be keeping a close eye on Tamaguiâ€™s development and growth. The idea of creating a custom design system from scratch to support both native and web platforms is both fascinating and useful. I hope you enjoyed this tutorial!

---

## Obsidian as a task manager doesn't work for me
Slug: task-management-with-obsidian-doesnt-work

I have been using Obsidian for more than a year to take notes of all sorts (meetings, work, personal, long-form writing, blog drafts, and so on). It provides a distraction-free environment to write drafts and do long-form writing, but I couldn't get the hang of it as my daily task manager.

I used to maintain an Inbox directory to capture everything (work and personal tasks). The list grew over time. I also used [Obsidian Tasks](<[https://github.com/obsidian-tasks-group/obsidian-tasks](https://github.com/obsidian-tasks-group/obsidian-tasks)>) plugin, which has modern-day app equivalent features of managing a task such as adding a due date, recurring date, setting priorities, checking the task as done or canceled, scheduling it, and more.

It worked fine, but it was overwhelming for me. Things got complicated quickly. The UI was boring, and since I don't use Obsidian Sync with my iOS device, it lost the point to capture everything/brain dump.

I ended up moving to the Things 3 app and a couple of good old friends &mdash; pen and paper. I won't do a second attempt at Obsidian since both Things 3 and paper work for my brain and help me with reminders and retention. I have used Things 3 just for work in my previous job, so it is not a new app that comes with a learning curve.

I'll still keep using Obsidian as my personal knowledge storage system and for long-form writing.

---

## Image Classification on React Native with TensorFlow.js and MobileNet
Slug: tensorflow-image-classification-expo

Recently, the alpha version [Tensorflow.js](https://www.tensorflow.org/js/) for React Native and Expo applications was released. It currently provides the capabilities of loading pre-trained models and training. Here is the announcement tweet:

> [Tweet](https://x.com/tensorflow/status/1169309153715732480?lang=en)

TensorFlow.js provides many [pre-trained models](https://github.com/tensorflow/tfjs-models) that simplify the time-consuming task of training a machine learning model from scratch. In this tutorial, we are going to explore [Tensorflow.js](https://www.tensorflow.org/js/) and the MobileNet pre-trained model to classify image based on the input image provided in a React Native mobile application.

Here is the link to the complete code in a [Github repo](https://github.com/amandeepmittal/mobilenet-tfjs-expo) for your reference.

## Requirements

- Nodejs >= 10.x.x install on your local dev environment
- `expo-cli`
- Expo Client app for Android or iOS, used for testing the app

## Integrating TFJS in an Expo app

To start and use the Tensorflow library in a React Native application, the initial step is to integrate the platform adapter. The module `tfjs-react-native` is the platform adapter that supports loading all major tfjs models from the web. It also provides GPU support using `expo-gl`.

Open the terminal window, and create a new Expo app by executing the command below.

```shell
expo init mobilenet-tfjs-expo
```

Next, make sure to generate Expo managed app. Then navigate inside the app directory and install the following dependencies.

```shell
yarn add @react-native-community/async-storage
@tensorflow/tfjs @tensorflow/tfjs-react-native
expo-gl @tensorflow-models/mobilenet jpeg-js
```

> _Note:_ If you are looking forward to using `react-native-cli` to generate an app, you can follow the clear instructions to modify `metro.config.js` file and other necessary steps, mentioned [here](https://github.com/tensorflow/tfjs/tree/master/tfjs-react-native).

Even though you are using Expo, it is necessary to install [async-storage](https://github.com/react-native-community/async-storage) as tfjs module depends on that.

## Testing TFJS that it is working

Before we move on, let us test out that the tfjs is getting loaded into the app before the app is rendered. There is an asynchronous function to do so, called `tf.ready()`. Open `App.js` file, import the necessary dependencies, and define an initial state `isTfReady` with a boolean false.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import * as tf from '@tensorflow/tfjs';
import { fetch } from '@tensorflow/tfjs-react-native';

class App extends React.Component {
  state = {
    isTfReady: false
  };

  async componentDidMount() {
    await tf.ready();
    this.setState({
      isTfReady: true
    });

    //Output in Expo console
    console.log(this.state.isTfReady);
  }

  render() {
    return (
      <View style={styles.container}>
        <Text>TFJS ready? {this.state.isTfReady ? <Text>Yes</Text> : ''}</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});

export default App;
```

Since the lifecycle method is asynchronous, it will only update the value of `isTfReady` to true when tfjs is actually loaded.

You can see the output in the simulator device as shown below.

<img src='https://miro.medium.com/max/300/1*Qc2DyJWJztezFuQ8JltDlw.png' />

Or in the console, if using the `console` statement as the above snippet.

<img src='https://miro.medium.com/max/319/1*0rmnFTDv6wAHCBdggIk8TA.png' />

## Loading Tensorflow model

Similar to the previous section, you can load the model being used in this app (_mobilenet_) is integrating or not. Loading a tfjs pre-trained model from the web is an expensive network call and will take a good amount of time. Modify the `App.js` file to load the MobileNet model. Start by importing the model.

```js
import * as mobilenet from '@tensorflow-models/mobilenet';
```

Next, add another property to the initial state.

```js
state = {
  isTfReady: false,
  isModelReady: false
};
```

Then, modify the lifecycle method.

```js
async componentDidMount() {
    await tf.ready()
    this.setState({
      isTfReady: true
    })
    this.model = await mobilenet.load()
    this.setState({ isModelReady: true })
}
```

Lastly, the display on the screen when the loading of the model is complete.

```js
<Text>
  Model ready?{' '}
  {this.state.isModelReady ? <Text>Yes</Text> : <Text>Loading Model...</Text>}
</Text>
```

When the model is being loaded, it will display the following message.

<img src='https://miro.medium.com/max/300/1*DIZZk1CMDLwnmq7XUq9TOA.png' />

When the loading of the MobileNet model is complete, you will get the following output.

<img src='https://miro.medium.com/max/300/1*hS5fFnGr4R_5Zuj9nHvtCg.png' />

## Asking user permissions

Now that both the platform adapter and the model are currently integrated with the React Native app, add an asynchronous function to ask for the user's permission to allow access to the camera roll. This is a mandatory step when building iOS applications using the image picker component from Expo.

Before, you proceed, run the following command to install all the packages provided by Expo SDK.

```shell
expo install expo-permissions expo-constants expo-image-picker
```

Next, add the following import statements in the `App.js` file.

```js
import Constants from 'expo-constants';
import * as Permissions from 'expo-permissions';
```

In the `App` class component, add the following method.

```js
getPermissionAsync = async () => {
  if (Constants.platform.ios) {
    const { status } = await Permissions.askAsync(Permissions.CAMERA_ROLL);
    if (status !== 'granted') {
      alert('Sorry, we need camera roll permissions to make this work!');
    }
  }
};
```

Lastly, call this asynchronous method inside `componentDidMount()`.

```js
async componentDidMount() {
    await tf.ready()
    this.setState({
      isTfReady: true
    })
    this.model = await mobilenet.load()
    this.setState({ isModelReady: true })

    // add this
    this.getPermissionAsync()
  }
```

## Convert a raw image into a Tensor

The application will require the user to upload an image from their phone's camera roll or gallery. You have to add a handler method that is going to load the image and allow the Tensorflow to decode the data from the image. Tensorflow supports JPEG and PNG formats.

In the `App.js` file, start by importing [`jpeg-js` package](https://www.npmjs.com/package/jpeg-js) that will be used to decode the data from the image.

```js
import * as jpeg from 'jpeg-js';
```

It decodes the width, height and the binary data from the image inside the handler method `imageToTensor` that accepts a parameter of the raw image data.

```js
imageToTensor(rawImageData) {
    const TO_UINT8ARRAY = true
    const { width, height, data } = jpeg.decode(rawImageData, TO_UINT8ARRAY)
    // Drop the alpha channel info for mobilenet
    const buffer = new Uint8Array(width * height * 3)
    let offset = 0 // offset into original data
    for (let i = 0; i < buffer.length; i += 3) {
      buffer[i] = data[offset]
      buffer[i + 1] = data[offset + 1]
      buffer[i + 2] = data[offset + 2]

      offset += 4
    }

    return tf.tensor3d(buffer, [height, width, 3])
  }
```

The `TO_UINT8ARRAY` array represents an array of 8-bit unsigned integers. the constructor method `Uint8Array()` is the [new ES2017 syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray). There are different types of typed arrays, each having its own byte range in the memory.

## Load and Classify the image

Next, we add another handler method `classifyImage` that will read the raw data from an image and yield results upon classification in the form of `predictions`.

The image is going to be read from a source and the path to that image source has to be saved in the `state` of the app component. Similarly, the results yield by this asynchronous method have to be saved too. Modify the existing state in the `App.js` file for the final time.

```js
state = {
  isTfReady: false,
  isModelReady: false,
  predictions: null,
  image: null
};
```

Next, add the asynchronous method.

```js
classifyImage = async () => {
  try {
    const imageAssetPath = Image.resolveAssetSource(this.state.image);
    const response = await fetch(imageAssetPath.uri, {}, { isBinary: true });
    const rawImageData = await response.arrayBuffer();
    const imageTensor = this.imageToTensor(rawImageData);
    const predictions = await this.model.classify(imageTensor);
    this.setState({ predictions });
    console.log(predictions);
  } catch (error) {
    console.log(error);
  }
};
```

The results from the pre-trained model are yield in an array. An example is shown below.

<img src='https://miro.medium.com/max/376/1*MIDSYfqejEkwyLO6SKkY9Q.png' />

## Allow user to pick the image

To select an image from the device's camera roll using the system's UI, you are going to use the asynchronous method `ImagePicker.launchImageLibraryAsync` provided the package `expo-image-picker`. Import the package itself.

```js
import * as Permissions from 'expo-permissions';
```

Next, add a handler method `selectImage` that will be responsible for

- let the image to be selected by the user
- if the image selection process is not canceled, populate the source URI object in the `state.image`
- lastly, invoke `classifyImage()` method to make predictions from the given input

```js
selectImage = async () => {
  try {
    let response = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.All,
      allowsEditing: true,
      aspect: [4, 3]
    });

    if (!response.cancelled) {
      const source = { uri: response.uri };
      this.setState({ image: source });
      this.classifyImage();
    }
  } catch (error) {
    console.log(error);
  }
};
```

The package `expo-image-picker` returns an object. In case the user cancels the process of picking an image, the image picker module will return a single property: `canceled: true`. f successful, the image picker module returns properties such as the `uri` of the image itself. Thatâ€™s why the `if` statement in the above snippet holds so much significance.

## Run the app

To complete this demonstration app, you need to add a touchable opacity where the user will click to add the image.

Here is the complete snippet of the `render` method in the `App.js` file.

```js
render() {
    const { isTfReady, isModelReady, predictions, image } = this.state

    return (
      <View style={styles.container}>
        <StatusBar barStyle='light-content' />
        <View style={styles.loadingContainer}>
          <Text style={styles.commonTextStyles}>
            TFJS ready? {isTfReady ? <Text>âœ…</Text> : ''}
          </Text>

          <View style={styles.loadingModelContainer}>
            <Text style={styles.text}>Model ready? </Text>
            {isModelReady ? (
              <Text style={styles.text}>âœ…</Text>
            ) : (
              <ActivityIndicator size='small' />
            )}
          </View>
        </View>
        <TouchableOpacity
          style={styles.imageWrapper}
          onPress={isModelReady ? this.selectImage : undefined}>
          {image && <Image source={image} style={styles.imageContainer} />}

          {isModelReady && !image && (
            <Text style={styles.transparentText}>Tap to choose image</Text>
          )}
        </TouchableOpacity>
        <View style={styles.predictionWrapper}>
          {isModelReady && image && (
            <Text style={styles.text}>
              Predictions: {predictions ? '' : 'Predicting...'}
            </Text>
          )}
          {isModelReady &&
            predictions &&
            predictions.map(p => this.renderPrediction(p))}
        </View>
        <View style={styles.footer}>
          <Text style={styles.poweredBy}>Powered by:</Text>
          <Image source={require('./assets/tfjs.jpg')} style={styles.tfLogo} />
        </View>
      </View>
    )
  }
}
```

Here is the list of the complete `styles` object.

```js
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#171f24',
    alignItems: 'center'
  },
  loadingContainer: {
    marginTop: 80,
    justifyContent: 'center'
  },
  text: {
    color: '#ffffff',
    fontSize: 16
  },
  loadingModelContainer: {
    flexDirection: 'row',
    marginTop: 10
  },
  imageWrapper: {
    width: 280,
    height: 280,
    padding: 10,
    borderColor: '#cf667f',
    borderWidth: 5,
    borderStyle: 'dashed',
    marginTop: 40,
    marginBottom: 10,
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center'
  },
  imageContainer: {
    width: 250,
    height: 250,
    position: 'absolute',
    top: 10,
    left: 10,
    bottom: 10,
    right: 10
  },
  predictionWrapper: {
    height: 100,
    width: '100%',
    flexDirection: 'column',
    alignItems: 'center'
  },
  transparentText: {
    color: '#ffffff',
    opacity: 0.7
  },
  footer: {
    marginTop: 40
  },
  poweredBy: {
    fontSize: 20,
    color: '#e69e34',
    marginBottom: 6
  },
  tfLogo: {
    width: 125,
    height: 70
  }
});
```

Run the application by executing the `expo start` command from a terminal window. The first thing youâ€™ll notice is that upon bootstrapping the app in the Expo client, it will ask for permissions.

<img src='https://miro.medium.com/max/300/1*yI8SE6c25GMpfSoqgethYg.png' />

Then, once the model is ready, it will display the text **"Tap to choose image"** inside the box. Select an image to see the results.

<img src='https://miro.medium.com/max/358/1*qxXtE5tU7yuuFKVKjQbIFg.gif' />

Predicting results can take some time. Here are the results of the previously selected image.

<img src='https://miro.medium.com/max/300/1*7yGIbTerLleJeSDUN5LW2A.png' />

## Conclusion

I hope this post serves the purpose of giving you a head start in understanding how to implement a TesnorFlow.js model in a React Native app, as well as a better understanding of image classification, a core use case in computer vision-based machine learning.

Since the TF.js for React Native is in alpha at the time of writing this post, we can hope to see many more advanced examples in the future to build real-time applications.
Here are some resources that I find extremely useful.

Here are some resources that I find extremely useful.

- [tfjs-react-native](https://github.com/tensorflow/tfjs/tree/master/tfjs-react-native) Github repo contain more examples using different pre-trained models
- Infinite Red's [NSFW JS and React Native example](https://shift.infinite.red/nsfw-js-for-react-native-a37c9ba45fe9)
- [Introduction to Tensorflow.js](https://medium.com/tensorflow/introducing-tensorflow-js-machine-learning-in-javascript-bf3eab376db)

You can find the complete code at this [Github repo](https://github.com/amandeepmittal/mobilenet-tfjs-expo).

Originally published at [Heartbeat.Fritz.ai](https://heartbeat.fritz.ai/image-classification-on-react-native-with-tensorflow-js-and-mobilenet-48a39185717c)

---

## The Node way - Philosophy of a Platform
Slug: the-node-way

Last week, when [Node.js](https://nodejs.org/en/blog/) community introduced its logo, it got me into thinking of why this technology as fresh in my mind as when I was first introduced to it a few months back. Why is that spark still ignited in the back of my head? The answer to this is the philosophy behind the technology of Node.js platform.

Every platform has its own philosophy, its own set of rules, its own principles and guidelines. This is necessary for the evolution of a platform and is important for developing an application using that platform. (Otherwise, we all can get carried away.) Node.js has its own philosophy, since its a platform, and it manages to find a middleground between JavaScript and UNIX.

Two of the most important principles of UNIX that are adaptable in Node.js are:

- Modularity, keeping simple parts short, connected with clean interfaces.
- A program should do one thing and it should do that awesomely.

Other rules described by Eric Steven Raymond in [The Art of UNIX Programming](http://www.catb.org/esr/writings/taoup/html/index.html) might fit to some extent but the two aforementioned are necessary to use Node.js pragmatically.

In Node.js this pragmaticism is provided the by a â€˜moduleâ€™. Module is the fundamental to structure the code of a program in Node.js. Module is also the building block of a package. (A package is any application or reusable libraries).

The principle here is to design small modules in terms of code and in terms of application scope. This principle provides:

- reusability of code
- easier to understand the code
- thus, making it simple to test and maintain

---

Another important aspect in the Node Philosophy is the dependency of each package. Writing a Node.js application, one tends to use a lot of packages (which is the genesis of Node.js Ecosystem: npm) and this might create a common problem known as: dependency hell. To overcome this conflict, Node.js manages dependencies of each installed package to have its own separate set of dependencies.

---

## Tips for Creating Nodejs REST APIs
Slug: tips-for-creating-node-js-rest-apis

> [Originally Published at Codeburst.io](https://codeburst.io/tips-for-creating-node-js-rest-apis-dfa0b2adb39c)

In this article, I am going to offer you some tips for writing REST APIs in Nodejs for a production level application. Writing RESTful APIs with Nodejs is one of the most popular use case using the JavaScript server side platform.

## Use HTTPÂ Methods

CRUD operations are basis of any API. In most applications you will be either:

- Creating new records
- Display them on a front end client aka reading a record from the database
- Updating an existing record
- Or deleting an existing record

Record here stands for anything that goes into the database. Afterall, an API is just way a to communicate from the user interface to database.

To develop an API that consist of CRUD operations, you must consider using correct HTTP method with the suitable endpoint:

- `POST /record` for creating a new record
- `PUT` or `PATCH /record/:id` for updating an existing record
- `GET /record/:id` getting a single record
- `GET /record` getting a list of all records
- `DELETE /record/:id` deleting a single existing record

## Use HTTP response status codes

You must consider using an HTTP status code if anything fails when serving a request.

- `2xx` if everything works fine
- `3xx` if record was moved
- `4xx` request fails due to client error
- `5xx` request fails due to server error (or API)

You can refer to either of these links for a detailed error code and message along with it.

- [HTTP Status Codes](http://www.restapitutorial.com/httpstatuscodes.html)
- [Mozilla HTTP Response Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

If using Express, most commonly framework used with Nodejs to create APIs, consider writing your code in this format:

```js
// in case 5xx
res.status(500).send({ error: 'Internal Server Error.' });

// in case 4xx, unauthorized
res.status(401).send({ error: 'Unauthorized. Please check.' });
```

## Consider Creating an API Documentation

Working as a team or even if individual and having a documented API, in the end will benefit all. Following open-source API documentation projects can help in this case:

## Avail options for building APIs inÂ Nodejs

There are quite a number of frameworks that you can choose from to build your next RESTful API with Nodejs.

Express, Koa, Hapi all can be used for creating browser based applications but Restify allows you to focus on building a RESTful service.

---

## To Travel, A Tech Conference and One Million views - a Recap
Slug: to-travel-a-tech-conference-and-one-million-views-a-recap

The year 2019 started for me a bit unusual than the previous ones. I never expected to get so much attraction on my blog posts that are mostly published here. Had only one trip planned, ended up doing two. Did end up attending a tech conference too. Something when I started my career as a developer I hadnâ€™t thought of.

Six months are already gone, hence, if you are on Twitter, you might be seeing the following tweet at least once a day.

This year so far has been a roller coaster ride. Similar to one I had in [January](https://www.instagram.com/p/BtK7sa3BOG3/) but a bit slow.

### Achievements ðŸŽ‰

This year, I set out some personal goals to achieve. Some came along the way unexpectedly or surprises. For some, I did sweat a lot. Some took more than the usual amount of coffee cups.

Here is a list of goals that I had mind when 2019 came along that I have achieved so far while some of them are still a work in progress and few of them are literally surprises.

âœ… Reach 500 subs on the weekly newsletter

ðŸš§ Reach 5k followers on Twitter

âœ… Revamp Personal Website

âœ… Receive a Patron on [Patreon.com](https://patreon.com/amanhimself) _(surprise)_

âœ… 1 Million blog post views

âœ… Under 30 days, receive more than 100k views on blog posts*(surprise)*

âœ… Reach 1k followers on Instagram

âœ… Travel abroad to at least one country, ended up traveling to 5

ðŸš§ Write 50 articles/tutorials on React Native _(published 19 so far)_

Most of these goals were to be achieved over the span of 6 months and few of them are still work in progress. For me, having personal goals as such, help to move forward in the direction I am ambitious for, that is, to spend a healthy amount of time creating content on development, teaching fellow developers when in need, using the set of technologies or frameworks that I am familiar and work with.

I have made some bad decisions along the way. Some good ones too. Accepting opportunities that I wasnâ€™t ready for did make me see things from a different perspective and helped me grow as a human being.

### Attend a Tech conference ðŸ‘©â€ðŸ’»

If your world revolves around software development in general, my suggestion is to attend at least one tech conference in your lifetime. Heck, attend 10 if you want!

The reason I am stating that is again come from a recent and dear personal experience. In the month of April 2019, I attended [**App.js Conf**](https://appjs.co/)**.** A one of its kind. A tech conference for Expo and React Native developers held for the first time in Krakow, Poland. It was my first time.

Twitter is quite famous in the dev world. Many thrive to make connections, many achieve that too. You can get to know almost any new framework being released, and learn it as well through Twitter. You might also be able to make good connections. Get to know people from an unconditional point of view for a long period of time. Open a new website or business. All that is good in my honest opinion.

<img src='https://cdn-images-1.medium.com/max/800/1*7SYuZvH2pZnM0H79V4ttPg.jpeg' />

But attending a tech conference in person is a bit intentional. It will help you reach people on a personal level. I would say, if you are lucky enough to have awesome meetups or a conference happening in your area or city you live in, try attending a few. You never know what lies behind that door.

As I was telling about the conference I attended. I personally met some awesome human beings, who made me realize that there are good and modest human beings on this planet who are willing to help a total stranger or give them company and share moments. I met those whom I admire in the dev world and learned a great number of new things. Also, I never expected someone to recognize me from my Twitter handle. I still donâ€™t believe that, but it happened.

ðŸ˜±

_That was my reaction._

I am planning to attend one more either the latter half of this year or early next year.

### Writing âœï¸

For the majority of the last year, I had stopped writing. I did run a blog for five years writing book reviews, interviewing some well-known authors and manage to be awarded twice as the [Best Book Blogs in India](http://readingbooks.blog). But in the end, I lost much of my interest as I felt there wasnâ€™t much left to do. I slowly moved my passion for writing in the tech world and boy did it open doors for me that I never know existed.

Along the way, I did learn a thing or two on how to promote content without hurting anyoneâ€™s feelings, using the internet. I never expected to reach 1 million views on a platform that I have for a little over two years.

I have written for various blogs, magazines, Medium publications. To manage and keep them in one place, I started maintaining a Github repository. You will find all the links ðŸ‘‡

[**amandeepmittal/tech-writing**](https://github.com/amandeepmittal/tech-writing)

The lesson I learned from this is that if you are passionate about something, canâ€™t stay away from it for a while, and are consistently taking action in that area, you will achieve _heights_. Passion does help you drive through that prolonged path.

### Travel âœˆï¸

_Why? Why not save all the ðŸ’²for your future self? Why travel at all?_

Many of my acquaintances did not know this but since my teenage days, I had been eager to travel. I have been shut until I had to force myself a little to make it happen.

_Now, I am in love with it._

We all have our own reasons related to the word â€œTravelâ€. Mine is to learn new things, meet new people, have brief moments with a few, or make some connections, visit places that I think are astonishing, manage everything from planning to expenses, food, accommodation and so on, and be myself. Finally, I did manage to travel to five countries including one of the most lavish cities in the middle east and four beautiful European countries that I am still amazed by their beauty and the calmness they possess.

Traveling to different places do have a deep impact on me. There are some important things I learned about myself and especially how I want to take the approach in my career and life in general. And other things that are essential to the places I visited or the people I met along the way.

I do have some future plans for traveling. I want to experiment with it this time, and not just take a vacation, but try to stay longer in one place. It might end up being a fulfilled personal goal that you get to hear about at the end of this year.

[Originally published at Hackernoon](https://medium.com/hackernoon/to-travel-a-tech-conference-and-one-million-views-a-recap-22e135a598c3)

---

## Tracking notes created in Obsidian with Dataview
Slug: tracking-notes-in-obsidian-with-dataview

My daily note is the starting point for capturing workday information. To record this information, I either create a fleeting note or add it to my daily note. Creating too many new notes can be cumbersome and overwhelming at the end of a week when I'm going through them for my weekly review sessions.

To review the notes created during the week, I do this by keeping track of the files created each day inside that day's daily note.

At the end of each daily note, I include a section for "Notes created today". Inside this, a live data query runs which provides a list of notes created on that day. The query links to the note titles using Obsidian's link `[[...]]` syntax.

Here's an example of today's notes listed in the daily note:

<img src="/images/obsidian/daily-3.png" alt="Graph view in Obsidian" class="sm:w-2/3 mx-auto"/>

The Dataview plugin runs the data query inside the callout.

## Prerequisites

Install the following Obsidian plugins to follow the instructions further:

- [Dataview](https://obsidian.md/plugins?id=dataview)
- Daily note (comes installed by default, enable it)

In the Daily note and Dataview plugin, I've set the date format to be `YYYY-MM-DD`:

<img src="/images/obsidian/daily-1.png" alt="Graph view in Obsidian" class="sm:w-3/3 mx-auto"/>

<img src="/images/obsidian/daily-2.png" alt="Graph view in Obsidian" class="sm:w-3/3 mx-auto"/>

## What is the Dataview plugin

Dataview is an Obsidian plugin that allows you to query metadata in real-time from files or folders within your vault. It lets you create dynamic lists, tables, and views of your notes based on their metadata.

For example, to list all of your notes in the Obsidian vault, use the following syntax:

````md
```dataview
LIST
```
````

The Dataview plugin supports writing queries with the [Dataview Query Language (DQL)](https://blacksmithgu.github.io/obsidian-dataview/queries/dql-js-inline/#dataview-query-language-dql) or as inline statements. For more complex queries, you can also use JavaScript.

For the purpose of this post, using the Dataview Query Language is enough.

## Using a query to view a list of notes created for a date

Notes created each day can be viewed using the following query:

````md
```dataview
LIST
WHERE file.cday = this.file.day
SORT file.ctime asc
```
````

If you are new to this syntax, it might initially seem confusing. Let's break down the components of the query:

- `LIST`: This command lists all notes that match the query criteria.
- `WHERE`: This statement filters results based on a specific condition. In the above example, the condition is `file.cday = this.file.day`.
  - Here, `file` refers to the note being queried for its metadata. `cday` is the "created date" of the note, and `file.day` refers to the date in the daily note's title. The `=` operator is used to compare the file's creation date with the daily note's date.
- `SORT`: This statement orders the query results. In this case, notes are sorted in ascending order by their creation time (`ctime`).

While the query effectively lists files created on a specific date, it also includes files from the â€˜Daily notesâ€™ and â€˜Templatesâ€™ folders, which is useless for my use case. To exclude files from those folders, update the query as follows:

````md
```dataview
>LIST
>WHERE file.cday = this.file.day
>WHERE !contains(file.path, "Daily notes/")
>WHERE !contains(file.path, "Templates/")
>SORT file.ctime asc
```
````

In the updated query, the `contains` function checks the path of the file (`file.path`) inside the directories (`Daily notes/` and `Templates/`). Using the `!` operator, any file in those directories is excluded from the Dataview query. This helps me avoid listing files I don't want to see inside this Dataview.

## Conclusion

Metadata is powerful in Obsidian notes. What's even more powerful is the ease of using metadata fields to create custom views with the Dataview plugin.

### References

- [Dataview sources documentation](https://blacksmithgu.github.io/obsidian-dataview/reference/sources)
- [Metadata pages and implicit fields](https://blacksmithgu.github.io/obsidian-dataview/annotation/metadata-pages/#implicit-fields)
- [Functions in Dataview](https://blacksmithgu.github.io/obsidian-dataview/reference/functions/)

---

## Detecting typos with typos-cli
Slug: typos-cli

Spell checking for typos in code, documentation, and blog sites can impair searchability, cause confusion, and introduce bugs. I have been using [`typos-cli`](https://github.com/crate-ci/typos/tree/master) for a while now to check for typos in my blog periodically and for work in the documentation site.

It's a [Rust](https://www.rust-lang.org/) based spell checker that can be used with any command line interface and includes many different options. In this post, I'll explore some of the common use cases I have found using this CLI tool.

## Getting started

Installing `typos-cli` as a command-line utility is straightforward. On macOS, it can be done with a package manager like [Homebrew](https://formulae.brew.sh/formula/typos-cli):

```bash
brew install typos-cli
```

If you are familiar with Rust, you can also install it using `cargo`. For other platforms, refer to [`typos-cli` documentation]().

## Detecting typos in the CLI

Run the following command to check for typos in a particular file or a directory:

```bash
typos
```

The output of this command provides all the typos detected from different files:

```bash
typos
error: `recieved` should be `received`
  --> ./src/api/handlers.js:15:10
    |
15  | // Data recieved from the server
    |         ^^^^^^^^

error: `succesfully` should be `successfully`
  --> ./docs/guide.md:42:8
    |
42  | Data succesfully processed
    |      ^^^^^^^^^^^
```

One thing to note here is that `typos-cli` is file extension agnostic. It works for JavaScript, TypeScript, Markdown (both `.md` and `.mdx`), and other common file extensions.

The above output shows:

- The typo found in the file
- The line number where the typo is located
- Suggested correction
- The file path and line number
- Context snippet to indicate where the typo is located

## Fixing typos automatically

`typos-cli` can also fix typos automatically. It has a `--write` option (_shorthand: `-w`_) to automatically correct detected typos:

```bash
typos -w
replacing `recieved` with `received`
replacing `succesfully` with `successfully`
```

In a typical documentation source code, I use this option with a caution. It's always a good idea to review the detection to ensure there aren't any false positives.

## Reviewing changes before applying

`typos-cli` provides `--diff` option to view what changes will be made before applying them:

```bash
typos --diff
-The _RCTBridge required dispatch_sync to load RCTDevLoadingView_ has become a common occurence when developing React Native apps with version `0.64` and `0.65`.
+The _RCTBridge required dispatch_sync to load RCTDevLoadingView_ has become a common occurrence when developing React Native apps with version `0.64` and `0.65`.
--- ./src/content/blog/setup-macbook-m1.md	original
+++ ./src/content/blog/setup-macbook-m1.md	fixed
```

## Formatting output

There are output format arguments available such as `brief` or `long`, which can be used to customize the format of the output by passing them as an argument to the `--format` option:

```bash
typos --format brief

./src/content/blog/atom-an-editor-of-21st-century.md:17:335: `Coffe` -> `Coffee`
./src/content/blog/build-a-progressive-web-app-using-react.md:388:60: `frome` -> `from`
```

## Checking specific files and directories

To target a specific file or a directory, pass the name of the file or the path of the directory:

```bash
# File
typos README.md

# Directory
typos pages/

## Possible to check multiple files or directories
typos README.md GUIDE.md
typos src/pages src/content
```

## Wrapping up

`typos-cli` can integrate well with GitHub Actions and VS Code. It also offers a different approach than other spell checkers out there, resulting in fewer false positives and is well suited for my use case right now.

---

## Uninstall a Node.js version using Volta on macOS
Slug: uninstall-nodejs-version-using-volta

If you're using Volta to manage Node.js versions on your computer, you might have noticed that running `volta uninstall node-version` command doesn't work as expected. This expectation comes from using other [Node.js version managers like NVM](/blog/install-nodejs-using-nvm-on-macos-m1/#uninstall-a-nodejs-version), unlike Volta, which requires removing each version manually.

## Check all installed Node.js versions

Before removing any versions, to see a list of installed Node.js versions on your macOS, run:

```shell
volta ls node
```

This command will display all runtimes installed:

```shell
âš¡ï¸ Node runtimes in your toolchain:

    v18.17.1
    v20.12.2
    v20.17.0 (default)
    v22.4.0
    v22.11.0
```

The `default` is the version I am actively using.

## Remove an installed version manually

1. To remove a specific version, navigate to the Volta's installation directory:

```shell
cd ~/.volta/images/node
```

2. All Node.js runtimes are installed inside their own version directory. Delete a directory for the version you want to remove:

```shell
rm -rf v22.11.0
```

3. Verify the removal by running `volta ls node` again:

```shell
âš¡ï¸ Node runtimes in your toolchain:

    v18.17.1
    v20.12.2
    v20.17.0 (default)
    v22.4.0
```

## Complete Volta uninstallation

If you need to remove Volta entirely from your macOS, you can delete the `.volta` directory:

```shell
rm -rf ~/.volta
```

## Summary

Compared to tools like nvm, Volta's approach to Node.js version management is a bit different considering this manual process.

---

## How to upload an image using Expo Camera to Cloudinary
Slug: upload-image-to-cloudinary-using-expo-camera

> Originally Published at **[Jscrambler's Blog](https://jscrambler.com/blog/how-to-upload-an-image-using-expo-camera-to-cloudinary/)**.

The camera feature in a mobile device allows it to capture pictures and record videos, making it very helpful in many circumstances. By using the expo-camera library the process of adding that camera feature to an application becomes seamless, which is why in this tutorial, weâ€™ll take a look at how to use [Expo Camera](https://docs.expo.io/versions/latest/sdk/camera/) to take a picture and then upload that same picture to a real-time cloud service [Cloudinary](https://cloudinary.com/).

## Prerequisites

To follow this tutorial, please make sure you are familiarized with JavaScript/ES6 and meet the following requirements in your local dev environment:

- Have [Node.js](https://nodejs.org/) version >= 14.x.x installed.
- Have access to one package manager such as npm or yarn or npx.
- Have [expo-cli](https://github.com/expo/expo-cli) installed, or use npx

**The source code is available at this [Github repository](https://github.com/amandeepmittal/react-native-examples/tree/master/camera-upload-to-cloudinary).**

## Create an Expo app

Start by creating a new Expo app and then install the dependency `expo-camera`. Execute the following commands in a terminal window:

```shell
npx create-expo-app project-name

# select the blank template

cd project-name

npx expo install expo-camera
```

## Create a custom camera component

The `expo-camera` library provides a React component that allows snapping pictures using a device's front or back camera. It exposes properties like zoom, autofocus, preview image after snapping, white balance, face detection, barcode scanning, and flash mode.

For this demo, let's create a component that when rendered renders the `<Camera>` component initially.

Start by adding the following import statements in the `App.js` file.

```js
import React, { useState, useRef, useEffect } from 'react';
import {
  StyleSheet,
  Dimensions,
  View,
  Text,
  TouchableOpacity
} from 'react-native';
import { Camera } from 'expo-camera';
import { AntDesign, MaterialIcons } from '@expo/vector-icons';
```

The `@expo/vector-icons` is another package bundled with Expo SDK and allows the use of various icons from different icon sets. You can find the references to these icons at [icons.expo.fyi](https://icons.expo.fyi/).

The `Dimensions` from React Native is used to get the applicationâ€™s windows width and height.

- To display the camera in full-screen mode, let's get the height of the window on which the application is running.
- Then, define a custom variable called CAPTURE_SIZE representing 80% of the window height. This variable is used in styles later.
- Add the following code snippet before the `App` component.

```js
const WINDOW_HEIGHT = Dimensions.get('window').height;
const CAPTURE_SIZE = Math.floor(WINDOW_HEIGHT * 0.08);
```

The `expo-camera` library exposes an API of methods. To invoke any of these methods, define a reference to the useRef React hook.

Add the following code snippet just after defining the `App`. Make sure to add a `ref` prop to the `Camera` component whose value is `cameraRef`.

```js
return (
  <View style={styles.container}>
    <Camera ref={cameraRef} style={styles.container} />
  </View>
);
```

## Why use absoluteFillObject to position View component

The `absoluteFillObject` automatically sets a `View` component to be full screen and absolutely positioned. It also allows overriding the values such as `top`. For example, you may want to absolute position the `View` component with an offset like `top: 30` to display it below the status bar.

Add the corresponding styles to the `App` component.

```js
const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject
  },
  text: {
    color: '#fff'
  }
});
```

## How to check for camera permissions

To use a device's camera, the application needs to ask a user to utilize the hardware functionality. This is done by asking the user to grant permission for camera access, and naturally, if the request gets denied, the application won't be able to use it.

- First, define a state variable using the `useState` React hook called `hasPermission`.
- Then, create a method called `onHandlePermission`. It is asynchronous and returns a Promise that resolves when the permissions are granted. To ask for permission, `Camera.requestPermissionsAsync` is used.
- Update the state variable using the update function from the array if the promise is resolved and the permission has been granted.
- Then, using a `useEffect` hook, invoke the method `onHandlePermission`.

Add the following code snippet in `App` component:

```js
export default function App() {
  const cameraRef = useRef();
  const [hasPermission, setHasPermission] = useState(null);

  useEffect(() => {
    onHandlePermission();
  }, []);

  const onHandlePermission = async () => {
    const { status } = await Camera.requestPermissionsAsync();
    setHasPermission(status === 'granted');
  };

  if (hasPermission === null) {
    return <View />;
  }
  if (hasPermission === false) {
    return <Text style={styles.text}>No access to camera</Text>;
  }

  // ...
}
```

In the above code snippet, the two `if` statements are used either when:

- The permission hasnâ€™t been requested.
- A user denies the permission, in which case, a text message stating that there is no access to the camera will be displayed.

Here is how asking for permissions are prompted on an Android device:

![ss1](https://i.imgur.com/5iOMbr1.png)

After the permission is granted, the Camera is now accessible on the device:

![ss2](https://i.imgur.com/90zdXLT.png)

## Switching between Camera types

To switch between different types of cameras on a device, let's add a custom method. The Camera component has a prop called `type` and by using it, the type of camera currently in use on the device can be determined.

Start by defining a state variable called `cameraType` to track the camera's current type. Give it a default value of type `back`. It determines that the default camera mode type is going to be back. The camera type is accessible from `Camera.Constants.Type.back`.

Define another state variable called `isPreview`. It will determine whether the app is in camera mode or image preview mode. It is going to have a default value of boolean `false`.

Add a method called `switchCamera` in the `App` component. Then, check if it is in the preview mode. If yes, return nothing.

If it is in the camera mode, write the logic to handle the switch between the back and front camera mode by updating the state value of `cameraType`.

Then, on the `Camera` component add a prop `type={cameraType}`.

Define the state variable to determine whether the camera is ready to capture photos or not. Call it `isCameraReady` with a default value of boolean `false`. Then, add a method called `onCameraReady` to update its value. Also, add the prop `onCameraReady={onCameraReady}` on the `Camera` component.

```js
export default function App() {
  const cameraRef = useRef();
  const [hasPermission, setHasPermission] = useState(null);
  const [cameraType, setCameraType] = useState(Camera.Constants.Type.back);
  const [isPreview, setIsPreview] = useState(false);
  const [isCameraReady, setIsCameraReady] = useState(false);

  useEffect(() => {
    onHandlePermission();
  }, []);

  const onHandlePermission = async () => {
    const { status } = await Camera.requestPermissionsAsync();
    setHasPermission(status === 'granted');
  };

  const onCameraReady = () => {
    setIsCameraReady(true);
  };

  const switchCamera = () => {
    if (isPreview) {
      return;
    }
    setCameraType(prevCameraType =>
      prevCameraType === Camera.Constants.Type.back
        ? Camera.Constants.Type.front
        : Camera.Constants.Type.back
    );
  };

  if (hasPermission === null) {
    return <View />;
  }
  if (hasPermission === false) {
    return <Text style={styles.text}>No access to camera</Text>;
  }

  return (
    <View style={styles.container}>
      <Camera
        ref={cameraRef}
        style={styles.container}
        type={cameraType}
        onCameraReady={onCameraReady}
      />
    </View>
  );
}
```

To allow the Camera to switch, add a custom icon button to switch between two different camera types. The icon is used from the `MaterialIcons` set from the `@expo/vector-icons library`.

After the `Camera` component in JSX code, add a `View` component that wraps the buttons such as switch camera types and capture a picture.

Inside the `View` component, create an icon button using `TouchableOpacity`. The `onPress` prop on this component is used to trigger an action. In this case, it is used to invoke the `switchCamera` method.

Add a `disabled` prop on `TouchableOpacity` that disables the button depending on the value of `isCameraReady`. If its value is false, then this button will not function.

```js
<View style={styles.container}>
  <Camera
    ref={cameraRef}
    style={styles.container}
    type={cameraType}
    onCameraReady={onCameraReady}
  />
  <View style={styles.container}>
    {!isPreview && (
      <View style={styles.bottomButtonsContainer}>
        <TouchableOpacity disabled={!isCameraReady} onPress={switchCamera}>
          <MaterialIcons name="flip-camera-ios" size={28} color="white" />
        </TouchableOpacity>
      </View>
    )}
  </View>
</View>
```

Add the styles for the above code snippet:

```js
const styles = StyleSheet.create({
  // ...
  bottomButtonsContainer: {
    position: 'absolute',
    flexDirection: 'row',
    bottom: 28,
    width: '100%',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

Here is how the switch button is displayed:

![ss3](https://i.imgur.com/aPslkxl.png)

## Take a picture from the Camera and preview it

Camera API from the `expo-camera` library uses a method called `takePictureAsync()` to take a picture. It saves the photographed image in the app's cache directory by default.

The method accepts a configuration object with different options such as quality, base64, skipProcessing, exif, and more. We will use two options:

- `quality` to specify the compression rate of the image snapped
- `base64` to include the image data in Base64 format.

These options are passed as properties in a JavaScript object. This object is then further passed as an argument to the `takePictureAsync` method.

Start by adding a new asynchronous method called `onSnap`. Start by checking the value of the `cameraRef.current`. If available, then the following logic defined in the code snippet below to take a picture will execute from this method.

Then, define an object called `options` with the following properties:

- quality and set its value to `0.7`. This option selects a value between 0 to 1.
- base64 and set its value to `true`. It accepts a boolean value of true or false

The `takePictureAsync` method, when invoked, returns a promise that resolves into an object. Store the value resolved in a variable called `data`. It contains the image data in form of the following properties:

- uri of the image stored in the app's cache.
- width and height of the image.
- if the base64 option is enabled, it will return the base64 data of the image.

Store the base64 data of the image in another variable called `source`.

Next, add an if condition to check if the source exists. If it exists, pause the camera mode and set the image preview mode to true to show the current picture after it is taken.

```js
const onSnap = async () => {
  if (cameraRef.current) {
    const options = { quality: 0.7, base64: true };
    const data = await cameraRef.current.takePictureAsync(options);
    const source = data.base64;

    if (source) {
      await cameraRef.current.pausePreview();
      setIsPreview(true);
    }
  }
};
```

To go back from the image preview mode to camera mode, add a method called `cancelPreview`. When this method invokes, it resumes the camera mode.

```js
const cancelPreview = async () => {
  await cameraRef.current.resumePreview();
  setIsPreview(false);
};
```

Add the `onSnap` method as an action on `TouchableOpacity` component as the value of `onPress` prop. This button is responsible for capturing an image and is wrapped by the View component when the image preview mode is false.

```js
<View style={styles.container}>
  {!isPreview && (
    <View style={styles.bottomButtonsContainer}>
      <TouchableOpacity disabled={!isCameraReady} onPress={switchCamera}>
        <MaterialIcons name="flip-camera-ios" size={28} color="white" />
      </TouchableOpacity>
      <TouchableOpacity
        activeOpacity={0.7}
        disabled={!isCameraReady}
        onPress={onSnap}
        style={styles.capture}
      />
    </View>
  )}
</View>
```

Add the styles for the above code snippet:

```js
const styles = StyleSheet.create({
  // ...
  capture: {
    backgroundColor: '#5A45FF',
    borderRadius: 5,
    height: CAPTURE_SIZE,
    width: CAPTURE_SIZE,
    borderRadius: Math.floor(CAPTURE_SIZE / 2),
    marginBottom: 28,
    marginHorizontal: 30
  }
});
```

Here is how the capture button is shown. It can now take pictures.

![ss4](https://i.imgur.com/RYAKlLf.png)

Add JSX code to trigger the `cancelPreview` method as an action on a `TouchableOpacity` component. It wraps an icon component from `AntDesign`. This is shown when the application is in image preview mode.

```js
<View style={styles.container}>
  {isPreview && (
    <TouchableOpacity
      onPress={cancelPreview}
      style={styles.closeButton}
      activeOpacity={0.7}
    >
      <AntDesign name='close' size={32} color='#fff' />
    </TouchableOpacity>
  )}
  {!isPreview && (
    // ...
  )}
</View>
```

Add the styles for the above code snippet:

```js
const styles = StyleSheet.create({
  // ...
  closeButton: {
    position: 'absolute',
    top: 35,
    right: 20,
    height: 50,
    width: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#5A45FF',
    opacity: 0.7
  }
});
```

After taking a picture, here is how the image preview mode is displayed:

![ss5](https://i.imgur.com/dIyq9ce.png)

## Setup the Cloudinary service

Before starting with this section, make sure you have a Cloudinary account set up. If you already have an account, [log in here](https://cloudinary.com/users/login).

After logging in, you will be welcomed by a dashboard screen similar to below:

![ss6](https://i.imgur.com/jIX6Yio.png)

To upload an image to their service, two things are required.

First, an apiUrl which is constructed of the following base URL:

```shell
'https://api.cloudinary.com/v1_1/<your-cloud-name>/image/upload'
```

The value for the placeholder `<your-cloud-name>` is the cloud name you entered when creating a new account or as shown in the dashboard screen.

The second parameter required is called `upload_preset`. It is created by following the steps below:

- From the Dashboard, click Settings in the menu bar and select the Upload tab.
- Look for the section "Upload presets" and click "Add upload preset".
- Enter the name of the upload preset. In the "Signing mode," select the value "Unsigned" from the drop-down menu.
- Then click Save.

![ss7](https://i.imgur.com/sfEYaDR.gif)

## Upload an image to Cloudinary

To upload an image to the service, we need a few required presets. We will use JavaScript's `fetch` API to send a POST request to the Cloudinary API URL. A service that allows uploading base64 images requires the image data to be appended by the `data:image/jpg;base64,` prefix.

The request also requires a `data` object which has the image data as the `file` and the value of the `upload_preset`.

Modify the `onSnap` method inside as shown below.

```js
const onSnap = async () => {
  if (cameraRef.current) {
    const options = { quality: 0.7, base64: true };
    const data = await cameraRef.current.takePictureAsync(options);
    const source = data.base64;

    if (source) {
      await cameraRef.current.pausePreview();
      setIsPreview(true);

      let base64Img = `data:image/jpg;base64,${source}`;
      let apiUrl =
        'https://api.cloudinary.com/v1_1/<your-cloud-name>/image/upload';
      let data = {
        file: base64Img,
        upload_preset: '<your-upload-preset>'
      };

      fetch(apiUrl, {
        body: JSON.stringify(data),
        headers: {
          'content-type': 'application/json'
        },
        method: 'POST'
      })
        .then(async response => {
          let data = await response.json();
          if (data.secure_url) {
            alert('Upload successful');
          }
        })
        .catch(err => {
          alert('Cannot upload');
        });
    }
  }
};
```

Take a picture and when it is successfully uploaded to the Cloudinary service, an alert message like below is displayed:

![ss8](https://i.imgur.com/gEQe5wP.png)

## Using Camera2 api for Android

Android devices have a new package called [android.hardware.camera2](https://developer.android.com/reference/android/hardware/camera2/package-summary) that provides an interface to an individual camera. It replaces the deprecated [Camera](https://developer.android.com/reference/android/hardware/Camera) class.

To use the latest package using `expo-camera`, add the following prop with a value of boolean `true` on the `Camera` component.

```js
<Camera
  // ...
  useCamera2Api={true}
/>
```

## Conclusion

In this post, we have successfully used Expo Camera to take a picture and then upload it to a real-time service like Cloudinary. To add image saving functionality check out the [expo-media-library](https://docs.expo.io/versions/latest/sdk/media-library/).

The source code is available at this [Github repository](https://github.com/amandeepmittal/react-native-examples/tree/master/camera-upload-to-cloudinary).

---

## Building Stylistic UIs with Emotion-JS for React Native
Slug: use-emotion-js-with-react-native

Styling is an important aspect of any mobile application. You cannot put enough emphasis on how important it is for a mobile app to have a pleasing design and good use of colors for the app users to use it in the long term.

If you are into React Native development, by now, you may know that there are different ways to style a React Native application. Methods such as by using `StyleSheet` object to create to styles for each component screen, or [encapsulating all of your styles](https://hackernoon.com/styling-the-react-native-way-3cc6d3ef52d0) in one file for the whole application.

Using third-party libraries for styling is another way that can save you a lot of time to develop your React Native application. Some CSS-in-JS libraries such as styled components and emotion-js are already a common practice among web developers. This tutorial is going to discuss and showcase how you can use [Emotion-JS](https://github.com/emotion-js/emotion) in a React Native application.

## What is Emotion-JS ðŸ‘©â€ðŸŽ¤?

Emotion is a flexible _CSS-in-JS_ library that somehow enforces developers to write each component with their own styles and has both of them in one place. This enforcement has lead to some happy times for some happy developers resulting in optimizing their experience and output. It has predictable composition to avoid specificity issues with CSS.

React Native tends to follow a certain convention when it comes to styling your app. Such as all CSS property names should be in camelCase such as for background-color in React Native is:

```css
background-color: 'papayawhip';
```

Developers coming from a web background, do get uncomfortable by these conventions. Using a third party library like emotion-js can give help you. You do not have to switch between the context of conventions, apart from the properties and React Nativeâ€™s own `flexbox` rules.

## Installing Emotion

To get started, you need a new React Native project. To quickly scaffold one, let us use the power of Expo. Run the following command to install expo cli and create a new React Native project using the same cli.

```shell
# To install expo-cli

npm install -S expo-cli

# Generate a project

expo init rn-emotion-demo
```

When running the last command, the command line prompt will you a few questions. First one is, Choose a template, where I chose `expo-template-blank`, then enter display name of your app and then either use `npm` or `yarn` to install dependencies. I am going with `yarn`.

Once all the dependencies installed, you can open this project in your favorite code editor. Next step is to install the latest version of emotion library.

```shell
yarn add prop-types @emotion/core @emotion/native
```

Guidelines in [emotion](https://www.npmjs.com/package/@emotion/native) package instructs that you need `prop-types` as the package installed with your project since Emotion as the package itself depends on it. Next two packages in the above command are necessary to use the library itself. Also, make sure, when you install these dependencies, you are inside the React Native project directory.

## Writing your first Emotion Style

To start the application in a simulator, run `expo start`. On successfully starting the application, you will be prompted with the default Expo app. Modify the `App.js` file like below to get started. Make changes to the componentâ€™s render function like below. Replace both `View` and `Text` with `Container` and `Title`. These new elements are going to be custom using semantics from emotion.

```js
export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Title>React Native with ðŸ‘©â€ðŸŽ¤ Emotion</Title>
      </Container>
    );
  }
}
```

Emotion-JS utilizes tagged template literals to style your components using back-ticks. When creating a component in React or React Native using this styling library, each component is going to have styles attached to it. Define the below styles in the same file after the `App` component.

```js
const Container = styled.View`
  flex: 1;
  background-color: papayawhip;
  justify-content: center;
  align-items: center;
`;

const Title = styled.Text`
  font-size: 20px;
  font-weight: 500;
  color: palevioletred;
`;
```

Notice the `Container` is a React Native `View` and has styling attached to it. Similarly, `Title` is utilizing `Text` component from React Native. You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*f74HA6IWnJM-cE_BNE9CTQ.png' />

Here is the complete code for `App.js` file.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import styled, { css } from '@emotion/native';

export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Title>React Native with ðŸ‘©â€ðŸŽ¤ Emotion</Title>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  background-color: papayawhip;
  justify-content: center;
  align-items: center;
`;

const Title = styled.Text`
  font-size: 24px;
  font-weight: 500;
  color: palevioletred;
`;
```

In the above snippet, do take a note that we are not importing a React Native core components such as `View`, `Text` or `StyleSheet` object. It is that simple. It uses the same `flexbox` model that React Native Layouts use. The advantage here is that you get to apply almost similar context and understandable syntax that you have been using in Web Development to style a React Native application.

## Using Props in Emotion-JS

Often you will find yourself creating custom components for your apps. This does give you the advantage to stay DRY. Leveraging emotion-js is no different. You can use this programming pattern by building custom components that require their parent components. `props` are commonly known as additional properties to a specific component. To demonstrate this, create a new file called `CustomButton.js`.

Inside this file, we are going to create a custom button that requires props such as `backgroundColor`, `textColor` and the `text` itself for the title of the button. You are going to use `TouchableOpacity` and `Text` to create this custom button but without importing `react-native` library and create a functional component `CustomButton`.

```js
import React from 'react';
import styled, { css } from '@emotion/native';

const CustomButton = props => (
  <ButtonContainer
    onPress={() => alert('You are using Emotion-JS!')}
    backgroundColor={props.backgroundColor}
  >
    <ButtonText textColor={props.textColor}>{props.text}</ButtonText>
  </ButtonContainer>
);

export default CustomButton;

const ButtonContainer = styled.TouchableOpacity`
  margin: 15px;
    width: 100px;
    height: 40px
    padding: 12px;
    border-radius: 10px;
    background-color: ${props => props.backgroundColor};
`;

const ButtonText = styled.Text`
  font-size: 15px;
  color: ${props => props.textColor};
  text-align: center;
`;
```

The important thing to notice in the above snippet is you can pass an interpolated function `${props => props...}` to an emotion-js template literal to extend it the component's style and keep the component re-usable.

To see this custom button in action, import it to the `App.js` file as below.

```js
// ... other imports
import CustomButton from './components/CustomButton';

// ...

export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Title>React Native with ðŸ‘©â€ðŸŽ¤ Emotion</Title>
        <CustomButton
          text="Click Me"
          textColor="#01d1e5"
          backgroundColor="lavenderblush"
        />
      </Container>
    );
  }
}
```

On running the simulator, you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*Cy1MdQqq5Uw4i6uNtXFTbQ.png' />

## Inline Styling

As React Native developer, you have used inline styling and you know how beneficial they can be, especially in the prototypal stage of an application.

To leverage this technique using Emotion-js, open `CustomButton.js` file and add an inline style like below. Do note that, we are not modifying the existing styles defined previously.

```js
const CustomButton = props => (
    <ButtonContainer
        onPress={() => alert("You are using Emotion-JS!")}
        backgroundColor={props.backgroundColor}
        style={css`
            border-width: 1px;
        `}
    >
        <ButtonText textColor={props.textColor}>{props.text}</ButtonText>
    </ButtonContainer>
```

The `style` tag in the above snippet uses `css` prop from `@emotion/native` library to allow us to add inline styles.

<img src='https://cdn-images-1.medium.com/max/800/1*WYeeuL0Xoq6gHDWOnW0P7w.png' />

## Building the Grocery UI

Onwards this section, you are going to use what you have just learned about Emotion-js by building a better UI in terms of complexity than a simple test and a button.

Open up App.js. Declare a new `ContainerView` using styled prop from emotion-js. Inside the backticks, you can put pure CSS code there with the exact same syntax. The View element is like a div in HTML or web programming in general. Also, create another view called `Titlebar` inside `Container`.

Inside `Titlebar`, it will contain three new elements. One is going to be an image `Avatar` and the other two are text: `Title` and `Name`.

```js
import React from 'react';
import styled, { css } from '@emotion/native';

export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Titlebar>
          <Avatar />
          <Title>Welcome back,</Title>
          <Name>Aman</Name>
        </Titlebar>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  background-color: white;
  justify-content: center;
  align-items: center;
`;

const Titlebar = styled.View`
  width: 100%;
  margin-top: 50px;
  padding-left: 80px;
`;

const Avatar = styled.Image``;

const Title = styled.Text`
  font-size: 20px;
  font-weight: 500;
  color: #b8bece;
`;

const Name = styled.Text`
  font-size: 20px;
  color: #333333;
  font-weight: bold;
`;
```

You will get the following result in the simulator.

<img src='https://cdn-images-1.medium.com/max/800/1*NOix_tBDR5Ya7U9vxKBWkA.png' />

Right now, everything is how in the middle of the screen. We need the `Titlebar` and its contents at the top of the mobile screen. So styles for `Container` can be modified as below.

```js
const Container = styled.View`
  flex: 1;
  background-color: white;
`;
```

You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*_y_4hWxNgScpmXjtJQngXQ.png' />

## Adding the user avatar image

I am going to use an image that is stored in the assets folder in the root of our project. If are free to use your own image but you can also download the assets for this project below.

- [rn-emotion-demo](https://github.com/amandeepmittal/rn-emotion-demo/tree/master/assets)

To create an image even with emotion-js, you need the `Image` component from React Native core. You can use the source props to reference the image based on where it is located.

```js
<Titlebar>
  <Avatar source={require('./assets/avatar.jpg')} />
  <Title>Welcome back,</Title>
  <Name>Aman</Name>
</Titlebar>
```

The styling for Avatar will begin with a width and a height each of `44` pixels.

```js
const Avatar = styled.Image`
  width: 44px;
  height: 44px;
`;
```

You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*86D8gQeBHwo42NwJ2bKbkA.png' />

## Absolute Positioning in React Native

Now notice that the avatar image and the text are piling up. They are taking the same space on the screen. To avoid this, you are going to use `position: absolute` CSS property.

CSS properties such as `padding` and `margin` are used to add space between UI elements in relation to one another. This is the default layout position. However, you are currently in a scenario where it will be beneficial to use absolute positioning of UI elements and place the desired UI element at the exact position you want.

In React Native and CSS in general, if `position` property is set to `absolute`, then the element is laid out relative to its parent. CSS has other values for `position` but React Native only supports `absolute`.

Modify `Avatar` styles as below.

```js
const Avatar = styled.Image`
  width: 44px;
  height: 44px;
  margin-left: 20px;
  position: absolute;
  top: 0;
  left: 0;
`;
```

Usually, with position absolute property, you are going to use a combination of the following properties:

- top
- left
- right
- bottom

In the case above, we use `top` and `left` and both are set to `0` pixels. You will get the following output.

<img src='https://cdn-images-1.medium.com/max/800/1*VyDbIWkN4io9aMFw9-Jucg.png' />

## Mapping through a list of categories

Inside `components/` folder create a new file called `Categories.js`. This file is going to render a list of category items for the Grocery UI app.

```js
import React from 'react';
import styled, { css } from '@emotion/native';

const Categories = props => (
  <Container>
    <Name>Fruits</Name>
    <Name>Bread</Name>
    <Name>Drinks</Name>
    <Name>Veggies</Name>
  </Container>
);

export default Categories;

const Container = styled.View``;

const Name = styled.Text`
  font-size: 28px;
  font-weight: 600;
  margin-left: 15px;
  color: #bcbece;
`;
```

All the data is static right now. Import this component in `App.js` and place it after `Titlebar`.

```js
<Container>
  <Titlebar>
    <Avatar source={require('./assets/avatar.jpg')} />
    <Title>Welcome back,</Title>
    <Name>Aman</Name>
  </Titlebar>
  <Categories />
</Container>
```

You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*UzOFxbJegk5DgdnWIIDFAA.png' />

There can be a number of categories. To make the names of categories dynamic, we can send it through `App.js` file.

```js
const items = [
  { text: 'Fruits' },
  { text: 'Bread' },
  { text: 'Drinks' },
  { text: 'Veggies' },
  { text: 'Meat' },
  { text: 'Paper Goods' }
];

// ...

// Inside the render function replace <Categories /> with

{
  items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ));
}
```

In the above snippet, you are using `map` function from JavaScript to iterate through an array render a list of items, in this category names. Adding a `key` prop is required. To make this work, also modify `Categories.js`.

```js
import React from 'react';
import styled, { css } from '@emotion/native';

const Categories = props => <Name>{props.name}</Name>;

export default Categories;

const Name = styled.Text`
  font-size: 28px;
  font-weight: 600;
  margin-left: 15px;
  color: #bcbece;
`;
```

There is no change in the UI.

<img src='https://cdn-images-1.medium.com/max/800/1*97cGkaf4B-iuoBqtaU_82g.png' />

## Adding Horizontal ScrollView

This list is right now not scrollable. To make it scrollable, let us place it inside a `ScrollView`. Open up `App.js` file place the categories inside a `ScrollView`, but first, import it from React Native core.

```js
import { ScrollView } from 'react-native';

//...
<ScrollView>
  {items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ))}
</ScrollView>;
```

You will notice not a single change in the UI. By default, scrollable lists in React Native using `ScrollView` are `vertical`. Make this horizontal by adding the prop `horizontal`.

```js
<ScrollView horizontal={true} showsHorizontalScrollIndicator={false}>
  {items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ))}
</ScrollView>
```

It works.

<img src='https://cdn-images-1.medium.com/max/800/1*Ca8deMUYzKMefqll-U8d2w.gif' />

To make it appear better, add some inline styling using `css` prop.

```js
<ScrollView
    horizontal={true}
    showsHorizontalScrollIndicator={false}
    style={css`
    margin: 20px;
    margin-left: 12px;
    `}
>
```

Now it looks better.

<img src='https://cdn-images-1.medium.com/max/800/1*Wv5LHX6N-LNKYFBLnzZZjw.gif' />

## Adding a vertical ScrollView

Next step is to add a `ScrollView` that acts as a wrapper inside the `Container` view such that the whole area becomes scrollable vertically. There is a reason to do this. You are now going to add items separated into two columns as images with texts related to a particular category.

Modify `App.js` file.

```js
return (
  <Container>
    <ScrollView>
      <Titlebar>{/* and its contents */}</Titlebar>
      <ScrollView horizontal={true}>
        {/* Categories being rendered */}
      </ScrollView>
      <Subtitle>Items</Subtitle>
    </ScrollView>
  </Container>
);
```

Notice that we are adding another emotion component called `Subtitle` which is nothing but a text.

It renders like below.

<img src='https://cdn-images-1.medium.com/max/800/1*pm3WO-qUP4JhE3yagUo93A.png' />

## Building a card component

In this section, we are going to create a card component that will hold an itemâ€™s image, the name of the item and the price as text. Each card component is going to have curved borders and box shadow. This is how it is going to look like.

<img src='https://cdn-images-1.medium.com/max/800/1*LACepyEU54zhnt028sfh5g.png' />

Create a new component file called `Card.js` inside the `components` directory. The structure of the Card component is going to be.

```js
import React from 'react';
import styled, { css } from '@emotion/native';

const Card = props => (
  <Container>
    <Cover>
      <Image source={require('../assets/pepper.jpg')} />
    </Cover>
    <Content>
      <Title>Pepper</Title>
      <PriceCaption>$ 2.99 each</PriceCaption>
    </Content>
  </Container>
);

export default Card;
```

Currently, it has static data, such as the image, title, and content. Let us add the styles for each styled UI elements in this file.

```js
const Container = styled.View`
  background: #fff;
  height: 200px;
  width: 150px;
  border-radius: 14px;
  margin: 18px;
  margin-top: 20px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
`;

const Cover = styled.View`
  width: 100%;
  height: 120px;
  border-top-left-radius: 14px;
  border-top-right-radius: 14px;
  overflow: hidden;
`;

const Image = styled.Image`
  width: 100%;
  height: 100%;
`;

const Content = styled.View`
  padding-top: 10px;
  flex-direction: column;
  align-items: center;
  height: 60px;
`;

const Title = styled.Text`
  color: #3c4560;
  font-size: 20px;
  font-weight: 600;
`;

const PriceCaption = styled.Text`
  color: #b8b3c3;
  font-size: 15px;
  font-weight: 600;
  margin-top: 4px;
`;
```

The `Container` view has a default background of white color. This is useful in scenarios where you are fetching images from a third party APIs. Also, it provides a background to the text area below the image.

Inside the `Container` view, add an `Image` and wrap it inside a `Cover` view. In React Native there two ways you can fetch an image.

If you are getting an image from the static resource as in our case, you use `source` prop with the keyword `require` that contains the relative path to the image asset stored in the project folder. In case of networking images or getting an image from an API, you use the same prop with a different keyword called `uri`. Here is an example of an image being fetched from an API.

```js
<Image
  source={{
    uri: 'https://facebook.github.io/react-native/docs/assets/favicon.png'
  }}
/>
```

The `Cover` view uses rounded corners with `overflow` property. This is done to reflect the rounded corners. iOS clips the images if coming from a child component. In our case, the image is coming from a `Card` component which is a child to the `App` component.

The `Image` component takes the width and height of the entire `Cover` view.

Now let us import this component inside App.js file, after the `Subtitle` and let us see what results do we get.

```js
render() {
    return (
    <Container>
        <ScrollView>
        {/* ... */}
        <Subtitle>Items</Subtitle>
            <ItemsLayout>
                <ColumnOne>
                    <Card />
                </ColumnOne>
                <ColumnTwo>
                    <Card />
                </ColumnTwo>
            </ItemsLayout>
        </ScrollView>
    </Container>
    )
}

// ...

const ItemsLayout = styled.View`
    flex-direction: row;
    flex: 1;
`;

const ColumnOne = styled.View``;

const ColumnTwo = styled.View``;
```

After `Subtitle` adds a new view called `ItemsLayout`. This is going to be a layout that allows different cards to be divided between two columns in each row. This can be done by giving this view a `flex-direction` property of value `row`. `ColumnOne` and `ColumnTwo` are two empty views.

On rendering the final result, it looks like below.

<img src='https://cdn-images-1.medium.com/max/800/1*1buKFeJ-C7yzw41ezKTv6g.png' />

## Conclusion

You have completed the tutorial for creating UIs with Emotion-JS and integrate it into a React Native and Expo application. Now go ahead and create those beautiful UIs for your applications.

[Originally published at Heartbeat](https://heartbeat.fritz.ai/how-to-use-emotion-js-with-react-native-fccac9c78779)

---

## When to use keyExtractor prop in React Native's FlatList
Slug: use-key-extractor-in-react-native-flatlist

![cover_image](https://i.imgur.com/sRxXsyt.png)

In React Native, the [FlatList component](https://reactnative.dev/docs/flatlist) works well to render a long list of data. It renders only the items are shown on the screen in a scrolling list and not all the data items at once.

To render a scrollable list of items using `FlatList`, you need to pass the required `data` prop to the component. The `data` prop accepts an array of items. Each item in the array represents a single item in the list. Another required prop is `renderItem`, which takes an item from the `data` and renders it on the list. This prop accepts a function that returns the JSX to be rendered.

To display an item in the scrollable list, the `FlatList` component requires that each item has a unique key such as an `id`. This key is what allows the `FlatList` component (since it uses [VirtualizedList](https://reactnative.dev/docs/virtualizedlist) under the hood) to track the order of items in the list. The key from the data array is extracted using the `keyExtractor` prop on the `FlatList` component.

In this post, let's talk about where you might need to use `keyExtractor` and what scenarios it is not required.

## Display a list of items using FlatList

Consider the following structure of data. There are ten items in the array, and each item has two properties, `id` and `title`. The `id` is the unique key for each item.

```js
const DATA_WITH_ID = [
  {
    id: 1,
    title: 'quidem molestiae enim'
  },
  {
    id: 2,
    title: 'sunt qui excepturi placeat culpa'
  },
  {
    id: 3,
    title: 'omnis laborum odio'
  },
  {
    id: 4,
    title: 'non esse culpa molestiae omnis sed optio'
  },
  {
    id: 5,
    title: 'eaque aut omnis a'
  },
  {
    id: 6,
    title: 'natus impedit quibusdam illo est'
  },
  {
    id: 7,
    title: 'quibusdam autem aliquid et et quia'
  },
  {
    id: 8,
    title: 'qui fuga est a eum'
  },
  {
    id: 9,
    title: 'saepe unde necessitatibus rem'
  },
  {
    id: 10,
    title: 'distinctio laborum qui'
  }
];
```

Using the `FlatList` component, you want to render the `title` of each item as shown below:

```js
export default function App() {
  const renderList = ({ item }) => {
    return (
      <View style={styles.listItem}>
        <Text style={styles.listItemText}>{item.title}</Text>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <FlatList data={DATA_WITH_ID} renderItem={renderList} />
    </View>
  );
}
```

The result of the above component will display a list of items without any errors or warnings. In addition, the `FlatList` component doesn't require a unique key to identify each item since the original data structure already contains a key called `id`.

Here is the output on a device's screen from the above snippet:

![ss2](https://i.imgur.com/ShoysNV.png)

## Using the keyExtractor prop

By default, the `keyExtractor` prop checks for properties like `key` and `id` (in that order). If any of the two is present in the original data structure, it will be considered a the unique key by the `FlatList` component. In this case(as in the previous example), you do not have to explicitly use the `keyExtractor` prop.

If none of them are provided, the `FlatList` component will throw a warning "VirtualizedList: missing keys for items ...":

![ss1](https://i.imgur.com/0zN4FXy.png)

Now, let's consider a scenario where array of data contains a unique key with each list item but the name of the unique key is neither `key` nor `id`. It contains a unique key property with the name of `userId`.

```js
const DATA_WITH_USER_ID = [
  {
    userId: 1,
    title: 'quidem molestiae enim'
  },
  {
    userId: 2,
    title: 'sunt qui excepturi placeat culpa'
  },
  {
    userId: 3,
    title: 'omnis laborum odio'
  },
  {
    userId: 4,
    title: 'non esse culpa molestiae omnis sed optio'
  },
  {
    userId: 5,
    title: 'eaque aut omnis a'
  },
  {
    userId: 6,
    title: 'natus impedit quibusdam illo est'
  },
  {
    userId: 7,
    title: 'quibusdam autem aliquid et et quia'
  },
  {
    userId: 8,
    title: 'qui fuga est a eum'
  },
  {
    userId: 9,
    title: 'saepe unde necessitatibus rem'
  },
  {
    userId: 10,
    title: 'distinctio laborum qui'
  }
];
```

When rendering the list, you will see the warning in this case because the `FlatList` component doesn't recognize the `userId` as the `key` or `id` name in the original data structure.

For custom key names such as `userId` in the example above, the `keyExtractor` prop is used. It extracts the unique key name and its value and tells the `FlatList` component to track the items based on that value.

For the above array of data, modify the `FlatList` component and use the `keyExtractor` prop to extract the key:

```js
<FlatList
  data={DATA_WITH_ID}
  renderItem={renderList}
  keyExtractor={item => item.userId}
/>
```

The warning will also disappear after this step.

## Conclusion

When using a `FlatList` component, if the data array has a unique `id` or a `key` property, you do not need to use the `keyExtractor` prop explicitly. However, for custom id names, use the `keyExtractor` prop to explicitly tell the component which unique key to extract.

If you like to learn more about React Native, check out the [React Native category](https://amanhimself.dev/tags/react-native/) and [Expo category](https://amanhimself.dev/tags/expo/) pages on my blog. You can also subscribe my [newsletter](https://amanhimself.substack.com/) or follow on [Twitter](https://x.com/amanhimself) to get updates on whenever I publish a new article or tutorial.

---

## User Authentication with Amplify in a React Native and Expo app
Slug: user-authentication-with-amplify-in-a-react-native-and-expo-app

AWS Amplify is a fantastic framework that helps you develop your web or mobile applications quickly. Not only it enhances your current tech stack but actually has many features in-built that you don't have to worry about especially when your app is in the development process.

Features such as:

- authentication
- GraphQL and REST API support
- storage
- S3 uploads
- a way to manage user pool
- hosting
- notifications
- interactions
- analytics
- compatibility to work with AWS Lambda functions

Not only that. Amplify can be integrated with most popular frontend frameworks like React, Vue, Angular, Ionic, React Native or just go vanilla JavaScript if you want to.

In this tutorial, we are going to take a look at one of the most important feature of an application and that is **authentication**. You know the scenarios where you need store some amount of user information (credentials) for them to get back and re-use the application rather creating a new account.

Amplify helps us integrate its authentication component _out of the box_. Do not hate me for saying this. Now, if you have developed an application with a proper authentication flow, you know what pain it gives when it comes to writing that amount of code. With Amplify you will see how easy it is to integrate things like new user's email verification.

Enough with the introduction, let us start. However, if this is your first time reading about Amplify framework and want to learn more about what it is or how to integrate it with a React Native or Expo application, [read my previous post](https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e).

It will walk you through from basics such as [What is Amplify?](https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e#a083), [How to create a new AWS IAM user](https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e#b8c6), and [creating a GraphQL API](https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e#cfaa) and so on.

### Table of Contents

- Requirements
- Creating a new React Native App
- Create a new AWS IAM user
- Initializing & Integrating Amplify SDK
- Enable Amplify Auth Resource
- `withAuthenticator`: Adding a High Order Component
- Testing the default Amplify auth flow

## Requirements

Here is a complete list of plugins, packages, and services youâ€™re going to need in order to gain something from this tutorial:

- Nodejs `v8.x.x` or higher installed along with npm/yarn
- `watchman`: The file change watcher for React Native projects
- AWS account
- [Amplify CLI](https://aws-amplify.github.io/docs/cli/)
- [Expo CLI](https://www.npmjs.com/package/expo-cli) (_previously known as create-react-native-app_)

_Note:_ To use any Amplify service and to follow the rest of this tutorial, you need an AWS account (which is free). If you donâ€™t have one, please consider signing up for one here for the free tier.

## Creating a new React Native App

To get started, make sure you have already installed [`expo-cli`](https://www.npmjs.com/package/expo-cli). Now, open up a terminal window at a desired directory or location where you keep your demo projects and type the following and then press enter to execute.

```shell
expo init customize-amplify-auth-ui
```

This command will create a new directory called `customize-amplify-auth-ui`. You can name it whatever you want. Inside this directory you will find a complete react native + expo SDK generated.

On running the above command, you will be asked by the CLI to make some choices by prompting some questions. I will be leaving the them default.

Expo CLI is a command line utility to create React Native apps with no build configuration. The reason we are relying on it, is that, first it is awesome tool for such use cases. Next, it will help us build this React Native app/project much faster for any of the mobile platform (_iOS_ or _android_) than a traditional React Native project generated with `react-native-cli`. This will save us time for now but you can go ahead with `react-native-cli` if you want to but remember to run `react native link` when integrating Amplify with React Native app.

## Create a new AWS IAM user

Once you are signed-in to AWS console (_remember_, I told you to create a free AWS account and sign-in. If you haven't done so already, go ahead do it. Otherwise, you might not enjoy and at the same time, be able to follow the rest of the tutorial).

Now, from your terminal window, execute the following command.

```shell
amplify configure
```

This will open up the AWS console dashboard. Go back to terminal and press enter to continue. This will lead you through a bunch of questions in order to configure a user account to use Amplify with the React Native application. Lastly, it will provide you with a **secret** key and an **access** key. Go back to terminal and enter those keys.

Here is a summary of questions prompted by AWS Amplify CLI.

<img src='https://cdn-images-1.medium.com/max/800/1*amSKLCe6467xU_wJ5Kgr0g.png' />

This process is easy, but if you are going through it for the first time, I'd recommend you to give the below link a visit and only in few minutes you will realise how easy it is to setup a new IAM user for AWS services.

https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e#b8c6

## Initializing & Integrating Amplify SDK

To integrate AWS Amplify with the React Native app run the following command that in return prompts you for some more questions. Later, in this section, we will install dependencies in the React Native app to complete this process.

_Note:_ For a complete step by step process, please refer to [**this link here**](https://heartbeat.fritz.ai/building-a-react-native-mobile-app-with-aws-amplify-and-expo-fcab6ee0555e#d79c). Do not worry, most of these configuration settings are going to be default at the moment. I am only going to walk you through essentials here.

To start, execute the following command. Make sure you are inside your React Native project directory and that too at the root of your project. This is required as this command will add some configuration files.

```shell
amplify init
```

Once you run this command, you will be prompted for the following questions.

<img src='https://cdn-images-1.medium.com/max/800/1*d1aVKZuIFzZN1Mgo86cAfQ.png' />

After the Amplify SDK initialization process is complete, notice there are some new file changes inside the project directory. A new directory `amplify/` which stores any local or cloud changes are made to configuration files. Also, a new file called `aws-exports.js` appears at the root that doesn't require to be committed over your Github account (_always remember_).

Make sure that `.gitignore` file is up to date. Amplify CLI is so good that it will update this file for you and take care of what to commit or not from the configuration part.

This is just the initialization part. We need to integrate amplify SDK now to tell our React Native app that we are going to use Amplify configuration and components in the app. To make this happen, install the following dependencies.

```shell
yarn add aws-amplify aws-amplify-react-native
```

Both of these packages are required. The package `aws-amplify` allows you to make requests to the auth and API services provided by AWS. The other one is framework specific which contains ready-to-use UI components. After these dependencies are installed, open `App.js` file and add the following.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

// --- This is the part to add

import Amplify from 'aws-amplify';
import config from './aws-exports';

Amplify.configure(config);

// ---

export default class App extends React.Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>React Native + Amplify = ðŸ’›</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

To verify that everything is on order and the app works fine, you can go ahead and run `npm start` command. Then select which mobile platform you want to run. If there no errors, you will get to see the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*3CQuczlaCMHVnFBojLqhVQ.png' />

## Enable Amplify Auth Resource

To include authentication experiences in your React Native app, amplify uses Amazon Cognito that is a fully featured user directory to handle user registration, login, and account recovery. Amplify interfaces with Cognito User Pools to store the user information, including social providers like Facebook, Google and so on.

Amplify gives you the superpower to generate an authentication flow by executing a command from the terminal window.

```shell
amplify add auth
```

On running the above command, you will be prompted with the first question like below.

<img src='https://cdn-images-1.medium.com/max/800/1*br7DyESd83gE1fz2gWV5Lg.png' />

This option is to choose the default authentication and security configuration. The second option to include a social provider like Facebook. Another option to look out for is Manual configuration about which you can read more at the [official amplify docs](https://aws-amplify.github.io/docs/js/react).

<img src='https://cdn-images-1.medium.com/max/800/1*w9im1GzV1CjKGdPpVR-DLg.png' />

Next, it will prompt you to choose the default sign in method. Choose `Username`.

Amplifyâ€™s command line interface is so interactive and in detail that it prompts you to provide input fields and select them from your terminal. Look at below.

<img src='https://cdn-images-1.medium.com/max/800/1*IIw8O4dwLrkyGoi9x5Y4iA.png' />

Choose `Email`. Now run the following command to publish all the local changes to the AWS in order to create a user pool.

```shell
amplify push
```

You will get the following screen after you execute the above command.

<img src='https://cdn-images-1.medium.com/max/800/1*14ONUYoXLzlwlVcSKLzWtQ.png' />

This shows the details of the current working environment (_which we manually entered at the time of configuring AWS IAM user_) and displays the status of the resource we are currently using ,that is `Auth`.

Executing this command will take some time to update the resources in order to enable and create a user pool for your React Native app. So go ahead, pause here, drink a cup of coffee. The user authentication setup is complete for now.

## withAuthenticator: Adding a High Order Component

Enough with the configuration part. Let us work with some app code. For React Native apps, the simplest way to add authentication flow into the app is to use `withAuthenticator` [High Order Component](https://reactjs.org/docs/higher-order-components.html).

Open up the file `App.js` and the following.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import Amplify from 'aws-amplify';
import config from './aws-exports';

// New ----
import { withAuthenticator } from 'aws-amplify-react-native';

Amplify.configure(config);

class App extends React.Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>React Native + Amplify = ðŸ’›</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});

// New ----
export default withAuthenticator(App, true);
```

This HOC wraps the `App` component. It automatically detects the authentication state and updates to the UI.
`withAuthenticator` component renders the `App` component after a successful user signed in, and it prevents non-sign-in users to interact with your app. The second argument passed in this HOC is a boolean value that tells whether to enable the Sign Out button (once the user is successfully logged-in) or not. You will see this in action later once we have created the user.

By default, on running `npm` start, you will get the Sign In screen like below.

<img src='https://cdn-images-1.medium.com/max/800/1*cNDW73k-43-FiHndSZ8YKw.png)' />

Do notice that right now in the above screen, the Sign In button is disabled since there the input fields are empty. This a too good to for the default flow. If you enter a username followed by a password, it even throws an error like below.

<img src='https://cdn-images-1.medium.com/max/800/1*33BkYtrQA_9NfumRr6ebWA.png' />

By clicking on Sign up button, you will go to the registration screen.

<img src='https://cdn-images-1.medium.com/max/800/1*jw2fK8IJ0xjL1MR4iBK2QA.png' />

On clicking Forgot Password, will take you to another screen where it will ask you for the registered username.

<img src='https://cdn-images-1.medium.com/max/800/1*mccJmsNibLlxIKtJ11USjw.png' />

If the user is signed in, the underlying component (_in current scenario, the `App` component_) is displayed otherwise signin/signup controls are displayed. Also, did you notice that just by adding two lines of code you have authentication flow that looks pretty decent? In the next section, let us see if it works or not.

_Bonus:_ If you love design, UI, UX, or want your apps to look good, at this link you can view the color palettes Amplify uses.

https://aws-amplify.github.io/media/ui_library

## Testing the default Amplify auth flow

Currently, there no userâ€™s registered to our app. So let us register one. Create the button `Sign Up` and enter the details asked. Do note that, enter a valid email address for the AWS cloud service will send you an email to verify your account.

Once you are done, click the `SIGN UP` button at the end of the registration form. You will get the following screen asking for the confirmation/verification code.

<img src='https://cdn-images-1.medium.com/max/800/1*fY2whWIX4Unwhrekjqleiw.png' />

Enter the verification code and click the confirm button. If it is confirmed, you will be directed back to the Sign in screen. Enter the credentials to login inside the app. You will be successfully logged in if you enter the correct credentials.

<img src='https://cdn-images-1.medium.com/max/800/1*8Xa9uKiLOikHO-A786fpJw.png' />

Notice how the sign-out button is appearing at top right corner next to the username. Yes, amplify greets the user and has the code for it integrated already at `withAuthenticator` HOC. Do take note in the above screen that the `App` component is getting rendered now.

## Conclusion

You have now successfully to add an authentication flow with Amplify and use it in a React Native app. Try using the federation or social login flow and gather the similarities or differences between the two.

You can find the complete code for this post in this [Github repository](https://github.com/amandeepmittal/expo-amplify-demo).

[Originally published at Heartbeat](https://heartbeat.fritz.ai/user-authentication-with-amplify-in-a-react-native-and-expo-app-d00cdaf1ac28)

---

## Using at() method in JavaScript to get the last item from an array
Slug: using-at-method-from-javascript

There are different ways in JavaScript to get the list item of an array. Recently, I learned about the `at()` method, and this post explores the traditional approach to getting the last item and the approach of using the `at()` method.

Let's assume you have the following array in your JavaScript code:

```js
const numbers = [1, 2, 3, 4];
```

Getting the last item of the array can be done by manually calculating the array's length and reducing `1` since the first item of the array is indexed at `0`, the second item is indexed at `1`, and so on.

```js
const lastItem = numbers[numbers.length - 1];
```

You can use the `slice()` method, which extracts a portion of an array and returns another array. Pass the `-1` as an argument to this method so it counts from the end of the array and then includes `[0]` so the return value is a number and not an array.

```js
const lastItem = numbers.slice(-1)[0];
```

There's another way you can extract the last item from the `numbers` array. You can use the `at()` method and pass the index value as an argument to this method to get the desired value.

Both positive and negative numbers can be passed as index values to this method. So, in the example of the `numbers` array, you can pass the `-1`, which tells this method to get the last item from this array.

```js
const lastItem = numbers.at(-1);
```

In the above example, the `-1` index will always point to the last item of the array.

When seeing this method in the code, the intent is clear; it is used to get a specific item from the array input.

The `at()` method works with any array-like object:

```js
// Strings
const message = 'Hello';

console.log(greeting.at(-2)); // Output: "l"
```

Comparing the `at()` method with `slice()` or doing manual calculations with the `length` property, the `at()` method is a much more readable solution. It also doesn't require calculating by inverting the array to read the last item from the array.

---

## Using Google Fonts in an Ionic Application
Slug: using-google-fonts-in-an-ionic-application

In this post, I will be showing you to change font in any Ionic 2/3 application. To start with, I will be setting up a new ionic project such that you can refer back to on Github.

```shell
$ ionic start ionic-use-google-fonts blank
```

`cd` in to the new project created by the above Ionic CLI command and run `ionic serve` to see the blank template with just a homepage available. As of now, the Ionic application looks like this:

<img src='https://cdn-images-1.medium.com/max/800/0*WUHLVkBP7bifnV8E.png' />

The font here used in the application at global level is default. We will be changing it to [Revalia](https://fonts.google.com/specimen/Revalia). Itâ€™s just a random suggestion, you can pick whatever you want but Iâ€™d suggest, if you are doing for the first time or new to Ionic development, pick a font in which you can see the changes reflected in the app.

<img src='https://cdn-images-1.medium.com/max/2560/0*NTLwsXqYlk1SPFPD.png' />

After selecting the font, open the highlighted link in the screenshot above, in a new tab.

<img src='https://cdn-images-1.medium.com/max/2560/0*Ok2hQifn4QpJFSsM.png' />

Again, open the link provided in the `latin` section, just like in the above image and download or save the file directly in you ionic project.

The location to save the file will be `YOUR-IonicApp > src/assets/fonts`. Create a new directory `fonts` in the `assets` folder if not available. Place the file there, and rename it as per your convenience.

<img src='https://cdn-images-1.medium.com/max/800/0*KIBUq3X7G1JztbmK.png' />

Now since we want this font to be used at the global level of application, open `app.scss` in `src/app` and first include the local file of the font we want to use and then use that font at global level by using an asterisk `*` as css-selector:

```css
@font-face {
  font-family: 'Revalia';
  src: url('../assets/fonts/revalia.woff2') format('woff2');
}

* {
  font-family: Revalia;
}
```

Run the ionic application with:

```shell
$ ionic serve
```

Output:

<img src='https://cdn-images-1.medium.com/max/800/0*cAeEa-sD5b1zHVNG.png' />

To get the full code, you can visit [**this Github Repository**](https://github.com/amandeepmittal/ionic-use-google-fonts).

[Originally Published at Hackernoon.com](https://medium.com/hackernoon/using-google-fonts-in-an-ionic-application-c3419c342f23)

---

## Using mas with homebrew for a streamlined macOS setup 
Slug: using-mas-with-homebrew

[Setting up a new or an old Mac](/blog/macbook-setup-2024/) after resetting it can be exciting but tedious at the same time. Most time is spent downloading app installers and installing those apps, whether it is from the Apple App Store or third-party sites.

I recently learned about `mas`, which is short for Mac App Store command-line interface. Combining it with a brewfile setup makes the tedious process a bit more efficient by automating the installation of macOS apps.

Take a look at the following [`brewfile.sh`](https://github.com/amandeepmittal/dotfiles/blob/master/brewfile.sh), which is a bundle file and is used to brew packages, system fonts, apps from Apple App Store, and other apps.

```shell
# Install packages
brew 'mas'
brew 'direnv'
brew 'git'
# ...

# Images, Video
brew 'ffmpeg'

# Fonts
cask 'font-jetbrains-mono'
cask 'font-hack-nerd-font'

# Other apps
cask 'insomnia'
cask 'visual-studio-code'
# ...

## App Store apps
mas "Slack", id: 803453959
mas 'Bandwidth+', id: 490461369
mas 'Obsidian', id: 1410676096
```

Notice, under the "App Store apps" section, there is an app name, and its ID. This `id` is referenced from the Apple App Store.

If you know that an app already exists on the App Store, you can search its ID using `mas`:

```shell
mas search Obsidian
```

Running this command will return a list of apps with their IDs and versions, as shown below:

<img src="/images/mas-search.png" alt="Using mas search command in terminal app." class="mx-auto" />

You can copy the app name and its ID and add it to your brewfile. One key point in your `brewfile.sh` is to install `mas` on your system as soon as you execute this bundle file. This is why, under the "Install packages" section of the brewfile example shown before, I am installing `mas` as the first thing.

This approach ensures all your essential applications, including those from the Apple App Store, are automatically installed with a single command without going through the App Store manually.

The beauty of this system is that you maintain one source of truth for your development environment, and if you have multiple machines, say, work and personal Macbook, you can use it across different machines.

---

## Using Styled Components with React Native
Slug: using-styled-components-with-react-native

### Introduction

Whether you are a web developer or mobile app developer, you know that without the proper styling of your application, the UI would probably suck. Styling an application is important. I cannot put enough emphasis on how important it is for a mobile app to have a pleasing design and good use of colors.

If you are getting into React Native or have already dipped your toes, you know that there are different ways you can style a React Native app. I have already discussed the basics and some of the different ways to style your React Native components in the article below. Such as, to create a new style object you use `**StyleSheet.create()**` method and encapsulating them. Go check it out ðŸ‘‡

This tutorial is going to be about styling your React Native apps using [ðŸ’… Styled Components](https://www.styled-components.com/docs/basics 'https://www.styled-components.com/docs/basics'). Yes, styled-components is a third party library. Using it is a matter of choice, but also another way to add styling to your app, and many might find it easy to use, especially if you have used this library before with other frameworks. One common use case is web apps built with React.

## Table of contents

### What are Styled Components?

Styled Components is a _CSS-in-JS_ library that enables developers to write each component with their own styles and allows the code to be in a single location. By coupling your styles with the components, it results in optimizing developer experience and output.

In React Native, the styling of components is already done by creating JavaScript objects and if you do not [**encapsulate them**](https://levelup.gitconnected.com/styling-the-react-native-way-3cc6d3ef52d0), in most cases, your components and their styling are going to end up in one place.

React Native tends to follow a certain convention when it comes to styling your app. Such as all CSS property names should be in `camelCase` such as for `background-color` in React Native is:

```css
backgroundcolor: 'blue';
```

Occasionally, web developers get uncomfortable by these conventions. Using a third party library like styled components can give you wings. You do not have to switch between the context of conventions much, apart from the properties and React Nativeâ€™s own Flexbox rules.

Behind the scenes, styled components just converts the CSS text into a React Native stylesheet object. You can check how it does that [**here**](https://github.com/styled-components/css-to-react-native 'https://github.com/styled-components/css-to-react-native')**.**

_Enough with story, letâ€™s get to work!_

### Installing Styled Components

To install the `styled-components` library in a React Native project, we will first initialize the app. To get started quickly, I am going to use the awesome **Expo** library. Make sure you have `expo-cli` installed.

```shell
# To install expo-cli

npm install -S expo-cli

# Generate a project

expo init [YourApp-Name]
```

When running the last command, the command line prompt will you a few questions. First one is, `Choose a template`, where I chose `expo-template-blank`, then enter display name of your app and then either use `npm` or `yarn` to install dependencies. I am using `npm`.

Once all the dependencies are installed, you can open this project in your favorite code editor. The next step is to install the latest version of `styled-components` library.

```shell
npm install -S styled-components
```

Thatâ€™s it for installation.

### Using Styled Components

Open up `App.js` file and make some modifications.

```js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class App extends React.Component {
  render() {
    return (
      <View style={styles.container}>
        <Text>Open up App.js to start working on your app!</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center'
  }
});
```

From your terminal, run the command: `npm run ios` if you are on macOS. For Linux and Windows users the command is `npm run android`, but make sure you have an Android virtual device running in the background. Our code currently looks like below.

<img src='https://cdn-images-1.medium.com/max/800/1*FJYy0ggO0KlAjamE81Z19w.png' />

Letâ€™s make some changes to it and use our newly installed library. To get started, import the library like below.

```js
import styled from 'styled-components';
```

Make changes to the componentâ€™s render function like below. Replace both `View` and `Text` with `Container` and `Title`. These new elements are going to be custom using semantics from `styled-components`.

```js
export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Title>React Native with ðŸ’… Styled Components</Title>
      </Container>
    );
  }
}
```

`styled-components` utilizes tagged template literals to style your components using backticks. When creating a component in React or React Native using `styled-components`, each component is going to have styles attached to it.

Notice the Container is a React Native `View` and has styling attached to it.

```js
const Container = styled.View`
  flex: 1;
  background-color: papayawhip;
  justify-content: center;
  align-items: center;
`;

const Title = styled.Text`
  font-size: 20px;
  font-weight: 500;
  color: palevioletred;
`;
```

<img src='https://cdn-images-1.medium.com/max/800/1*FJYy0ggO0KlAjamE81Z19w.png' />

The complete code for `App.js` file after changes.

```js
import React from 'react';
import styled from 'styled-components';

export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Title>React Native with ðŸ’… Styled Components</Title>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  background-color: papayawhip;
  justify-content: center;
  align-items: center;
`;

const Title = styled.Text`
  font-size: 24px;
  font-weight: 500;
  color: palevioletred;
`;
```

In the above snippet, do take a note that we are not importing a React Native core components such as `View`, `Text`, or the `StyleSheet` object. It is that simple. It uses the same `flexbox` model that React Native Layouts. The advantage here is that you get the advantage of using the same understandable syntax that you have been using in web development and standard CSS.

### Using Props in Styled Components

Often you will find yourself creating custom components for your apps. This does give you the advantage to stay DRY. Using `styled-components` is no different. You can leverage this programming pattern by building custom components that require their parent components. `props` are commonly known as additional properties to a specific component. To demonstrate this, create a new file called `CustomButton.js`.

Inside this file, we are going to create a custom button that requires props such as `backgroundColor`, `textColor` and the text itself for the button. You are going to use `TouchableOpacity` and `Text` to create this custom button but without importing `react-native` library using a functional component `CustomButton`.

```js
import React from 'react';
import styled from 'styled-components';

const CustomButton = props => (
  <ButtonContainer
    onPress={() => alert('Hi!')}
    backgroundColor={props.backgroundColor}
  >
    <ButtonText textColor={props.textColor}>{props.text}</ButtonText>
  </ButtonContainer>
);

export default CustomButton;

const ButtonContainer = styled.TouchableOpacity`
	width: 100px;
	height: 40px
	padding: 12px;
	border-radius: 10px;
	background-color: ${props => props.backgroundColor};
`;

const ButtonText = styled.Text`
  font-size: 15px;
  color: ${props => props.textColor};
  text-align: center;
`;
```

By passing an interpolated function `${props => props...}` to a styled component's template literal you can extend its styles. Now add this button to `App.js` file.

```js

render() {
		return (
			<Container>
				<Title>React Native with ðŸ’… Styled Components</Title>
				<CustomButton text="Click Me" textColor="#01d1e5" backgroundColor="lavenderblush" />
			</Container>
		);
  }
```

On running the simulator, you will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*NtpTxTjtBxNl_IR4W-W7lA.png' />

### Building the appâ€Šâ€”â€ŠGroceryÂ UI

In this section we are building a UI screen for an app that would be used for a grocery store. You are going to build the home screen that looks like the one below.

<img src='https://cdn-images-1.medium.com/max/800/1*qRd6EyuiB_nvs3jolhOCeA.png' />

We will be using our knowledge of `styled-components` so let's get started! Open up `App.js`. Declare a new `Container` `View` using `styled`. Inside the backticks, you can put pure CSS code there with the exact same syntax. The `View` element is like a `div` in HTML or web programming in general. Also, create another view called `Titlebar` inside `Container`.

Inside `Titlebar`, it will contain three new elements. One is going to be an image `Avatar` and the other two are text: `Title`and `Name`.

```js
import React from 'react';
import styled from 'styled-components';

export default class App extends React.Component {
  render() {
    return (
      <Container>
        <Titlebar>
          <Avatar />
          <Title>Welcome back,</Title>
          <Name>Aman</Name>
        </Titlebar>
      </Container>
    );
  }
}

const Container = styled.View`
  flex: 1;
  background-color: white;
  justify-content: center;
  align-items: center;
`;

const Titlebar = styled.View`
  width: 100%;
  margin-top: 50px;
  padding-left: 80px;
`;

const Avatar = styled.Image``;

const Title = styled.Text`
  font-size: 20px;
  font-weight: 500;
  color: #b8bece;
`;

const Name = styled.Text`
  font-size: 20px;
  color: #3c4560;
  font-weight: bold;
`;
```

Run `npm run ios` and see it in action.

<img src='https://cdn-images-1.medium.com/max/800/1*QWsjF7juUsD8wHsuD_4M-A.png' />

Right now, the content is in the middle of the screen. We need the `Titlebar` and its contents at the top of the mobile screen. So styles for `Container` will be as below.

```js
const Container = styled.View`
  flex: 1;
  background-color: white;
`;
```

### Adding user avatarÂ image

I am going to use an image that is stored in `assets` folder in the root of our project. You are free to use your own image but you can also download the assets for this project below.

[**amandeepmittal/react-native-workspace**
\_âš›ï¸ + ðŸ“± React Native Things. Contribute to amandeepmittal/react-native-workspace development by creating an account onâ€¦\_github.com](https://github.com/amandeepmittal/react-native-workspace/tree/master/03-RNgrocery-ui/assets 'https://github.com/amandeepmittal/react-native-workspace/tree/master/03-RNgrocery-ui/assets')[](https://github.com/amandeepmittal/react-native-workspace/tree/master/03-RNgrocery-ui/assets)

To create an image with `styled-components`, you need the `Image` component. You can use the `source` props to reference the image based on where it is located.

```js
<Titlebar>
  <Avatar source={require('./assets/avatar.jpg')} />
  <Title>Welcome back,</Title>
  <Name>Aman</Name>
</Titlebar>
```

The styling for `Avatar` will begin with a width and height of `44` pixels. Having a `border-radius` exactly half the value of width and height, which makes the image a circle. `border-radius` is the property that you will be using frequently to create rounded corners.

```js
const Avatar = styled.Image`
  width: 44px;
  height: 44px;
  background: black;
  border-radius: 22px;
  margin-left: 20px;
`;
```

You will get the following result.

<img src='https://cdn-images-1.medium.com/max/800/1*AR9C05E4OOHGmWVkrnxjVQ.png' />

Now notice that the avatar image and the text are piling up. They are taking the same space on the screen. To avoid this, you are going to use `position: absolute` CSS property.

### Absolute Positioning in ReactÂ Native

CSS properties such as `padding` and `margin` are used to add space between UI elements in relation to one another. This is the default layout position. However, you are currently in a scenario where it will be beneficial to use absolute positioning of UI elements and place the desired UI element at the exact position you want.

In React Native and CSS in general, if `position` property is set to `absolute`, then the element is laid out relative to its parent. CSS has other values for `position` but React Native only supports `absolute`.

Modify `Avatar` styles as below.

```js
const Avatar = styled.Image`
  width: 44px;
  height: 44px;
  background: black;
  border-radius: 22px;
  margin-left: 20px;
  position: absolute;
  top: 0;
  left: 0;
`;
```

Usually, with position absolute property, you are going to use a combination of the following properties:

- top
- left
- right
- bottom

In our case above, we use `top` and `left` both set to `0` pixels. You will get the following output.

<img src='https://cdn-images-1.medium.com/max/800/1*xuQEJUyE0rGBNCuzz14ajw.png' />

### Adding icons in a ReactÂ Native

Expo boilerplate comes with a set of different icon libraries such as Ionicons, FontAwesome, Glyphicons, Material icons and many more. The complete list of icons you can find [**here**](https://expo.github.io/vector-icons/), a searchable website.

To use the library, all you have to do is write the import statement.

```js
import { Ionicons } from '@expo/vector-icons';
```

Inside the `Titlebar` view, add the icon.

```js
<Titlebar>
  {/* ... */}
  <Ionicons name="md-cart" size={32} color="red" />
</Titlebar>
```

Each icon needs props for the name that you can choose, size and color. Right now, if you look at the simulator, you will notice the same problem we had when adding the avatar image. There is no space between the icon and other UI elements inside the title bar.

<img src='https://cdn-images-1.medium.com/max/800/1*k0ongnUA5ZLGzvK-QBDvXQ.png' />

To solve this, let us use the absolute positioning property as an inline style to `<Ionicons />`.

```js
<Ionicons
  name="md-cart"
  size={32}
  color="red"
  style={{ position: 'absolute', right: 20, top: 5 }}
/>
```

Why an inline style? Because `Ionicons` is not generated using styled-components.

<img src='https://cdn-images-1.medium.com/max/800/1*EjxFzga9cQWUDNXesQ5KkA.png' />

### Mapping through aÂ List

Inside `components/` folder create a new file called `Categories.js`. This file is going to render a list of category items for the Grocery UI app.

```js
import React from 'react';
import styled from 'styled-components';

const Categories = props => (
  <Container>
    <Name>Fruits</Name>
    <Name>Bread</Name>
    <Name>Drinks</Name>
    <Name>Veggies</Name>
  </Container>
);

export default Categories;

const Container = styled.View``;

const Name = styled.Text`
  font-size: 32px;
  font-weight: 600;
  margin-left: 15px;
  color: #bcbece;
`;
```

All the data is static right now. Import this component in `App.js` and place it after `Titlebar`.

```js
import Categories from './components/Categories';

// ...

return (
  <Container>
    <Titlebar>{/* ... */}</Titlebar>
    <Categories />
  </Container>
);
```

You will get the following output.

<img src='https://cdn-images-1.medium.com/max/800/1*kkLH38JDwcNg6gNCBFs-eA.png' />

There can be a number of categories. To make the names of categories dynamic, we can send it through `App.js`file.

```js
const Items = [
  { text: 'Fruits' },
  { text: 'Bread' },
  { text: 'Drinks' },
  { text: 'Veggies' },
  { text: 'Meat' },
  { text: 'Paper Goods' }
];

// Inside the render function replace <Categories /> with

{
  items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ));
}
```

In the above snippet, you are using the `map` function from JavaScript to iterate through an array render a list of items, in this category names. Adding a `key` prop is required. To make this work, also modify `Categories.js`.

```js
const Categories = props => <Name>{props.name}</Name>;
```

### Adding Horizontal ScrollView

This list is right now not scrollable. To make it scrollable, let us place it inside a `ScrollView`. Open up `App.js` file place the categories inside a `ScrollView`, but first, import it from React Native core.

```js
import { ScrollView } from 'react-native';

// ...
<ScrollView>
  {items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ))}
</ScrollView>;
```

You will notice not a single change in the UI. By default scrollable lists in React Native using `ScrollView` are vertical. Make this horizontal by adding the prop `horizontal`.

```js
<ScrollView horizontal={true}>
  {items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ))}
</ScrollView>
```

It works but does not looks good.

<img src='https://cdn-images-1.medium.com/max/800/1*ynb8YhFnnn56-nLYqSPThg.gif' />

Let us add some inline styles to the `ScrollView`.

```js
<ScrollView
  horizontal={true}
  style={{
    padding: 20,
    paddingLeft: 12,
    paddingTop: 30,
    flexDirection: 'row'
  }}
  showsHorizontalScrollIndicator={false}
>
  {items.map((category, index) => (
    <Categories name={category.text} key={index} />
  ))}
</ScrollView>
```

Now it looks better. The prop `showsHorizontalScrollIndicator` hides the horizontal scroll bar that by default appears beneath the name of the categories.

<img src='https://cdn-images-1.medium.com/max/800/1*IYqopJpgJkPAyif2slhVEw.png' />

### Adding a vertical ScrollView

Next step is to add a `ScrollView` that acts as a wrapper inside the `Container` view such that the whole area becomes scrollable vertically. There is a reason to do this. You are now going to have items separated into two columns as images with texts related to a particular category.

Modify `App.js` file.

```js
return (
  <Container>
    <ScrollView>
      <Titlebar>{/* and its contents */}</Titlebar>
      <ScrollView horizontal={true}>
        {/* Categories being rendered */}
      </ScrollView>
      <Subtitle>Items</Subtitle>
    </ScrollView>
  </Container>
);
```

Notice that we are adding another styled component called `Subtitle` which is nothing but a text.

```js
const Subtitle = styled.Text`
  font-size: 20px;
  color: #3c4560;
  font-weight: 500;
  margin-top: 10px;
  margin-left: 25px;
  text-transform: uppercase;
`;
```

It renders like below.

<img src='https://cdn-images-1.medium.com/max/800/1*X9Db80WNDFSLRVGC1sdkWw.png' />

### Building a card component

In this section, we are going to create a card component that will hold an itemâ€™s image, the name of the item and the price as text. Each card component is going to have curved borders and box shadow. This is how it is going to look like.

<img src='https://cdn-images-1.medium.com/max/800/1*bNCJQ4koGEZVKtbGu6EeqA.png' />

Create a new component file called `Card.js` inside `components` directory. The structure of the `Card` component is going to be.

```js
import React from 'react';
import styled from 'styled-components';

const Card = props => (
  <Container>
    <Cover>
      <Image source={require('../assets/pepper.jpg')} />
    </Cover>
    <Content>
      <Title>Pepper</Title>
      <PriceCaption>$ 2.99 each</PriceCaption>
    </Content>
  </Container>
);

export default Card;
```

Currently, it has static data, such as the image, title, and content. Let us add the styles for each styled UI elements in this file.

```js
const Container = styled.View`
  background: #fff;
  height: 200px;
  width: 150px;
  border-radius: 14px;
  margin: 18px;
  margin-top: 20px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
`;

const Cover = styled.View`
  width: 100%;
  height: 120px;
  border-top-left-radius: 14px;
  border-top-right-radius: 14px;
  overflow: hidden;
`;

const Image = styled.Image`
  width: 100%;
  height: 100%;
`;

const Content = styled.View`
  padding-top: 10px;
  flex-direction: column;
  align-items: center;
  height: 60px;
`;

const Title = styled.Text`
  color: #3c4560;
  font-size: 20px;
  font-weight: 600;
`;

const PriceCaption = styled.Text`
  color: #b8b3c3;
  font-size: 15px;
  font-weight: 600;
  margin-top: 4px;
`;
```

The `Container` view has a default background of white color. This is useful in scenarios where you are fetching images from a third party APIs. Also, it provides a background to the text area below the image.

Inside the `Container` view, add an `Image` and wrap it inside a `Cover` view. In React Native there two ways you can fetch an image

If you are getting an image from the static resource as in our case, you use `source` prop with keyword `require` that contains the relative path to the image asset stored in the project folder. In case of networking images or getting an image from an API, you use the same prop with a different keyword called `uri`. Here is an example of an image being fetched from an API.

```js
<Image
  source={{
    uri: 'https://facebook.github.io/react-native/docs/assets/favicon.png'
  }}
/>
```

The `Cover` view uses rounded corners with `overflow` property. This is done to reflect the rounded corners. iOS clips the images if coming from a child component. In our case, the image is coming from a `Card` component which is a child to `App` component.

The `Image` component takes the width and height of the entire `Cover` view.

Now let us import this component inside `App.js` file, after the `Subtitle` and let us see what results do we get.

```js
render() {
	return (
	<Container>
		<ScrollView>
		{/* ... */}
		<Subtitle>Items</Subtitle>
			<ItemsLayout>
				<ColumnOne>
					<Card />
				</ColumnOne>
				<ColumnTwo>
					<Card />
				</ColumnTwo>
			</ItemsLayout>
		</ScrollView>
	</Container>
	)
}

// ...

const ItemsLayout = styled.View`
	flex-direction: row;
	flex: 1;
`;

const ColumnOne = styled.View``;

const ColumnTwo = styled.View``;
```

After `Subtitle`add a new view called `ItemsLayout`. This is going to be a layout that allows different cards to be divided between two columns in each row. This can be done by giving this view a `flex-direction` property of value `row`. `ColumnOne` and `ColumnTwo` are two empty views.

On rendering the screen of the simulator, looks like below.

<img src='https://cdn-images-1.medium.com/max/800/1*qRd6EyuiB_nvs3jolhOCeA.png' />

### Conclusion

Have you tried styled-components with React Native before? If not, are you going to try it now in your next project? Do comment below if you do or do not find `styled-components` a comfortable way to use in your React Native applications. _You can extend this application too! Let your imagination wander._ You are welcome to submit a PR if you decide to do so.

You can find the complete code for this article in the Github repo ðŸ‘‡

[**amandeepmittal/react-native-workspace**](https://github.com/amandeepmittal/react-native-workspace/tree/master/03-RNgrocery-ui)

[Originally published at Level up coding](https://levelup.gitconnected.com/using-styled-components-with-react-native-de645fcf4787)

---

## Avoiding version conflicts with Vale and GitHub Actions
Slug: vale-and-github-actions

While implementing [Vale](https://vale.sh/) with Reviewdog and GitHub Actions is straightforward in theory, I have encountered a few issues that can sometimes break your CI. Both times, the solution was explicitly defining the Vale CLI version in the CI pipeline.

## Importance of version pinning in CI pipelines

At my day job, we use the prose linting process through Vale and run it on the documentation pull requests and deployment. One of the frustrating things that can happen is the inconsistent results between local and CI (GitHub Actions) due to version differences.

As an example, here is what the complete job looks like:

```yaml
name: Docs Website PR - Content Linting

defaults:
  run:
    shell: bash
    working-directory: docs

jobs:
  docs-pr:
    runs-on: ubuntu-22.04
    steps:
      - name: ðŸ’¬ Lint Docs website content
        uses: errata-ai/vale-action@reviewdog
        with:
          version: 3.11.1 # <--- Pinned version
          reporter: github-pr-check
          files: 'docs/pages'
          vale_flags: '--config=./docs/.vale.ini'
          fail_on_error: true
```

Under `Lint Docs website content`, the `version` explicitly allows for setting a pinned version for this workflow. By default, the `version` is always used as the `latest`, but specifying the Vale CLI version helps avoid inconsistencies between the local version used and the CI.

**Another critical point** that it helps with is to avoid breaking changes. Sometimes, when a breaking change occurs on the latest version of the Vale CLI, it might break your CI. One recent breaking change was the feature introduced in Vale CLI version `3.11.0` to lint [Front Matter](https://vale.sh/docs/formats/front-matter) fields.

## How version differences manifest

The symptoms of version inconsistency are often subtle and, at times, dependent on custom rules you have set in your configuration rules. Newer Vale CLI versions might interpret rules differently and starts flagging the previously acceptable content.

Continuing the real-world example I shared in the previous section, the introduction of version `3.11.0` broke stuff in the following way:

```shell
E100 [pages/some-page.mdx] Runtime error

'Apple Developer Program roles and permissions' not found

Execution stopped with code 1.
```

It took me a while to go back and forth between the version I was using locally and the version used on the CI pipeline to identify what broke and why. Luckily, the maintainer had already deployed the fix in Vale CLI.

## How to use this version locally

There are two ways you can use Vale's CLI version locally. The easiest and lone-wolf approach is to install it in your development environment using one of the [available methods described in Vale's documentation](https://vale.sh/docs/install).

If you are working in a team environment, I recommend using something like [`@vvago/vale`](https://www.npmjs.com/package/@vvago/vale), which can download Vale binary and allow you to run it locally. In my case, it's part of our lint scripts inside the `package.json` file:

```json
{
  "scripts": {
    "lint-prose": "yarn vale ."
  }
}
```

## Verifying your pinned version

If you use the local version as a part of your docs app, you can easily verify it by installing a specific version. The dependency installed will be listed inside `package.json`:

```json
{
  "devDependencies": {
    "@vvago/vale": "3.11.1"
  }
}
```

On CI, after you've pinned the version in the workflow job, you can easily verify the output when that workflow runs by checking the installed Vale CLI version:

<img src="/images/github-actions-vale.png" alt="GitHub Actions Vale job log." class="mx-auto"/>

## Wrapping up

Version consistency might seem like a minor detail, but it can save hours of debugging cryptic CI failures. By pinning the Vale CLI version in GitHub Actions and ensuring it matches the local environment, you will have a much smoother workflow.

---

## Week 2 With React Native - Building a Weather App
Slug: week-2-with-react-native-building-a-weather-app

> [Originally published at Hackernoon.com](https://medium.com/hackernoon/week-2-with-react-native-building-a-weather-app-ca50fcfcb1e1)

This post was supposed to come out last weekend. I had a busy weekend could not find the time to write it nor had the energy to pull off it. Last week, I announced publicly, [in the first post](https://medium.com/@amanhimself/starting-over-with-react-native-aff0dbdf5909), that I have re-started learning and getting hands on experience using React Native. This post is a continuation to that one.

This week I advanced further in my journey. I completed [Spencer Carli](https://medium.com/u/1ec17560bf99)â€™s â€œ[How to Setup a new React Native Project](https://learn.handlebarlabs.com/courses/enrolled/253279)â€. The course goes through absolute basics of setting up a bare minimum app in which I got to learn things like:

- configuring iOS simulator on MAC
- linting with ESlint
- Prettier: using code formatting tool
- Debugging

Though, I had been already familiar with the process of lint and prettier since I use both of them in my daily workflow. Debugging and other modules are a delight to get familiar with in the start and will give an overall aspect of things such that you do not loose patience with yourself when trying to use them later. Moreover, Spencer is a calm instructor and has soothing voice. I enjoyed their method of teaching.

### eslint-config ðŸ› 

I took the linting process with ESLint a step further. I worked on a small npm module called [eslint-config-amanhimself](https://www.npmjs.com/package/eslint-config-amanhimself) and the advantage of using it is that, now I do not have to setup and configure every other React-Native project I start from scratch. The other advantages of using lint tool if you are familiar with web programming, you do not need an introduction.

I personally, recommend you to use [ESLint](https://eslint.org/) with your projects, not only React Native but any other JavaScript library or framework you choose to work with. It does bring consistency in writing code and save minute errors from occurring at the time of compilation.

[**amandeepmittal/eslint-config-amanhimself**](https://github.com/amandeepmittal/eslint-config-amanhimself)

This tool is completely open source and saves a lot of my time and yours will too, if you decide to use it. At least give it a try. I want you to know that I am open to contributors if we can make this utility better that benefits every one.

### Weather CardsÂ â›…ï¸

Next thing I worked on was a small application that I built to fetch weather of city using a third party API and display a set of data in the form of a card. This is how it looks like.

![](https://i.imgur.com/XPIOrxO.png)
![](https://i.imgur.com/5rz4eNi.png)

The main elements that I used in building this application are the following:

- Background image (using `ImageBackground`)
- InputText Value
- Fetching Weather Data from the API `[https://www.metaweather.com/api/](https://www.metaweather.com/api/)`
- Card View UI to display Data

Background Image changes accordingly to the type of the weather which is fetched from the API. In this process, I also learned a bit about using React Nativeâ€™s `Platform` API and how to elevate the card style which is done differently for iOS and android.

Developing for Mobile is different from developing an app for web. In mobile, there are so many different elements to use and take care of. For example, in the below screen notice two things. One is a little cross button to delete the text in one action from the input field (only supported for iOS by RN API, I am sure there might be solution for android but I havenâ€™t tried yet). Next, is the `KeyboardAvoidingView` which automatically re-positions the keyboard (or any other UI element) in the view to show maximum display elements.

![KeyboardAvoidingView Example](https://i.imgur.com/a81AmEV.gif)

In this process, I also learned that creating a custom component is not so hard but publishing it on `npm` for React Native apps is a difficult task. The card view in this application I am using can be found here as a separate component:

[**amandeepmittal/react-native-simple-card**](https://github.com/amandeepmittal/react-native-simple-card)

To setup and build this project I have used _Create-React-Native-App_ which is another wonderful open source tool to quickly kickstart a React Native project.

I had a fun week with React Native. I tried to spend as much time as I could get. _ðŸ™ Thank you for reading this post_.

I also published another article this week on React Native:

[_React Native: How to Setup Your First App_](https://medium.com/@amanhimself/react-native-how-to-setup-your-first-app-a36c450a8a2f)

---

## Week 3 with React Native - Why use Expo?
Slug: week-3-with-react-native

[Originally published at Hackernoon.com](https://medium.com/hackernoon/week-3-with-react-native-107f6779a831)

This week has been a hectic one for me. Deadline coming closer, and too many tasks to complete. It has been a happening one also. I got the invite to join Gatsbyjs open source team, to help and maintain the on going projects. I love contributing to open source communities and projects.

![](https://i.imgur.com/K7zj9sl.png)

### ðŸ‘

This week I took a dive deeper in Expo and React Native. I successfully, implemented Facebook login and access to Firebase database in a RN app using Expo API. Expo is beautiful to work with. It takes care of a lot of native work that otherwise one would be integrating by opening either Xcode or Android Studio. I found these links helpful to go through for providing a Facebook authentication in a React Native app.

- [Expo Facebook](https://docs.expo.io/versions/latest/sdk/facebook#__next)
- For Firebase SDK setup and integration in a React Native app go through [this link](https://docs.expo.io/versions/latest/guides/using-firebase#__next), also provided by Expo API.

One good thing about Expo is that it comes with Create-React-Native-App starter project. Second most important thing I went through this week was integrating and implementing a Redux store in a React Native. To quickly get started, I went through a [Udemy Course by Stefan Hyltoft](https://www.udemy.com/learn-redux-in-react-native-in-less-than-2-hours/) since enrolling was free and seemed to the point. Their explanation of concepts is clear but their methodology of working did not appeal me. Any recommendation on how to organize the actions and reducers will be helpful.

### Why Use Expo for ReactÂ Native?

Expo is popular because it handles a lot of headache tasks itself and provide smooth APIs that work with React Native app outside the box. It is open source and does cost anything to use. To test on a real iOS device you need an Apple developer account (\$99/year). You can accomplish this using Expo for both platforms: iOS and android. Expo provides a client app and by downloading it from the respective stores based on the mobile platform your device runs, you can easily test applications.

Currently, Expoâ€™s SDK handles camera, maps, location tracking, analytics, push notifications and much more. Distributing it an Expo app is easy to. You can complete the process just by running the following command. It has dedicated [store](https://expo.io/) where you can publish apps for others to use. Quite helpful in prototyping.

```shell
exp publish
```

For standalone applications there are command available from the Expo CLI tool that you can use. A standalone app does not need the Expo client to run the application. You can generate IPA or apk files by running:

```shell
exp build:ios

# OR

exp build:android
```

There are shortcomings using Expo. I am not going to list them here but the team behind it seems to works rapidly to implement these new features. You can submit a feature or upvote one using this or get involved as a contributor.

[**Feature Requests for Expo**](https://expo.canny.io/feature-requests)

---

## Week notes 01
Slug: week-notes-01

As 2024 comes to an end, I am starting to write Week Notes. Since this is my first one, I'll keep this recap a short one mainly because these notes are only for me. Also, this week has not been a busy one. With winter and gloomy cold weather due to recent rain, I don't have much to add.

- Rainy end of the week. Mostly, I stayed inside. On days on which the sun was shining brightly, I traveled within the city.
- Headaches are back. I am not sure about the root cause yet; if I am tired or caused by lack of sleep.
- Christmas came and went. I tried to watch a Christmas movie but was unable to pick (decision fatigue), so I decided to start reading Breakfast with Seneca by David Fideler.
- Cleaned up some recurring tasks in Things 3 as they are no longer required. Every morning I wake up and open the laptop, my brain does the job now of reminding them.
- Spent a couple of days working on the dogfooding project using Expo and RAWG API. Tried Expo's new public environment variables for the first time. I am feeling pretty good about the progress I have made so far, which includes using the local development setup environment and using my iPhone to test the app with the iPhone mirroring feature of Sequoia. Spent some time polishing the app's UI. So far, it uses Expo Router for navigation, displays a home screen to display an infinite list of games (using React Query's infinite query hook), Expo Dev tools plugin for React Query, and a second stacked screen to view the details for a particular game item. Created a dynamic modal screen that uses form-sheet presentation for iOS.
- I made naan bread again (after the breadpalooza activity at Expo earlier this month), and this time, they were stuffed.

## Writing

- Wrote 4 complete drafts for upcoming blog posts. I planned out a few more that I hope to complete in the coming weeks. The big one is the yearly review.
- Updated My Macbook setup post's description and VS Code extensions list
- Wrote one unfinished blog post based on the recent dogfooding Expo app

## Reading

- Finished book 54: Breakfast with Seneca by David Fideler. Started reading it on Christmas day. I liked how they focused on twelve to thirteen Seneca's letters for the book's core. It has some references from Epictetus and Marcus Aurelius, but you cannot go without it when reading or writing a book, Stoicism.
- Finished book 55: The Art of Note-taking by Thinknetic. It was okay. The five note-taking strategies discussed in the book, the sentence-based note-taking technique, stood out. I learned about myself that I already do that sometimes (especially during meetings) with a list/outline structure that I follow.

## Photos

One pic of the week is the stats from my Kobo Libra 2 color:

<img src="/images/week-notes/01.jpeg" alt="Weekly Kobo Libra 2 stats" width="360">

---

## Week notes 02
Slug: week-notes-02

Happy New Year! First-week notes of 2025.

- Maintained my workout routine for the latter half of the week.
- Completed EAS tutorial updates, a mini project I started over the winter holidays.
- I went through the Google Search Console 404 report for the docs site I help maintain at work. Found something interesting. Even though the dashboard shows that the affected pages are over 1.4k, the genuinely affected pages were less in number, and the source of these pages comes from the redirects that haven't been updated in a while after some clean-ups and removing the archived pages during the last 6 weeks of 2024.
- Went down the path of generating an `llms.txt` file for the Expo docs site. The online available tools like [llmstxt.firecrawl.dev](https://llmstxt.firecrawl.dev/) and [llms.txt generator by Sitespeak.ai](https://sitespeak.ai/tools/llms-txt-generator) did not work as expected. I expected them to generate an output of all the pages with their meta description. However, it seems there are too many pages for these kinds of tools.
  - Then, after a little bit of searching I found a tool called [llmstxt](https://github.com/dotenvx/llmstxt) by dotenvx team that converts the `sitemap.xml` of a site to `llms.txt`.
  - I think this tool is pretty easy to use because it is available as an npm package.
  - I also think it could fit with maintenance when new pages are added to the docs site.
  - One thing left here is I need to go through the output again to find any false positives or missing context before committing this to the Expo docs.
- The air quality in New Delhi was terrible for most of the week:

<blockquote class="bluesky-embed" data-bluesky-uri="at://did:plc:plmvu6gny24jklc5lqgcnblt/app.bsky.feed.post/3levepkk2qk2d" data-bluesky-cid="bafyreiad3a5skf7rctwvs6iloiyf3jhg7lqbhyyspdh3smneezdb26qt34"><p lang="en">404 air not found<br><br><a href="https://bsky.app/profile/did:plc:plmvu6gny24jklc5lqgcnblt/post/3levepkk2qk2d?ref_src=embed">[image or embed]</a></p>&mdash; Aman Mittal (<a href="https://bsky.app/profile/did:plc:plmvu6gny24jklc5lqgcnblt?ref_src=embed">@aman.bsky.social</a>) <a href="https://bsky.app/profile/did:plc:plmvu6gny24jklc5lqgcnblt/post/3levepkk2qk2d?ref_src=embed">January 4, 2025 at 10:58 AM</a></blockquote><script async src="https://embed.bsky.app/static/embed.js" charset="utf-8"></script>

## Writing

- Published my [yearly review for 2024](/blog/year-in-review-2024/). It was a last-minute draft, so I followed the same pattern for the post as last year.

- Wrote four complete drafts that I will publish soon. I need to plan out their publishing dates to consistently publish these new posts.

## Reading

- Started Reading Every page is page one by Mark Baker, a book on how people on the web use content and strategies on topic-based documentation.

---

## Week notes 03
Slug: week-notes-03

First full-blown week of work after winter holidays in the USA.

- Maintained my first work routine for the first half of the week. Due to not sleeping enough, I missed the workout for the next 3 days.
- Experimented creating an interactive diagram using the React Flow library for docs work. Things got a bit complicated, but I like the outcome so far.
- Going to look at adding hidden but viewable side-quests next week.
- Started doodling. I did end up drawing a lighthouse.
- Created a mini-game clone in React Native with the help of Claude. Used it mostly to rectify logic and generate sprites. I am fascinated by how Claude can help with tasks that I could spend endless hours on the internet.

## Writing

- Not much writing outside work. No new drafts.

## Reading

- Completed Every Page is Page One by Mark Baker. Started this at the end of 2024. It was a heavy read with lots of information. Learned about a bottom-up approach for topic-based writing and presenting documentation to the end user.
- Completed two short graphic novels.
- Completed How to Take Smart Notes by SÃ¶nke Ahrens. I'm surprised that this book is so approachable and has a perfect length without any repetition or time wasting. I learned about fleeting, literature, and permanent notes while maintaining a Zettelkasten.

---

## Week notes 04
Slug: week-notes-04

Second full week back to work this year.

- I was able to get a workout for half of this week. It includes mostly weight but a little bit of cardio.
- I did some self-reflection. There are a lot of things I'd like to work on about myself and my mental health.
- Played Celeste. Such a beautiful game. Not only was the narrative to the mark, but the play was also interesting. Even though I died a lot and took the help of assist mode (well thought out by developers), it was a nice 3 hours spent.
  - The Celeste classic version was created in Pico-8, which is amazing! I only learned about Pico-8 last week and its usage. Fascinating!
  - I do not pay much attention to soundtrack while playing games but this game has a really immersive one.

## Writing

- Wrote one new blog post draft this week.

## Reading

- Started The Dance of Fear by Harriet Lerner.
- Took a little break from the reading this week. I didn't complete the book I started, and yet it feels nice to take a break.

---

## Week notes 05
Slug: week-notes-05

- My mental health has not been the best this week. It's been difficult to focus to watch/read/listen due to lack of sleep.
- Made more progress to completing the llms.txt project at work. Ended up writing custom scripts to generate data in markdown from local files instead of using an external tool to scrape data from the document site.
- Played around with PiCO-8 for a while over the weekend. It was nice and fun. I like how restrictive it is.
- Did some style changes to the blog by fixing some issues with both dark and light themes that are used on this blog. In the end, I decided to change the color scheme for both themes because I felt the code blocks for both themes didn't match the dark theme at all and were too light for the light theme.

## Writing

- One new draft this week.

## Reading

- Finished reading Masters of Doom by David Kushner. While it was nostalgic since I remember playing Wolfenstein 3D as one of the first games on a PC, the book wasn't that impressive. It jumped a lot between different timelines in a short number of pages.

---

## Week notes 06
Slug: week-notes-06

Happy February! I honestly don't know where January went.

- I was able to make more progress this week with the llms.txt project. Other tasks did suffer because of that.
- Did some more style changes to the blog this week by fixing some theme issues. Good thing about using Astro it that it [includes Shiki](/blog/new-blog-theme-and-colors/) out of the box.
- I had a bad migraine episode which lasted for almost two days.
- Made progress on a hobby project that I started last month.

## Writing

- One new post on the new blog theme.

## Reading

- Completed 5 volumes of the Bakuman, a manga about a manga artist's journey.

---

## Week notes 07
Slug: week-notes-07

Not a good week for my mental health. Most of the week was spent overthinking, migraine, more overthinking, and more pain.

- The weather is changing and becoming warmer, so it might help in the coming weeks.
- Work week was busy.
- Workout-wise, it was a good week. I managed to do complete routines and brisk walking for the majority of the week.
- Started playing Shovel Knight: Shover of Hope and mind blown that there's no save the progress feature available. I guess that's retro platformer behavior they tried to implement in this game, but I really miss it.

## Writing

- Published a [new blog post](/blog/using-at-method-from-javascript/).

## Reading

- Completed volume 6 of the Bakuman.
- Completed How to Calm Your Mind by Chris Bailey. I can confirm I am not a fan this book.

---

## Week notes 08
Slug: week-notes-08

<!-- vale off -->

Trying out a slightly new format for weekly notes this week.

- The weather was primarily warm during the daytime; I suspect the summer will be here in no time.
- ðŸ“ I [shared](https://amanhimself.dev/blog/dual-shiki-themes-with-astro/) how easy it is to set up dual Shiki themes for code blocks in an Astro blog. This is also something I implemented on my blog recently.
- ðŸ“š Started reading Good Habits, Bad Habits by Wendy Wood.
- ðŸ‹ï¸ Only 3 days this week.
- ðŸ‘¾ Started playing Octopath Traveller 2. This is my first [JRPG](https://geektogeekmedia.com/geekery/video-games/what-is-a-jrpg-definition-japanese-jrpgs-game/). I like this game. The graphics are extraordinarily amazing! The in-game battle mechanics always have something new to offer, and there is so much to offer. The only thing I am struggling with so far is what to do with townsfolk when, as an MC, you visit a new town.
- ðŸ”— Blogroll (post(s) I have been reading this week)
  - I loved reading [My Obsidian Note-Taking Workflow](https://www.ssp.sh/blog/obsidian-note-taking-workflow/) by Simon SpÃ¤ti on his blog. He explains how he uses PARA and Zettelkasten together while keeping things in his workflow simple and efficient so that he can continue taking notes. There is also a focus on everything being based on Plaintext files and being Local First, which is why I [prefer using Obsidian myself](/tags/obsidian/).

<!-- vale on -->

---

## Week notes 09
Slug: week-notes-09

Another week, another set of notes.

- Completed the llms.txt project at work. Now, all areas of documentation have their llms.txt files generated. I am using custom scripts, and the challenging part was navigating the SDK documentation. After trying different methods to achieve an output level without missing any information, I decided to use a third-party library called [sitefetch](https://github.com/egoist/sitefetch) instead of writing my own script for the SDK docs. Yes, it does make network calls, but that isn't a trade-off in this situation. Fetching data from over 90 SDK pages only takes a minute, considering the amount of data rendered on those pages.
- ðŸ“ Shared how to change the PICO-8 cart storage location on macOS. I wrote a draft about excluding certain JSX components from Vale to prevent them from being linted. This use case is common when MDX is employed to manage Markdown text within a documentation's source code.
- ðŸ“š Completed reading Good Habits, Bad Habits by Wendy Wood and completed 3 Sakamoto Days volumes.
- ðŸ‘¾ Continued playing Octopath Traveller 2 for a little while. Not much progress.
- ðŸ”— Post(s) I read this week
  - [The Flow State](https://vale.rocks/posts/the-flow-state) by Declan Chidlow

---

## Week notes 10
Slug: week-notes-10

_I haven't written a weekly note since [February](/blog/week-notes-09/) and I am trying to get back into it._

This week has been incredibly busy with a busier weekend and I am writing this late on a Sunday.

- ðŸ“ Published a post about [avoiding version conflicts when using Vale as part of your docs tooling](/blog/vale-and-github-actions/). At my workplace, we use GitHub Actions and recently, I ran into an issue where Vale CLI broke both locally and on CI. I wrote this post as a reminder to always make sure that the version used locally (which is battle-tested) should be the same version used in the CI pipeline.
- ðŸ“ Another post in the docs-as-code (I have three now, can I call it series?). This time it's an explanation about disabling the scope inside a Vale CLI rule file for [front matter](/blog/front-matter-scope-in-vale/).
- It took some courage, but I finally started sharing what I wrote on this blog with my "social" network. I shared the docs-as-code posts that I've written recently about Vale. And yes, I did end up calling it a series.
- ðŸ“ I also worked on two draft posts in the realms of React Native. I need to polish them more before publishing.
- ðŸ“– I've subscribed to Readwise Reader app and all my TBR list living inside Chrome tabs for last six months is now inside the Reader app's inbox.
- ðŸ“šThis month I have read a three fiction books (they were great companions when I was traveling earlier). I have managed to finish The 30-Day burnout fix by Janessa Rhoades.
- ðŸ”— Post(s) I'm reading this week
  - [What Is Developer Advocacy? (2025 Edition)](https://ashley.dev/posts/what-is-developer-advocacy/) by Ashley Willis

---

## Week notes 11
Slug: week-notes-11

I am back to writing weekly notes and I am going to keep things casual this time.

This week was a bit fast and slow at the same time.

- ðŸ“ Published a post about creating a ["copy Markdown" button for documentation sites that use MDX for content and Next.js](/blog/create-a-copy-as-markdown-for-mdx-documentation/). This is a custom approach that I'm using at work. I wanted to share an overview of this approach since the main reason a docs site uses MDX is that it has different dynamic content sources that are stitched together at runtime to present the final content on a page. Dynamic content sources are not included in the raw Markdown output of an MDX file, and it can be tricky to handle them for a "copy Markdown" button.
  - This is one of the longer posts I have written this year.

- ðŸ“ Another post I published last weekend was about [adding a recent posts section to a blog that uses Astro as an SSG engine](/blog/add-recents-posts-astro-section/). I used the same approach to add a "related posts" section to each post.

- ðŸ’» I've made some improvements to my blog, which include displaying tag counts with each tag link on the [blog](/blog/) index page. I've also added a "related posts" section at the end of each post. The last change I made was to add a new page to view a year-by-year bar chart of all posts published on this blog at [posts-count](/posts-count/).

- ðŸ“š This month I have read two books:
  - I finally completed [Prompt Engineering for LLMs](https://www.goodreads.com/book/show/221244015-prompt-engineering-for-llms) by John Berryman and Albert Zielger. I started this book in September and it took me a while to finish it. It is an interesting read as it covers the basics and some advanced techniques on how to deal with prompts. The important takeaway for me was to get a view of the _magic_ that happens behind the scenes when we use LLMs.
  - The second book I read was [Writing better with Vale](https://www.goodreads.com/book/show/241849517-write-better-with-vale) by Brian P. Hogan. It's a short book and nails the introduction to Vale, which is a tool to lint your documentation content. There are some in-depth examples discussed in the book for use in a monorepo setup or when you have multiple content sources hosted from a large repository. It also goes into the basics of how Vale works behind the scenes and how to use it with a CI/CD pipeline.

---

## What is Ionic
Slug: what-is-ionic

Ionic is an open source, front-end SDK for developing Hybrid Mobile Applications using web technologies such as HTML, CSS and JavaScript. It provides mobile optimised web technology based components as well as native APIs using Cordova and Ionic Native.

Ionic with itâ€™s latest version, is performance efficient using minimal DOM manipulation. Angular also plays a major role in increasing the performance of an Ionic application.

It has itâ€™s own command line interface tool that is really helpful to scaffold and develop an application and majorly in avoid writing boilerplate code, thus, saving precious time.

### Development Setup forÂ Ionic

### Nodejs andÂ npm

To develop and run Ionic apps, we need Nodejs, most importantly, because Ionic uses Nodeâ€™s CLI to build tasks and generate resources. Navigate to [Nodejs official website](https://nodejs.org/) to download Nodejs and itâ€™s package manager: `npm`.

To check of Nodejs is installed correctly, in your terminal window:

```shell
$ node -v
v6.11.0

$ npm -v
3.10.10
```

npm is a Package Manager that is used to download almost every dependency in an Ionic Project.

### TypeScript

Next step is to install TypeScript compiler.

```shell
$ npm install -g typescript

# After installation, to check if installed correctly:
$ tsc -v
Version 2.3.4
```

### Install Cordova and IonicÂ CLI

```shell
$ npm install -g cordova ionic
```

Verify your installation by:

```shell
$ cordova -v
7.0.1

$ ionic info
global packages:

    @ionic/cli-utils : 1.3.0
    Ionic CLI        : 3.3.0

System:

    Node       : v6.11.0
    OS         : macOS Sierra
    Xcode      : Xcode 8.1 Build version 8B62
    ios-deploy : not installed
    ios-sim    : not installed
```

### Platform Guides

To install platforms such as iOS and especially android, I will want you to refer to the official guidelines:

- for iOS: [Cordova iOS Platform Guide](https://cordova.apache.org/docs/en/latest/guide/platforms/ios/)
- for android: [Cordova Android Platform Guide](https://cordova.apache.org/docs/en/latest/guide/platforms/android/)

[Originally Published at Hackernoon.com](https://medium.com/hackernoon/what-is-ionic-c1da6eab0d8a)

---

## Whatâ€™s New in npm 5?
Slug: whats-new-in-npm-5

In May, in the very last week, [**npm**](https://npmjs.com/) announced the new major release for the JavaScript package manager. **5.0.0**, hopefully, will be shipped with upcoming version of [**Nodejs**](https://nodejs.org/en/) **(>=8.0.0)**as well. It seems a big step towards providing better tooling with significantly improved performance as quite a lot of developers made a switch to `yarn`, just because it could download the packages from the `npm` registry at a faster rate. However, this point is debatable, so letâ€™s not get into that.

## A Peek at MajorÂ Changes

Some of the major changes that I want to highlight in this article and am eagerly looking forward to are:

- `npm will --save` is available by default now. See the [demo](https://x.com/maybekatz/status/859229741676625920) with your own eyes.
- Running `npm` while offline will no longer insist on retrying network requests. npm will now immediately fall back to cache if possible, or fail.
- `--cache-min` and `--cache-max` have been deprecated, so, existing npm caches will no longer be used.
- A new `--prefer-offline` option will make npm skip any conditional requests for stale cache data, and only hit the network if something is missing from the cache.
- A new `--prefer-online` option that will force npm to revalidate cached data, ignoring any staleness checks, and refreshing the cache with revalidated, fresh data.
- A new `--offline` option will force npm to use the cache or exit. It will error with an `ENOTCACHED` code if anything it tries to install isnâ€™t already in the cache.
- A standardised lockfile feature is available by default and will be for cross-package-manager compatibility (`package-lock.json`), and a new format and semantics for shrinkwrap.
- Downloads for large packages are streamed in and out of disk. npm is now able to install packages of any size without running out of memory.
- Last, itâ€™s a bit faster. [Demo here](https://x.com/maybekatz/status/865393382260056064?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed&ref_url=https%3A%2F%2Fcdn.embedly.com%2Fwidgets%2Fmedia.html%3Ftype%3Dtext%252Fhtml%26key%3Da19fcc184b9711e1b4764040d3dc5c07%26schema%3Dtwitter%26url%3Dhttps%253A%2F%2Ftwitter.com%2Fmaybekatz%2Fstatus%2F865393382260056064%26image%3Dhttps%253A%2F%2Fi.embed.ly%2F1%2Fimage%253Furl%253Dhttps%25253A%25252F%25252Fpbs.twimg.com%25252Fprofile_images%25252F848625085942349824%25252FBZtSBqtV_400x400.jpg%2526key%253Da19fcc184b9711e1b4764040d3dc5c07)

Hopefully, they update their docs quickly with this new update and more users like me will be able to switch or access much of these key features. For detailed look into npm5â€™s features have a look at their [official blog post](http://blog.npmjs.org/post/161081169345/v500) in which they have listed every other breaking change coming with the new release.

To start using the latest version of npm, you can in your terminal window or preferable shell:

```shell
npm install -g npm@next

# Or

npm install -g npm@latest
```

---

## 2021 - A year in review
Slug: year-in-review-2021

As we transition to 2022 and leave 2021 behind, it's a great time to reflect on the year passing by. It is my second year writing a ["year review"](https://amanhimself.dev/blog/year-rewind-2020/). It's fun for me to look back over what I did and what I focused on last year. I want to continue the tradition this year as well.

I started this year in a burnout phase. I didn't feel like doing things that generally excite me. It took me a while to realize that I was in the phase. If you don't realize it, you won't know what hit you. Getting burned out from last year was not over. It takes time to accept it and get out of it. That's okay, and I'm glad I took my time.

That said, I focused on the areas I could or had the energy to do so. And I'm happy with the choices I've made so far.

## Working as a Developer Advocate ðŸ¥‘

I got my first role in DevRel early this year from a career perspective. I started [working as a Developer Advocate at Draftbit](https://amanhimself.dev/blog/first-three-months-as-developer-advocate/). It was not something I was actively looking for, but I couldn't say no to it when the opportunity arrived. It was a significant change for me, the kind of change I needed without knowing.

Working as a Developer Advocate allowed me to learn a lot about different things, majorly about documentation and working in a fast-paced environment. Working closely with a team with a lot of experience and learning about moving pieces of a business is a precious addition to any technical career.

Most of my work time was spent on writing content and leading documentation. Picking up pieces and trying to recognize the gaps were challenging. That's still a work in progress. For me, technical writing and blogging have been an integral part of my career. This year was better because I used my skills and experience and acquired more knowledge.

## I wrote 43 articles âœï¸

Writing tech articles or tutorials is a gateway for me to engage with the tech community and keep me indulging in upcoming updates, starting conversations with people, and meeting new folks. I enjoy the process of writing and everything that comes with it. I still get to learn and share many long-form tutorials, but I also tried publishing a few short notes on this blog. Something that I haven't done in a long time and turns out people like to read them too.

Here are some of the most popular posts I wrote this year:

- [Setup Macbook M1 for Web and React Native development](https://amanhimself.dev/blog/setup-macbook-m1/): one of the most read blog posts. I'm glad I wrote it. The process of setting up a new laptop thrice a year can be daunting (the laptop that I bought at the start of this year went dead for no apparent reason, and then I had to buy a replacement for it while it went for repair, fun times ðŸ˜¬). I'm also actively updating this post and will continue to do so for a while.

- [How to Create a Custom Image Gallery in React Native](https://amanhimself.dev/blog/custom-preview-image-gallery-in-react-native/) In this tutorial, I talk about how to create a custom gallery of images using react-native-snap-carousel and FlatList component from React Native. The FlatList is used to display the thumbnail view for each image below the carousel. The construction of the syncing part between the two is to add functionality such that when an image in the carousel is scrolled either left or right, the thumb in the FlatList is also going to be scrolled along with it. To achieve this synchronization between the two, I used React Hooks.

- [How to use shared element transitions in React Native](https://amanhimself.dev/blog/shared-element-transitions/) I learned a bit about using Shared Elements in React Native and React Navigation. Transitions in mobile applications provide design continuity. This continuity is provided by connecting common elements from one view to the next while navigating in the app. I wrote about the process of doing that in this post.

- [How to Create a Custom Tab Bar in React Native](https://amanhimself.dev/blog/create-custom-tab-bar-in-react-native/) Another post that I was excited to work on. Creating a custom tab bar using Bottom Tab Navigator from React Navigation and Blur View.

My personal blog is one of the most consistent things in my life. I didn't run experiments on it, move to a new framework, or try a complete overhaul. It is still flawed. I have an ongoing list of things that I'd like to implement as I find myself writing more active over the years. I also love that people like to visit it and read the content I share here.

Overall, I got a pretty consistent readership this year with over 90k+ views:

![ss1](https://i.imgur.com/0gGHK68.png)

It is also interesting to see that whatâ€™s driving most of the traffic is old articles:

![ss3](https://i.imgur.com/msuWpjr.png)

And, also that visitors are coming mostly through organic search:

![ss4](https://i.imgur.com/xErLMj1.png)

I still cross-post stuff at times on [Medium](https://medium.com/@amanhimself), [Dev.to](https://dev.to/amanhimself) and ~~[Hashnode](https://amanhimself.hashnode.dev/)~~. Not as much as I would like to, but I am eager to explore Hashnode more next year.

Dev.to has been my focus on cross-posting this year. I did manage to get 70k+ views and 15k followers.

![ss2](https://i.imgur.com/B8tQxBN.png)

## I spoke at a few events ðŸ—£

Giving talks or speaking is not my strongest asset, and I used to find it quite challenging (at least in my head). Although, after going through some appearances, I did find it quite satisfying.

Thanks to React Day Bangalore for inviting me for a panel discussion on React Native. It's on [YouTube](https://www.youtube.com/watch?v=_HKzhe8f47Y). I also [gave workshops](https://amanhimself.dev/speaking) due to my role of working as a Developer Advocate.

I also got invited [to speak at a Twitter space](https://x.com/TheAnkurTyagi/status/1465624585773228034). Thanks to my friend Ankur ([@TheAnkurTyagi](https://x.com/TheAnkurTyagi/)) for the invitation and hosting it. We talked about tech writing and its impact on being a Developer Advocate role and working with startups.

## Highlights from my GitHub ðŸ™

Last year, I started to maintain [a single GitHub repo](https://github.com/amandeepmittal/react-native-examples) for all the demos and example apps I write using React Native and Expo. These example apps are part of the tutorials you see on this blog. I continued to do it this year as well.

Another thing I maintain is an [Expo Community project](https://github.com/expo-community/expo-firebase-starter) that integrates Firebase JS SDK in an Expo app. Since the Expo SDK's exponential growth in the past year with the awesome tooling, Developer Experience (DX), and support for native modules, I have some thoughts on what changes I'll be doing next year. Keep an eye on this [GitHub repo](https://github.com/expo-community/expo-firebase-starter).

I also got my first [GitHub sponsor](https://x.com/amanhimself/status/1454352509124820994) this year ðŸ¤©

## Newsletter saga continues ðŸ’Œ

I failed to run my [weekly newsletter](https://amanhimself.substack.com/). First, it became bi-weekly and then monthly. It's all due to my inconsistency in sending out and not managing my time with publishing posts. However, it did grow to 1319 subscribers from 1201 last year. I appreciate folks who stick around after me being inconsistent enough to deliver.

<!-- vale off -->

I did move it from Substack to Revue after Twitter acquired Revue. With Revue, I like the experience so far. I've been using it for three months and have sent three newsletters. Anyone using Twitter can now easily subscribe from [my Twitter profile](https://x.com/amanhimself). Thanks to my buddy [Scott Spence](https://x.com/spences10) who showed me how easy it was to migrate to Revue. If you're on Twitter, then give Scott a follow. He's an amazing person, an experienced developer, and he creates awesome content in the Web Dev space.

<!-- vale on -->

## Reading ðŸ“š

I did manage to go through some good books this year. Here are some of my picks that I enjoyed reading:

- [Getting Started in Developer Relations by Sam Julien](https://www.goodreads.com/book/show/57735972-getting-started-in-developer-relations): One of the best resources I read starting out. Sam concisely talks about what a Dev Rel/Advocacy role is about, the skillset, the mindset, and some red flags when seeking a role like this one. I highly recommend this book.
- [The Business Value of Developer Relations: How and Why Technical Communities Are Key to Your Success](https://www.goodreads.com/book/show/40167835-the-business-value-of-developer-relations): It goes more in-depth and talks about the importance of nurturing a community, maintaining positive relations, building a team of DevRels, and much more.
- [Before the Coffee Gets Cold: Tales from the CafÃ©](https://www.goodreads.com/book/show/54373691-before-the-coffee-gets-cold) &mdash; I've only one word for it: mesmerizing!

## Travelling

During the end of the year, I managed to get out of New Delhi for the first time in two years for a [weekend trip](https://www.instagram.com/p/CXsVqr9lJyY/):

![ss5](https://i.imgur.com/qRBwCNO.jpg)

## Wrapping up

Even though I have been inconsistent with my personal goals this year, failing to achieve many of them, yet, there is a lot of things when I look back at this year that I did and the choices I made, I am glad it happened.

Thank you for reading this post and reading any other post, opening and reading email newsletters, reading my tweets on Twitter, and listening to me ðŸ™

Have a great 2022!

---

## 2022 - A year in review
Slug: year-in-review-2022

My blog has been neglected for the last few months. Writing a year review is my way of making amendments to start writing back and reflecting on the year gone by.

It's been a good year that allowed me to focus on myself. I do not feel one bit guilty about not writing enough or creating enough. I spent most of my time prior to this year in a burnout state. I did not want to repeat that. Getting over burnout is tricky, and I am not sure if I am completely over it, but I often feel that I am coping better than before.

Right now, I'm still trying to balance my life and work and find a way to fit the new endeavors I'm seeking to pursue in between.

## Starting the year with a new job

I started the year by switching jobs in a new role as a [Senior Content Developer at Vercel](https://x.com/amanhimself/status/1488351029708341251).

I was excited to work full-time on the docs team. In the past year, I have often felt like I have been working towards this career path. I started at the end of January and left it at the end of April.

During my time there, I learned a lot about working on a team full of creative and hyper-focused people who shared a love for writing and creating content like mine. But unfortunately, it was a short adventure. I felt left out as the weeks passed. Besides writing in tech, I've been a part of React Native community since almost the beginning of my career. So that shift in tech focus I was working daily was a huge leap to take mentally.

## App.js conf 2022

[App.js conference](https://appjs.co/) has been a vital part of my professional career. I forgot what it felt like to be at a tech conference (since the last one I attended was in 2019) and in the end, it was an amazing experience.

Meeting with beautiful and like-minded people who share their work and interesting ways of solving problems is always fascinating and curiosity-engaging. Not only one gets to see the new and exciting upcoming stuff but also meeting people in person after such a long and limited human exposure felt like it was the first time.

![Me with friends at the App.js conference in June 2022](https://2022.appjs.co/images/photos/0014.jpg)

[It was a wonderful experience to attend it in person](https://x.com/amanhimself/status/1535694759653740547), meet old friends, make new ones and travel once again. Everything from the venue, the beautiful city of Krakow, the quality talks, and the MCs, was a great experience. Kudos to the organizers for hosting it and providing that altogether!

## Joining Expo

I joined Expo at the end of June 2022. Leaving my previous role, traveling and attending a tech conference, and getting the new opportunity was like a full circle. I am working majorly on the docs. Other areas of my work include engaging with the community.

Before joining, I'd been familiar with the team and their work for four years. From the outside, I know the tremendous amount of hard work the whole team puts in. Driving React Native ecosystem forward, making exponential improvements with each SDK version, focusing on better tooling, Developer Experience (DX), and adding support for native modules. After joining, it is exciting to observe that closely and be a part of it every day!

## I wrote 21 articles

I enjoy the process of writing for many reasons. One is that I get to learn something new and deepen my understanding of a topic. Another is pretending to be the first user and trying to understand a way of solving a specific problem.

It also opens doors for me to explore new opportunities. This year, I got to work with some of the publications I have been working with for a long time such as Jscrambler and Logrocket. Two new additions where I published a couple of tutorials as a guest author for [Sentry](https://blog.sentry.io/authors/aman-mittal/) and [FlyCode](https://blog.flycode.com/how-to-use-flycode-to-update-your-react-apps-on-the-fly).

It also turns out people like to read them too. Here are some of the most popular posts I wrote this year:

- [Setup Macbook M1 for Web and React Native development](https://amanhimself.dev/blog/setup-macbook-m1/): Even though, this post was Originally published in 2021, I'm actively updating this post and will continue to do so for a while. It's been a popular post once again and I hope it helped folks to get started with their new Macbooks.

- [How to install Node.js using NVM on macOS M1](https://amanhimself.dev/blog/install-nodejs-using-nvm-on-macos-m1/): I had fun collecting this piece of information. For a long time, I have been using NVM to manage Node.js on the fly. I wrote this one to make a walkthrough of how to set it up and keep up with the latest Node.js versions.

- [Getting Started with React Navigation v6 and TypeScript in React Native](https://amanhimself.dev/blog/react-navigation-v6-and-typescript-in-react-native/): A post that was exciting to work on. In this tutorial, I discussed how to add type checks to the app screens and how to add type checks to the React Navigation navigators. Using type checks and annotating navigators is a great way to make your app more robust and maintainable when using TypeScript with React Navigation.

- [Implementing Infinite Scroll with React Query and FlatList in React Native](https://amanhimself.dev/blog/infinite-scroll-with-react-query-and-flatlist-in-react-native/): Another exciting post that I wrote to explore how to implement infinite scrolling in an app using React Query and a real-time external API.

- [Set up a Next.js project with ESLint, Prettier, Husky, and Lint Staged](https://amanhimself.dev/blog/setup-nextjs-project-with-eslint-prettier-husky-lint-staged/): In this post, I shared my personal and minimal configuration that I used in a couple of Next.js projects.

## I redesigned my blog

My blog is one of the most consistent things in my life. This year, I decided to finally move it to Next.js (if you have been reading this post from the top, you might have realized why ðŸ˜„). It was fun to do it and to learn new frameworks such as Next.js and Chakra UI.and and implement some of the tweaks that have been on my backlog for a while. I have decided to call the current version 9. Honestly, there have been so many changes and tweaks since I started it in 2019 that I have lost track in the past.

### My blog in numbers

I moved away from Google Universal Analytics since their public announcement about GA4 to Fathom in the middle of March. However, I did not remove Google Analytics from my blog after I realized that I might lose historical data for the first three months.

Overall I got a pretty consistent readership this year with over [150k+ views](https://amanhimself.dev/blog/year-in-review-2021/#i-wrote-43-articles):

![Yearly stats from Google Analytics 3](https://res.cloudinary.com/amanmittal/image/upload/v1672559907/CleanShot_2023-01-01_at_13.24.51_2x_zujbbg.png)

It is also interesting to see that what's driving most of the traffic is a mixture of both old and new articles:

![This year, both old and new articles are driving traffic to my blog](https://res.cloudinary.com/amanmittal/image/upload/v1672561827/CleanShot_2023-01-01_at_13.59.48_2x_bv5t2n.png)

Also that visitors are coming mostly through organic search:

![Most traffic is organic](https://res.cloudinary.com/amanmittal/image/upload/v1672561601/CleanShot_2023-01-01_at_13.56.26_2x_x6jacf.png)

I occasionally cross-posted my articles on [Medium](https://medium.com/@amanhimself), [Dev.to](https://dev.to/amanhimself) and ~~[Hashnode](https://amanhimself.hashnode.dev/)~~. Not as much as I would like to since I didn't spend that much time writing.

Dev.to is my primary platform to focus on cross-posting this year. I did manage to get 45k+ views.

![Dev.to stats, in a nutshell, this year](https://res.cloudinary.com/amanmittal/image/upload/v1672562431/CleanShot_2023-01-01_at_14.05.52_2x_z0rws4.png)

## Hackernoon award

Awesome folks at Hackernoon nominated me for two categories in the Noonies 2022 awards. One of the categories was [Most authentic Developer Advocate of the year](https://noonies.hackernoon.com/2022/programming/2022-most-authentic-developer-advocate-of-the-year).

I ended up winning the award (to my surprise). **A huge thanks to anyone who voted for me (and is reading this post ðŸ¤—).** I'm humbled by the recognition

![Noonies 2022 award for most authentic developer advocate of the year](https://pbs.twimg.com/media/Fj7zc51acAELXgH?format=jpg&name=medium).

### Newsletter saga continues

Less writing equals less number of issues. I did manage to send out a newsletter anytime I had something to share. However, this project was also abandoned for the last four or five months.

[Last year](https://amanhimself.dev/blog/year-in-review-2021), I was charmed by Revue and decided to jump on the wagon. Unfortunately, however, Twitter's new owners have decided to close it down. After moving to Revue, I thought I could stick with the service for some time, but the newsletter saga continues.

I have decided to move to Substack. I have used it in the past, and it's a good service. If you haven't already subscribed and would like to, here is the link: [amanhimself.substack.com](https://amanhimself.substack.com/). Even though Revue did allow migrating existing subscribers to Substack, there was no way of migrating the previous issues.

## Highlights from my GitHub

A couple of years back, I started to maintain a [single repo](https://github.com/amandeepmittal/react-native-examples) for all the demos and example apps I write using React Native and Expo. These example apps are part of the tutorials you see on this blog. To my surprise, it reached 700+ stars. It's still being actively maintained by me and occasional PRs from other contributors.

I also continued to maintain the [Expo Community project that integrates Firebase JS SDK in an Expo app](https://github.com/expo-community/expo-firebase-starter). After being involved directly with the [changes in the latest Expo SDK around Firebase](https://docs.expo.dev/guides/using-firebase), I planned out a new version of this project. Even after working on official integration documentation and guides, I feel this project can still serve as an additional resource.

### I made a lot of commits

Working on open-source projects makes the GitHub chart go green:

![A glimpse of activity on my GitHub account](https://res.cloudinary.com/amanmittal/image/upload/v1672574631/CleanShot_2023-01-01_at_17.32.15_2x_px9qkx.png)

_A big shout and a huge thanks to folks who [sponsored me on GitHub](https://github.com/sponsors/amandeepmittal) this year!_

## Reading

I did manage to go through some good books this year. Here are some of my picks that I enjoyed reading:

- [First, We Make the Beast Beautiful by Sarah Wilson](https://www.goodreads.com/book/show/35847961-first-we-make-the-beast-beautiful): A beautifully written book about anxiety for anxious people without any fluff. Love the short chapters, and the writing style which is quite soothing.
- [The Practice of Groundedness by Brad Stulberg](https://www.goodreads.com/book/show/57504944-the-practice-of-groundedness): I first heard Brad speaking about his book on a podcast. I don't remember what got me hooked in the first place. I remember picking this book after listening to that episode and I am glad I did. It talks a lot about patience.
- [Four Thousand Weeks by Oliver Burkeman](https://www.goodreads.com/book/show/55742688-four-thousand-weeks): Having read "time hacks" books in the past, this book becomes a bit easier to read and understand the flaws with the former strategies (or hacks). I realized that those "hacks" work only until one gets burned out completely and gets put off track in life. The importance of flexibility, living one's life, being patient, and coming to a realization that work is a never-ending, spiral pit.

## Traveling

I did manage to escape on two occasions but overall did not travel as much as I would have liked to.

## Wrapping up

I have been writing [yearly reviews](https://amanhimself.dev/tags/year-review/) since 2020. It's fun for me to look back over what I did and what I focused on last year or where my time went.

Thank you all for reading this post or reading any other post!

That's it for now. Happy New Year!

---

## 2023 - A year in review
Slug: year-in-review-2023

I must admit that I'm late to the yearly review party this time. The calendar has already flipped to the end of January, yet here I find myself, typing away.

## App.js conf 2023

This year's [App.js conference](https://appjs.co/) wasn't just an event. It was a reunion of mind and spirits. So many amazing people sharing their expert knowledge to make our developer lives better.

I'm extremely thankful for the opportunity I got this year to give an in-person workshop. Giving a workshop at my favorite conference was surreal and exciting. I caught a glimpse of familiar faces in the crowd and loved every bit of it.

![Workshop at App.js with Alek](/images/year-2023/b0.jpeg)

Thankful to the conference organizers at Software Mansion and my team at Expo for this opportunity. And of course, to [Aleksander Mikucki](https://x.com/aleqsio) who was my partner in crime.

![Customary photo with Catalin Miron and David Leuliette](/images/year-2023/b12.jpeg)

[It was a wonderful experience to attend it in person](https://x.com/amanhimself/status/1535694759653740547), meet old friends, make new ones and travel once again. Everything from the venue, the beautiful city of Krakow, and quality talks, was a great experience. Kudos to the organizers for hosting it and providing that altogether!

I can also officially say I met my colleagues in person since I started working at Expo, mostly after a year and to many, for the first time. The conference just feels different when you are surrounded by people whose avatars you interact with all the time and once a day or week, meet them in a huddle or a Zoom call.

## Blog

Writing is also the primary part of my day job. Occupied in personal and professional life, finding that thin line in between was absent for most of this year. This year, I found myself pulled away from my keyboard on multiple occasions and for the majority of the year, my blog remained silent.

I also didn't mingle with the design of the blog as it has been customary in the past. I did contemplate re-designing it or moving to a newer framework (just for the sake of learning it) but it didn't happen. I've settled on this layout and the functionality of the blog for the time being.

### I wrote 15 posts

It turns out that folks still visit and want to read. Here are some of the most popular posts I wrote or updated this year:

- [Setup Macbook M1 for Web and React Native development](https://amanhimself.dev/blog/setup-macbook-m1/): Even though, this post was Originally published in 2021, I updated the whole post and re-published it again. It's been a popular post once again and I hope it helped folks to get started with their new Macbooks.
- [Set default location for images, files and attachments in Obsidian](https://amanhimself.dev/blog/set-default-folder-for-images-files-and-attachments-in-obsidian/): This post was a result of necessity. Over the last year, I've settled on how to organize my notes and other files in the Obsidian vault. The post gives a brief overview.
- [How to configure ESLint and Prettier in an Expo project](https://amanhimself.dev/blog/configure-eslint-prettier-expo-project/): Wrote this one for myself. Even though [Expo documentation](https://docs.expo.dev/guides/using-eslint/) covers this in detail (after I published this post), I wanted to collect these configuration steps so that I don't lose track of them.

### My blog in numbers

In 2022, I [moved away from Google Universal Analytics](https://amanhimself.dev/blog/year-in-review-2022/) and moved to using Fathom. I really like their minimal interface. It is not overwhelming and shows me what I want to see.

Since my lack of writing and absolutely not sharing any posts on any media platforms or external sites it took a fall in June, but, overall it has been consistent for the rest of the year:

![Yearly blog stats](/images/year-2023/b1.png)

It is also interesting to see that what's driving most of the traffic are old posts:

![Yearly blog stats part 2](/images/year-2023/b2.png)

Also, most visitors are coming mostly through search engines:

![Yearly blog stats part 3](/images/year-2023/b3.png)

For the lack of time and energy, I also stopped contributing to external publications or cross-posting to other sites. That said, this blog has been my primary interface to talk about or share something.

## Newsletter saga finally comes to an end

Last year, after Revue got closed and I jumped to the Substack wagon, I decided to not pursue it further. Mostly, it was because I didn't have much to share. Although I think some of my friends and regular readers would love to get my posts delivered straight to their inbox.

I'm not sure if I'll start one in the future yet.

## Highlights from my GitHub

A couple of years back, I started to maintain aÂ [single repo](https://github.com/amandeepmittal/react-native-examples)Â for all the demos and example apps I write using React Native and Expo. These example apps are mostly part of the tutorials you see on this blog. To my surprise, it reached 850+ stars. It's still being actively maintained.

I did not maintain the Â [Expo Community project that integrates Firebase JS SDK in an Expo app](https://github.com/expo-community/expo-firebase-starter). However, I do have plans to update it this year with a new Expo SDK release.

### I did make a lot of commits

I maintain and work on Expo docs among other things, all of them are open source. The green chart below is mainly work:

![Yearly GitHub stats](/images/year-2023/b4.png)

_A big shout and a huge thanks to folks whoÂ [sponsored me on GitHub](https://github.com/sponsors/amandeepmittal)Â this year!_

## Reading

I did manage to go through some good books this year. Here are some of my picks that I enjoyed reading:

- Tao of Seneca [vol. 1](https://www.goodreads.com/book/show/36130406-the-tao-of-seneca) & [2](https://www.goodreads.com/book/show/36130410-the-tao-of-seneca): I've read other translations and this one is not easy, though, I'd recommend this over any other translation unless I come across a better one. The letters are well-organized and appended based on a theme sometimes. It is also available in the public domain (thanks to Tim Ferriss!). A must-read because life is like a sine wave.
- [Seven and a Half Lessons About the Brain](https://www.goodreads.com/book/show/56319768-seven-and-a-half-lessons-about-the-brain): Sometimes I wonder why I do a particular thing and what drives out. This book made me realize a lot is going on behind that. It is also like a getting-started guide to learning about brains.
- [Intimacies by Kitamura Katie](https://www.goodreads.com/book/show/59539686-intimacies): Beautiful, unique, thought-provoking and one of those that I wish was longer. Completely character-driven and with doses of realism.
- [How to Be an Adult by David Richo](https://www.goodreads.com/book/show/978759.How_to_Be_an_Adult): I wish I had known about this one five years ago. Now is also not a bad time to read it. I first heard about it on a podcast and checked it out, and has been helpful. Can get overwhelming if you try to read it cover from cover (like I did), so don't forget to take your time with this one.

## Traveling

I didn't travel as to my liking and only managed to escape on a couple of occasions.

## Wrapping up

I struggled mostly with anxiety. I've always repeatedly heard this saying, "Go with the flow...". I think I finally had a glimpse of it for a while.

I have been writingÂ [yearly reviews](https://amanhimself.dev/tags/year-review/)Â since 2020. It's fun for me to look back over what I did and what I focused on last year or where my time went.

That's it for now. If you made it so far, I appreciate you!

---

## 2024 - A year in review
Slug: year-in-review-2024

As 2024 draws close, it's time for my annual year in review reflection. This tradition helps me analyze and appreciate the various projects and experiences that shaped my year. Let's dive into what 2024 brought.

This year, I was mostly focused on work, so nothing much happened on this site. I'll keep this post short.

## Work

One thing that might not get enough credit but I believe has been quite significant was the integration of the Vale prose lint tool, which improved Expo docs documentation quality:

- Standardized writing style across 800+ pages
- I did not measure it, but this change reduced the editing/review cycles
- The goal was to create a more consistent reading experience for our users and docs contributors. Hopefully, we've reached both

## Blog

A significant milestone this year was migrating from Next.js to Astro after three years. The migration brought several benefits:

- Lower maintenance overhead
- Smoother version upgrades (the recent major version upgrade was seamless)
- Simplified content management and minimal theme with the AstroPaper template
- Improved performance

Migrating to Astro isn't about trying the new shiny framework. Some of the above-mentioned benefits really matter to me in order to keep this blog running in the long run. I'll discuss this in more detail in a future post.

### Popular posts

Occupied in personal and professional life, finding time to write more blog posts didn't come naturally this year. However, I ended up publishing 15 new blog posts this year. It turns out people still find my blog through Google and other search engines and visit this blog. Here are some of the most visited blog posts this year:

- [**Stash changes in a git repository with VS Code**](https://amanhimself.dev/blog/stash-changes-with-vscode/): This post was published originally in 2023. I made a few minor updates to this post this year, and it is the most popular post on my blog.
- [**How to install Node.js using NVM on macOS M1**](https://amanhimself.dev/blog/install-nodejs-using-nvm-on-macos-m1/): Another 2023 post that was visited multiple times this year.
- [**My Macbook setup 2024**](https://amanhimself.dev/blog/macbook-setup-2024/): A new guide I wrote this year when setting up my macbook. This post describes all the requirements I configure when setting up a new machine.

### Blog in numbers

The analytics from Fathom show some interesting trends this year. With over 100k page views, the blog has maintained a steady readership.

<img src="/images/year-2024/01.png" width="640" />

What's particularly interesting is how certain technical guides continue to provide value long after publication:

<img src="/images/year-2024/02.png" width="480" />

Also, most visitors are coming through search engines:

<img src="/images/year-2024/03.png" width="480" />

This year, I also made analytics more transparent by creating "/slash" pages and making the stats public at [/stats/](https://app.usefathom.com/share/habfbpub/amanhimself.dev). This allows readers to explore the data and aligns with my belief in open metrics.

## Highlights from my GitHub

A couple of years back, I started to maintain aÂ [single repository](https://github.com/amandeepmittal/react-native-examples)Â for all the demos and example apps I write using React Native and Expo. These example apps are mostly part of the tutorials you see on this blog. This year, it reached 960+ stars. It's still being actively maintained.

### I made a lot of commits

My role at Expo continues to be a major driver of my GitHub activity. The dense contribution graph reflects me working on Expo's documentation among other things:

<img src="/images/year-2024/04.png" width="640" />

_A big shout and a huge thanks to folks whoÂ [sponsored me on GitHub](https://github.com/sponsors/amandeepmittal)Â this year!_

## Traveling

I didn't travel to my liking and only managed to escape on a couple of occasions.

<img src="/images/year-2024/05.jpg" width="360" />

### App.js conf 2024

This year'sÂ [App.js conference](https://appjs.co/) was a good one. There are so many amazing people sharing expert knowledge to make the lives of React Native and Expo developers better.

I'm extremely thankful that I got the opportunity to visit this year. This was my 4th time visiting the conference. Meeting people you work with in person was the highlight of the conference for me this year.

<img src="/images/year-2024/06.jpg" width="360" />

Everything from the venue, the beautiful city of Krakow, and quality talks was a great experience. Kudos to the organizers for hosting it!

<img src="/images/year-2024/07.jpg" width="360" />

## Reading

I successfully completed my yearly Goodreads reading challenge, diving into books across different domains. Here are my picks that I enjoyed reading too much:

- [Docs for Developers](https://www.goodreads.com/book/show/58278048-docs-for-developers): I finally read this one from cover to cover after starting it twice in 2022 and 2023. It is still my recommended book for an engineer who works with technical documentation or tech writers who are docs engineers within their organization. This book is full of insights and practical examples on how to tackle and make decisions around everyday docs stuff. Documentation isn't just about writingâ€”it's about understanding your audience's journey. The book's framework for planning documentation structure based on user experience is one key takeaway.

- [Apprenticeship Patterns](https://www.goodreads.com/book/show/19411007-apprenticeship-patterns): This is one of those that I feel I should have read when I was starting my career. The concept of "breakable toys" &mdash; creating safe environments to experiment and fail &mdash; has changed how I approach learning new technologies, but I learned this the hard way. This book offers the "what" and "why" of the concept and tips to adopt it at the beginning of your career.

- [The Creative Act by Rick Rubin](https://www.goodreads.com/book/show/60965426-the-creative-act): I did enjoy reading this one, but much less than I anticipated. Some of the chapters I found were quite repeatable, considering it's a thick one.

- [Endurance: Shackleton's Incredible Voyage by Alfred Lansing](https://www.goodreads.com/book/show/17377349-endurance): I loved reading the first half of this book. It is definitely an adventure that dives into the human psyche from the perspective of how a group faces adversity together. Remarkably written.

- [Technical Writing for Software Developers by Chris Chinchilla](https://www.goodreads.com/book/show/210181947-technical-writing-for-software-developers): A great insight into the world of different types of documentation with an exploration of the current state of the tech writing industry. I wish more tech writers/doc engineers wrote more books/blogs. The "docs-as-code" approach isn't just a trendâ€”it's revolutionizing how we maintain and scale documentation. The book's insights on treating docs with the same rigor as code has given me confidence about the things I am doing right in my day job.

- [Tao of Seneca vol. 3](https://www.goodreads.com/book/show/36130412-the-tao-of-seneca): Completed the trilogy of Tao of Seneca. Tim Ferriss edits the whole series, and all the letters are categorized based on themes. The translation for this set of Seneca's letters is better than the others I have read. It is also available in the public domain (thanks to Tim Ferriss!).

## Wrapping up

That's a wrap! Even though this year was full of anxiety, I think the last two months have been much better in terms of me achieving the restricted state of inner tranquility.

If you made it so far, I appreciate you!

If you are curious about the previous year-in-review posts or how long I have been writing these posts, check out the links below:

<!-- vale off -->

- [2023 - A year in review](/blog/year-in-review-2023/)
- [2022 - A year in review](/blog/year-in-review-2022/)
- [2021 - A year in review](/blog/year-in-review-2021/)
- [Year rewind: 2020](/blog/year-rewind-2020/) (_yes, this one is titled differently, and I don't remember anymore as to why_)

<!-- vale on -->

Onwards to 2025.

<img src="/images/year-2024/08.jpg" width="360" />

---

## Year rewind: 2020
Slug: year-rewind-2020

<!-- vale off -->

The year 2020 is coming to an end. The Earth is completing one more revolution around the Sun.

I am not a big fan of new year's resolutions since I never end up completing or even following one for a long time. However, I do like to introspect on the year passing by ðŸ˜¬.

## How the year was? ðŸŽ¢

The thing is, just like the Earthâ€™s revolution, this year, I feel like I have also gone around a circle and completed one or two revolutions myself. When the year started I had plans. I wanted to write code (as usual), learn some new things, and travel. The way it turned out to be is quite different from where it started.

I am glad and feel lucky that I did not lose my source of income from my day job and was fortunate enough to get a few opportunities. I am glad I did not lose touch with my network and made new connections.

Things I am not glad about this year include anxiety attacks and getting burned out. I have never felt how or what burning out looks like but only after going through it, I did realize what is happening with me. For me, in life in general, curiosity is one of the most important things in life. Without being curious, I wonâ€™t be writing this post, and you wonâ€™t be reading it. However, when I lost the ability to be curious about things around me both in the personal and professional world, onwards started a downward spiral.

I did not pursue anything else other than spending my time on a laptop that could help me take my mind off things or be a fruitful distraction. I wanted to do too many things but without planning on how to accomplish them and divide them into doable modular tasks. I lost interest in reading books for a while (an activity that I value most in my life and have been practicing for the last decade) and am still trying to cope or find a way to get back to my usual routine.

After this kind of experience, something did not feel right. And no, it did not get better after that. Not until I started to accept the fact that what I have gone through is the actual burn out. No, the lockdown or the pandemic wasnâ€™t the major cause of it. They sure did contribute but I think if they were not part of the equation, I might still have gone through a similar phase. One thing lockdown or the pandemic brought out for me is to spend time together with my parents.

The safe way I have found is to make small changes and stick to them and then decide whether the things are working out for good or not. The lesson I would like to learn from this is to be organized with one's routine, being consistent while one can is better than anything out there, donâ€™t try to change everything all at once, rather, make small changes and stick to them. Take breaks, mental health is an important aspect of being human, and right now is the perfect time to start talking about it and embrace it and experience the things that are not in my control even though they try to entwine with the stuff that is in my control.

## I wrote 75 articles ðŸ“

I believe to get better at something is to do it regularly and especially, if one enjoys it. I do enjoy writing blog posts and being able to do it consistently helps me learn new things, update my existing spectrum of knowledge, and share what I know. It also keeps my life engaging.

There is also the other side that says â€œquality over quantityâ€. For me, it does not work that way. Writing, just like any other thing, is something one has to practice to write a â€œqualityâ€ post. How about practicing it in public?

Most of the posts I wrote are in the long form of tutorials to accomplish one thing by using a multitude of things. I am always surprised by the things that happened after I publish a post. Usually, the post I am expecting a lot from is never read by more than 100 people. The feedback sometimes I get on a post I wrote months ago is absolutely wonderful.

Here are some of the posts that I wrote this year:

- [Styling the React Native Way](https://amanhimself.dev/blog/styling-the-react-native-way/). I revamped this post, which I originally published in 2019. React Native has changed quite a bit since this year started and I thought it was the right time to update one of my most-read posts.
- [React Native and Firebase Chat app series](https://amanhimself.dev/blog/chat-app-with-react-native-part-2/). With an introduction to React Hooks last year, and the react-navigation library being updated to `v5`, I wanted to cover both of them in some detail. Thus, I ended up writing a series of six blog posts.
- Writing and taking steps in the Animation side of React Native is fun. There is a lot to do and a lot is happening when it comes to animations but I did a fair job on the usage of React Native's Animated API from a beginner's point of view in these two posts:
  - [How to create a custom scrollbar with React Native Animated API](https://amanhimself.dev/blog/custom-scroll-bar-indicator-with-react-native-animated-api/)
  - [How to Animate a Header View on Scroll With React Native Animated](https://amanhimself.dev/blog/animate-header-view-on-scroll-with-react-native-animated-api/)
- Serverless databases or tech stacks excite me. Don't get me wrong here. I am not against the idea of writing an API from scratch. In fact, I started my career on the backend side of JavaScript. But seeing the line of serverless architectures getting advance and trying to fulfill most of our needs is exciting. Thus, I was introduced to HarperDB this year. A database service that supports both SQL and NoSQL queries for CRUD operations. I ended up writing two posts, covering [the API part with Node.js](https://amanhimself.dev/blog/build-rest-api-with-nodejs-harperdb/) and using it with a frontend [library like React](https://amanhimself.dev/blog/harperdb-with-react-hooks/).
- I am not using React Hooks that much at work, but I did try to explore hooks from my own perspective. I wrote two posts, one on explaining how [`useState` hook works](https://amanhimself.dev/blog/react-app-with-localstorage-api-and-hooks/) and another on [managing state in React apps with `useReducer` and `useContext` hooks](https://amanhimself.dev/blog/manage-state-with-usecontext-usereducer-in-react-apps/).
- Expo came out with ease of [using fonts as hook](https://github.com/byCedric/use-expo/blob/main/packages/font/docs/use-fonts.md). I shared using it in [Creating "Quarantine Pro" â€” A Fun Learning Experiment in React Native](https://amanhimself.dev/blog/quarantine-pro-app/).

## I moved my blog from Gatsby to Next.js and back to Gatsby again ðŸ¤ª

My personal blog has been the most consistent thing over course of these 12 months in my life. It deserves more credit than I give it. Also, I never planned to have a self-hosted blog until a friend of mine, [Valentin](https://x.com/RadValentin), casually suggested its importance. I started writing on [Medium](https://medium.com/@amanhimself) when I was getting into web development back in late 2016 and early 2017. At that time, I did not think much about pursuing writing posts or the importance of sharing via creating content. It was all new to me. I was just exploring horizons and wanted to document the good things about it.

![ss4](/images/2020-1.png)

Three years forward, in 2020, I did not give much emphasis on Medium this year as my primary blog publishing platform. Even though I did reach an exploding [2 million views](https://x.com/amanhimself/status/1285554115464982528), I do not like how some publications (that I think have an impact in terms of audience) are forcing down to have a payment wall associated with a post published under their publication. I am not against getting the original author paid for their work but as a popular publication with a significant audience, it should not force a contributing writer and be open about it. That said, some publications are not forcing down and are still enjoyable to write for.

This gave me an opportunity to continue to build and maintain my own blog which was initially created using [Gatsby](https://www.gatsbyjs.com/). However, in the desire to explore things, I migrated my blog to [Next.js](https://nextjs.org/) in the middle of the year. I wanted to continue using it. As a framework built over React, I think Next.js is more flexible than Gatsby but in the month of November, I decided to migrate back to Gatsby since I feel more comfortable using it since I have been closely following its development for quite some years, and I was able to cut down the 10 minutes of build time that was happening with Next.js by 70% with Gatsby. I am sure that it was my fault that the build time was around 10 minutes with Next.js and I was too lazy and uninterested to actually debug it. Nonetheless, I am glad for the opportunity to try out Next.js for the first time and will try to use it in some other projects next year.

I also realized that Markdown is definitely one of the best things to happen in the dev world. I cannot imagine any other way to write. I did try MDX with Next.js but the maintenance and time spent on converting an MDX post to a normal markdown to cross-post on popular blogging platforms is too much for me.

Not focusing on Medium enough, also gave me the opportunity to explore two awesome blogging platforms that are meant for developers:

- [Dev.to](https://dev.to/amanhimself)
- ~~[Hashnode](https://hashnode.com/@amanhimself)~~

I started cross-posting on Dev.to [last year](https://dev.to/amanhimself/getting-started-with-react-native-in-2019-build-your-first-app-542d) and in this year I have managed to get around 100k+ views.

![ss1](/images/2020-2.png))

I am excited to publish more on Hashnode. Only in the month of December, I started publishing there. I think it is different from a usual blogging platform and one thing that excites me is how community-driven it is. Developers and the whole at Hashnode are always closely listening to the wants and needs of their users and this is something I have not seen much of. It's like building in public. The ability to have a hosted newsletter and use your own domain is somewhat unusual for a platform. I like where they are going with it and would be love to see how it happens. It's a high time we need a consistent platform that could be the "YouTube" for technical writers and publications (it might sound ambitious but it is not!).

## A Big Thank You to all the editors ðŸ™

Writing a blog post and publishing is just one aspect. Since the year 2018, I have worked with quite a few awesome editors and content managers at different publications.

Thus, I'd like to thank from the bottom of my heart, these awesome human beings for always listening to my ideas and not taking my mistakes too seriously, and sharing their insight and unique perspective which has helped me not only write but grow as a person.

- [Filipe Lima](https://x.com/filipeslima) at Jscrambler
- [Kate Trahan](https://x.com/Katerade4) at Logrocket
- [Austin Kodra](https://x.com/austin_kodra) at Fritz AI & Heartbeat
- [Nick Selman](https://x.com/nickselman) at Draftbit
- [Margo McCabe](https://x.com/margo_hdb) at HarperDB

Without their feedback and honest review, their perspective on what works and what doesn't, I would have never been able to improve in the skill of writing. Most blog posts that you get to read on this blog or on their publications would never have been in the readable format and would have never seen the light of getting published.

## I did one presentation ðŸ’¬

This happened by just a Twitter DM. I never expected that I would be able to speak in front of an audience, even in an online, remote event. This year, I got the opportunity to speak about [How to write consistently](https://www.youtube.com/watch?v=YIRxTUCY0NQ) at [Hashnode's Technical Writing Bootcamp](https://hashnode.com/bootcamp/batch-2), a free virtual Bootcamp to help developers who are getting started in technical writing.

## I made 1541 commits ðŸ‘¨â€ðŸ’»

Personally, this statistic does not matter but the GitHub's commit graph is fun. It is also great to see that I have less green or empty blocks on weekends which is a good sign.

![ss2](/images/2020-3.png)

In 2019, I made 939 commits. What changed this year? I started using GitHub at my day job for some projects.

![ss3](/images/2020-4.png)

### Highlights from my GitHub ðŸ™€

I have also started maintaining [one single GitHub repo](https://github.com/amandeepmittal/react-native-examples) for all the demos and examples I write using React Native and Expo blog posts.

Continued to maintain the [expo-community project on integrating Firebase SDK in an Expo app](https://github.com/expo-community/expo-firebase-starter), thanks to my friend [Cedric](https://github.com/byCedric) and awesome people at Expo. I have seen it was helpful to some folks as they were getting started with Expo and Firebase. Will try continue maintaining it over the next and year include more Expo related stuff.

## Newsletter saga continues ðŸ’Œ

I run [a weekly newsletter](https://amanhimself.substack.com/) that is of late, has become a bi-weekly newsletter due to my inconsistency of publishing blog posts. I don't send out newsletters when I don't have anything to share in terms of blog articles or tutorials. I don't like getting spam and I don't want to spam anyone. I started taking sending out newsletters seriously in 2019 and at the end of that year, I had [845 subscribers](https://x.com/amanhimself/status/1201933182070874112). This year, it did manage to grow to 1201 subscribers. I did not count how many newsletters in total I send out and now it's too late.

I did move from [Tinyletter](http://tinyletter.com/) to [Substack](https://substack.com/). After using Tinyletter for 22 months, I was missing out on somethings, but importantly, I was not able to provide a good reading experience to my readers who open the email they receive and spend time reading it. Both are free, but I find Substack has a more modern UI and a pleasing to the eye approach. Thanks to my friend [Alex Kallaway](https://x.com/ka11away) for making me realize this and convincing me to make the move.

I also took a free seven day email course called [**Blogging for Devs**](https://bloggingfordevs.com/) created [Monica Lent](https://x.com/monicalent). Without giving too much away, I learned a great deal from it. She is an inspiration to me because, in 2019, her income from blogging enabled her to quit her day job and pursue her own journey of bootstrapping a SaaS company. Reading her emails made me realize what I was doing wrong and how can I improve on some of the things I do.

## Coffee â˜•ï¸

I have received a lifetime of **26** coffee donations on [**Ko-Fi**](https://ko-fi.com/amanhimself). Thank you so much ðŸ™ .

## Reading ðŸ“š

I think that if a book is able to offer at least one new idea from what I already know, is a good book.

I did manage to scrape through some good books this year. Here some of my picks that I enjoyed reading:

### The Unicorn Project by Gene Kim

I like to read about the world of technology whether it is written from a perspective of fiction narrative or non-fiction. The Unicorn Project is one of the first books I read this year and it definitely goes in-depth about the process of what goes into a tech company and the importance of communication. The narrative might not be too true but overall it resonates.

- [Goodreads](https://www.goodreads.com/book/show/45293317-the-unicorn-project)

### The Developer's Guide to Content Creation by Stephanie Morillo

This book resonated with me a lot. It offers good insights and guidance for a developer who is interested in creating content.

- [Goodreads](https://www.goodreads.com/book/show/50996057-the-developer-s-guide-to-content-creation)

### The Company of One by Paul Jarvis

This book is about the mindset of working for oneself and I would add that it's a semi-autobiography of Paul's own journey of what he did when he left the traditional corporate world and how scaling and growth from an individual's perspective or for small-scaled bootstrapped business are not what it seems or the perception I had.

- [Goodreads](https://www.goodreads.com/book/show/38922272-company-of-one)

### Writing for Software Developers by Philip Kiely

This book goes in-depth about being a technical writer from a software developer's point of view. It offers great guidance on how to get started, managing one's workflow and where can one find publications to publish their own piece of posts and articles. It also discusses the business aspect of being a technical writer.

- [Goodreads](https://www.goodreads.com/book/show/53466825-writing-for-software-developers)

### The Practice by Seth Godin

This book by Seth Godin is all about why practice is important and how quantity helps one sustain that quality of work in their own domain.

- [Goodreads](https://www.goodreads.com/book/show/53479927-the-practice)

### The Midnight Library by Matt Haig

My favorite fiction read of the year and why experiencing life matters.

- [Goodreads](https://www.goodreads.com/book/show/53568397-the-midnight-library)

## What I want to learn in 2021 ðŸ¤”

Learning is one of the few constants in our lives. There are a few things that I've learned this year but I am going to share a list of new things that I want to learn next year:

- GraphQL and Amplify AppSync
- More of TypeScript
- Different UI and animation patterns in React Native apps
- More on React Hooks
- Delve more in [Expo](https://docs.expo.io/guides/) that is always improving and it's always helpful API.

## Conclusion

I am planning to write blog posts that are in short format next year or may be add another way to share content ðŸ‘€. There is a lot of stuff that I miss out on sharing since I am always thinking of connecting things.

Thank you all for reading this post and reading any other post, opening and reading email newsletters, reading my tweets on Twitter, and listening to me ðŸ™ .

Have a great 2021!

---

## View most used commands with zsh_stats
Slug: zsh-stats

[ZSH](https://github.com/zsh-users/zsh) is the default shell in macOS. If you use [Oh my Zsh](https://ohmyz.sh/) to manage the ZSH configuration plugins and a theme to prettify the terminal, you can also use several built-in utilities.

One such utility is the `zsh_stats` command, which provides a list of your top twenty most frequently used commands and how many times each command has run. To use it, run the following command from a terminal window:

```shell
zsh_stats
```

This command will display an output like this:

![zsh_stats running inside a terminal window.](/images/zsh-stats.png)

It is useful for analyzing your command usage patterns.